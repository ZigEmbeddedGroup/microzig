const std = @import("std");
const isa_def = @embedFile("isa.txt");
const isa = @import("isa");

const BoundedArray = @import("bounded-array").BoundedArray;

fn string_to_enum(comptime T: type, str: []const u8) ?T {
    inline for (@typeInfo(T).@"enum".fields) |enumField| {
        if (std.mem.eql(u8, str, enumField.name)) {
            return @field(T, enumField.name);
        }
    }
    return null;
}

pub fn main() !void {
    const allocator = std.heap.page_allocator;

    const argv = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, argv);

    if (argv.len != 2) @panic("usage: aviron-table-gen <out>");

    var out = try std.fs.cwd().createFile(argv[1], .{});
    defer out.close();

    var buf = std.array_list.Managed(u8).init(allocator);
    defer buf.deinit();

    const writer = buf.writer();

    var lut = [_]isa.Opcode{.unknown} ** (std.math.maxInt(u16) + 1);

    var base_number_bit_set = std.bit_set.IntegerBitSet(16).initEmpty();
    var unknown_indices = try BoundedArray(u8, 16).init(0);
    var unknown_indices_bit_set = std.bit_set.IntegerBitSet(16).initEmpty();
    var result_bit_set = std.bit_set.IntegerBitSet(16).initEmpty();

    var positionals = std.enums.EnumArray(isa.Opcode, std.AutoArrayHashMapUnmanaged(u8, BoundedArray(u8, 16))).initFill(.{});
    defer for (&positionals.values) |*map| {
        map.deinit(allocator);
    };

    var lit = std.mem.splitScalar(u8, isa_def, '\n');
    while (lit.next()) |line| {
        var pit = std.mem.tokenizeScalar(u8, line, ' ');

        const op_name = pit.next() orelse continue;
        const opcode = string_to_enum(isa.Opcode, op_name) orelse @panic(op_name);

        base_number_bit_set.mask = 0;
        try unknown_indices.resize(0);

        var index: usize = 0;
        for (pit.rest()) |r| {
            if (r == ' ')
                continue;
            if (index >= 16)
                break;

            switch (r) {
                '0' => {},
                '1' => base_number_bit_set.set(index),
                else => {
                    const gop = try positionals.getPtr(opcode).getOrPut(allocator, r);
                    if (!gop.found_existing) {
                        gop.value_ptr.* = try BoundedArray(u8, 16).init(0);
                    }
                    try gop.value_ptr.*.append(@intCast(index));

                    try unknown_indices.append(@intCast(index));
                },
            }

            index += 1;
        }

        const max_int = (try std.math.powi(usize, 2, unknown_indices.len)) - 1;
        index = 0;
        while (index <= max_int) : (index += 1) {
            unknown_indices_bit_set.mask = @intCast(index);
            result_bit_set.mask = base_number_bit_set.mask;

            for (unknown_indices.slice(), 0..) |v, i| {
                result_bit_set.setValue(v, unknown_indices_bit_set.isSet(i));
            }

            const result = @bitReverse(result_bit_set.mask);

            if (lut[result] != .unknown) {
                std.log.err("Overlap ({b}): {s} vs {s}", .{ result, @tagName(lut[result]), @tagName(opcode) });
                return;
            }
            lut[result] = opcode;
        }
    }

    try writer.writeAll("//! AUTOGENERATED CODE. DO NOT MODIFY!\n\n");

    try writer.writeAll("const isa = @import(\"isa\");\n\n");

    try writer.writeAll("pub const Instruction = union(isa.Opcode) {");

    for (positionals.values, 0..) |map, i| {
        const opcode = std.enums.EnumIndexer(isa.Opcode).keyForIndex(i);

        try writer.print("{}: ", .{std.zig.fmtId(@tagName(opcode))});

        const BitSet = struct {
            name: u8,
            count: usize,

            pub fn lt(ctx: void, lh: @This(), rh: @This()) bool {
                _ = ctx;
                return lh.name < rh.name;
            }
        };

        var items = std.array_list.Managed(BitSet).init(allocator);
        defer items.deinit();

        var it = map.iterator();
        while (it.next()) |entry| {
            try items.append(.{
                .name = entry.key_ptr.*,
                .count = entry.value_ptr.*.slice().len,
            });
        }

        std.sort.block(BitSet, items.items, {}, BitSet.lt);

        if (items.items.len == 0) {
            try writer.writeAll("void");
        } else {
            try writer.writeAll("isa.opinfo.");
            for (items.items) |key| {
                try writer.print("{c}{d}", .{ key.name, key.count });
            }
        }

        try writer.writeAll(",\n");
    }

    try writer.writeAll("};\n\n");

    try writer.writeAll("pub const lookup = [65536]isa.Opcode {");

    for (lut, 0..) |v, i| {
        try writer.print(".{},", .{std.zig.fmtId(@tagName(v))});
        if ((i + 1) % 16 == 0) {
            try writer.print("\n", .{});
        }
    }

    try writer.writeAll("};\n\npub const positionals = .{");

    for (positionals.values, 0..) |map, i| {
        try writer.print(".{} = .{{", .{std.zig.fmtId(@tagName(std.enums.EnumIndexer(isa.Opcode).keyForIndex(i)))});
        var it = map.iterator();
        while (it.next()) |entry| {
            try writer.print(".{{'{c}', .{{", .{entry.key_ptr.*});

            const slice = entry.value_ptr.*.slice();
            for (slice, 0..) |val, ii| {
                try writer.print("{d}", .{val});
                if (ii != slice.len - 1) {
                    try writer.writeAll(",");
                }
            }

            try writer.writeAll("}}");

            if (it.index != it.len) {
                try writer.writeAll(",");
            }
        }
        try writer.writeAll("},");
        if ((i + 1) % 16 == 0) {
            try writer.print("\n", .{});
        }
    }

    try writer.writeAll("};");

    const txt = try buf.toOwnedSliceSentinel(0);
    defer allocator.free(txt);

    var tree = try std.zig.Ast.parse(allocator, txt, .zig);
    defer tree.deinit(allocator);

    if (tree.errors.len != 0) {
        for (tree.errors) |err| {
            try tree.renderError(err, std.io.getStdErr().writer());
        }
        try out.writer().writeAll(txt);
    } else {
        const render_result = try tree.render(allocator);
        defer allocator.free(render_result);

        try out.writer().writeAll(render_result);
    }
}
