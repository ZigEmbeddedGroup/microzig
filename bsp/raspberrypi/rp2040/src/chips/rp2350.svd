<?xml version="1.0" encoding="UTF-8"?>
<device schemaVersion="1.1" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
    <vendor>Raspberry Pi</vendor>
    <name>RP2350</name>
    <series>RP</series>
    <version>0.1</version>
    <description>Dual Cortex-M33 or Hazard3 processors at 150MHz
        520kB on-chip SRAM, in 10 independent banks
        Extended low-power sleep states with optional SRAM retention: as low as 10uA DVDD
        8kB of one-time-programmable storage (OTP)
        Up to 16MB of external QSPI flash/PSRAM via dedicated QSPI bus
        Additional 16MB flash/PSRAM accessible via optional second chip-select
        On-chip switched-mode power supply to generate core voltage
        Low-quiescent-current LDO mode can be enabled for sleep states
        2x on-chip PLLs for internal or external clock generation
        GPIOs are 5V-tolerant (powered), and 3.3V-failsafe (unpowered)
        Security features:
        Optional boot signing, enforced by on-chip mask ROM, with key fingerprint in OTP
        Protected OTP storage for optional boot decryption key
        Global bus filtering based on Arm or RISC-V security/privilege levels
        Peripherals, GPIOs and DMA channels individually assignable to security domains
        Hardware mitigations for fault injection attacks
        Hardware SHA-256 accelerator
        Peripherals:
        2x UARTs
        2x SPI controllers
        2x I2C controllers
        24x PWM channels
        USB 1.1 controller and PHY, with host and device support
        12x PIO state machines
        1x HSTX peripheral</description>
    <licenseText>Copyright (c) 2024 Raspberry Pi Ltd.

        SPDX-License-Identifier: BSD-3-Clause</licenseText>
    <cpu>
        <name>CM33</name>
        <revision>r1p0</revision>
        <endian>little</endian>
        <mpuPresent>true</mpuPresent>
        <fpuPresent>true</fpuPresent>
        <dspPresent>true</dspPresent>
        <vtorPresent>true</vtorPresent>
        <nvicPrioBits>4</nvicPrioBits>
        <vendorSystickConfig>false</vendorSystickConfig>
        <deviceNumInterrupts>52</deviceNumInterrupts>
        <sauNumRegions>8</sauNumRegions>
    </cpu>
    <addressUnitBits>8</addressUnitBits>
    <width>32</width>
    <size>0x20</size>
    <access>read-write</access>
    <resetValue>0x00000000</resetValue>
    <resetMask>0xFFFFFFFF</resetMask>
    <peripherals>
        <peripheral>
            <name>RESETS</name>
            <baseAddress>0x40020000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0xC</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>RESET</name>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x1FFFFFFF</resetValue>
                    <fields>
                        <field>
                            <name>USBCTRL</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>UART1</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>UART0</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TRNG</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TIMER1</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TIMER0</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TBMAN</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SYSINFO</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SYSCFG</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SPI1</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SPI0</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SHA256</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PWM</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PLL_USB</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PLL_SYS</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PIO2</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PIO1</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PIO0</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PADS_QSPI</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PADS_BANK0</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>JTAG</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>IO_QSPI</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>IO_BANK0</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>I2C1</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>I2C0</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HSTX</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BUSCTRL</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ADC</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>WDSEL</name>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>USBCTRL</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>UART1</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>UART0</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TRNG</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TIMER1</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TIMER0</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TBMAN</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SYSINFO</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SYSCFG</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SPI1</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SPI0</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SHA256</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PWM</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PLL_USB</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PLL_SYS</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PIO2</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PIO1</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PIO0</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PADS_QSPI</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PADS_BANK0</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>JTAG</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>IO_QSPI</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>IO_BANK0</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>I2C1</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>I2C0</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HSTX</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BUSCTRL</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ADC</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RESET_DONE</name>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>USBCTRL</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>UART1</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>UART0</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TRNG</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TIMER1</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TIMER0</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TBMAN</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SYSINFO</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SYSCFG</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SPI1</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SPI0</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SHA256</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PWM</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PLL_USB</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PLL_SYS</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PIO2</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PIO1</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PIO0</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PADS_QSPI</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PADS_BANK0</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>JTAG</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>IO_QSPI</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>IO_BANK0</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>I2C1</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>I2C0</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HSTX</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BUSCTRL</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ADC</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>PSM</name>
            <baseAddress>0x40018000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x10</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>FRCE_ON</name>
                    <description>Force block out of reset (i.e. power it on)</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PROC1</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PROC0</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ACCESSCTRL</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SIO</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>XIP</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM9</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM8</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM7</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM6</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM5</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM4</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM3</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM2</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM1</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM0</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BOOTRAM</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ROM</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BUSFABRIC</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PSM_READY</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLOCKS</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RESETS</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>XOSC</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ROSC</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>OTP</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PROC_COLD</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FRCE_OFF</name>
                    <description>Force into reset (i.e. power it off)</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PROC1</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PROC0</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ACCESSCTRL</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SIO</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>XIP</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM9</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM8</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM7</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM6</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM5</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM4</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM3</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM2</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM1</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM0</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BOOTRAM</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ROM</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BUSFABRIC</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PSM_READY</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLOCKS</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RESETS</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>XOSC</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ROSC</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>OTP</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PROC_COLD</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>WDSEL</name>
                    <description>Set to 1 if the watchdog should reset this</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PROC1</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PROC0</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ACCESSCTRL</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SIO</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>XIP</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM9</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM8</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM7</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM6</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM5</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM4</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM3</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM2</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM1</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM0</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BOOTRAM</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ROM</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BUSFABRIC</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PSM_READY</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLOCKS</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RESETS</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>XOSC</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ROSC</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>OTP</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PROC_COLD</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DONE</name>
                    <description>Is the subsystem ready?</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PROC1</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PROC0</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ACCESSCTRL</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SIO</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>XIP</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SRAM9</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SRAM8</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SRAM7</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SRAM6</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SRAM5</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SRAM4</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SRAM3</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SRAM2</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SRAM1</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SRAM0</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BOOTRAM</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ROM</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BUSFABRIC</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PSM_READY</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLOCKS</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RESETS</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>XOSC</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ROSC</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>OTP</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PROC_COLD</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>CLOCKS</name>
            <baseAddress>0x40010000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0xD4</size>
                <usage>registers</usage>
            </addressBlock>
            <interrupt>
                <name>CLOCKS_IRQ</name>
                <value>30</value>
            </interrupt>
            <registers>
                <register>
                    <name>CLK_GPOUT0_CTRL</name>
                    <description>Clock control, can be changed on-the-fly (except for auxsrc)</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ENABLED</name>
                            <description>clock generator is enabled</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUDGE</name>
                            <description>An edge on this signal shifts the phase of the output by 1 cycle of the input clock
                                This can be done at any time</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PHASE</name>
                            <description>This delays the enable signal by up to 3 cycles of the input clock
                                This must be set before the clock is enabled to have any effect</description>
                            <bitRange>[17:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DC50</name>
                            <description>Enables duty cycle correction for odd divisors, can be changed on-the-fly</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>Starts and stops the clock generator cleanly</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>KILL</name>
                            <description>Asynchronously kills the clock generator, enable must be set low before deasserting kill</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AUXSRC</name>
                            <description>Selects the auxiliary clock source, will glitch when switching</description>
                            <bitRange>[8:5]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>clksrc_pll_sys</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin0</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin1</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_usb</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_usb_primary_ref_opcg</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rosc_clksrc</name>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xosc_clksrc</name>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>lposc_clksrc</name>
                                    <value>7</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_sys</name>
                                    <value>8</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_usb</name>
                                    <value>9</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_adc</name>
                                    <value>10</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_ref</name>
                                    <value>11</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_peri</name>
                                    <value>12</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_hstx</name>
                                    <value>13</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>otp_clk2fc</name>
                                    <value>14</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_GPOUT0_DIV</name>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00010000</resetValue>
                    <fields>
                        <field>
                            <name>INT</name>
                            <description>Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly</description>
                            <bitRange>[31:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FRAC</name>
                            <description>Fractional component of the divisor, can be changed on-the-fly</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_GPOUT0_SELECTED</name>
                    <description>Indicates which src is currently selected (one-hot)</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>CLK_GPOUT0_SELECTED</name>
                            <description>This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_GPOUT1_CTRL</name>
                    <description>Clock control, can be changed on-the-fly (except for auxsrc)</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ENABLED</name>
                            <description>clock generator is enabled</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUDGE</name>
                            <description>An edge on this signal shifts the phase of the output by 1 cycle of the input clock
                                This can be done at any time</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PHASE</name>
                            <description>This delays the enable signal by up to 3 cycles of the input clock
                                This must be set before the clock is enabled to have any effect</description>
                            <bitRange>[17:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DC50</name>
                            <description>Enables duty cycle correction for odd divisors, can be changed on-the-fly</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>Starts and stops the clock generator cleanly</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>KILL</name>
                            <description>Asynchronously kills the clock generator, enable must be set low before deasserting kill</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AUXSRC</name>
                            <description>Selects the auxiliary clock source, will glitch when switching</description>
                            <bitRange>[8:5]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>clksrc_pll_sys</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin0</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin1</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_usb</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_usb_primary_ref_opcg</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rosc_clksrc</name>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xosc_clksrc</name>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>lposc_clksrc</name>
                                    <value>7</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_sys</name>
                                    <value>8</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_usb</name>
                                    <value>9</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_adc</name>
                                    <value>10</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_ref</name>
                                    <value>11</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_peri</name>
                                    <value>12</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_hstx</name>
                                    <value>13</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>otp_clk2fc</name>
                                    <value>14</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_GPOUT1_DIV</name>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00010000</resetValue>
                    <fields>
                        <field>
                            <name>INT</name>
                            <description>Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly</description>
                            <bitRange>[31:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FRAC</name>
                            <description>Fractional component of the divisor, can be changed on-the-fly</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_GPOUT1_SELECTED</name>
                    <description>Indicates which src is currently selected (one-hot)</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>CLK_GPOUT1_SELECTED</name>
                            <description>This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_GPOUT2_CTRL</name>
                    <description>Clock control, can be changed on-the-fly (except for auxsrc)</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ENABLED</name>
                            <description>clock generator is enabled</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUDGE</name>
                            <description>An edge on this signal shifts the phase of the output by 1 cycle of the input clock
                                This can be done at any time</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PHASE</name>
                            <description>This delays the enable signal by up to 3 cycles of the input clock
                                This must be set before the clock is enabled to have any effect</description>
                            <bitRange>[17:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DC50</name>
                            <description>Enables duty cycle correction for odd divisors, can be changed on-the-fly</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>Starts and stops the clock generator cleanly</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>KILL</name>
                            <description>Asynchronously kills the clock generator, enable must be set low before deasserting kill</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AUXSRC</name>
                            <description>Selects the auxiliary clock source, will glitch when switching</description>
                            <bitRange>[8:5]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>clksrc_pll_sys</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin0</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin1</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_usb</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_usb_primary_ref_opcg</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rosc_clksrc_ph</name>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xosc_clksrc</name>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>lposc_clksrc</name>
                                    <value>7</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_sys</name>
                                    <value>8</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_usb</name>
                                    <value>9</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_adc</name>
                                    <value>10</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_ref</name>
                                    <value>11</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_peri</name>
                                    <value>12</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_hstx</name>
                                    <value>13</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>otp_clk2fc</name>
                                    <value>14</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_GPOUT2_DIV</name>
                    <addressOffset>0x1C</addressOffset>
                    <resetValue>0x00010000</resetValue>
                    <fields>
                        <field>
                            <name>INT</name>
                            <description>Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly</description>
                            <bitRange>[31:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FRAC</name>
                            <description>Fractional component of the divisor, can be changed on-the-fly</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_GPOUT2_SELECTED</name>
                    <description>Indicates which src is currently selected (one-hot)</description>
                    <addressOffset>0x20</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>CLK_GPOUT2_SELECTED</name>
                            <description>This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_GPOUT3_CTRL</name>
                    <description>Clock control, can be changed on-the-fly (except for auxsrc)</description>
                    <addressOffset>0x24</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ENABLED</name>
                            <description>clock generator is enabled</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUDGE</name>
                            <description>An edge on this signal shifts the phase of the output by 1 cycle of the input clock
                                This can be done at any time</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PHASE</name>
                            <description>This delays the enable signal by up to 3 cycles of the input clock
                                This must be set before the clock is enabled to have any effect</description>
                            <bitRange>[17:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DC50</name>
                            <description>Enables duty cycle correction for odd divisors, can be changed on-the-fly</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>Starts and stops the clock generator cleanly</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>KILL</name>
                            <description>Asynchronously kills the clock generator, enable must be set low before deasserting kill</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AUXSRC</name>
                            <description>Selects the auxiliary clock source, will glitch when switching</description>
                            <bitRange>[8:5]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>clksrc_pll_sys</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin0</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin1</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_usb</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_usb_primary_ref_opcg</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rosc_clksrc_ph</name>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xosc_clksrc</name>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>lposc_clksrc</name>
                                    <value>7</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_sys</name>
                                    <value>8</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_usb</name>
                                    <value>9</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_adc</name>
                                    <value>10</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_ref</name>
                                    <value>11</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_peri</name>
                                    <value>12</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_hstx</name>
                                    <value>13</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>otp_clk2fc</name>
                                    <value>14</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_GPOUT3_DIV</name>
                    <addressOffset>0x28</addressOffset>
                    <resetValue>0x00010000</resetValue>
                    <fields>
                        <field>
                            <name>INT</name>
                            <description>Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly</description>
                            <bitRange>[31:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FRAC</name>
                            <description>Fractional component of the divisor, can be changed on-the-fly</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_GPOUT3_SELECTED</name>
                    <description>Indicates which src is currently selected (one-hot)</description>
                    <addressOffset>0x2C</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>CLK_GPOUT3_SELECTED</name>
                            <description>This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_REF_CTRL</name>
                    <description>Clock control, can be changed on-the-fly (except for auxsrc)</description>
                    <addressOffset>0x30</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>AUXSRC</name>
                            <description>Selects the auxiliary clock source, will glitch when switching</description>
                            <bitRange>[6:5]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>clksrc_pll_usb</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin0</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin1</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_usb_primary_ref_opcg</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SRC</name>
                            <description>Selects the clock source glitchlessly, can be changed on-the-fly</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>rosc_clksrc_ph</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_clk_ref_aux</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xosc_clksrc</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>lposc_clksrc</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_REF_DIV</name>
                    <addressOffset>0x34</addressOffset>
                    <resetValue>0x00010000</resetValue>
                    <fields>
                        <field>
                            <name>INT</name>
                            <description>Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_REF_SELECTED</name>
                    <description>Indicates which src is currently selected (one-hot)</description>
                    <addressOffset>0x38</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>CLK_REF_SELECTED</name>
                            <description>The glitchless multiplexer does not switch instantaneously (to avoid glitches), so software should poll this register to wait for the switch to complete. This register contains one decoded bit for each of the clock sources enumerated in the CTRL SRC field. At most one of these bits will be set at any time, indicating that clock is currently present at the output of the glitchless mux. Whilst switching is in progress, this register may briefly show all-0s.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_SYS_CTRL</name>
                    <description>Clock control, can be changed on-the-fly (except for auxsrc)</description>
                    <addressOffset>0x3C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>AUXSRC</name>
                            <description>Selects the auxiliary clock source, will glitch when switching</description>
                            <bitRange>[7:5]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>clksrc_pll_sys</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_usb</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rosc_clksrc</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xosc_clksrc</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin0</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin1</name>
                                    <value>5</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SRC</name>
                            <description>Selects the clock source glitchlessly, can be changed on-the-fly</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>clk_ref</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_clk_sys_aux</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_SYS_DIV</name>
                    <addressOffset>0x40</addressOffset>
                    <resetValue>0x00010000</resetValue>
                    <fields>
                        <field>
                            <name>INT</name>
                            <description>Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly</description>
                            <bitRange>[31:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FRAC</name>
                            <description>Fractional component of the divisor, can be changed on-the-fly</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_SYS_SELECTED</name>
                    <description>Indicates which src is currently selected (one-hot)</description>
                    <addressOffset>0x44</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>CLK_SYS_SELECTED</name>
                            <description>The glitchless multiplexer does not switch instantaneously (to avoid glitches), so software should poll this register to wait for the switch to complete. This register contains one decoded bit for each of the clock sources enumerated in the CTRL SRC field. At most one of these bits will be set at any time, indicating that clock is currently present at the output of the glitchless mux. Whilst switching is in progress, this register may briefly show all-0s.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_PERI_CTRL</name>
                    <description>Clock control, can be changed on-the-fly (except for auxsrc)</description>
                    <addressOffset>0x48</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ENABLED</name>
                            <description>clock generator is enabled</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>Starts and stops the clock generator cleanly</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>KILL</name>
                            <description>Asynchronously kills the clock generator, enable must be set low before deasserting kill</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AUXSRC</name>
                            <description>Selects the auxiliary clock source, will glitch when switching</description>
                            <bitRange>[7:5]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>clk_sys</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_sys</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_usb</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rosc_clksrc_ph</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xosc_clksrc</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin0</name>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin1</name>
                                    <value>6</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_PERI_DIV</name>
                    <addressOffset>0x4C</addressOffset>
                    <resetValue>0x00010000</resetValue>
                    <fields>
                        <field>
                            <name>INT</name>
                            <description>Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly</description>
                            <bitRange>[17:16]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_PERI_SELECTED</name>
                    <description>Indicates which src is currently selected (one-hot)</description>
                    <addressOffset>0x50</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>CLK_PERI_SELECTED</name>
                            <description>This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_HSTX_CTRL</name>
                    <description>Clock control, can be changed on-the-fly (except for auxsrc)</description>
                    <addressOffset>0x54</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ENABLED</name>
                            <description>clock generator is enabled</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUDGE</name>
                            <description>An edge on this signal shifts the phase of the output by 1 cycle of the input clock
                                This can be done at any time</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PHASE</name>
                            <description>This delays the enable signal by up to 3 cycles of the input clock
                                This must be set before the clock is enabled to have any effect</description>
                            <bitRange>[17:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>Starts and stops the clock generator cleanly</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>KILL</name>
                            <description>Asynchronously kills the clock generator, enable must be set low before deasserting kill</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AUXSRC</name>
                            <description>Selects the auxiliary clock source, will glitch when switching</description>
                            <bitRange>[7:5]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>clk_sys</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_sys</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_usb</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin0</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin1</name>
                                    <value>4</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_HSTX_DIV</name>
                    <addressOffset>0x58</addressOffset>
                    <resetValue>0x00010000</resetValue>
                    <fields>
                        <field>
                            <name>INT</name>
                            <description>Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly</description>
                            <bitRange>[17:16]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_HSTX_SELECTED</name>
                    <description>Indicates which src is currently selected (one-hot)</description>
                    <addressOffset>0x5C</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>CLK_HSTX_SELECTED</name>
                            <description>This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_USB_CTRL</name>
                    <description>Clock control, can be changed on-the-fly (except for auxsrc)</description>
                    <addressOffset>0x60</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ENABLED</name>
                            <description>clock generator is enabled</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUDGE</name>
                            <description>An edge on this signal shifts the phase of the output by 1 cycle of the input clock
                                This can be done at any time</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PHASE</name>
                            <description>This delays the enable signal by up to 3 cycles of the input clock
                                This must be set before the clock is enabled to have any effect</description>
                            <bitRange>[17:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>Starts and stops the clock generator cleanly</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>KILL</name>
                            <description>Asynchronously kills the clock generator, enable must be set low before deasserting kill</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AUXSRC</name>
                            <description>Selects the auxiliary clock source, will glitch when switching</description>
                            <bitRange>[7:5]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>clksrc_pll_usb</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_sys</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rosc_clksrc_ph</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xosc_clksrc</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin0</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin1</name>
                                    <value>5</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_USB_DIV</name>
                    <addressOffset>0x64</addressOffset>
                    <resetValue>0x00010000</resetValue>
                    <fields>
                        <field>
                            <name>INT</name>
                            <description>Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_USB_SELECTED</name>
                    <description>Indicates which src is currently selected (one-hot)</description>
                    <addressOffset>0x68</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>CLK_USB_SELECTED</name>
                            <description>This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_ADC_CTRL</name>
                    <description>Clock control, can be changed on-the-fly (except for auxsrc)</description>
                    <addressOffset>0x6C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ENABLED</name>
                            <description>clock generator is enabled</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUDGE</name>
                            <description>An edge on this signal shifts the phase of the output by 1 cycle of the input clock
                                This can be done at any time</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PHASE</name>
                            <description>This delays the enable signal by up to 3 cycles of the input clock
                                This must be set before the clock is enabled to have any effect</description>
                            <bitRange>[17:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>Starts and stops the clock generator cleanly</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>KILL</name>
                            <description>Asynchronously kills the clock generator, enable must be set low before deasserting kill</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AUXSRC</name>
                            <description>Selects the auxiliary clock source, will glitch when switching</description>
                            <bitRange>[7:5]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>clksrc_pll_usb</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_sys</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rosc_clksrc_ph</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xosc_clksrc</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin0</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin1</name>
                                    <value>5</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_ADC_DIV</name>
                    <addressOffset>0x70</addressOffset>
                    <resetValue>0x00010000</resetValue>
                    <fields>
                        <field>
                            <name>INT</name>
                            <description>Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_ADC_SELECTED</name>
                    <description>Indicates which src is currently selected (one-hot)</description>
                    <addressOffset>0x74</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>CLK_ADC_SELECTED</name>
                            <description>This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DFTCLK_XOSC_CTRL</name>
                    <addressOffset>0x78</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SRC</name>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NULL</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_usb_primary</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin0</name>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DFTCLK_ROSC_CTRL</name>
                    <addressOffset>0x7C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SRC</name>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NULL</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_sys_primary_rosc</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin1</name>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DFTCLK_LPOSC_CTRL</name>
                    <addressOffset>0x80</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SRC</name>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NULL</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_pll_usb_primary_lposc</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin1</name>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_SYS_RESUS_CTRL</name>
                    <addressOffset>0x84</addressOffset>
                    <resetValue>0x000000FF</resetValue>
                    <fields>
                        <field>
                            <name>CLEAR</name>
                            <description>For clearing the resus after the fault that triggered it has been corrected</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FRCE</name>
                            <description>Force a resus, for test purposes only</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>Enable resus</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TIMEOUT</name>
                            <description>This is expressed as a number of clk_ref cycles
                                and must be &gt;= 2x clk_ref_freq/min_clk_tst_freq</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLK_SYS_RESUS_STATUS</name>
                    <addressOffset>0x88</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RESUSSED</name>
                            <description>Clock has been resuscitated, correct the error then send ctrl_clear=1</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FC0_REF_KHZ</name>
                    <description>Reference clock frequency in kHz</description>
                    <addressOffset>0x8C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FC0_REF_KHZ</name>
                            <bitRange>[19:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FC0_MIN_KHZ</name>
                    <description>Minimum pass frequency in kHz. This is optional. Set to 0 if you are not using the pass/fail flags</description>
                    <addressOffset>0x90</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FC0_MIN_KHZ</name>
                            <bitRange>[24:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FC0_MAX_KHZ</name>
                    <description>Maximum pass frequency in kHz. This is optional. Set to 0x1ffffff if you are not using the pass/fail flags</description>
                    <addressOffset>0x94</addressOffset>
                    <resetValue>0x01FFFFFF</resetValue>
                    <fields>
                        <field>
                            <name>FC0_MAX_KHZ</name>
                            <bitRange>[24:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FC0_DELAY</name>
                    <description>Delays the start of frequency counting to allow the mux to settle
                        Delay is measured in multiples of the reference clock period</description>
                    <addressOffset>0x98</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>FC0_DELAY</name>
                            <bitRange>[2:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FC0_INTERVAL</name>
                    <description>The test interval is 0.98us * 2**interval, but let's call it 1us * 2**interval
                        The default gives a test interval of 250us</description>
                    <addressOffset>0x9C</addressOffset>
                    <resetValue>0x00000008</resetValue>
                    <fields>
                        <field>
                            <name>FC0_INTERVAL</name>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FC0_SRC</name>
                    <description>Clock sent to frequency counter, set to 0 when not required
                        Writing to this register initiates the frequency count</description>
                    <addressOffset>0xA0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FC0_SRC</name>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NULL</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>pll_sys_clksrc_primary</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>pll_usb_clksrc_primary</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rosc_clksrc</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rosc_clksrc_ph</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xosc_clksrc</name>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin0</name>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clksrc_gpin1</name>
                                    <value>7</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_ref</name>
                                    <value>8</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_sys</name>
                                    <value>9</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_peri</name>
                                    <value>10</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_usb</name>
                                    <value>11</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_adc</name>
                                    <value>12</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>clk_hstx</name>
                                    <value>13</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>lposc_clksrc</name>
                                    <value>14</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>otp_clk2fc</name>
                                    <value>15</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>pll_usb_clksrc_primary_dft</name>
                                    <value>16</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FC0_STATUS</name>
                    <description>Frequency counter status</description>
                    <addressOffset>0xA4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DIED</name>
                            <description>Test clock stopped during test</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FAST</name>
                            <description>Test clock faster than expected, only valid when status_done=1</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SLOW</name>
                            <description>Test clock slower than expected, only valid when status_done=1</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FAIL</name>
                            <description>Test failed</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WAITING</name>
                            <description>Waiting for test clock to start</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RUNNING</name>
                            <description>Test running</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DONE</name>
                            <description>Test complete</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PASS</name>
                            <description>Test passed</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FC0_RESULT</name>
                    <description>Result of frequency measurement, only valid when status_done=1</description>
                    <addressOffset>0xA8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>KHZ</name>
                            <bitRange>[29:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FRAC</name>
                            <bitRange>[4:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>WAKE_EN0</name>
                    <description>enable clock in wake mode</description>
                    <addressOffset>0xAC</addressOffset>
                    <resetValue>0xFFFFFFFF</resetValue>
                    <fields>
                        <field>
                            <name>CLK_SYS_SIO</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SHA256</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PSM</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_ROSC</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_ROM</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_RESETS</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PWM</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_POWMAN</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_REF_POWMAN</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PLL_USB</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PLL_SYS</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PIO2</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PIO1</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PIO0</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PADS</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_OTP</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_REF_OTP</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_JTAG</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_IO</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_I2C1</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_I2C0</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_HSTX</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_HSTX</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_GLITCH_DETECTOR</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_DMA</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_BUSFABRIC</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_BUSCTRL</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_BOOTRAM</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_ADC</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_ADC</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_ACCESSCTRL</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_CLOCKS</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>WAKE_EN1</name>
                    <description>enable clock in wake mode</description>
                    <addressOffset>0xB0</addressOffset>
                    <resetValue>0x7FFFFFFF</resetValue>
                    <fields>
                        <field>
                            <name>CLK_SYS_XOSC</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_XIP</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_WATCHDOG</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_USB</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_USBCTRL</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_UART1</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_PERI_UART1</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_UART0</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_PERI_UART0</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_TRNG</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_TIMER1</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_TIMER0</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_TICKS</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_REF_TICKS</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_TBMAN</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SYSINFO</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SYSCFG</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM9</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM8</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM7</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM6</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM5</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM4</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM3</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM2</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM1</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM0</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SPI1</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_PERI_SPI1</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SPI0</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_PERI_SPI0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SLEEP_EN0</name>
                    <description>enable clock in sleep mode</description>
                    <addressOffset>0xB4</addressOffset>
                    <resetValue>0xFFFFFFFF</resetValue>
                    <fields>
                        <field>
                            <name>CLK_SYS_SIO</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SHA256</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PSM</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_ROSC</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_ROM</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_RESETS</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PWM</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_POWMAN</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_REF_POWMAN</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PLL_USB</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PLL_SYS</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PIO2</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PIO1</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PIO0</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PADS</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_OTP</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_REF_OTP</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_JTAG</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_IO</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_I2C1</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_I2C0</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_HSTX</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_HSTX</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_GLITCH_DETECTOR</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_DMA</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_BUSFABRIC</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_BUSCTRL</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_BOOTRAM</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_ADC</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_ADC</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_ACCESSCTRL</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_CLOCKS</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SLEEP_EN1</name>
                    <description>enable clock in sleep mode</description>
                    <addressOffset>0xB8</addressOffset>
                    <resetValue>0x7FFFFFFF</resetValue>
                    <fields>
                        <field>
                            <name>CLK_SYS_XOSC</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_XIP</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_WATCHDOG</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_USB</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_USBCTRL</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_UART1</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_PERI_UART1</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_UART0</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_PERI_UART0</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_TRNG</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_TIMER1</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_TIMER0</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_TICKS</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_REF_TICKS</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_TBMAN</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SYSINFO</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SYSCFG</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM9</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM8</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM7</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM6</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM5</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM4</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM3</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM2</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM1</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM0</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SPI1</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_PERI_SPI1</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SPI0</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLK_PERI_SPI0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ENABLED0</name>
                    <description>indicates the state of the clock enable</description>
                    <addressOffset>0xBC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLK_SYS_SIO</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SHA256</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PSM</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_ROSC</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_ROM</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_RESETS</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PWM</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_POWMAN</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_REF_POWMAN</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PLL_USB</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PLL_SYS</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PIO2</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PIO1</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PIO0</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_PADS</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_OTP</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_REF_OTP</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_JTAG</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_IO</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_I2C1</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_I2C0</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_HSTX</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_HSTX</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_GLITCH_DETECTOR</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_DMA</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_BUSFABRIC</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_BUSCTRL</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_BOOTRAM</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_ADC</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_ADC</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_ACCESSCTRL</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_CLOCKS</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ENABLED1</name>
                    <description>indicates the state of the clock enable</description>
                    <addressOffset>0xC0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLK_SYS_XOSC</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_XIP</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_WATCHDOG</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_USB</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_USBCTRL</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_UART1</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_PERI_UART1</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_UART0</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_PERI_UART0</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_TRNG</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_TIMER1</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_TIMER0</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_TICKS</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_REF_TICKS</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_TBMAN</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SYSINFO</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SYSCFG</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM9</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM8</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM7</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM6</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM5</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM4</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM3</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM2</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM1</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SRAM0</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SPI1</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_PERI_SPI1</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_SYS_SPI0</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLK_PERI_SPI0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTR</name>
                    <description>Raw Interrupts</description>
                    <addressOffset>0xC4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLK_SYS_RESUS</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTE</name>
                    <description>Interrupt Enable</description>
                    <addressOffset>0xC8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLK_SYS_RESUS</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTF</name>
                    <description>Interrupt Force</description>
                    <addressOffset>0xCC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLK_SYS_RESUS</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTS</name>
                    <description>Interrupt status after masking &amp; forcing</description>
                    <addressOffset>0xD0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLK_SYS_RESUS</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>TICKS</name>
            <baseAddress>0x40108000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x48</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <cluster>
                    <dim>6</dim>
                    <dimIncrement>0xC</dimIncrement>
                    <dimIndex>PROC0,PROC1,TIMER0,TIMER1,WATCHDOG,RISCV</dimIndex>
                    <name>TICK%s</name>
                    <description>Cluster TICK%s, containing *_CTRL, *_CYCLES, *_COUNT</description>
                    <addressOffset>0x0</addressOffset>
                    <register>
                        <name>CTRL</name>
                        <description>Controls the tick generator</description>
                        <addressOffset>0x0</addressOffset>
                        <resetValue>0x00000000</resetValue>
                        <fields>
                            <field>
                                <name>RUNNING</name>
                                <description>Is the tick generator running?</description>
                                <bitRange>[1:1]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>ENABLE</name>
                                <description>start / stop tick generation</description>
                                <bitRange>[0:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>CYCLES</name>
                        <addressOffset>0x4</addressOffset>
                        <resetValue>0x00000000</resetValue>
                        <fields>
                            <field>
                                <name>PROC0_CYCLES</name>
                                <description>Total number of clk_tick cycles before the next tick.</description>
                                <bitRange>[8:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>COUNT</name>
                        <addressOffset>0x8</addressOffset>
                        <resetMask>0x00000000</resetMask>
                        <fields>
                            <field>
                                <name>PROC0_COUNT</name>
                                <description>Count down timer: the remaining number clk_tick cycles before the next tick is generated.</description>
                                <bitRange>[8:0]</bitRange>
                                <access>read-only</access>
                            </field>
                        </fields>
                    </register>
                </cluster>
            </registers>
        </peripheral>
        <peripheral>
            <name>PADS_BANK0</name>
            <baseAddress>0x40038000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0xCC</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>VOLTAGE_SELECT</name>
                    <description>Voltage select. Per bank control</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>VOLTAGE_SELECT</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>3v3</name>
                                    <description>Set voltage to 3.3V (DVDD &gt;= 2V5)</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>1v8</name>
                                    <description>Set voltage to 1.8V (DVDD &lt;= 1V8)</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>48</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-47</dimIndex>
                    <name>GPIO%s</name>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000116</resetValue>
                    <fields>
                        <field>
                            <name>ISO</name>
                            <description>Pad isolation control. Remove this once the pad is configured by software.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>OD</name>
                            <description>Output disable. Has priority over output enable from peripherals</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>IE</name>
                            <description>Input enable</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DRIVE</name>
                            <description>Drive strength.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>2mA</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4mA</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8mA</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>12mA</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>PUE</name>
                            <description>Pull up enable</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PDE</name>
                            <description>Pull down enable</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SCHMITT</name>
                            <description>Enable schmitt trigger</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SLEWFAST</name>
                            <description>Slew rate control. 1 = Fast, 0 = Slow</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SWCLK</name>
                    <addressOffset>0xC4</addressOffset>
                    <resetValue>0x0000005A</resetValue>
                    <fields>
                        <field>
                            <name>ISO</name>
                            <description>Pad isolation control. Remove this once the pad is configured by software.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>OD</name>
                            <description>Output disable. Has priority over output enable from peripherals</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>IE</name>
                            <description>Input enable</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DRIVE</name>
                            <description>Drive strength.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>2mA</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4mA</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8mA</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>12mA</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>PUE</name>
                            <description>Pull up enable</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PDE</name>
                            <description>Pull down enable</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SCHMITT</name>
                            <description>Enable schmitt trigger</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SLEWFAST</name>
                            <description>Slew rate control. 1 = Fast, 0 = Slow</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SWD</name>
                    <addressOffset>0xC8</addressOffset>
                    <resetValue>0x0000005A</resetValue>
                    <fields>
                        <field>
                            <name>ISO</name>
                            <description>Pad isolation control. Remove this once the pad is configured by software.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>OD</name>
                            <description>Output disable. Has priority over output enable from peripherals</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>IE</name>
                            <description>Input enable</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DRIVE</name>
                            <description>Drive strength.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>2mA</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4mA</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8mA</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>12mA</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>PUE</name>
                            <description>Pull up enable</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PDE</name>
                            <description>Pull down enable</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SCHMITT</name>
                            <description>Enable schmitt trigger</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SLEWFAST</name>
                            <description>Slew rate control. 1 = Fast, 0 = Slow</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>PADS_QSPI</name>
            <baseAddress>0x40040000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x1C</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>VOLTAGE_SELECT</name>
                    <description>Voltage select. Per bank control</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>VOLTAGE_SELECT</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>3v3</name>
                                    <description>Set voltage to 3.3V (DVDD &gt;= 2V5)</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>1v8</name>
                                    <description>Set voltage to 1.8V (DVDD &lt;= 1V8)</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_QSPI_SCLK</name>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000156</resetValue>
                    <fields>
                        <field>
                            <name>ISO</name>
                            <description>Pad isolation control. Remove this once the pad is configured by software.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>OD</name>
                            <description>Output disable. Has priority over output enable from peripherals</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>IE</name>
                            <description>Input enable</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DRIVE</name>
                            <description>Drive strength.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>2mA</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4mA</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8mA</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>12mA</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>PUE</name>
                            <description>Pull up enable</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PDE</name>
                            <description>Pull down enable</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SCHMITT</name>
                            <description>Enable schmitt trigger</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SLEWFAST</name>
                            <description>Slew rate control. 1 = Fast, 0 = Slow</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_QSPI_SD0</name>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000156</resetValue>
                    <fields>
                        <field>
                            <name>ISO</name>
                            <description>Pad isolation control. Remove this once the pad is configured by software.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>OD</name>
                            <description>Output disable. Has priority over output enable from peripherals</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>IE</name>
                            <description>Input enable</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DRIVE</name>
                            <description>Drive strength.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>2mA</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4mA</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8mA</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>12mA</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>PUE</name>
                            <description>Pull up enable</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PDE</name>
                            <description>Pull down enable</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SCHMITT</name>
                            <description>Enable schmitt trigger</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SLEWFAST</name>
                            <description>Slew rate control. 1 = Fast, 0 = Slow</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_QSPI_SD1</name>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00000156</resetValue>
                    <fields>
                        <field>
                            <name>ISO</name>
                            <description>Pad isolation control. Remove this once the pad is configured by software.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>OD</name>
                            <description>Output disable. Has priority over output enable from peripherals</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>IE</name>
                            <description>Input enable</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DRIVE</name>
                            <description>Drive strength.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>2mA</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4mA</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8mA</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>12mA</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>PUE</name>
                            <description>Pull up enable</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PDE</name>
                            <description>Pull down enable</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SCHMITT</name>
                            <description>Enable schmitt trigger</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SLEWFAST</name>
                            <description>Slew rate control. 1 = Fast, 0 = Slow</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_QSPI_SD2</name>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x0000015A</resetValue>
                    <fields>
                        <field>
                            <name>ISO</name>
                            <description>Pad isolation control. Remove this once the pad is configured by software.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>OD</name>
                            <description>Output disable. Has priority over output enable from peripherals</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>IE</name>
                            <description>Input enable</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DRIVE</name>
                            <description>Drive strength.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>2mA</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4mA</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8mA</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>12mA</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>PUE</name>
                            <description>Pull up enable</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PDE</name>
                            <description>Pull down enable</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SCHMITT</name>
                            <description>Enable schmitt trigger</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SLEWFAST</name>
                            <description>Slew rate control. 1 = Fast, 0 = Slow</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_QSPI_SD3</name>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x0000015A</resetValue>
                    <fields>
                        <field>
                            <name>ISO</name>
                            <description>Pad isolation control. Remove this once the pad is configured by software.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>OD</name>
                            <description>Output disable. Has priority over output enable from peripherals</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>IE</name>
                            <description>Input enable</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DRIVE</name>
                            <description>Drive strength.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>2mA</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4mA</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8mA</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>12mA</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>PUE</name>
                            <description>Pull up enable</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PDE</name>
                            <description>Pull down enable</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SCHMITT</name>
                            <description>Enable schmitt trigger</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SLEWFAST</name>
                            <description>Slew rate control. 1 = Fast, 0 = Slow</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_QSPI_SS</name>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x0000015A</resetValue>
                    <fields>
                        <field>
                            <name>ISO</name>
                            <description>Pad isolation control. Remove this once the pad is configured by software.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>OD</name>
                            <description>Output disable. Has priority over output enable from peripherals</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>IE</name>
                            <description>Input enable</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DRIVE</name>
                            <description>Drive strength.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>2mA</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4mA</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8mA</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>12mA</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>PUE</name>
                            <description>Pull up enable</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PDE</name>
                            <description>Pull down enable</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SCHMITT</name>
                            <description>Enable schmitt trigger</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SLEWFAST</name>
                            <description>Slew rate control. 1 = Fast, 0 = Slow</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>IO_QSPI</name>
            <baseAddress>0x40030000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x240</size>
                <usage>registers</usage>
            </addressBlock>
            <interrupt>
                <name>IO_IRQ_QSPI</name>
                <value>23</value>
            </interrupt>
            <interrupt>
                <name>IO_IRQ_QSPI_NS</name>
                <value>24</value>
            </interrupt>
            <registers>
                <register>
                    <name>USBPHY_DP_STATUS</name>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>IRQTOPROC</name>
                            <description>interrupt to processors, after override is applied</description>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>INFROMPAD</name>
                            <description>input signal from pad, before filtering and override are applied</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>OETOPAD</name>
                            <description>output enable to pad after register override is applied</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>OUTTOPAD</name>
                            <description>output signal to pad after register override is applied</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>USBPHY_DP_CTRL</name>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x0000001F</resetValue>
                    <fields>
                        <field>
                            <name>IRQOVER</name>
                            <bitRange>[29:28]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NORMAL</name>
                                    <description>don't invert the interrupt</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INVERT</name>
                                    <description>invert the interrupt</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>LOW</name>
                                    <description>drive interrupt low</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>HIGH</name>
                                    <description>drive interrupt high</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>INOVER</name>
                            <bitRange>[17:16]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NORMAL</name>
                                    <description>don't invert the peri input</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INVERT</name>
                                    <description>invert the peri input</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>LOW</name>
                                    <description>drive peri input low</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>HIGH</name>
                                    <description>drive peri input high</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>OEOVER</name>
                            <bitRange>[15:14]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NORMAL</name>
                                    <description>drive output enable from peripheral signal selected by funcsel</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INVERT</name>
                                    <description>drive output enable from inverse of peripheral signal selected by funcsel</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>DISABLE</name>
                                    <description>disable output</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLE</name>
                                    <description>enable output</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>OUTOVER</name>
                            <bitRange>[13:12]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NORMAL</name>
                                    <description>drive output from peripheral signal selected by funcsel</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INVERT</name>
                                    <description>drive output from inverse of peripheral signal selected by funcsel</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>LOW</name>
                                    <description>drive output low</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>HIGH</name>
                                    <description>drive output high</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>FUNCSEL</name>
                            <description>0-31 -&gt; selects pin function according to the gpio table
                                31 == NULL</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>uart1_tx</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>i2c0_sda</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc_56</name>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>null</name>
                                    <value>31</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>USBPHY_DM_STATUS</name>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>IRQTOPROC</name>
                            <description>interrupt to processors, after override is applied</description>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>INFROMPAD</name>
                            <description>input signal from pad, before filtering and override are applied</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>OETOPAD</name>
                            <description>output enable to pad after register override is applied</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>OUTTOPAD</name>
                            <description>output signal to pad after register override is applied</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>USBPHY_DM_CTRL</name>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x0000001F</resetValue>
                    <fields>
                        <field>
                            <name>IRQOVER</name>
                            <bitRange>[29:28]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NORMAL</name>
                                    <description>don't invert the interrupt</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INVERT</name>
                                    <description>invert the interrupt</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>LOW</name>
                                    <description>drive interrupt low</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>HIGH</name>
                                    <description>drive interrupt high</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>INOVER</name>
                            <bitRange>[17:16]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NORMAL</name>
                                    <description>don't invert the peri input</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INVERT</name>
                                    <description>invert the peri input</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>LOW</name>
                                    <description>drive peri input low</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>HIGH</name>
                                    <description>drive peri input high</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>OEOVER</name>
                            <bitRange>[15:14]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NORMAL</name>
                                    <description>drive output enable from peripheral signal selected by funcsel</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INVERT</name>
                                    <description>drive output enable from inverse of peripheral signal selected by funcsel</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>DISABLE</name>
                                    <description>disable output</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLE</name>
                                    <description>enable output</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>OUTOVER</name>
                            <bitRange>[13:12]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NORMAL</name>
                                    <description>drive output from peripheral signal selected by funcsel</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INVERT</name>
                                    <description>drive output from inverse of peripheral signal selected by funcsel</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>LOW</name>
                                    <description>drive output low</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>HIGH</name>
                                    <description>drive output high</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>FUNCSEL</name>
                            <description>0-31 -&gt; selects pin function according to the gpio table
                                31 == NULL</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>uart1_rx</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>i2c0_scl</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc_57</name>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>null</name>
                                    <value>31</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <cluster>
                    <dim>6</dim>
                    <dimIncrement>0x8</dimIncrement>
                    <dimIndex>SCLK,SS,SD0,SD1,SD2,SD3</dimIndex>
                    <name>GPIO_QSPI%s</name>
                    <description>Cluster GPIO_QSPI%s, containing GPIO_QSPI_*_STATUS, GPIO_QSPI_*_CTRL</description>
                    <addressOffset>0x10</addressOffset>
                    <register>
                        <name>GPIO_STATUS</name>
                        <addressOffset>0x0</addressOffset>
                        <resetValue>0x00000000</resetValue>
                        <fields>
                            <field>
                                <name>IRQTOPROC</name>
                                <description>interrupt to processors, after override is applied</description>
                                <bitRange>[26:26]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>INFROMPAD</name>
                                <description>input signal from pad, before filtering and override are applied</description>
                                <bitRange>[17:17]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>OETOPAD</name>
                                <description>output enable to pad after register override is applied</description>
                                <bitRange>[13:13]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>OUTTOPAD</name>
                                <description>output signal to pad after register override is applied</description>
                                <bitRange>[9:9]</bitRange>
                                <access>read-only</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>GPIO_CTRL</name>
                        <addressOffset>0x4</addressOffset>
                        <resetValue>0x0000001F</resetValue>
                        <fields>
                            <field>
                                <name>IRQOVER</name>
                                <bitRange>[29:28]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>NORMAL</name>
                                        <description>don't invert the interrupt</description>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>INVERT</name>
                                        <description>invert the interrupt</description>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>LOW</name>
                                        <description>drive interrupt low</description>
                                        <value>2</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>HIGH</name>
                                        <description>drive interrupt high</description>
                                        <value>3</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>INOVER</name>
                                <bitRange>[17:16]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>NORMAL</name>
                                        <description>don't invert the peri input</description>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>INVERT</name>
                                        <description>invert the peri input</description>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>LOW</name>
                                        <description>drive peri input low</description>
                                        <value>2</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>HIGH</name>
                                        <description>drive peri input high</description>
                                        <value>3</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>OEOVER</name>
                                <bitRange>[15:14]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>NORMAL</name>
                                        <description>drive output enable from peripheral signal selected by funcsel</description>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>INVERT</name>
                                        <description>drive output enable from inverse of peripheral signal selected by funcsel</description>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>DISABLE</name>
                                        <description>disable output</description>
                                        <value>2</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>ENABLE</name>
                                        <description>enable output</description>
                                        <value>3</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>OUTOVER</name>
                                <bitRange>[13:12]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>NORMAL</name>
                                        <description>drive output from peripheral signal selected by funcsel</description>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>INVERT</name>
                                        <description>drive output from inverse of peripheral signal selected by funcsel</description>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>LOW</name>
                                        <description>drive output low</description>
                                        <value>2</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>HIGH</name>
                                        <description>drive output high</description>
                                        <value>3</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>FUNCSEL</name>
                                <description>0-31 -&gt; selects pin function according to the gpio table
                                    31 == NULL</description>
                                <bitRange>[4:0]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>xip_sclk</name>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>uart1_cts</name>
                                        <value>2</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>i2c1_sda</name>
                                        <value>3</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>siob_proc_58</name>
                                        <value>5</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>uart1_tx</name>
                                        <value>11</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>null</name>
                                        <value>31</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                        </fields>
                    </register>
                </cluster>
                <register>
                    <name>IRQSUMMARY_PROC0_SECURE</name>
                    <addressOffset>0x200</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_QSPI_SD3</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQSUMMARY_PROC0_NONSECURE</name>
                    <addressOffset>0x204</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_QSPI_SD3</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQSUMMARY_PROC1_SECURE</name>
                    <addressOffset>0x208</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_QSPI_SD3</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQSUMMARY_PROC1_NONSECURE</name>
                    <addressOffset>0x20C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_QSPI_SD3</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQSUMMARY_DORMANT_WAKE_SECURE</name>
                    <addressOffset>0x210</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_QSPI_SD3</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQSUMMARY_DORMANT_WAKE_NONSECURE</name>
                    <addressOffset>0x214</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_QSPI_SD3</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTR</name>
                    <description>Raw Interrupts</description>
                    <addressOffset>0x218</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PROC0_INTE</name>
                    <description>Interrupt Enable for proc0</description>
                    <addressOffset>0x21C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PROC0_INTF</name>
                    <description>Interrupt Force for proc0</description>
                    <addressOffset>0x220</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PROC0_INTS</name>
                    <description>Interrupt status after masking &amp; forcing for proc0</description>
                    <addressOffset>0x224</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PROC1_INTE</name>
                    <description>Interrupt Enable for proc1</description>
                    <addressOffset>0x228</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PROC1_INTF</name>
                    <description>Interrupt Force for proc1</description>
                    <addressOffset>0x22C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PROC1_INTS</name>
                    <description>Interrupt status after masking &amp; forcing for proc1</description>
                    <addressOffset>0x230</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DORMANT_WAKE_INTE</name>
                    <description>Interrupt Enable for dormant_wake</description>
                    <addressOffset>0x234</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DORMANT_WAKE_INTF</name>
                    <description>Interrupt Force for dormant_wake</description>
                    <addressOffset>0x238</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DORMANT_WAKE_INTS</name>
                    <description>Interrupt status after masking &amp; forcing for dormant_wake</description>
                    <addressOffset>0x23C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD3_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD2_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD1_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SD0_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SS_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO_QSPI_SCLK_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DM_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USBPHY_DP_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>IO_BANK0</name>
            <baseAddress>0x40028000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x320</size>
                <usage>registers</usage>
            </addressBlock>
            <interrupt>
                <name>IO_IRQ_BANK0</name>
                <value>21</value>
            </interrupt>
            <interrupt>
                <name>IO_IRQ_BANK0_NS</name>
                <value>22</value>
            </interrupt>
            <registers>
                <cluster>
                    <dim>48</dim>
                    <dimIncrement>0x8</dimIncrement>
                    <dimIndex>0-47</dimIndex>
                    <name>GPIO%s</name>
                    <description>Cluster GPIO%s, containing GPIO*_STATUS, GPIO*_CTRL</description>
                    <addressOffset>0x0</addressOffset>
                    <register>
                        <name>GPIO_STATUS</name>
                        <addressOffset>0x0</addressOffset>
                        <resetValue>0x00000000</resetValue>
                        <fields>
                            <field>
                                <name>IRQTOPROC</name>
                                <description>interrupt to processors, after override is applied</description>
                                <bitRange>[26:26]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>INFROMPAD</name>
                                <description>input signal from pad, before filtering and override are applied</description>
                                <bitRange>[17:17]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>OETOPAD</name>
                                <description>output enable to pad after register override is applied</description>
                                <bitRange>[13:13]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>OUTTOPAD</name>
                                <description>output signal to pad after register override is applied</description>
                                <bitRange>[9:9]</bitRange>
                                <access>read-only</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>GPIO_CTRL</name>
                        <addressOffset>0x4</addressOffset>
                        <resetValue>0x0000001F</resetValue>
                        <fields>
                            <field>
                                <name>IRQOVER</name>
                                <bitRange>[29:28]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>NORMAL</name>
                                        <description>don't invert the interrupt</description>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>INVERT</name>
                                        <description>invert the interrupt</description>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>LOW</name>
                                        <description>drive interrupt low</description>
                                        <value>2</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>HIGH</name>
                                        <description>drive interrupt high</description>
                                        <value>3</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>INOVER</name>
                                <bitRange>[17:16]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>NORMAL</name>
                                        <description>don't invert the peri input</description>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>INVERT</name>
                                        <description>invert the peri input</description>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>LOW</name>
                                        <description>drive peri input low</description>
                                        <value>2</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>HIGH</name>
                                        <description>drive peri input high</description>
                                        <value>3</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>OEOVER</name>
                                <bitRange>[15:14]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>NORMAL</name>
                                        <description>drive output enable from peripheral signal selected by funcsel</description>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>INVERT</name>
                                        <description>drive output enable from inverse of peripheral signal selected by funcsel</description>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>DISABLE</name>
                                        <description>disable output</description>
                                        <value>2</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>ENABLE</name>
                                        <description>enable output</description>
                                        <value>3</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>OUTOVER</name>
                                <bitRange>[13:12]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>NORMAL</name>
                                        <description>drive output from peripheral signal selected by funcsel</description>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>INVERT</name>
                                        <description>drive output from inverse of peripheral signal selected by funcsel</description>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>LOW</name>
                                        <description>drive output low</description>
                                        <value>2</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>HIGH</name>
                                        <description>drive output high</description>
                                        <value>3</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>FUNCSEL</name>
                                <description>0-31 -&gt; selects pin function according to the GPIO table. Not all options are valid for all GPIO pins.</description>
                                <bitRange>[4:0]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <name>FUNCSEL</name>
                                    <enumeratedValue>
                                        <name>jtag</name>
                                        <description>Connect to JTAG peripheral</description>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>spi</name>
                                        <description>Connect to matching SPI peripheral</description>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>uart</name>
                                        <description>Connect to matching UART peripheral</description>
                                        <value>2</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>i2c</name>
                                        <description>Connect to matching I2C peripheral</description>
                                        <value>3</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>pwm</name>
                                        <description>Connect to matching PWM peripheral</description>
                                        <value>4</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>sio</name>
                                        <description>Use as a GPIO pin (connect to SIO peripheral)</description>
                                        <value>5</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>pio0</name>
                                        <description>Connect to PIO0 peripheral</description>
                                        <value>6</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>pio1</name>
                                        <description>Connect to PIO1 peripheral</description>
                                        <value>7</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>pio2</name>
                                        <description>Connect to PIO2 peripheral</description>
                                        <value>8</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>gpck</name>
                                        <description>Connect to GPCK peripheral</description>
                                        <value>9</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>usb</name>
                                        <description>Connect to USB peripheral </description>
                                        <value>10</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>uart_aux</name>
                                        <description>Connect to matching UART_AUX peripheral </description>
                                        <value>11</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>null</name>
                                        <description>Connect to nothing</description>
                                        <value>31</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                        </fields>
                    </register>
                </cluster>
                <register>
                    <name>IRQSUMMARY_PROC0_SECURE0</name>
                    <addressOffset>0x200</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO31</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO30</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO29</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO28</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO27</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO26</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO25</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO24</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO23</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO22</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO21</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO20</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO19</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO18</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO17</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO16</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO15</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO14</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO13</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO12</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO11</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO10</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO9</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO8</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO7</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQSUMMARY_PROC0_SECURE1</name>
                    <addressOffset>0x204</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO47</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO46</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO45</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO44</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO43</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO42</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO41</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO40</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO39</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO38</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO37</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO36</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO35</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO34</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO33</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO32</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQSUMMARY_PROC0_NONSECURE0</name>
                    <addressOffset>0x208</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO31</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO30</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO29</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO28</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO27</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO26</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO25</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO24</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO23</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO22</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO21</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO20</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO19</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO18</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO17</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO16</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO15</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO14</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO13</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO12</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO11</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO10</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO9</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO8</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO7</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQSUMMARY_PROC0_NONSECURE1</name>
                    <addressOffset>0x20C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO47</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO46</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO45</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO44</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO43</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO42</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO41</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO40</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO39</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO38</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO37</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO36</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO35</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO34</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO33</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO32</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQSUMMARY_PROC1_SECURE0</name>
                    <addressOffset>0x210</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO31</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO30</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO29</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO28</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO27</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO26</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO25</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO24</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO23</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO22</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO21</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO20</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO19</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO18</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO17</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO16</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO15</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO14</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO13</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO12</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO11</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO10</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO9</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO8</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO7</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQSUMMARY_PROC1_SECURE1</name>
                    <addressOffset>0x214</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO47</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO46</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO45</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO44</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO43</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO42</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO41</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO40</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO39</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO38</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO37</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO36</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO35</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO34</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO33</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO32</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQSUMMARY_PROC1_NONSECURE0</name>
                    <addressOffset>0x218</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO31</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO30</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO29</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO28</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO27</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO26</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO25</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO24</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO23</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO22</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO21</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO20</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO19</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO18</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO17</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO16</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO15</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO14</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO13</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO12</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO11</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO10</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO9</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO8</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO7</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQSUMMARY_PROC1_NONSECURE1</name>
                    <addressOffset>0x21C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO47</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO46</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO45</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO44</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO43</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO42</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO41</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO40</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO39</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO38</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO37</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO36</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO35</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO34</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO33</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO32</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQSUMMARY_DORMANT_WAKE_SECURE0</name>
                    <addressOffset>0x220</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO31</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO30</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO29</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO28</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO27</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO26</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO25</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO24</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO23</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO22</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO21</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO20</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO19</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO18</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO17</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO16</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO15</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO14</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO13</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO12</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO11</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO10</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO9</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO8</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO7</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQSUMMARY_DORMANT_WAKE_SECURE1</name>
                    <addressOffset>0x224</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO47</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO46</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO45</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO44</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO43</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO42</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO41</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO40</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO39</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO38</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO37</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO36</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO35</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO34</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO33</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO32</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQSUMMARY_DORMANT_WAKE_NONSECURE0</name>
                    <addressOffset>0x228</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO31</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO30</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO29</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO28</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO27</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO26</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO25</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO24</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO23</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO22</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO21</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO20</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO19</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO18</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO17</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO16</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO15</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO14</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO13</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO12</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO11</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO10</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO9</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO8</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO7</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQSUMMARY_DORMANT_WAKE_NONSECURE1</name>
                    <addressOffset>0x22C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO47</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO46</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO45</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO44</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO43</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO42</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO41</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO40</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO39</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO38</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO37</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO36</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO35</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO34</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO33</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO32</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>6</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-5</dimIndex>
                    <name>INTR%s</name>
                    <description>Raw Interrupts</description>
                    <addressOffset>0x230</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO7_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO7_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>6</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-5</dimIndex>
                    <name>PROC0_INTE%s</name>
                    <description>Interrupt Enable for proc0</description>
                    <addressOffset>0x248</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO7_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO7_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>6</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-5</dimIndex>
                    <name>PROC0_INTF%s</name>
                    <description>Interrupt Force for proc0</description>
                    <addressOffset>0x260</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO7_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO7_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>6</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-5</dimIndex>
                    <name>PROC0_INTS%s</name>
                    <description>Interrupt status after masking &amp; forcing for proc0</description>
                    <addressOffset>0x278</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO7_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO7_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>6</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-5</dimIndex>
                    <name>PROC1_INTE%s</name>
                    <description>Interrupt Enable for proc1</description>
                    <addressOffset>0x290</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO7_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO7_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>6</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-5</dimIndex>
                    <name>PROC1_INTF%s</name>
                    <description>Interrupt Force for proc1</description>
                    <addressOffset>0x2A8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO7_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO7_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>6</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-5</dimIndex>
                    <name>PROC1_INTS%s</name>
                    <description>Interrupt status after masking &amp; forcing for proc1</description>
                    <addressOffset>0x2C0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO7_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO7_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>6</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-5</dimIndex>
                    <name>DORMANT_WAKE_INTE%s</name>
                    <description>Interrupt Enable for dormant_wake</description>
                    <addressOffset>0x2D8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO7_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO7_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>6</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-5</dimIndex>
                    <name>DORMANT_WAKE_INTF%s</name>
                    <description>Interrupt Force for dormant_wake</description>
                    <addressOffset>0x2F0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO7_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO7_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>6</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-5</dimIndex>
                    <name>DORMANT_WAKE_INTS%s</name>
                    <description>Interrupt status after masking &amp; forcing for dormant_wake</description>
                    <addressOffset>0x308</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO7_EDGE_HIGH</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO7_EDGE_LOW</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_HIGH</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO7_LEVEL_LOW</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_HIGH</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6_EDGE_LOW</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_HIGH</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO6_LEVEL_LOW</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_HIGH</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5_EDGE_LOW</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_HIGH</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO5_LEVEL_LOW</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_HIGH</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4_EDGE_LOW</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_HIGH</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO4_LEVEL_LOW</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_HIGH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3_EDGE_LOW</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_HIGH</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO3_LEVEL_LOW</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_HIGH</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2_EDGE_LOW</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_HIGH</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO2_LEVEL_LOW</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_HIGH</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1_EDGE_LOW</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_HIGH</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO1_LEVEL_LOW</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_HIGH</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0_EDGE_LOW</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_HIGH</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO0_LEVEL_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>SYSINFO</name>
            <baseAddress>0x40000000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x18</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>CHIP_ID</name>
                    <description>JEDEC JEP-106 compliant chip identifier.</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>REVISION</name>
                            <bitRange>[31:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PART</name>
                            <bitRange>[27:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>MANUFACTURER</name>
                            <bitRange>[11:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>STOP_BIT</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PACKAGE_SEL</name>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PACKAGE_SEL</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PLATFORM</name>
                    <description>Platform register. Allows software to know what environment it is running in during pre-production development. Post-production, the PLATFORM is always ASIC, non-SIM.</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GATESIM</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BATCHSIM</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HDLSIM</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ASIC</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FPGA</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GITREF_RP2350</name>
                    <description>Git hash of the chip source. Used to identify chip version.</description>
                    <addressOffset>0x14</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>GITREF_RP2350</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>SHA256</name>
            <description>SHA-256 hash function implementation</description>
            <baseAddress>0x400F8000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x28</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>CSR</name>
                    <description>Control and status register</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00001206</resetValue>
                    <fields>
                        <field>
                            <name>BSWAP</name>
                            <description>Enable byte swapping of 32-bit values at the point they are committed to the SHA message scheduler.

                                This block's bus interface assembles byte/halfword data into message words in little-endian order, so that DMAing the same buffer with different transfer sizes always gives the same result on a little-endian system like RP2350.

                                However, when marshalling bytes into blocks, SHA expects that the first byte is the *most significant* in each message word. To resolve this, once the bus interface has accumulated 32 bits of data (either a word write, two halfword writes in little-endian order, or four byte writes in little-endian order) the final value can be byte-swapped before passing to the actual SHA core.

                                This feature is enabled by default because using the SHA core to checksum byte buffers is expected to be more common than having preformatted SHA message words lying around.</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA_SIZE</name>
                            <description>Configure DREQ logic for the correct DMA data size. Must be configured before the DMA channel is triggered.

                                The SHA-256 core's DREQ logic requests one entire block of data at once, since there is no FIFO, and data goes straight into the core's message schedule and digest hardware. Therefore, when transferring data with DMA, CSR_DMA_SIZE must be configured in advance so that the correct number of transfers can be requested per block.</description>
                            <bitRange>[9:8]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>8bit</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>16bit</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>32bit</name>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ERR_WDATA_NOT_RDY</name>
                            <description>Set when a write occurs whilst the SHA-256 core is not ready for data (WDATA_RDY is low). Write one to clear.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>SUM_VLD</name>
                            <description>If 1, the SHA-256 checksum presented in registers SUM0 through SUM7 is currently valid.

                                Goes low when WDATA is first written, then returns high once 16 words have been written and the digest of the current 512-bit block has subsequently completed.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WDATA_RDY</name>
                            <description>If 1, the SHA-256 core is ready to accept more data through the WDATA register.

                                After writing 16 words, this flag will go low for 57 cycles whilst the core completes its digest.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>START</name>
                            <description>Write 1 to prepare the SHA-256 core for a new checksum.

                                The SUMx registers are initialised to the proper values (fractional bits of square roots of first 8 primes) and internal counters are cleared. This immediately forces WDATA_RDY and SUM_VLD high.

                                START must be written before initiating a DMA transfer to the SHA-256 core, because the core will always request 16 transfers at a time (1 512-bit block). Additionally, the DMA channel should be configured for a multiple of 16 32-bit transfers.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>WDATA</name>
                    <description>Write data register</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>WDATA</name>
                            <description>After pulsing START and writing 16 words of data to this register, WDATA_RDY will go low and the SHA-256 core will complete the digest of the current 512-bit block.

                                Software is responsible for ensuring the data is correctly padded and terminated to a whole number of 512-bit blocks.

                                After this, WDATA_RDY will return high, and more data can be written (if any).

                                This register supports word, halfword and byte writes, so that DMA from non-word-aligned buffers can be supported. The total amount of data per block remains the same (16 words, 32 halfwords or 64 bytes) and byte/halfword transfers must not be mixed within a block.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SUM0</name>
                    <description>256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SUM0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SUM1</name>
                    <description>256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SUM1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SUM2</name>
                    <description>256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SUM2</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SUM3</name>
                    <description>256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SUM3</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SUM4</name>
                    <description>256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SUM4</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SUM5</name>
                    <description>256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.</description>
                    <addressOffset>0x1C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SUM5</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SUM6</name>
                    <description>256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.</description>
                    <addressOffset>0x20</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SUM6</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SUM7</name>
                    <description>256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.</description>
                    <addressOffset>0x24</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SUM7</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>HSTX_FIFO</name>
            <description>FIFO status and write access for HSTX</description>
            <baseAddress>0x50600000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x8</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>STAT</name>
                    <description>FIFO status</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>WOF</name>
                            <description>FIFO was written when full. Write 1 to clear.</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EMPTY</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FULL</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LEVEL</name>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FIFO</name>
                    <description>Write access to FIFO</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FIFO</name>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>HSTX_CTRL</name>
            <description>Control interface to HSTX. For FIFO write access and status, see the HSTX_FIFO register block.</description>
            <baseAddress>0x400C0000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x2C</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>CSR</name>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x10050600</resetValue>
                    <fields>
                        <field>
                            <name>CLKDIV</name>
                            <description>Clock period of the generated clock, measured in HSTX clock cycles. Can be odd or even. The generated clock advances only on cycles where the shift register shifts.

                                For example, a clkdiv of 5 would generate a complete output clock period for every 5 HSTX clocks (or every 10 half-clocks).

                                A CLKDIV value of 0 is mapped to a period of 16 HSTX clock cycles.</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLKPHASE</name>
                            <description>Set the initial phase of the generated clock.

                                A CLKPHASE of 0 means the clock is initially low, and the first rising edge occurs after one half period of the generated clock (i.e. CLKDIV/2 cycles of clk_hstx). Incrementing CLKPHASE by 1 will advance the initial clock phase by one half clk_hstx period. For example, if CLKDIV=2 and CLKPHASE=1:

                                * The clock will be initially low

                                * The first rising edge will be 0.5 clk_hstx cycles after asserting first data

                                * The first falling edge will be 1.5 clk_hstx cycles after asserting first data

                                This configuration would be suitable for serialising at a bit rate of clk_hstx with a centre-aligned DDR clock.

                                When the HSTX is halted by clearing CSR_EN, the clock generator will return to its initial phase as configured by the CLKPHASE field.

                                Note CLKPHASE must be strictly less than double the value of CLKDIV (one full period), else its operation is undefined.</description>
                            <bitRange>[27:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>N_SHIFTS</name>
                            <description>Number of times to shift the shift register before refilling it from the FIFO. (A count of how many times it has been shifted, *not* the total shift distance.)

                                A register value of 0 means shift 32 times.</description>
                            <bitRange>[20:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SHIFT</name>
                            <description>How many bits to right-rotate the shift register by each cycle.

                                The use of a rotate rather than a shift allows left shifts to be emulated, by subtracting the left-shift amount from 32. It also allows data to be repeated, when the product of SHIFT and N_SHIFTS is greater than 32.</description>
                            <bitRange>[12:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>COUPLED_SEL</name>
                            <description>Select which PIO to use for coupled mode operation.</description>
                            <bitRange>[6:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>COUPLED_MODE</name>
                            <description>Enable the PIO-to-HSTX 1:1 connection. The HSTX must be clocked *directly* from the system clock (not just from some other clock source of the same frequency) for this synchronous interface to function correctly.

                                When COUPLED_MODE is set, BITx_SEL_P and SEL_N indices 24 through 31 will select bits from the 8-bit PIO-to-HSTX path, rather than shifter bits. Indices of 0 through 23 will still index the shift register as normal.

                                The PIO outputs connected to the PIO-to-HSTX bus are those same outputs that would appear on the HSTX-capable pins if those pins' FUNCSELs were set to PIO instead of HSTX.

                                For example, if HSTX is on GPIOs 12 through 19, then PIO outputs 12 through 19 are connected to the HSTX when coupled mode is engaged.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EXPAND_EN</name>
                            <description>Enable the command expander. When 0, raw FIFO data is passed directly to the output shift register. When 1, the command expander can perform simple operations such as run length decoding on data between the FIFO and the shift register.

                                Do not change CXPD_EN whilst EN is set. It's safe to set CXPD_EN simultaneously with setting EN.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>When EN is 1, the HSTX will shift out data as it appears in the FIFO. As long as there is data, the HSTX shift register will shift once per clock cycle, and the frequency of popping from the FIFO is determined by the ratio of SHIFT and SHIFT_THRESH.

                                When EN is 0, the FIFO is not popped. The shift counter and clock generator are also reset to their initial state for as long as EN is low. Note the initial phase of the clock generator can be configured by the CLKPHASE field.

                                Once the HSTX is enabled again, and data is pushed to the FIFO, the generated clock's first rising edge will be one half-period after the first data is launched.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BIT0</name>
                    <description>Data control register for output bit 0</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLK</name>
                            <description>Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INV</name>
                            <description>Invert this data output (logical NOT)</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL_N</name>
                            <description>Shift register data bit select for the second half of the HSTX clock cycle</description>
                            <bitRange>[12:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL_P</name>
                            <description>Shift register data bit select for the first half of the HSTX clock cycle</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BIT1</name>
                    <description>Data control register for output bit 1</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLK</name>
                            <description>Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INV</name>
                            <description>Invert this data output (logical NOT)</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL_N</name>
                            <description>Shift register data bit select for the second half of the HSTX clock cycle</description>
                            <bitRange>[12:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL_P</name>
                            <description>Shift register data bit select for the first half of the HSTX clock cycle</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BIT2</name>
                    <description>Data control register for output bit 2</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLK</name>
                            <description>Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INV</name>
                            <description>Invert this data output (logical NOT)</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL_N</name>
                            <description>Shift register data bit select for the second half of the HSTX clock cycle</description>
                            <bitRange>[12:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL_P</name>
                            <description>Shift register data bit select for the first half of the HSTX clock cycle</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BIT3</name>
                    <description>Data control register for output bit 3</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLK</name>
                            <description>Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INV</name>
                            <description>Invert this data output (logical NOT)</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL_N</name>
                            <description>Shift register data bit select for the second half of the HSTX clock cycle</description>
                            <bitRange>[12:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL_P</name>
                            <description>Shift register data bit select for the first half of the HSTX clock cycle</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BIT4</name>
                    <description>Data control register for output bit 4</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLK</name>
                            <description>Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INV</name>
                            <description>Invert this data output (logical NOT)</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL_N</name>
                            <description>Shift register data bit select for the second half of the HSTX clock cycle</description>
                            <bitRange>[12:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL_P</name>
                            <description>Shift register data bit select for the first half of the HSTX clock cycle</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BIT5</name>
                    <description>Data control register for output bit 5</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLK</name>
                            <description>Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INV</name>
                            <description>Invert this data output (logical NOT)</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL_N</name>
                            <description>Shift register data bit select for the second half of the HSTX clock cycle</description>
                            <bitRange>[12:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL_P</name>
                            <description>Shift register data bit select for the first half of the HSTX clock cycle</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BIT6</name>
                    <description>Data control register for output bit 6</description>
                    <addressOffset>0x1C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLK</name>
                            <description>Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INV</name>
                            <description>Invert this data output (logical NOT)</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL_N</name>
                            <description>Shift register data bit select for the second half of the HSTX clock cycle</description>
                            <bitRange>[12:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL_P</name>
                            <description>Shift register data bit select for the first half of the HSTX clock cycle</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BIT7</name>
                    <description>Data control register for output bit 7</description>
                    <addressOffset>0x20</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLK</name>
                            <description>Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INV</name>
                            <description>Invert this data output (logical NOT)</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL_N</name>
                            <description>Shift register data bit select for the second half of the HSTX clock cycle</description>
                            <bitRange>[12:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL_P</name>
                            <description>Shift register data bit select for the first half of the HSTX clock cycle</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>EXPAND_SHIFT</name>
                    <description>Configure the optional shifter inside the command expander</description>
                    <addressOffset>0x24</addressOffset>
                    <resetValue>0x01000100</resetValue>
                    <fields>
                        <field>
                            <name>ENC_N_SHIFTS</name>
                            <description>Number of times to consume from the shift register before refilling it from the FIFO, when the current command is an encoded data command (e.g. TMDS). A register value of 0 means shift 32 times.</description>
                            <bitRange>[28:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENC_SHIFT</name>
                            <description>How many bits to right-rotate the shift register by each time data is pushed to the output shifter, when the current command is an encoded data command (e.g. TMDS).</description>
                            <bitRange>[20:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RAW_N_SHIFTS</name>
                            <description>Number of times to consume from the shift register before refilling it from the FIFO, when the current command is a raw data command. A register value of 0 means shift 32 times.</description>
                            <bitRange>[12:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RAW_SHIFT</name>
                            <description>How many bits to right-rotate the shift register by each time data is pushed to the output shifter, when the current command is a raw data command.</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>EXPAND_TMDS</name>
                    <description>Configure the optional TMDS encoder inside the command expander</description>
                    <addressOffset>0x28</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>L2_NBITS</name>
                            <description>Number of valid data bits for the lane 2 TMDS encoder, starting from bit 7 of the rotated data. Field values of 0 -&gt; 7 encode counts of 1 -&gt; 8 bits.</description>
                            <bitRange>[23:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>L2_ROT</name>
                            <description>Right-rotate applied to the current shifter data before the lane 2 TMDS encoder.</description>
                            <bitRange>[20:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>L1_NBITS</name>
                            <description>Number of valid data bits for the lane 1 TMDS encoder, starting from bit 7 of the rotated data. Field values of 0 -&gt; 7 encode counts of 1 -&gt; 8 bits.</description>
                            <bitRange>[15:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>L1_ROT</name>
                            <description>Right-rotate applied to the current shifter data before the lane 1 TMDS encoder.</description>
                            <bitRange>[12:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>L0_NBITS</name>
                            <description>Number of valid data bits for the lane 0 TMDS encoder, starting from bit 7 of the rotated data. Field values of 0 -&gt; 7 encode counts of 1 -&gt; 8 bits.</description>
                            <bitRange>[7:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>L0_ROT</name>
                            <description>Right-rotate applied to the current shifter data before the lane 0 TMDS encoder.</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>EPPB</name>
            <description>Cortex-M33 EPPB vendor register block for RP2350</description>
            <baseAddress>0xE0080000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0xC</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>NMI_MASK0</name>
                    <description>NMI mask for IRQs 0 through 31. This register is core-local, and is reset by a processor warm reset.</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NMI_MASK0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NMI_MASK1</name>
                    <description>NMI mask for IRQs 0 though 51. This register is core-local, and is reset by a processor warm reset.</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NMI_MASK1</name>
                            <bitRange>[19:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SLEEPCTRL</name>
                    <description>Nonstandard sleep control register</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000002</resetValue>
                    <fields>
                        <field>
                            <name>WICENACK</name>
                            <description>Status signal from the processor's interrupt controller. Changes to WICENREQ are eventually reflected in WICENACK.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WICENREQ</name>
                            <description>Request that the next processor deep sleep is a WIC sleep. After setting this bit, before sleeping, poll WICENACK to ensure the processor interrupt controller has acknowledged the change.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>LIGHT_SLEEP</name>
                            <description>By default, any processor sleep will deassert the system-level clock request. Reenabling the clocks incurs 5 cycles of additional latency on wakeup.

                                Setting LIGHT_SLEEP to 1 keeps the clock request asserted during a normal sleep (Arm SCR.SLEEPDEEP = 0), for faster wakeup. Processor deep sleep (Arm SCR.SLEEPDEEP = 1) is not affected, and will always deassert the system-level clock request.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>PPB</name>
            <description>TEAL registers accessible through the debug interface</description>
            <baseAddress>0xE0000000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x43000</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>ITM_STIM0</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM1</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM2</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM3</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM4</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM5</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM6</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM7</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x1C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM8</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x20</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM9</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x24</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM10</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x28</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM11</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x2C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM12</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x30</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM13</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x34</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM14</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x38</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM15</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x3C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM16</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x40</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM17</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x44</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM18</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x48</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM19</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x4C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM20</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x50</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM21</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x54</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM22</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x58</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM23</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x5C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM24</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x60</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM25</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x64</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM26</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x68</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM27</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x6C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM28</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x70</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM29</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x74</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM30</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x78</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_STIM31</name>
                    <description>Provides the interface for generating Instrumentation packets</description>
                    <addressOffset>0x7C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMULUS</name>
                            <description>Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_TER0</name>
                    <description>Provide an individual enable bit for each ITM_STIM register</description>
                    <addressOffset>0xE00</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STIMENA</name>
                            <description>For STIMENA[m] in ITM_TER*n, controls whether ITM_STIM(32*n + m) is enabled</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_TPR</name>
                    <description>Controls which stimulus ports can be accessed by unprivileged code</description>
                    <addressOffset>0xE40</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRIVMASK</name>
                            <description>Bit mask to enable tracing on ITM stimulus ports</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_TCR</name>
                    <description>Configures and controls transfers through the ITM interface</description>
                    <addressOffset>0xE80</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BUSY</name>
                            <description>Indicates whether the ITM is currently processing events</description>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TRACEBUSID</name>
                            <description>Identifier for multi-source trace stream formatting. If multi-source trace is in use, the debugger must write a unique non-zero trace ID value to this field</description>
                            <bitRange>[22:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GTSFREQ</name>
                            <description>Defines how often the ITM generates a global timestamp, based on the global timestamp clock frequency, or disables generation of global timestamps</description>
                            <bitRange>[11:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TSPRESCALE</name>
                            <description>Local timestamp prescaler, used with the trace packet reference clock</description>
                            <bitRange>[9:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>STALLENA</name>
                            <description>Stall the PE to guarantee delivery of Data Trace packets.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SWOENA</name>
                            <description>Enables asynchronous clocking of the timestamp counter</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TXENA</name>
                            <description>Enables forwarding of hardware event packet from the DWT unit to the ITM for output to the TPIU</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SYNCENA</name>
                            <description>Enables Synchronization packet transmission for a synchronous TPIU</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TSENA</name>
                            <description>Enables Local timestamp generation</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ITMENA</name>
                            <description>Enables the ITM</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INT_ATREADY</name>
                    <description>Integration Mode: Read ATB Ready</description>
                    <addressOffset>0xEF0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>AFVALID</name>
                            <description>A read of this bit returns the value of AFVALID</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ATREADY</name>
                            <description>A read of this bit returns the value of ATREADY</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INT_ATVALID</name>
                    <description>Integration Mode: Write ATB Valid</description>
                    <addressOffset>0xEF8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>AFREADY</name>
                            <description>A write to this bit gives the value of AFREADY</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ATREADY</name>
                            <description>A write to this bit gives the value of ATVALID</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_ITCTRL</name>
                    <description>Integration Mode Control Register</description>
                    <addressOffset>0xF00</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>IME</name>
                            <description>Integration mode enable bit - The possible values are:  0 - The trace unit is not in integration mode. 1 - The trace unit is in integration mode. This mode enables: A debug agent to perform topology detection. SoC test software to perform integration testing.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_DEVARCH</name>
                    <description>Provides CoreSight discovery information for the ITM</description>
                    <addressOffset>0xFBC</addressOffset>
                    <resetValue>0x47701A01</resetValue>
                    <fields>
                        <field>
                            <name>ARCHITECT</name>
                            <description>Defines the architect of the component. Bits [31:28] are the JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the JEP106 ID code.</description>
                            <bitRange>[31:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PRESENT</name>
                            <description>Defines that the DEVARCH register is present</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>REVISION</name>
                            <description>Defines the architecture revision of the component</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ARCHVER</name>
                            <description>Defines the architecture version of the component</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ARCHPART</name>
                            <description>Defines the architecture of the component</description>
                            <bitRange>[11:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_DEVTYPE</name>
                    <description>Provides CoreSight discovery information for the ITM</description>
                    <addressOffset>0xFCC</addressOffset>
                    <resetValue>0x00000043</resetValue>
                    <fields>
                        <field>
                            <name>SUB</name>
                            <description>Component sub-type</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>MAJOR</name>
                            <description>Component major type</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_PIDR4</name>
                    <description>Provides CoreSight discovery information for the ITM</description>
                    <addressOffset>0xFD0</addressOffset>
                    <resetValue>0x00000004</resetValue>
                    <fields>
                        <field>
                            <name>SIZE</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DES_2</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_PIDR5</name>
                    <description>Provides CoreSight discovery information for the ITM</description>
                    <addressOffset>0xFD4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ITM_PIDR5</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_PIDR6</name>
                    <description>Provides CoreSight discovery information for the ITM</description>
                    <addressOffset>0xFD8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ITM_PIDR6</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_PIDR7</name>
                    <description>Provides CoreSight discovery information for the ITM</description>
                    <addressOffset>0xFDC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ITM_PIDR7</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_PIDR0</name>
                    <description>Provides CoreSight discovery information for the ITM</description>
                    <addressOffset>0xFE0</addressOffset>
                    <resetValue>0x00000021</resetValue>
                    <fields>
                        <field>
                            <name>PART_0</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_PIDR1</name>
                    <description>Provides CoreSight discovery information for the ITM</description>
                    <addressOffset>0xFE4</addressOffset>
                    <resetValue>0x000000BD</resetValue>
                    <fields>
                        <field>
                            <name>DES_0</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PART_1</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_PIDR2</name>
                    <description>Provides CoreSight discovery information for the ITM</description>
                    <addressOffset>0xFE8</addressOffset>
                    <resetValue>0x0000000B</resetValue>
                    <fields>
                        <field>
                            <name>REVISION</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>JEDEC</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DES_1</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_PIDR3</name>
                    <description>Provides CoreSight discovery information for the ITM</description>
                    <addressOffset>0xFEC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>REVAND</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CMOD</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_CIDR0</name>
                    <description>Provides CoreSight discovery information for the ITM</description>
                    <addressOffset>0xFF0</addressOffset>
                    <resetValue>0x0000000D</resetValue>
                    <fields>
                        <field>
                            <name>PRMBL_0</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_CIDR1</name>
                    <description>Provides CoreSight discovery information for the ITM</description>
                    <addressOffset>0xFF4</addressOffset>
                    <resetValue>0x00000090</resetValue>
                    <fields>
                        <field>
                            <name>CLASS</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PRMBL_1</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_CIDR2</name>
                    <description>Provides CoreSight discovery information for the ITM</description>
                    <addressOffset>0xFF8</addressOffset>
                    <resetValue>0x00000005</resetValue>
                    <fields>
                        <field>
                            <name>PRMBL_2</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITM_CIDR3</name>
                    <description>Provides CoreSight discovery information for the ITM</description>
                    <addressOffset>0xFFC</addressOffset>
                    <resetValue>0x000000B1</resetValue>
                    <fields>
                        <field>
                            <name>PRMBL_3</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_CTRL</name>
                    <description>Provides configuration and status information for the DWT unit, and used to control features of the unit</description>
                    <addressOffset>0x1000</addressOffset>
                    <resetValue>0x73741824</resetValue>
                    <fields>
                        <field>
                            <name>NUMCOMP</name>
                            <description>Number of DWT comparators implemented</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NOTRCPKT</name>
                            <description>Indicates whether the implementation does not support trace</description>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NOEXTTRIG</name>
                            <description>Reserved, RAZ</description>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NOCYCCNT</name>
                            <description>Indicates whether the implementation does not include a cycle counter</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NOPRFCNT</name>
                            <description>Indicates whether the implementation does not include the profiling counters</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CYCDISS</name>
                            <description>Controls whether the cycle counter is disabled in Secure state</description>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CYCEVTENA</name>
                            <description>Enables Event Counter packet generation on POSTCNT underflow</description>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FOLDEVTENA</name>
                            <description>Enables DWT_FOLDCNT counter</description>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>LSUEVTENA</name>
                            <description>Enables DWT_LSUCNT counter</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SLEEPEVTENA</name>
                            <description>Enable DWT_SLEEPCNT counter</description>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EXCEVTENA</name>
                            <description>Enables DWT_EXCCNT counter</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CPIEVTENA</name>
                            <description>Enables DWT_CPICNT counter</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EXTTRCENA</name>
                            <description>Enables generation of Exception Trace packets</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PCSAMPLENA</name>
                            <description>Enables use of POSTCNT counter as a timer for Periodic PC Sample packet generation</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SYNCTAP</name>
                            <description>Selects the position of the synchronization packet counter tap on the CYCCNT counter. This determines the Synchronization packet rate</description>
                            <bitRange>[11:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CYCTAP</name>
                            <description>Selects the position of the POSTCNT tap on the CYCCNT counter</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>POSTINIT</name>
                            <description>Initial value for the POSTCNT counter</description>
                            <bitRange>[8:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>POSTPRESET</name>
                            <description>Reload value for the POSTCNT counter</description>
                            <bitRange>[4:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CYCCNTENA</name>
                            <description>Enables CYCCNT</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_CYCCNT</name>
                    <description>Shows or sets the value of the processor cycle counter, CYCCNT</description>
                    <addressOffset>0x1004</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CYCCNT</name>
                            <description>Increments one on each processor clock cycle when DWT_CTRL.CYCCNTENA == 1 and DEMCR.TRCENA == 1. On overflow, CYCCNT wraps to zero</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_EXCCNT</name>
                    <description>Counts the total cycles spent in exception processing</description>
                    <addressOffset>0x100C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EXCCNT</name>
                            <description>Counts one on each cycle when all of the following are true: - DWT_CTRL.EXCEVTENA == 1 and DEMCR.TRCENA == 1. - No instruction is executed, see DWT_CPICNT. - An exception-entry or exception-exit related operation is in progress. - Either SecureNoninvasiveDebugAllowed() == TRUE, or NS-Req for the operation is set to Non-secure and NoninvasiveDebugAllowed() == TRUE.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_LSUCNT</name>
                    <description>Increments on the additional cycles required to execute all load or store instructions</description>
                    <addressOffset>0x1014</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>LSUCNT</name>
                            <description>Counts one on each cycle when all of the following are true: - DWT_CTRL.LSUEVTENA == 1 and DEMCR.TRCENA == 1. - No instruction is executed, see DWT_CPICNT. - No exception-entry or exception-exit operation is in progress, see DWT_EXCCNT. - A load-store operation is in progress. - Either SecureNoninvasiveDebugAllowed() == TRUE, or NS-Req for the operation is set to Non-secure and NoninvasiveDebugAllowed() == TRUE.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_FOLDCNT</name>
                    <description>Increments on the additional cycles required to execute all load or store instructions</description>
                    <addressOffset>0x1018</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FOLDCNT</name>
                            <description>Counts on each cycle when all of the following are true: - DWT_CTRL.FOLDEVTENA == 1 and DEMCR.TRCENA == 1. - At least two instructions are executed, see DWT_CPICNT. - Either SecureNoninvasiveDebugAllowed() == TRUE, or the PE is in Non-secure state and NoninvasiveDebugAllowed() == TRUE. The counter is incremented by the number of instructions executed, minus one</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_COMP0</name>
                    <description>Provides a reference value for use by watchpoint comparator 0</description>
                    <addressOffset>0x1020</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DWT_COMP0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_FUNCTION0</name>
                    <description>Controls the operation of watchpoint comparator 0</description>
                    <addressOffset>0x1028</addressOffset>
                    <resetValue>0x58000000</resetValue>
                    <fields>
                        <field>
                            <name>ID</name>
                            <description>Identifies the capabilities for MATCH for comparator *n</description>
                            <bitRange>[31:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>MATCHED</name>
                            <description>Set to 1 when the comparator matches</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DATAVSIZE</name>
                            <description>Defines the size of the object being watched for by Data Value and Data Address comparators</description>
                            <bitRange>[11:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ACTION</name>
                            <description>Defines the action on a match. This field is ignored and the comparator generates no actions if it is disabled by MATCH</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MATCH</name>
                            <description>Controls the type of match generated by this comparator</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_COMP1</name>
                    <description>Provides a reference value for use by watchpoint comparator 1</description>
                    <addressOffset>0x1030</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DWT_COMP1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_FUNCTION1</name>
                    <description>Controls the operation of watchpoint comparator 1</description>
                    <addressOffset>0x1038</addressOffset>
                    <resetValue>0x89000828</resetValue>
                    <fields>
                        <field>
                            <name>ID</name>
                            <description>Identifies the capabilities for MATCH for comparator *n</description>
                            <bitRange>[31:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>MATCHED</name>
                            <description>Set to 1 when the comparator matches</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DATAVSIZE</name>
                            <description>Defines the size of the object being watched for by Data Value and Data Address comparators</description>
                            <bitRange>[11:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ACTION</name>
                            <description>Defines the action on a match. This field is ignored and the comparator generates no actions if it is disabled by MATCH</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MATCH</name>
                            <description>Controls the type of match generated by this comparator</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_COMP2</name>
                    <description>Provides a reference value for use by watchpoint comparator 2</description>
                    <addressOffset>0x1040</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DWT_COMP2</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_FUNCTION2</name>
                    <description>Controls the operation of watchpoint comparator 2</description>
                    <addressOffset>0x1048</addressOffset>
                    <resetValue>0x50000000</resetValue>
                    <fields>
                        <field>
                            <name>ID</name>
                            <description>Identifies the capabilities for MATCH for comparator *n</description>
                            <bitRange>[31:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>MATCHED</name>
                            <description>Set to 1 when the comparator matches</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DATAVSIZE</name>
                            <description>Defines the size of the object being watched for by Data Value and Data Address comparators</description>
                            <bitRange>[11:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ACTION</name>
                            <description>Defines the action on a match. This field is ignored and the comparator generates no actions if it is disabled by MATCH</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MATCH</name>
                            <description>Controls the type of match generated by this comparator</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_COMP3</name>
                    <description>Provides a reference value for use by watchpoint comparator 3</description>
                    <addressOffset>0x1050</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DWT_COMP3</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_FUNCTION3</name>
                    <description>Controls the operation of watchpoint comparator 3</description>
                    <addressOffset>0x1058</addressOffset>
                    <resetValue>0x20000800</resetValue>
                    <fields>
                        <field>
                            <name>ID</name>
                            <description>Identifies the capabilities for MATCH for comparator *n</description>
                            <bitRange>[31:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>MATCHED</name>
                            <description>Set to 1 when the comparator matches</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DATAVSIZE</name>
                            <description>Defines the size of the object being watched for by Data Value and Data Address comparators</description>
                            <bitRange>[11:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ACTION</name>
                            <description>Defines the action on a match. This field is ignored and the comparator generates no actions if it is disabled by MATCH</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MATCH</name>
                            <description>Controls the type of match generated by this comparator</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_DEVARCH</name>
                    <description>Provides CoreSight discovery information for the DWT</description>
                    <addressOffset>0x1FBC</addressOffset>
                    <resetValue>0x47701A02</resetValue>
                    <fields>
                        <field>
                            <name>ARCHITECT</name>
                            <description>Defines the architect of the component. Bits [31:28] are the JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the JEP106 ID code.</description>
                            <bitRange>[31:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PRESENT</name>
                            <description>Defines that the DEVARCH register is present</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>REVISION</name>
                            <description>Defines the architecture revision of the component</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ARCHVER</name>
                            <description>Defines the architecture version of the component</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ARCHPART</name>
                            <description>Defines the architecture of the component</description>
                            <bitRange>[11:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_DEVTYPE</name>
                    <description>Provides CoreSight discovery information for the DWT</description>
                    <addressOffset>0x1FCC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SUB</name>
                            <description>Component sub-type</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>MAJOR</name>
                            <description>Component major type</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_PIDR4</name>
                    <description>Provides CoreSight discovery information for the DWT</description>
                    <addressOffset>0x1FD0</addressOffset>
                    <resetValue>0x00000004</resetValue>
                    <fields>
                        <field>
                            <name>SIZE</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DES_2</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_PIDR5</name>
                    <description>Provides CoreSight discovery information for the DWT</description>
                    <addressOffset>0x1FD4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DWT_PIDR5</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_PIDR6</name>
                    <description>Provides CoreSight discovery information for the DWT</description>
                    <addressOffset>0x1FD8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DWT_PIDR6</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_PIDR7</name>
                    <description>Provides CoreSight discovery information for the DWT</description>
                    <addressOffset>0x1FDC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DWT_PIDR7</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_PIDR0</name>
                    <description>Provides CoreSight discovery information for the DWT</description>
                    <addressOffset>0x1FE0</addressOffset>
                    <resetValue>0x00000021</resetValue>
                    <fields>
                        <field>
                            <name>PART_0</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_PIDR1</name>
                    <description>Provides CoreSight discovery information for the DWT</description>
                    <addressOffset>0x1FE4</addressOffset>
                    <resetValue>0x000000BD</resetValue>
                    <fields>
                        <field>
                            <name>DES_0</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PART_1</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_PIDR2</name>
                    <description>Provides CoreSight discovery information for the DWT</description>
                    <addressOffset>0x1FE8</addressOffset>
                    <resetValue>0x0000000B</resetValue>
                    <fields>
                        <field>
                            <name>REVISION</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>JEDEC</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DES_1</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_PIDR3</name>
                    <description>Provides CoreSight discovery information for the DWT</description>
                    <addressOffset>0x1FEC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>REVAND</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CMOD</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_CIDR0</name>
                    <description>Provides CoreSight discovery information for the DWT</description>
                    <addressOffset>0x1FF0</addressOffset>
                    <resetValue>0x0000000D</resetValue>
                    <fields>
                        <field>
                            <name>PRMBL_0</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_CIDR1</name>
                    <description>Provides CoreSight discovery information for the DWT</description>
                    <addressOffset>0x1FF4</addressOffset>
                    <resetValue>0x00000090</resetValue>
                    <fields>
                        <field>
                            <name>CLASS</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PRMBL_1</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_CIDR2</name>
                    <description>Provides CoreSight discovery information for the DWT</description>
                    <addressOffset>0x1FF8</addressOffset>
                    <resetValue>0x00000005</resetValue>
                    <fields>
                        <field>
                            <name>PRMBL_2</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DWT_CIDR3</name>
                    <description>Provides CoreSight discovery information for the DWT</description>
                    <addressOffset>0x1FFC</addressOffset>
                    <resetValue>0x000000B1</resetValue>
                    <fields>
                        <field>
                            <name>PRMBL_3</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_CTRL</name>
                    <description>Provides FPB implementation information, and the global enable for the FPB unit</description>
                    <addressOffset>0x2000</addressOffset>
                    <resetValue>0x60005580</resetValue>
                    <fields>
                        <field>
                            <name>REV</name>
                            <description>Flash Patch and Breakpoint Unit architecture revision</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUM_CODE_14_12_</name>
                            <description>Indicates the number of implemented instruction address comparators. Zero indicates no Instruction Address comparators are implemented. The Instruction Address comparators are numbered from 0 to NUM_CODE - 1</description>
                            <bitRange>[14:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUM_LIT</name>
                            <description>Indicates the number of implemented literal address comparators. The Literal Address comparators are numbered from NUM_CODE to NUM_CODE + NUM_LIT - 1</description>
                            <bitRange>[11:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUM_CODE_7_4_</name>
                            <description>Indicates the number of implemented instruction address comparators. Zero indicates no Instruction Address comparators are implemented. The Instruction Address comparators are numbered from 0 to NUM_CODE - 1</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY</name>
                            <description>Writes to the FP_CTRL are ignored unless KEY is concurrently written to one</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>Enables the FPB</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_REMAP</name>
                    <description>Indicates whether the implementation supports Flash Patch remap and, if it does, holds the target address for remap</description>
                    <addressOffset>0x2004</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RMPSPT</name>
                            <description>Indicates whether the FPB unit supports the Flash Patch remap function</description>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>REMAP</name>
                            <description>Holds the bits[28:5] of the Flash Patch remap address</description>
                            <bitRange>[28:5]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_COMP0</name>
                    <description>Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator</description>
                    <addressOffset>0x2008</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BE</name>
                            <description>Selects between flashpatch and breakpoint functionality</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_COMP1</name>
                    <description>Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator</description>
                    <addressOffset>0x200C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BE</name>
                            <description>Selects between flashpatch and breakpoint functionality</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_COMP2</name>
                    <description>Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator</description>
                    <addressOffset>0x2010</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BE</name>
                            <description>Selects between flashpatch and breakpoint functionality</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_COMP3</name>
                    <description>Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator</description>
                    <addressOffset>0x2014</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BE</name>
                            <description>Selects between flashpatch and breakpoint functionality</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_COMP4</name>
                    <description>Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator</description>
                    <addressOffset>0x2018</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BE</name>
                            <description>Selects between flashpatch and breakpoint functionality</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_COMP5</name>
                    <description>Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator</description>
                    <addressOffset>0x201C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BE</name>
                            <description>Selects between flashpatch and breakpoint functionality</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_COMP6</name>
                    <description>Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator</description>
                    <addressOffset>0x2020</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BE</name>
                            <description>Selects between flashpatch and breakpoint functionality</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_COMP7</name>
                    <description>Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator</description>
                    <addressOffset>0x2024</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BE</name>
                            <description>Selects between flashpatch and breakpoint functionality</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_DEVARCH</name>
                    <description>Provides CoreSight discovery information for the FPB</description>
                    <addressOffset>0x2FBC</addressOffset>
                    <resetValue>0x47701A03</resetValue>
                    <fields>
                        <field>
                            <name>ARCHITECT</name>
                            <description>Defines the architect of the component. Bits [31:28] are the JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the JEP106 ID code.</description>
                            <bitRange>[31:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PRESENT</name>
                            <description>Defines that the DEVARCH register is present</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>REVISION</name>
                            <description>Defines the architecture revision of the component</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ARCHVER</name>
                            <description>Defines the architecture version of the component</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ARCHPART</name>
                            <description>Defines the architecture of the component</description>
                            <bitRange>[11:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_DEVTYPE</name>
                    <description>Provides CoreSight discovery information for the FPB</description>
                    <addressOffset>0x2FCC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SUB</name>
                            <description>Component sub-type</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>MAJOR</name>
                            <description>Component major type</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_PIDR4</name>
                    <description>Provides CoreSight discovery information for the FP</description>
                    <addressOffset>0x2FD0</addressOffset>
                    <resetValue>0x00000004</resetValue>
                    <fields>
                        <field>
                            <name>SIZE</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DES_2</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_PIDR5</name>
                    <description>Provides CoreSight discovery information for the FP</description>
                    <addressOffset>0x2FD4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FP_PIDR5</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_PIDR6</name>
                    <description>Provides CoreSight discovery information for the FP</description>
                    <addressOffset>0x2FD8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FP_PIDR6</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_PIDR7</name>
                    <description>Provides CoreSight discovery information for the FP</description>
                    <addressOffset>0x2FDC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FP_PIDR7</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_PIDR0</name>
                    <description>Provides CoreSight discovery information for the FP</description>
                    <addressOffset>0x2FE0</addressOffset>
                    <resetValue>0x00000021</resetValue>
                    <fields>
                        <field>
                            <name>PART_0</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_PIDR1</name>
                    <description>Provides CoreSight discovery information for the FP</description>
                    <addressOffset>0x2FE4</addressOffset>
                    <resetValue>0x000000BD</resetValue>
                    <fields>
                        <field>
                            <name>DES_0</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PART_1</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_PIDR2</name>
                    <description>Provides CoreSight discovery information for the FP</description>
                    <addressOffset>0x2FE8</addressOffset>
                    <resetValue>0x0000000B</resetValue>
                    <fields>
                        <field>
                            <name>REVISION</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>JEDEC</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DES_1</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_PIDR3</name>
                    <description>Provides CoreSight discovery information for the FP</description>
                    <addressOffset>0x2FEC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>REVAND</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CMOD</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_CIDR0</name>
                    <description>Provides CoreSight discovery information for the FP</description>
                    <addressOffset>0x2FF0</addressOffset>
                    <resetValue>0x0000000D</resetValue>
                    <fields>
                        <field>
                            <name>PRMBL_0</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_CIDR1</name>
                    <description>Provides CoreSight discovery information for the FP</description>
                    <addressOffset>0x2FF4</addressOffset>
                    <resetValue>0x00000090</resetValue>
                    <fields>
                        <field>
                            <name>CLASS</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PRMBL_1</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_CIDR2</name>
                    <description>Provides CoreSight discovery information for the FP</description>
                    <addressOffset>0x2FF8</addressOffset>
                    <resetValue>0x00000005</resetValue>
                    <fields>
                        <field>
                            <name>PRMBL_2</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FP_CIDR3</name>
                    <description>Provides CoreSight discovery information for the FP</description>
                    <addressOffset>0x2FFC</addressOffset>
                    <resetValue>0x000000B1</resetValue>
                    <fields>
                        <field>
                            <name>PRMBL_3</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ICTR</name>
                    <description>Provides information about the interrupt controller</description>
                    <addressOffset>0xE004</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>INTLINESNUM</name>
                            <description>Indicates the number of the highest implemented register in each of the NVIC control register sets, or in the case of NVIC_IPR*n, 4×INTLINESNUM</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ACTLR</name>
                    <description>Provides IMPLEMENTATION DEFINED configuration and control options</description>
                    <addressOffset>0xE008</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EXTEXCLALL</name>
                            <description>External Exclusives Allowed with no MPU</description>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DISITMATBFLUSH</name>
                            <description>Disable ATB Flush</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FPEXCODIS</name>
                            <description>Disable FPU exception outputs</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DISOOFP</name>
                            <description>Disable out-of-order FP instruction completion</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DISFOLD</name>
                            <description>Disable dual-issue.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DISMCYCINT</name>
                            <description>Disable dual-issue.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SYST_CSR</name>
                    <description>Use the SysTick Control and Status Register to enable the SysTick features.</description>
                    <addressOffset>0xE010</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>COUNTFLAG</name>
                            <description>Returns 1 if timer counted to 0 since last time this was read. Clears on read by application or debugger.</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLKSOURCE</name>
                            <description>SysTick clock source. Always reads as one if SYST_CALIB reports NOREF.
                                Selects the SysTick timer clock source:
                                0 = External reference clock.
                                1 = Processor clock.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TICKINT</name>
                            <description>Enables SysTick exception request:
                                0 = Counting down to zero does not assert the SysTick exception request.
                                1 = Counting down to zero to asserts the SysTick exception request.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>Enable SysTick counter:
                                0 = Counter disabled.
                                1 = Counter enabled.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SYST_RVR</name>
                    <description>Use the SysTick Reload Value Register to specify the start value to load into the current value register when the counter reaches 0. It can be any value between 0 and 0x00FFFFFF. A start value of 0 is possible, but has no effect because the SysTick interrupt and COUNTFLAG are activated when counting from 1 to 0. The reset value of this register is UNKNOWN.
                        To generate a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1. For example, if the SysTick interrupt is required every 100 clock pulses, set RELOAD to 99.</description>
                    <addressOffset>0xE014</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RELOAD</name>
                            <description>Value to load into the SysTick Current Value Register when the counter reaches 0.</description>
                            <bitRange>[23:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SYST_CVR</name>
                    <description>Use the SysTick Current Value Register to find the current value in the register. The reset value of this register is UNKNOWN.</description>
                    <addressOffset>0xE018</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CURRENT</name>
                            <description>Reads return the current value of the SysTick counter. This register is write-clear. Writing to it with any value clears the register to 0. Clearing this register also clears the COUNTFLAG bit of the SysTick Control and Status Register.</description>
                            <bitRange>[23:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SYST_CALIB</name>
                    <description>Use the SysTick Calibration Value Register to enable software to scale to any required speed using divide and multiply.</description>
                    <addressOffset>0xE01C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NOREF</name>
                            <description>If reads as 1, the Reference clock is not provided - the CLKSOURCE bit of the SysTick Control and Status register will be forced to 1 and cannot be cleared to 0.</description>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SKEW</name>
                            <description>If reads as 1, the calibration value for 10ms is inexact (due to clock frequency).</description>
                            <bitRange>[30:30]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TENMS</name>
                            <description>An optional Reload value to be used for 10ms (100Hz) timing, subject to system clock skew errors. If the value reads as 0, the calibration value is not known.</description>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_ISER0</name>
                    <description>Enables or reads the enabled state of each group of 32 interrupts</description>
                    <addressOffset>0xE100</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SETENA</name>
                            <description>For SETENA[m] in NVIC_ISER*n, indicates whether interrupt 32*n + m is enabled</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_ISER1</name>
                    <description>Enables or reads the enabled state of each group of 32 interrupts</description>
                    <addressOffset>0xE104</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SETENA</name>
                            <description>For SETENA[m] in NVIC_ISER*n, indicates whether interrupt 32*n + m is enabled</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_ICER0</name>
                    <description>Clears or reads the enabled state of each group of 32 interrupts</description>
                    <addressOffset>0xE180</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLRENA</name>
                            <description>For CLRENA[m] in NVIC_ICER*n, indicates whether interrupt 32*n + m is enabled</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_ICER1</name>
                    <description>Clears or reads the enabled state of each group of 32 interrupts</description>
                    <addressOffset>0xE184</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLRENA</name>
                            <description>For CLRENA[m] in NVIC_ICER*n, indicates whether interrupt 32*n + m is enabled</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_ISPR0</name>
                    <description>Enables or reads the pending state of each group of 32 interrupts</description>
                    <addressOffset>0xE200</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SETPEND</name>
                            <description>For SETPEND[m] in NVIC_ISPR*n, indicates whether interrupt 32*n + m is pending</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_ISPR1</name>
                    <description>Enables or reads the pending state of each group of 32 interrupts</description>
                    <addressOffset>0xE204</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SETPEND</name>
                            <description>For SETPEND[m] in NVIC_ISPR*n, indicates whether interrupt 32*n + m is pending</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_ICPR0</name>
                    <description>Clears or reads the pending state of each group of 32 interrupts</description>
                    <addressOffset>0xE280</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLRPEND</name>
                            <description>For CLRPEND[m] in NVIC_ICPR*n, indicates whether interrupt 32*n + m is pending</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_ICPR1</name>
                    <description>Clears or reads the pending state of each group of 32 interrupts</description>
                    <addressOffset>0xE284</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLRPEND</name>
                            <description>For CLRPEND[m] in NVIC_ICPR*n, indicates whether interrupt 32*n + m is pending</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_IABR0</name>
                    <description>For each group of 32 interrupts, shows the active state of each interrupt</description>
                    <addressOffset>0xE300</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ACTIVE</name>
                            <description>For ACTIVE[m] in NVIC_IABR*n, indicates the active state for interrupt 32*n+m</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_IABR1</name>
                    <description>For each group of 32 interrupts, shows the active state of each interrupt</description>
                    <addressOffset>0xE304</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ACTIVE</name>
                            <description>For ACTIVE[m] in NVIC_IABR*n, indicates the active state for interrupt 32*n+m</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_ITNS0</name>
                    <description>For each group of 32 interrupts, determines whether each interrupt targets Non-secure or Secure state</description>
                    <addressOffset>0xE380</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ITNS</name>
                            <description>For ITNS[m] in NVIC_ITNS*n, `IAAMO the target Security state for interrupt 32*n+m</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_ITNS1</name>
                    <description>For each group of 32 interrupts, determines whether each interrupt targets Non-secure or Secure state</description>
                    <addressOffset>0xE384</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ITNS</name>
                            <description>For ITNS[m] in NVIC_ITNS*n, `IAAMO the target Security state for interrupt 32*n+m</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_IPR0</name>
                    <description>Sets or reads interrupt priorities</description>
                    <addressOffset>0xE400</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_N3</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N2</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N1</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N0</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_IPR1</name>
                    <description>Sets or reads interrupt priorities</description>
                    <addressOffset>0xE404</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_N3</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N2</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N1</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N0</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_IPR2</name>
                    <description>Sets or reads interrupt priorities</description>
                    <addressOffset>0xE408</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_N3</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N2</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N1</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N0</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_IPR3</name>
                    <description>Sets or reads interrupt priorities</description>
                    <addressOffset>0xE40C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_N3</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N2</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N1</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N0</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_IPR4</name>
                    <description>Sets or reads interrupt priorities</description>
                    <addressOffset>0xE410</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_N3</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N2</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N1</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N0</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_IPR5</name>
                    <description>Sets or reads interrupt priorities</description>
                    <addressOffset>0xE414</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_N3</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N2</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N1</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N0</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_IPR6</name>
                    <description>Sets or reads interrupt priorities</description>
                    <addressOffset>0xE418</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_N3</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N2</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N1</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N0</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_IPR7</name>
                    <description>Sets or reads interrupt priorities</description>
                    <addressOffset>0xE41C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_N3</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N2</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N1</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N0</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_IPR8</name>
                    <description>Sets or reads interrupt priorities</description>
                    <addressOffset>0xE420</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_N3</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N2</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N1</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N0</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_IPR9</name>
                    <description>Sets or reads interrupt priorities</description>
                    <addressOffset>0xE424</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_N3</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N2</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N1</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N0</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_IPR10</name>
                    <description>Sets or reads interrupt priorities</description>
                    <addressOffset>0xE428</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_N3</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N2</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N1</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N0</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_IPR11</name>
                    <description>Sets or reads interrupt priorities</description>
                    <addressOffset>0xE42C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_N3</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N2</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N1</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N0</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_IPR12</name>
                    <description>Sets or reads interrupt priorities</description>
                    <addressOffset>0xE430</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_N3</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N2</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N1</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N0</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_IPR13</name>
                    <description>Sets or reads interrupt priorities</description>
                    <addressOffset>0xE434</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_N3</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N2</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N1</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N0</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_IPR14</name>
                    <description>Sets or reads interrupt priorities</description>
                    <addressOffset>0xE438</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_N3</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N2</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N1</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N0</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NVIC_IPR15</name>
                    <description>Sets or reads interrupt priorities</description>
                    <addressOffset>0xE43C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_N3</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N2</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N1</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_N0</name>
                            <description>For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CPUID</name>
                    <description>Provides identification information for the PE, including an implementer code for the device and a device ID number</description>
                    <addressOffset>0xED00</addressOffset>
                    <resetValue>0x411FD210</resetValue>
                    <fields>
                        <field>
                            <name>IMPLEMENTER</name>
                            <description>This field must hold an implementer code that has been assigned by ARM</description>
                            <bitRange>[31:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VARIANT</name>
                            <description>IMPLEMENTATION DEFINED variant number. Typically, this field is used to distinguish between different product variants, or major revisions of a product</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ARCHITECTURE</name>
                            <description>Defines the Architecture implemented by the PE</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PARTNO</name>
                            <description>IMPLEMENTATION DEFINED primary part number for the device</description>
                            <bitRange>[15:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>REVISION</name>
                            <description>IMPLEMENTATION DEFINED revision number for the device</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ICSR</name>
                    <description>Controls and provides status information for NMI, PendSV, SysTick and interrupts</description>
                    <addressOffset>0xED04</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PENDNMISET</name>
                            <description>Indicates whether the NMI exception is pending</description>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PENDNMICLR</name>
                            <description>Allows the NMI exception pend state to be cleared</description>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PENDSVSET</name>
                            <description>Indicates whether the PendSV `FTSSS exception is pending</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PENDSVCLR</name>
                            <description>Allows the PendSV exception pend state to be cleared `FTSSS</description>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PENDSTSET</name>
                            <description>Indicates whether the SysTick `FTSSS exception is pending</description>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PENDSTCLR</name>
                            <description>Allows the SysTick exception pend state to be cleared `FTSSS</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>STTNS</name>
                            <description>Controls whether in a single SysTick implementation, the SysTick is Secure or Non-secure</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ISRPREEMPT</name>
                            <description>Indicates whether a pending exception will be serviced on exit from debug halt state</description>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ISRPENDING</name>
                            <description>Indicates whether an external interrupt, generated by the NVIC, is pending</description>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VECTPENDING</name>
                            <description>The exception number of the highest priority pending and enabled interrupt</description>
                            <bitRange>[20:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RETTOBASE</name>
                            <description>In Handler mode, indicates whether there is more than one active exception</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VECTACTIVE</name>
                            <description>The exception number of the current executing exception</description>
                            <bitRange>[8:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>VTOR</name>
                    <description>The VTOR indicates the offset of the vector table base address from memory address 0x00000000.</description>
                    <addressOffset>0xED08</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TBLOFF</name>
                            <description>Vector table base offset field. It contains bits[31:7] of the offset of the table base from the bottom of the memory map.</description>
                            <bitRange>[31:7]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>AIRCR</name>
                    <description>Use the Application Interrupt and Reset Control Register to: determine data endianness, clear all active state information from debug halt mode, request a system reset.</description>
                    <addressOffset>0xED0C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>VECTKEY</name>
                            <description>Register key:
                                Reads as Unknown
                                On writes, write 0x05FA to VECTKEY, otherwise the write is ignored.</description>
                            <bitRange>[31:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENDIANESS</name>
                            <description>Data endianness implemented:
                                0 = Little-endian.</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PRIS</name>
                            <description>Prioritize Secure exceptions. The value of this bit defines whether Secure exception priority boosting is enabled.
                                0	Priority ranges of Secure and Non-secure exceptions are identical.
                                1	Non-secure exceptions are de-prioritized.</description>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BFHFNMINS</name>
                            <description>BusFault, HardFault, and NMI Non-secure enable.
                                0	BusFault, HardFault, and NMI are Secure.
                                1	BusFault and NMI are Non-secure and exceptions can target Non-secure HardFault.</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRIGROUP</name>
                            <description>Interrupt priority grouping field. This field determines the split of group priority from subpriority.
                                See https://developer.arm.com/documentation/100235/0004/the-cortex-m33-peripherals/system-control-block/application-interrupt-and-reset-control-register?lang=en</description>
                            <bitRange>[10:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SYSRESETREQS</name>
                            <description>System reset request, Secure state only.
                                0	SYSRESETREQ functionality is available to both Security states.
                                1 SYSRESETREQ functionality is only available to Secure state.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SYSRESETREQ</name>
                            <description>Writing 1 to this bit causes the SYSRESETREQ signal to the outer system to be asserted to request a reset. The intention is to force a large system reset of all major components except for debug. The C_HALT bit in the DHCSR is cleared as a result of the system reset requested. The debugger does not lose contact with the device.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VECTCLRACTIVE</name>
                            <description>Clears all active state information for fixed and configurable exceptions. This bit: is self-clearing, can only be set by the DAP when the core is halted.  When set: clears all active exception status of the processor, forces a return to Thread mode, forces an IPSR of 0. A debugger must re-initialize the stack.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SCR</name>
                    <description>System Control Register. Use the System Control Register for power-management functions: signal to the system when the processor can enter a low power state, control how the processor enters and exits low power states.</description>
                    <addressOffset>0xED10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SEVONPEND</name>
                            <description>Send Event on Pending bit:
                                0 = Only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded.
                                1 = Enabled events and all interrupts, including disabled interrupts, can wakeup the processor.
                                When an event or interrupt becomes pending, the event signal wakes up the processor from WFE. If the
                                processor is not waiting for an event, the event is registered and affects the next WFE.
                                The processor also wakes up on execution of an SEV instruction or an external event.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SLEEPDEEPS</name>
                            <description>0 SLEEPDEEP is available to both security states
                                1 SLEEPDEEP is only available to Secure state</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SLEEPDEEP</name>
                            <description>Controls whether the processor uses sleep or deep sleep as its low power mode:
                                0 = Sleep.
                                1 = Deep sleep.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SLEEPONEXIT</name>
                            <description>Indicates sleep-on-exit when returning from Handler mode to Thread mode:
                                0 = Do not sleep when returning to Thread mode.
                                1 = Enter sleep, or deep sleep, on return from an ISR to Thread mode.
                                Setting this bit to 1 enables an interrupt driven application to avoid returning to an empty main application.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CCR</name>
                    <description>Sets or returns configuration and control data</description>
                    <addressOffset>0xED14</addressOffset>
                    <resetValue>0x00000201</resetValue>
                    <fields>
                        <field>
                            <name>BP</name>
                            <description>Enables program flow prediction `FTSSS</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>IC</name>
                            <description>This is a global enable bit for instruction caches in the selected Security state</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DC</name>
                            <description>Enables data caching of all data accesses to Normal memory `FTSSS</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>STKOFHFNMIGN</name>
                            <description>Controls the effect of a stack limit violation while executing at a requested priority less than 0</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RES1</name>
                            <description>Reserved, RES1</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BFHFNMIGN</name>
                            <description>Determines the effect of precise BusFaults on handlers running at a requested priority less than 0</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DIV_0_TRP</name>
                            <description>Controls the generation of a DIVBYZERO UsageFault when attempting to perform integer division by zero</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>UNALIGN_TRP</name>
                            <description>Controls the trapping of unaligned word or halfword accesses</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USERSETMPEND</name>
                            <description>Determines whether unprivileged accesses are permitted to pend interrupts via the STIR</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RES1_1</name>
                            <description>Reserved, RES1</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SHPR1</name>
                    <description>Sets or returns priority for system handlers 4 - 7</description>
                    <addressOffset>0xED18</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_7_3</name>
                            <description>Priority of system handler 7, SecureFault</description>
                            <bitRange>[31:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_6_3</name>
                            <description>Priority of system handler 6, SecureFault</description>
                            <bitRange>[23:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_5_3</name>
                            <description>Priority of system handler 5, SecureFault</description>
                            <bitRange>[15:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_4_3</name>
                            <description>Priority of system handler 4, SecureFault</description>
                            <bitRange>[7:5]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SHPR2</name>
                    <description>Sets or returns priority for system handlers 8 - 11</description>
                    <addressOffset>0xED1C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_11_3</name>
                            <description>Priority of system handler 11, SecureFault</description>
                            <bitRange>[31:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_10</name>
                            <description>Reserved, RES0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PRI_9</name>
                            <description>Reserved, RES0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PRI_8</name>
                            <description>Reserved, RES0</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SHPR3</name>
                    <description>Sets or returns priority for system handlers 12 - 15</description>
                    <addressOffset>0xED20</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRI_15_3</name>
                            <description>Priority of system handler 15, SecureFault</description>
                            <bitRange>[31:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_14_3</name>
                            <description>Priority of system handler 14, SecureFault</description>
                            <bitRange>[23:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PRI_13</name>
                            <description>Reserved, RES0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PRI_12_3</name>
                            <description>Priority of system handler 12, SecureFault</description>
                            <bitRange>[7:5]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SHCSR</name>
                    <description>Provides access to the active and pending status of system exceptions</description>
                    <addressOffset>0xED24</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>HARDFAULTPENDED</name>
                            <description>`IAAMO the pending state of the HardFault exception `CTTSSS</description>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SECUREFAULTPENDED</name>
                            <description>`IAAMO the pending state of the SecureFault exception</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SECUREFAULTENA</name>
                            <description>`DW the SecureFault exception is enabled</description>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USGFAULTENA</name>
                            <description>`DW the UsageFault exception is enabled `FTSSS</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BUSFAULTENA</name>
                            <description>`DW the BusFault exception is enabled</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MEMFAULTENA</name>
                            <description>`DW the MemManage exception is enabled `FTSSS</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SVCALLPENDED</name>
                            <description>`IAAMO the pending state of the SVCall exception `FTSSS</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BUSFAULTPENDED</name>
                            <description>`IAAMO the pending state of the BusFault exception</description>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MEMFAULTPENDED</name>
                            <description>`IAAMO the pending state of the MemManage exception `FTSSS</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USGFAULTPENDED</name>
                            <description>The UsageFault exception is banked between Security states, `IAAMO the pending state of the UsageFault exception `FTSSS</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SYSTICKACT</name>
                            <description>`IAAMO the active state of the SysTick exception `FTSSS</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PENDSVACT</name>
                            <description>`IAAMO the active state of the PendSV exception `FTSSS</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MONITORACT</name>
                            <description>`IAAMO the active state of the DebugMonitor exception</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SVCALLACT</name>
                            <description>`IAAMO the active state of the SVCall exception `FTSSS</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NMIACT</name>
                            <description>`IAAMO the active state of the NMI exception</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SECUREFAULTACT</name>
                            <description>`IAAMO the active state of the SecureFault exception</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USGFAULTACT</name>
                            <description>`IAAMO the active state of the UsageFault exception `FTSSS</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HARDFAULTACT</name>
                            <description>Indicates and allows limited modification of the active state of the HardFault exception `FTSSS</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BUSFAULTACT</name>
                            <description>`IAAMO the active state of the BusFault exception</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MEMFAULTACT</name>
                            <description>`IAAMO the active state of the MemManage exception `FTSSS</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CFSR</name>
                    <description>Contains the three Configurable Fault Status Registers.

                        31:16 UFSR: Provides information on UsageFault exceptions

                        15:8 BFSR: Provides information on BusFault exceptions

                        7:0 MMFSR: Provides information on MemManage exceptions</description>
                    <addressOffset>0xED28</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>UFSR_DIVBYZERO</name>
                            <description>Sticky flag indicating whether an integer division by zero error has occurred</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>UFSR_UNALIGNED</name>
                            <description>Sticky flag indicating whether an unaligned access error has occurred</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>UFSR_STKOF</name>
                            <description>Sticky flag indicating whether a stack overflow error has occurred</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>UFSR_NOCP</name>
                            <description>Sticky flag indicating whether a coprocessor disabled or not present error has occurred</description>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>UFSR_INVPC</name>
                            <description>Sticky flag indicating whether an integrity check error has occurred</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>UFSR_INVSTATE</name>
                            <description>Sticky flag indicating whether an EPSR.T or EPSR.IT validity error has occurred</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>UFSR_UNDEFINSTR</name>
                            <description>Sticky flag indicating whether an undefined instruction error has occurred</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BFSR_BFARVALID</name>
                            <description>Indicates validity of the contents of the BFAR register</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BFSR_LSPERR</name>
                            <description>Records whether a BusFault occurred during FP lazy state preservation</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BFSR_STKERR</name>
                            <description>Records whether a derived BusFault occurred during exception entry stacking</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BFSR_UNSTKERR</name>
                            <description>Records whether a derived BusFault occurred during exception return unstacking</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BFSR_IMPRECISERR</name>
                            <description>Records whether an imprecise data access error has occurred</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BFSR_PRECISERR</name>
                            <description>Records whether a precise data access error has occurred</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BFSR_IBUSERR</name>
                            <description>Records whether a BusFault on an instruction prefetch has occurred</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MMFSR</name>
                            <description>Provides information on MemManage exceptions</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>HFSR</name>
                    <description>Shows the cause of any HardFaults</description>
                    <addressOffset>0xED2C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DEBUGEVT</name>
                            <description>Indicates when a Debug event has occurred</description>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FORCED</name>
                            <description>Indicates that a fault with configurable priority has been escalated to a HardFault exception, because it could not be made active, because of priority, or because it was disabled</description>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VECTTBL</name>
                            <description>Indicates when a fault has occurred because of a vector table read error on exception processing</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DFSR</name>
                    <description>Shows which debug event occurred</description>
                    <addressOffset>0xED30</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EXTERNAL</name>
                            <description>Sticky flag indicating whether an External debug request debug event has occurred</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VCATCH</name>
                            <description>Sticky flag indicating whether a Vector catch debug event has occurred</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DWTTRAP</name>
                            <description>Sticky flag indicating whether a Watchpoint debug event has occurred</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BKPT</name>
                            <description>Sticky flag indicating whether a Breakpoint debug event has occurred</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HALTED</name>
                            <description>Sticky flag indicating that a Halt request debug event or Step debug event has occurred</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MMFAR</name>
                    <description>Shows the address of the memory location that caused an MPU fault</description>
                    <addressOffset>0xED34</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDRESS</name>
                            <description>This register is updated with the address of a location that produced a MemManage fault. The MMFSR shows the cause of the fault, and whether this field is valid. This field is valid only when MMFSR.MMARVALID is set, otherwise it is UNKNOWN</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BFAR</name>
                    <description>Shows the address associated with a precise data access BusFault</description>
                    <addressOffset>0xED38</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDRESS</name>
                            <description>This register is updated with the address of a location that produced a BusFault. The BFSR shows the reason for the fault. This field is valid only when BFSR.BFARVALID is set, otherwise it is UNKNOWN</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ID_PFR0</name>
                    <description>Gives top-level information about the instruction set supported by the PE</description>
                    <addressOffset>0xED40</addressOffset>
                    <resetValue>0x00000030</resetValue>
                    <fields>
                        <field>
                            <name>STATE1</name>
                            <description>T32 instruction set support</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>STATE0</name>
                            <description>A32 instruction set support</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ID_PFR1</name>
                    <description>Gives information about the programmers' model and Extensions support</description>
                    <addressOffset>0xED44</addressOffset>
                    <resetValue>0x00000520</resetValue>
                    <fields>
                        <field>
                            <name>MPROGMOD</name>
                            <description>Identifies support for the M-Profile programmers' model support</description>
                            <bitRange>[11:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SECURITY</name>
                            <description>Identifies whether the Security Extension is implemented</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ID_DFR0</name>
                    <description>Provides top level information about the debug system</description>
                    <addressOffset>0xED48</addressOffset>
                    <resetValue>0x00200000</resetValue>
                    <fields>
                        <field>
                            <name>MPROFDBG</name>
                            <description>Indicates the supported M-profile debug architecture</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ID_AFR0</name>
                    <description>Provides information about the IMPLEMENTATION DEFINED features of the PE</description>
                    <addressOffset>0xED4C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>IMPDEF3</name>
                            <description>IMPLEMENTATION DEFINED meaning</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>IMPDEF2</name>
                            <description>IMPLEMENTATION DEFINED meaning</description>
                            <bitRange>[11:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>IMPDEF1</name>
                            <description>IMPLEMENTATION DEFINED meaning</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>IMPDEF0</name>
                            <description>IMPLEMENTATION DEFINED meaning</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ID_MMFR0</name>
                    <description>Provides information about the implemented memory model and memory management support</description>
                    <addressOffset>0xED50</addressOffset>
                    <resetValue>0x00101F40</resetValue>
                    <fields>
                        <field>
                            <name>AUXREG</name>
                            <description>Indicates support for Auxiliary Control Registers</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TCM</name>
                            <description>Indicates support for tightly coupled memories (TCMs)</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SHARELVL</name>
                            <description>Indicates the number of shareability levels implemented</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>OUTERSHR</name>
                            <description>Indicates the outermost shareability domain implemented</description>
                            <bitRange>[11:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PMSA</name>
                            <description>Indicates support for the protected memory system architecture (PMSA)</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ID_MMFR1</name>
                    <description>Provides information about the implemented memory model and memory management support</description>
                    <addressOffset>0xED54</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ID_MMFR1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ID_MMFR2</name>
                    <description>Provides information about the implemented memory model and memory management support</description>
                    <addressOffset>0xED58</addressOffset>
                    <resetValue>0x01000000</resetValue>
                    <fields>
                        <field>
                            <name>WFISTALL</name>
                            <description>Indicates the support for Wait For Interrupt (WFI) stalling</description>
                            <bitRange>[27:24]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ID_MMFR3</name>
                    <description>Provides information about the implemented memory model and memory management support</description>
                    <addressOffset>0xED5C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BPMAINT</name>
                            <description>Indicates the supported branch predictor maintenance</description>
                            <bitRange>[11:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CMAINTSW</name>
                            <description>Indicates the supported cache maintenance operations by set/way</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CMAINTVA</name>
                            <description>Indicates the supported cache maintenance operations by address</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ID_ISAR0</name>
                    <description>Provides information about the instruction set implemented by the PE</description>
                    <addressOffset>0xED60</addressOffset>
                    <resetValue>0x08092300</resetValue>
                    <fields>
                        <field>
                            <name>DIVIDE</name>
                            <description>Indicates the supported Divide instructions</description>
                            <bitRange>[27:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DEBUG</name>
                            <description>Indicates the implemented Debug instructions</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>COPROC</name>
                            <description>Indicates the supported Coprocessor instructions</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CMPBRANCH</name>
                            <description>Indicates the supported combined Compare and Branch instructions</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BITFIELD</name>
                            <description>Indicates the supported bit field instructions</description>
                            <bitRange>[11:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BITCOUNT</name>
                            <description>Indicates the supported bit count instructions</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ID_ISAR1</name>
                    <description>Provides information about the instruction set implemented by the PE</description>
                    <addressOffset>0xED64</addressOffset>
                    <resetValue>0x05725000</resetValue>
                    <fields>
                        <field>
                            <name>INTERWORK</name>
                            <description>Indicates the implemented Interworking instructions</description>
                            <bitRange>[27:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>IMMEDIATE</name>
                            <description>Indicates the implemented for data-processing instructions with long immediates</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>IFTHEN</name>
                            <description>Indicates the implemented If-Then instructions</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EXTEND</name>
                            <description>Indicates the implemented Extend instructions</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ID_ISAR2</name>
                    <description>Provides information about the instruction set implemented by the PE</description>
                    <addressOffset>0xED68</addressOffset>
                    <resetValue>0x30173426</resetValue>
                    <fields>
                        <field>
                            <name>REVERSAL</name>
                            <description>Indicates the implemented Reversal instructions</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>MULTU</name>
                            <description>Indicates the implemented advanced unsigned Multiply instructions</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>MULTS</name>
                            <description>Indicates the implemented advanced signed Multiply instructions</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>MULT</name>
                            <description>Indicates the implemented additional Multiply instructions</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>MULTIACCESSINT</name>
                            <description>Indicates the support for interruptible multi-access instructions</description>
                            <bitRange>[11:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>MEMHINT</name>
                            <description>Indicates the implemented Memory Hint instructions</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOADSTORE</name>
                            <description>Indicates the implemented additional load/store instructions</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ID_ISAR3</name>
                    <description>Provides information about the instruction set implemented by the PE</description>
                    <addressOffset>0xED6C</addressOffset>
                    <resetValue>0x07895729</resetValue>
                    <fields>
                        <field>
                            <name>TRUENOP</name>
                            <description>Indicates the implemented true NOP instructions</description>
                            <bitRange>[27:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>T32COPY</name>
                            <description>Indicates the support for T32 non flag-setting MOV instructions</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TABBRANCH</name>
                            <description>Indicates the implemented Table Branch instructions</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SYNCHPRIM</name>
                            <description>Used in conjunction with ID_ISAR4.SynchPrim_frac to indicate the implemented Synchronization Primitive instructions</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SVC</name>
                            <description>Indicates the implemented SVC instructions</description>
                            <bitRange>[11:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SIMD</name>
                            <description>Indicates the implemented SIMD instructions</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SATURATE</name>
                            <description>Indicates the implemented saturating instructions</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ID_ISAR4</name>
                    <description>Provides information about the instruction set implemented by the PE</description>
                    <addressOffset>0xED70</addressOffset>
                    <resetValue>0x01310132</resetValue>
                    <fields>
                        <field>
                            <name>PSR_M</name>
                            <description>Indicates the implemented M profile instructions to modify the PSRs</description>
                            <bitRange>[27:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SYNCPRIM_FRAC</name>
                            <description>Used in conjunction with ID_ISAR3.SynchPrim to indicate the implemented Synchronization Primitive instructions</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BARRIER</name>
                            <description>Indicates the implemented Barrier instructions</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WRITEBACK</name>
                            <description>Indicates the support for writeback addressing modes</description>
                            <bitRange>[11:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WITHSHIFTS</name>
                            <description>Indicates the support for writeback addressing modes</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>UNPRIV</name>
                            <description>Indicates the implemented unprivileged instructions</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ID_ISAR5</name>
                    <description>Provides information about the instruction set implemented by the PE</description>
                    <addressOffset>0xED74</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ID_ISAR5</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTR</name>
                    <description>Provides information about the architecture of the caches. CTR is RES0 if CLIDR is zero.</description>
                    <addressOffset>0xED7C</addressOffset>
                    <resetValue>0x8000C000</resetValue>
                    <fields>
                        <field>
                            <name>RES1</name>
                            <description>Reserved, RES1</description>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CWG</name>
                            <description>Log2 of the number of words of the maximum size of memory that can be overwritten as a result of the eviction of a cache entry that has had a memory location in it modified</description>
                            <bitRange>[27:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ERG</name>
                            <description>Log2 of the number of words of the maximum size of the reservation granule that has been implemented for the Load-Exclusive and Store-Exclusive instructions</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DMINLINE</name>
                            <description>Log2 of the number of words in the smallest cache line of all the data caches and unified caches that are controlled by the PE</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RES1_1</name>
                            <description>Reserved, RES1</description>
                            <bitRange>[15:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>IMINLINE</name>
                            <description>Log2 of the number of words in the smallest cache line of all the instruction caches that are controlled by the PE</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CPACR</name>
                    <description>Specifies the access privileges for coprocessors and the FP Extension</description>
                    <addressOffset>0xED88</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CP11</name>
                            <description>The value in this field is ignored. If the implementation does not include the FP Extension, this field is RAZ/WI. If the value of this bit is not programmed to the same value as the CP10 field, then the value is UNKNOWN</description>
                            <bitRange>[23:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CP10</name>
                            <description>Defines the access rights for the floating-point functionality</description>
                            <bitRange>[21:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CP7</name>
                            <description>Controls access privileges for coprocessor 7</description>
                            <bitRange>[15:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CP6</name>
                            <description>Controls access privileges for coprocessor 6</description>
                            <bitRange>[13:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CP5</name>
                            <description>Controls access privileges for coprocessor 5</description>
                            <bitRange>[11:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CP4</name>
                            <description>Controls access privileges for coprocessor 4</description>
                            <bitRange>[9:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CP3</name>
                            <description>Controls access privileges for coprocessor 3</description>
                            <bitRange>[7:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CP2</name>
                            <description>Controls access privileges for coprocessor 2</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CP1</name>
                            <description>Controls access privileges for coprocessor 1</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CP0</name>
                            <description>Controls access privileges for coprocessor 0</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NSACR</name>
                    <description>Defines the Non-secure access permissions for both the FP Extension and coprocessors CP0 to CP7</description>
                    <addressOffset>0xED8C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CP11</name>
                            <description>Enables Non-secure access to the Floating-point Extension</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CP10</name>
                            <description>Enables Non-secure access to the Floating-point Extension</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CP7</name>
                            <description>Enables Non-secure access to coprocessor CP7</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CP6</name>
                            <description>Enables Non-secure access to coprocessor CP6</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CP5</name>
                            <description>Enables Non-secure access to coprocessor CP5</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CP4</name>
                            <description>Enables Non-secure access to coprocessor CP4</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CP3</name>
                            <description>Enables Non-secure access to coprocessor CP3</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CP2</name>
                            <description>Enables Non-secure access to coprocessor CP2</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CP1</name>
                            <description>Enables Non-secure access to coprocessor CP1</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CP0</name>
                            <description>Enables Non-secure access to coprocessor CP0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_TYPE</name>
                    <description>The MPU Type Register indicates how many regions the MPU `FTSSS supports</description>
                    <addressOffset>0xED90</addressOffset>
                    <resetValue>0x00000800</resetValue>
                    <fields>
                        <field>
                            <name>DREGION</name>
                            <description>Number of regions supported by the MPU</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SEPARATE</name>
                            <description>Indicates support for separate instructions and data address regions</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_CTRL</name>
                    <description>Enables the MPU and, when the MPU is enabled, controls whether the default memory map is enabled as a background region for privileged accesses, and whether the MPU is enabled for HardFaults, NMIs, and exception handlers when FAULTMASK is set to 1</description>
                    <addressOffset>0xED94</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PRIVDEFENA</name>
                            <description>Controls whether the default memory map is enabled for privileged software</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HFNMIENA</name>
                            <description>Controls whether handlers executing with priority less than 0 access memory with the MPU enabled or disabled. This applies to HardFaults, NMIs, and exception handlers when FAULTMASK is set to 1</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>Enables the MPU</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_RNR</name>
                    <description>Selects the region currently accessed by MPU_RBAR and MPU_RLAR</description>
                    <addressOffset>0xED98</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>REGION</name>
                            <description>Indicates the memory region accessed by MPU_RBAR and MPU_RLAR</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_RBAR</name>
                    <description>Provides indirect read and write access to the base address of the currently selected MPU region `FTSSS</description>
                    <addressOffset>0xED9C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BASE</name>
                            <description>Contains bits [31:5] of the lower inclusive limit of the selected MPU memory region. This value is zero extended to provide the base address to be checked against</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SH</name>
                            <description>Defines the Shareability domain of this region for Normal memory</description>
                            <bitRange>[4:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AP</name>
                            <description>Defines the access permissions for this region</description>
                            <bitRange>[2:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>XN</name>
                            <description>Defines whether code can be executed from this region</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_RLAR</name>
                    <description>Provides indirect read and write access to the limit address of the currently selected MPU region `FTSSS</description>
                    <addressOffset>0xEDA0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>LIMIT</name>
                            <description>Contains bits [31:5] of the upper inclusive limit of the selected MPU memory region. This value is postfixed with 0x1F to provide the limit address to be checked against</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ATTRINDX</name>
                            <description>Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1 fields</description>
                            <bitRange>[3:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>Region enable</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_RBAR_A1</name>
                    <description>Provides indirect read and write access to the base address of the MPU region selected by MPU_RNR[7:2]:(1[1:0]) `FTSSS</description>
                    <addressOffset>0xEDA4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BASE</name>
                            <description>Contains bits [31:5] of the lower inclusive limit of the selected MPU memory region. This value is zero extended to provide the base address to be checked against</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SH</name>
                            <description>Defines the Shareability domain of this region for Normal memory</description>
                            <bitRange>[4:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AP</name>
                            <description>Defines the access permissions for this region</description>
                            <bitRange>[2:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>XN</name>
                            <description>Defines whether code can be executed from this region</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_RLAR_A1</name>
                    <description>Provides indirect read and write access to the limit address of the currently selected MPU region selected by MPU_RNR[7:2]:(1[1:0]) `FTSSS</description>
                    <addressOffset>0xEDA8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>LIMIT</name>
                            <description>Contains bits [31:5] of the upper inclusive limit of the selected MPU memory region. This value is postfixed with 0x1F to provide the limit address to be checked against</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ATTRINDX</name>
                            <description>Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1 fields</description>
                            <bitRange>[3:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>Region enable</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_RBAR_A2</name>
                    <description>Provides indirect read and write access to the base address of the MPU region selected by MPU_RNR[7:2]:(2[1:0]) `FTSSS</description>
                    <addressOffset>0xEDAC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BASE</name>
                            <description>Contains bits [31:5] of the lower inclusive limit of the selected MPU memory region. This value is zero extended to provide the base address to be checked against</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SH</name>
                            <description>Defines the Shareability domain of this region for Normal memory</description>
                            <bitRange>[4:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AP</name>
                            <description>Defines the access permissions for this region</description>
                            <bitRange>[2:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>XN</name>
                            <description>Defines whether code can be executed from this region</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_RLAR_A2</name>
                    <description>Provides indirect read and write access to the limit address of the currently selected MPU region selected by MPU_RNR[7:2]:(2[1:0]) `FTSSS</description>
                    <addressOffset>0xEDB0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>LIMIT</name>
                            <description>Contains bits [31:5] of the upper inclusive limit of the selected MPU memory region. This value is postfixed with 0x1F to provide the limit address to be checked against</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ATTRINDX</name>
                            <description>Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1 fields</description>
                            <bitRange>[3:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>Region enable</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_RBAR_A3</name>
                    <description>Provides indirect read and write access to the base address of the MPU region selected by MPU_RNR[7:2]:(3[1:0]) `FTSSS</description>
                    <addressOffset>0xEDB4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BASE</name>
                            <description>Contains bits [31:5] of the lower inclusive limit of the selected MPU memory region. This value is zero extended to provide the base address to be checked against</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SH</name>
                            <description>Defines the Shareability domain of this region for Normal memory</description>
                            <bitRange>[4:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AP</name>
                            <description>Defines the access permissions for this region</description>
                            <bitRange>[2:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>XN</name>
                            <description>Defines whether code can be executed from this region</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_RLAR_A3</name>
                    <description>Provides indirect read and write access to the limit address of the currently selected MPU region selected by MPU_RNR[7:2]:(3[1:0]) `FTSSS</description>
                    <addressOffset>0xEDB8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>LIMIT</name>
                            <description>Contains bits [31:5] of the upper inclusive limit of the selected MPU memory region. This value is postfixed with 0x1F to provide the limit address to be checked against</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ATTRINDX</name>
                            <description>Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1 fields</description>
                            <bitRange>[3:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>Region enable</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_MAIR0</name>
                    <description>Along with MPU_MAIR1, provides the memory attribute encodings corresponding to the AttrIndex values</description>
                    <addressOffset>0xEDC0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ATTR3</name>
                            <description>Memory attribute encoding for MPU regions with an AttrIndex of 3</description>
                            <bitRange>[31:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ATTR2</name>
                            <description>Memory attribute encoding for MPU regions with an AttrIndex of 2</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ATTR1</name>
                            <description>Memory attribute encoding for MPU regions with an AttrIndex of 1</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ATTR0</name>
                            <description>Memory attribute encoding for MPU regions with an AttrIndex of 0</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_MAIR1</name>
                    <description>Along with MPU_MAIR0, provides the memory attribute encodings corresponding to the AttrIndex values</description>
                    <addressOffset>0xEDC4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ATTR7</name>
                            <description>Memory attribute encoding for MPU regions with an AttrIndex of 7</description>
                            <bitRange>[31:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ATTR6</name>
                            <description>Memory attribute encoding for MPU regions with an AttrIndex of 6</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ATTR5</name>
                            <description>Memory attribute encoding for MPU regions with an AttrIndex of 5</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ATTR4</name>
                            <description>Memory attribute encoding for MPU regions with an AttrIndex of 4</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SAU_CTRL</name>
                    <description>Allows enabling of the Security Attribution Unit</description>
                    <addressOffset>0xEDD0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ALLNS</name>
                            <description>When SAU_CTRL.ENABLE is 0 this bit controls if the memory is marked as Non-secure or Secure</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>Enables the SAU</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SAU_TYPE</name>
                    <description>Indicates the number of regions implemented by the Security Attribution Unit</description>
                    <addressOffset>0xEDD4</addressOffset>
                    <resetValue>0x00000008</resetValue>
                    <fields>
                        <field>
                            <name>SREGION</name>
                            <description>The number of implemented SAU regions</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SAU_RNR</name>
                    <description>Selects the region currently accessed by SAU_RBAR and SAU_RLAR</description>
                    <addressOffset>0xEDD8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>REGION</name>
                            <description>Indicates the SAU region accessed by SAU_RBAR and SAU_RLAR</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SAU_RBAR</name>
                    <description>Provides indirect read and write access to the base address of the currently selected SAU region</description>
                    <addressOffset>0xEDDC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BADDR</name>
                            <description>Holds bits [31:5] of the base address for the selected SAU region</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SAU_RLAR</name>
                    <description>Provides indirect read and write access to the limit address of the currently selected SAU region</description>
                    <addressOffset>0xEDE0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>LADDR</name>
                            <description>Holds bits [31:5] of the limit address for the selected SAU region</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSC</name>
                            <description>Controls whether Non-secure state is permitted to execute an SG instruction from this region</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>SAU region enable</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SFSR</name>
                    <description>Provides information about any security related faults</description>
                    <addressOffset>0xEDE4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>LSERR</name>
                            <description>Sticky flag indicating that an error occurred during lazy state activation or deactivation</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SFARVALID</name>
                            <description>This bit is set when the SFAR register contains a valid value. As with similar fields, such as BFSR.BFARVALID and MMFSR.MMARVALID, this bit can be cleared by other exceptions, such as BusFault</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>LSPERR</name>
                            <description>Stick flag indicating that an SAU or IDAU violation occurred during the lazy preservation of floating-point state</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INVTRAN</name>
                            <description>Sticky flag indicating that an exception was raised due to a branch that was not flagged as being domain crossing causing a transition from Secure to Non-secure memory</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AUVIOL</name>
                            <description>Sticky flag indicating that an attempt was made to access parts of the address space that are marked as Secure with NS-Req for the transaction set to Non-secure. This bit is not set if the violation occurred during lazy state preservation. See LSPERR</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INVER</name>
                            <description>This can be caused by EXC_RETURN.DCRS being set to 0 when returning from an exception in the Non-secure state, or by EXC_RETURN.ES being set to 1 when returning from an exception in the Non-secure state</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INVIS</name>
                            <description>This bit is set if the integrity signature in an exception stack frame is found to be invalid during the unstacking operation</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INVEP</name>
                            <description>This bit is set if a function call from the Non-secure state or exception targets a non-SG instruction in the Secure state. This bit is also set if the target address is a SG instruction, but there is no matching SAU/IDAU region with the NSC flag set</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SFAR</name>
                    <description>Shows the address of the memory location that caused a Security violation</description>
                    <addressOffset>0xEDE8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDRESS</name>
                            <description>The address of an access that caused a attribution unit violation. This field is only valid when SFSR.SFARVALID is set. This allows the actual flip flops associated with this register to be shared with other fault address registers. If an implementation chooses to share the storage in this way, care must be taken to not leak Secure address information to the Non-secure state. One way of achieving this is to share the SFAR register with the MMFAR_S register, which is not accessible to the Non-secure state</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DHCSR</name>
                    <description>Controls halting debug</description>
                    <addressOffset>0xEDF0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>S_RESTART_ST</name>
                            <description>Indicates the PE has processed a request to clear DHCSR.C_HALT to 0. That is, either a write to DHCSR that clears DHCSR.C_HALT from 1 to 0, or an External Restart Request</description>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>S_RESET_ST</name>
                            <description>Indicates whether the PE has been reset since the last read of the DHCSR</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>S_RETIRE_ST</name>
                            <description>Set to 1 every time the PE retires one of more instructions</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>S_SDE</name>
                            <description>Indicates whether Secure invasive debug is allowed</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>S_LOCKUP</name>
                            <description>Indicates whether the PE is in Lockup state</description>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>S_SLEEP</name>
                            <description>Indicates whether the PE is sleeping</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>S_HALT</name>
                            <description>Indicates whether the PE is in Debug state</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>S_REGRDY</name>
                            <description>Handshake flag to transfers through the DCRDR</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>C_SNAPSTALL</name>
                            <description>Allow imprecise entry to Debug state</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>C_MASKINTS</name>
                            <description>When debug is enabled, the debugger can write to this bit to mask PendSV, SysTick and external configurable interrupts</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>C_STEP</name>
                            <description>Enable single instruction step</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>C_HALT</name>
                            <description>PE enter Debug state halt request</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>C_DEBUGEN</name>
                            <description>Enable Halting debug</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DCRSR</name>
                    <description>With the DCRDR, provides debug access to the general-purpose registers, special-purpose registers, and the FP extension registers. A write to the DCRSR specifies the register to transfer, whether the transfer is a read or write, and starts the transfer</description>
                    <addressOffset>0xEDF4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>REGWNR</name>
                            <description>Specifies the access type for the transfer</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>REGSEL</name>
                            <description>Specifies the general-purpose register, special-purpose register, or FP register to transfer</description>
                            <bitRange>[6:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DCRDR</name>
                    <description>With the DCRSR, provides debug access to the general-purpose registers, special-purpose registers, and the FP Extension registers. If the Main Extension is implemented, it can also be used for message passing between an external debugger and a debug agent running on the PE</description>
                    <addressOffset>0xEDF8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DBGTMP</name>
                            <description>Provides debug access for reading and writing the general-purpose registers, special-purpose registers, and Floating-point Extension registers</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DEMCR</name>
                    <description>Manages vector catch behavior and DebugMonitor handling when debugging</description>
                    <addressOffset>0xEDFC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRCENA</name>
                            <description>Global enable for all DWT and ITM features</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SDME</name>
                            <description>Indicates whether the DebugMonitor targets the Secure or the Non-secure state and whether debug events are allowed in Secure state</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>MON_REQ</name>
                            <description>DebugMonitor semaphore bit</description>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MON_STEP</name>
                            <description>Enable DebugMonitor stepping</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MON_PEND</name>
                            <description>Sets or clears the pending state of the DebugMonitor exception</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MON_EN</name>
                            <description>Enable the DebugMonitor exception</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VC_SFERR</name>
                            <description>SecureFault exception halting debug vector catch enable</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VC_HARDERR</name>
                            <description>HardFault exception halting debug vector catch enable</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VC_INTERR</name>
                            <description>Enable halting debug vector catch for faults during exception entry and return</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VC_BUSERR</name>
                            <description>BusFault exception halting debug vector catch enable</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VC_STATERR</name>
                            <description>Enable halting debug trap on a UsageFault exception caused by a state information error, for example an Undefined Instruction exception</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VC_CHKERR</name>
                            <description>Enable halting debug trap on a UsageFault exception caused by a checking error, for example an alignment check error</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VC_NOCPERR</name>
                            <description>Enable halting debug trap on a UsageFault caused by an access to a coprocessor</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VC_MMERR</name>
                            <description>Enable halting debug trap on a MemManage exception</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VC_CORERESET</name>
                            <description>Enable Reset Vector Catch. This causes a warm reset to halt a running system</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DSCSR</name>
                    <description>Provides control and status information for Secure debug</description>
                    <addressOffset>0xEE08</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CDSKEY</name>
                            <description>Writes to the CDS bit are ignored unless CDSKEY is concurrently written to zero</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CDS</name>
                            <description>This field indicates the current Security state of the processor</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SBRSEL</name>
                            <description>If SBRSELEN is 1 this bit selects whether the Non-secure or the Secure version of the memory-mapped Banked registers are accessible to the debugger</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SBRSELEN</name>
                            <description>Controls whether the SBRSEL field or the current Security state of the processor selects which version of the memory-mapped Banked registers are accessed to the debugger</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>STIR</name>
                    <description>Provides a mechanism for software to generate an interrupt</description>
                    <addressOffset>0xEF00</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTID</name>
                            <description>Indicates the interrupt to be pended. The value written is (ExceptionNumber - 16)</description>
                            <bitRange>[8:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FPCCR</name>
                    <description>Holds control data for the Floating-point extension</description>
                    <addressOffset>0xEF34</addressOffset>
                    <resetValue>0x20000472</resetValue>
                    <fields>
                        <field>
                            <name>ASPEN</name>
                            <description>When this bit is set to 1, execution of a floating-point instruction sets the CONTROL.FPCA bit to 1</description>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>LSPEN</name>
                            <description>Enables lazy context save of floating-point state</description>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>LSPENS</name>
                            <description>This bit controls whether the LSPEN bit is writeable from the Non-secure state</description>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLRONRET</name>
                            <description>Clear floating-point caller saved registers on exception return</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLRONRETS</name>
                            <description>This bit controls whether the CLRONRET bit is writeable from the Non-secure state</description>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TS</name>
                            <description>Treat floating-point registers as Secure enable</description>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>UFRDY</name>
                            <description>Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the UsageFault exception to pending</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SPLIMVIOL</name>
                            <description>This bit is banked between the Security states and indicates whether the floating-point context violates the stack pointer limit that was active when lazy state preservation was activated. SPLIMVIOL modifies the lazy floating-point state preservation behavior</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MONRDY</name>
                            <description>Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the DebugMonitor exception to pending</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SFRDY</name>
                            <description>Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the SecureFault exception to pending. This bit is only present in the Secure version of the register, and behaves as RAZ/WI when accessed from the Non-secure state</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BFRDY</name>
                            <description>Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the BusFault exception to pending</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MMRDY</name>
                            <description>Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the MemManage exception to pending</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HFRDY</name>
                            <description>Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the HardFault exception to pending</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>THREAD</name>
                            <description>Indicates the PE mode when it allocated the floating-point stack frame</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Security status of the floating-point context. This bit is only present in the Secure version of the register, and behaves as RAZ/WI when accessed from the Non-secure state. This bit is updated whenever lazy state preservation is activated, or when a floating-point instruction is executed</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USER</name>
                            <description>Indicates the privilege level of the software executing when the PE allocated the floating-point stack frame</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>LSPACT</name>
                            <description>Indicates whether lazy preservation of the floating-point state is active</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FPCAR</name>
                    <description>Holds the location of the unpopulated floating-point register space allocated on an exception stack frame</description>
                    <addressOffset>0xEF38</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDRESS</name>
                            <description>The location of the unpopulated floating-point register space allocated on an exception stack frame</description>
                            <bitRange>[31:3]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FPDSCR</name>
                    <description>Holds the default values for the floating-point status control data that the PE assigns to the FPSCR when it creates a new floating-point context</description>
                    <addressOffset>0xEF3C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>AHP</name>
                            <description>Default value for FPSCR.AHP</description>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DN</name>
                            <description>Default value for FPSCR.DN</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FZ</name>
                            <description>Default value for FPSCR.FZ</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RMODE</name>
                            <description>Default value for FPSCR.RMode</description>
                            <bitRange>[23:22]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MVFR0</name>
                    <description>Describes the features provided by the Floating-point Extension</description>
                    <addressOffset>0xEF40</addressOffset>
                    <resetValue>0x60540601</resetValue>
                    <fields>
                        <field>
                            <name>FPROUND</name>
                            <description>Indicates the rounding modes supported by the FP Extension</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FPSQRT</name>
                            <description>Indicates the support for FP square root operations</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FPDIVIDE</name>
                            <description>Indicates the support for FP divide operations</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FPDP</name>
                            <description>Indicates support for FP double-precision operations</description>
                            <bitRange>[11:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FPSP</name>
                            <description>Indicates support for FP single-precision operations</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SIMDREG</name>
                            <description>Indicates size of FP register file</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MVFR1</name>
                    <description>Describes the features provided by the Floating-point Extension</description>
                    <addressOffset>0xEF44</addressOffset>
                    <resetValue>0x85000089</resetValue>
                    <fields>
                        <field>
                            <name>FMAC</name>
                            <description>Indicates whether the FP Extension implements the fused multiply accumulate instructions</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FPHP</name>
                            <description>Indicates whether the FP Extension implements half-precision FP conversion instructions</description>
                            <bitRange>[27:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FPDNAN</name>
                            <description>Indicates whether the FP hardware implementation supports NaN propagation</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FPFTZ</name>
                            <description>Indicates whether subnormals are always flushed-to-zero</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MVFR2</name>
                    <description>Describes the features provided by the Floating-point Extension</description>
                    <addressOffset>0xEF48</addressOffset>
                    <resetValue>0x00000060</resetValue>
                    <fields>
                        <field>
                            <name>FPMISC</name>
                            <description>Indicates support for miscellaneous FP features</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DDEVARCH</name>
                    <description>Provides CoreSight discovery information for the SCS</description>
                    <addressOffset>0xEFBC</addressOffset>
                    <resetValue>0x47702A04</resetValue>
                    <fields>
                        <field>
                            <name>ARCHITECT</name>
                            <description>Defines the architect of the component. Bits [31:28] are the JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the JEP106 ID code.</description>
                            <bitRange>[31:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PRESENT</name>
                            <description>Defines that the DEVARCH register is present</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>REVISION</name>
                            <description>Defines the architecture revision of the component</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ARCHVER</name>
                            <description>Defines the architecture version of the component</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ARCHPART</name>
                            <description>Defines the architecture of the component</description>
                            <bitRange>[11:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DDEVTYPE</name>
                    <description>Provides CoreSight discovery information for the SCS</description>
                    <addressOffset>0xEFCC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SUB</name>
                            <description>Component sub-type</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>MAJOR</name>
                            <description>CoreSight major type</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DPIDR4</name>
                    <description>Provides CoreSight discovery information for the SCS</description>
                    <addressOffset>0xEFD0</addressOffset>
                    <resetValue>0x00000004</resetValue>
                    <fields>
                        <field>
                            <name>SIZE</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DES_2</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DPIDR5</name>
                    <description>Provides CoreSight discovery information for the SCS</description>
                    <addressOffset>0xEFD4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DPIDR5</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DPIDR6</name>
                    <description>Provides CoreSight discovery information for the SCS</description>
                    <addressOffset>0xEFD8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DPIDR6</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DPIDR7</name>
                    <description>Provides CoreSight discovery information for the SCS</description>
                    <addressOffset>0xEFDC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DPIDR7</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DPIDR0</name>
                    <description>Provides CoreSight discovery information for the SCS</description>
                    <addressOffset>0xEFE0</addressOffset>
                    <resetValue>0x00000021</resetValue>
                    <fields>
                        <field>
                            <name>PART_0</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DPIDR1</name>
                    <description>Provides CoreSight discovery information for the SCS</description>
                    <addressOffset>0xEFE4</addressOffset>
                    <resetValue>0x000000BD</resetValue>
                    <fields>
                        <field>
                            <name>DES_0</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PART_1</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DPIDR2</name>
                    <description>Provides CoreSight discovery information for the SCS</description>
                    <addressOffset>0xEFE8</addressOffset>
                    <resetValue>0x0000000B</resetValue>
                    <fields>
                        <field>
                            <name>REVISION</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>JEDEC</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DES_1</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DPIDR3</name>
                    <description>Provides CoreSight discovery information for the SCS</description>
                    <addressOffset>0xEFEC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>REVAND</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CMOD</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DCIDR0</name>
                    <description>Provides CoreSight discovery information for the SCS</description>
                    <addressOffset>0xEFF0</addressOffset>
                    <resetValue>0x0000000D</resetValue>
                    <fields>
                        <field>
                            <name>PRMBL_0</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DCIDR1</name>
                    <description>Provides CoreSight discovery information for the SCS</description>
                    <addressOffset>0xEFF4</addressOffset>
                    <resetValue>0x00000090</resetValue>
                    <fields>
                        <field>
                            <name>CLASS</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PRMBL_1</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DCIDR2</name>
                    <description>Provides CoreSight discovery information for the SCS</description>
                    <addressOffset>0xEFF8</addressOffset>
                    <resetValue>0x00000005</resetValue>
                    <fields>
                        <field>
                            <name>PRMBL_2</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DCIDR3</name>
                    <description>Provides CoreSight discovery information for the SCS</description>
                    <addressOffset>0xEFFC</addressOffset>
                    <resetValue>0x000000B1</resetValue>
                    <fields>
                        <field>
                            <name>PRMBL_3</name>
                            <description>See CoreSight Architecture Specification</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCPRGCTLR</name>
                    <description>Programming Control Register</description>
                    <addressOffset>0x41004</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EN</name>
                            <description>Trace Unit Enable</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCSTATR</name>
                    <description>The TRCSTATR indicates the ETM-Teal status</description>
                    <addressOffset>0x4100C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PMSTABLE</name>
                            <description>Indicates whether the ETM-Teal registers are stable and can be read</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>IDLE</name>
                            <description>Indicates that the trace unit is inactive</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCCONFIGR</name>
                    <description>The TRCCONFIGR sets the basic tracing options for the trace unit</description>
                    <addressOffset>0x41010</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RS</name>
                            <description>Return stack enable</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TS</name>
                            <description>Global timestamp tracing</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>COND</name>
                            <description>Conditional instruction tracing</description>
                            <bitRange>[10:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CCI</name>
                            <description>Cycle counting in instruction trace</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BB</name>
                            <description>Branch broadcast mode</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCEVENTCTL0R</name>
                    <description>The TRCEVENTCTL0R controls the tracing of events in the trace stream. The events also drive the ETM-Teal external outputs.</description>
                    <addressOffset>0x41020</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TYPE1</name>
                            <description>Selects the resource type for event 1</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL1</name>
                            <description>Selects the resource number, based on the value of TYPE1: When TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL1[2:0].  When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined by SEL1[2:0]</description>
                            <bitRange>[10:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TYPE0</name>
                            <description>Selects the resource type for event 0</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL0</name>
                            <description>Selects the resource number, based on the value of TYPE0: When TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL0[2:0].  When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined by SEL0[2:0]</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCEVENTCTL1R</name>
                    <description>The TRCEVENTCTL1R controls how the events selected by TRCEVENTCTL0R behave</description>
                    <addressOffset>0x41024</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>LPOVERRIDE</name>
                            <description>Low power state behavior override</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ATB</name>
                            <description>ATB enabled</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INSTEN1</name>
                            <description>One bit per event, to enable generation of an event element in the instruction trace stream when the selected event occurs</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INSTEN0</name>
                            <description>One bit per event, to enable generation of an event element in the instruction trace stream when the selected event occurs</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCSTALLCTLR</name>
                    <description>The TRCSTALLCTLR enables ETM-Teal to stall the processor if the ETM-Teal FIFO goes over the programmed level to minimize risk of overflow</description>
                    <addressOffset>0x4102C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INSTPRIORITY</name>
                            <description>Reserved, RES0</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ISTALL</name>
                            <description>Stall processor based on instruction trace buffer space</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>LEVEL</name>
                            <description>Threshold at which stalling becomes active. This provides four levels. This level can be varied to optimize the level of invasion caused by stalling, balanced against the risk of a FIFO overflow</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCTSCTLR</name>
                    <description>The TRCTSCTLR controls the insertion of global timestamps into the trace stream. A timestamp is always inserted into the instruction trace stream</description>
                    <addressOffset>0x41030</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TYPE0</name>
                            <description>Selects the resource type for event 0</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL0</name>
                            <description>Selects the resource number, based on the value of TYPE0: When TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL0[2:0].  When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined by SEL0[2:0]</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCSYNCPR</name>
                    <description>The TRCSYNCPR specifies the period of trace synchronization of the trace streams. TRCSYNCPR defines a number of bytes of trace between requests for trace synchronization. This value is always a power of two</description>
                    <addressOffset>0x41034</addressOffset>
                    <resetValue>0x0000000A</resetValue>
                    <fields>
                        <field>
                            <name>PERIOD</name>
                            <description>Defines the number of bytes of trace between trace synchronization requests as a total of the number of bytes generated by the instruction stream. The number of bytes is 2N where N is the value of this field: - A value of zero disables these periodic trace synchronization requests, but does not disable other trace synchronization requests.  - The minimum value that can be programmed, other than zero, is 8, providing a minimum trace synchronization period of 256 bytes.  - The maximum value is 20, providing a maximum trace synchronization period of 2^20 bytes</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCCCCTLR</name>
                    <description>The TRCCCCTLR sets the threshold value for instruction trace cycle counting. The threshold represents the minimum interval between cycle count trace packets</description>
                    <addressOffset>0x41038</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>THRESHOLD</name>
                            <description>Instruction trace cycle count threshold</description>
                            <bitRange>[11:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCVICTLR</name>
                    <description>The TRCVICTLR controls instruction trace filtering</description>
                    <addressOffset>0x41080</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EXLEVEL_S3</name>
                            <description>In Secure state, each bit controls whether instruction tracing is enabled for the corresponding exception level</description>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EXLEVEL_S0</name>
                            <description>In Secure state, each bit controls whether instruction tracing is enabled for the corresponding exception level</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TRCERR</name>
                            <description>Selects whether a system error exception must always be traced</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TRCRESET</name>
                            <description>Selects whether a reset exception must always be traced</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SSSTATUS</name>
                            <description>Indicates the current status of the start/stop logic</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TYPE0</name>
                            <description>Selects the resource type for event 0</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEL0</name>
                            <description>Selects the resource number, based on the value of TYPE0: When TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL0[2:0].  When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined by SEL0[2:0]</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCCNTRLDVR0</name>
                    <description>The TRCCNTRLDVR defines the reload value for the reduced function counter</description>
                    <addressOffset>0x41140</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>VALUE</name>
                            <description>Defines the reload value for the counter. This value is loaded into the counter each time the reload event occurs</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCIDR8</name>
                    <description>TRCIDR8</description>
                    <addressOffset>0x41180</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>MAXSPEC</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCIDR9</name>
                    <description>TRCIDR9</description>
                    <addressOffset>0x41184</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NUMP0KEY</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCIDR10</name>
                    <description>TRCIDR10</description>
                    <addressOffset>0x41188</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NUMP1KEY</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCIDR11</name>
                    <description>TRCIDR11</description>
                    <addressOffset>0x4118C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NUMP1SPC</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCIDR12</name>
                    <description>TRCIDR12</description>
                    <addressOffset>0x41190</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>NUMCONDKEY</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCIDR13</name>
                    <description>TRCIDR13</description>
                    <addressOffset>0x41194</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NUMCONDSPC</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCIMSPEC</name>
                    <description>The TRCIMSPEC shows the presence of any IMPLEMENTATION SPECIFIC features, and enables any features that are provided</description>
                    <addressOffset>0x411C0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SUPPORT</name>
                            <description>Reserved, RES0</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCIDR0</name>
                    <description>TRCIDR0</description>
                    <addressOffset>0x411E0</addressOffset>
                    <resetValue>0x280006E1</resetValue>
                    <fields>
                        <field>
                            <name>COMMOPT</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TSSIZE</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[28:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TRCEXDATA</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>QSUPP</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[16:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>QFILT</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CONDTYPE</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[13:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUMEVENT</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[11:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RETSTACK</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TRCCCI</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TRCCOND</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TRCBB</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TRCDATA</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[4:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>INSTP0</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[2:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RES1</name>
                            <description>Reserved, RES1</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCIDR1</name>
                    <description>TRCIDR1</description>
                    <addressOffset>0x411E4</addressOffset>
                    <resetValue>0x4100F421</resetValue>
                    <fields>
                        <field>
                            <name>DESIGNER</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[31:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RES1</name>
                            <description>Reserved, RES1</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TRCARCHMAJ</name>
                            <description>reads as 0b0100</description>
                            <bitRange>[11:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TRCARCHMIN</name>
                            <description>reads as 0b0000</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>REVISION</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCIDR2</name>
                    <description>TRCIDR2</description>
                    <addressOffset>0x411E8</addressOffset>
                    <resetValue>0x00000004</resetValue>
                    <fields>
                        <field>
                            <name>CCSIZE</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[28:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DVSIZE</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[24:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DASIZE</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[19:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VMIDSIZE</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[14:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CIDSIZE</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[9:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>IASIZE</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCIDR3</name>
                    <description>TRCIDR3</description>
                    <addressOffset>0x411EC</addressOffset>
                    <resetValue>0x0F090004</resetValue>
                    <fields>
                        <field>
                            <name>NOOVERFLOW</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUMPROC</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[30:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SYSSTALL</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>STALLCTL</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SYNCPR</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TRCERR</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EXLEVEL_NS</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EXLEVEL_S</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CCITMIN</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[11:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCIDR4</name>
                    <description>TRCIDR4</description>
                    <addressOffset>0x411F0</addressOffset>
                    <resetValue>0x00114000</resetValue>
                    <fields>
                        <field>
                            <name>NUMVMIDC</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUMCIDC</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[27:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUMSSCC</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[23:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUMRSPAIR</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUMPC</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SUPPDAC</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUMDVC</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUMACPAIRS</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCIDR5</name>
                    <description>TRCIDR5</description>
                    <addressOffset>0x411F4</addressOffset>
                    <resetValue>0x90C70004</resetValue>
                    <fields>
                        <field>
                            <name>REDFUNCNTR</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUMCNTR</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[30:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUMSEQSTATE</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[27:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LPOVERRIDE</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ATBTRIG</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TRACEIDSIZE</name>
                            <description>reads as 0x07</description>
                            <bitRange>[21:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUMEXTINSEL</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[11:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUMEXTIN</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[8:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCIDR6</name>
                    <description>TRCIDR6</description>
                    <addressOffset>0x411F8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRCIDR6</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCIDR7</name>
                    <description>TRCIDR7</description>
                    <addressOffset>0x411FC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRCIDR7</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCRSCTLR2</name>
                    <description>The TRCRSCTLR controls the trace resources</description>
                    <addressOffset>0x41208</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PAIRINV</name>
                            <description>Inverts the result of a combined pair of resources.  This bit is only implemented on the lower register for a pair of resource selectors</description>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INV</name>
                            <description>Inverts the selected resources</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GROUP</name>
                            <description>Selects a group of resource</description>
                            <bitRange>[18:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SELECT</name>
                            <description>Selects one or more resources from the wanted group. One bit is provided per resource from the group</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCRSCTLR3</name>
                    <description>The TRCRSCTLR controls the trace resources</description>
                    <addressOffset>0x4120C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PAIRINV</name>
                            <description>Inverts the result of a combined pair of resources.  This bit is only implemented on the lower register for a pair of resource selectors</description>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INV</name>
                            <description>Inverts the selected resources</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GROUP</name>
                            <description>Selects a group of resource</description>
                            <bitRange>[18:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SELECT</name>
                            <description>Selects one or more resources from the wanted group. One bit is provided per resource from the group</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCSSCSR</name>
                    <description>Controls the corresponding single-shot comparator resource</description>
                    <addressOffset>0x412A0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STATUS</name>
                            <description>Single-shot status bit. Indicates if any of the comparators, that TRCSSCCRn.SAC or TRCSSCCRn.ARC selects, have matched</description>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PC</name>
                            <description>Reserved, RES1</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DV</name>
                            <description>Reserved, RES0</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DA</name>
                            <description>Reserved, RES0</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>INST</name>
                            <description>Reserved, RES0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCSSPCICR</name>
                    <description>Selects the PE comparator inputs for Single-shot control</description>
                    <addressOffset>0x412C0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PC</name>
                            <description>Selects one or more PE comparator inputs for Single-shot control.  TRCIDR4.NUMPC defines the size of the PC field.  1 bit is provided for each implemented PE comparator input.  For example, if bit[1] == 1 this selects PE comparator input 1 for Single-shot control</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCPDCR</name>
                    <description>Requests the system to provide power to the trace unit</description>
                    <addressOffset>0x41310</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PU</name>
                            <description>Powerup request bit:</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCPDSR</name>
                    <description>Returns the following information about the trace unit: - OS Lock status.  - Core power domain status.  - Power interruption status</description>
                    <addressOffset>0x41314</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>OSLK</name>
                            <description>OS Lock status bit:</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>STICKYPD</name>
                            <description>Sticky powerdown status bit. Indicates whether the trace register state is valid:</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>POWER</name>
                            <description>Power status bit:</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCITATBIDR</name>
                    <description>Trace Integration ATB Identification Register</description>
                    <addressOffset>0x41EE4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ID</name>
                            <description>Trace ID</description>
                            <bitRange>[6:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCITIATBINR</name>
                    <description>Trace Integration Instruction ATB In Register</description>
                    <addressOffset>0x41EF4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>AFVALIDM</name>
                            <description>Integration Mode instruction AFVALIDM in</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ATREADYM</name>
                            <description>Integration Mode instruction ATREADYM in</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCITIATBOUTR</name>
                    <description>Trace Integration Instruction ATB Out Register</description>
                    <addressOffset>0x41EFC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>AFREADY</name>
                            <description>Integration Mode instruction AFREADY out</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ATVALID</name>
                            <description>Integration Mode instruction ATVALID out</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCCLAIMSET</name>
                    <description>Claim Tag Set Register</description>
                    <addressOffset>0x41FA0</addressOffset>
                    <resetValue>0x0000000F</resetValue>
                    <fields>
                        <field>
                            <name>SET3</name>
                            <description>When a write to one of these bits occurs, with the value:</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SET2</name>
                            <description>When a write to one of these bits occurs, with the value:</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SET1</name>
                            <description>When a write to one of these bits occurs, with the value:</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SET0</name>
                            <description>When a write to one of these bits occurs, with the value:</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCCLAIMCLR</name>
                    <description>Claim Tag Clear Register</description>
                    <addressOffset>0x41FA4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLR3</name>
                            <description>When a write to one of these bits occurs, with the value:</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLR2</name>
                            <description>When a write to one of these bits occurs, with the value:</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLR1</name>
                            <description>When a write to one of these bits occurs, with the value:</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLR0</name>
                            <description>When a write to one of these bits occurs, with the value:</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCAUTHSTATUS</name>
                    <description>Returns the level of tracing that the trace unit can support</description>
                    <addressOffset>0x41FB8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SNID</name>
                            <description>Indicates whether the system enables the trace unit to support Secure non-invasive debug:</description>
                            <bitRange>[7:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SID</name>
                            <description>Indicates whether the trace unit supports Secure invasive debug:</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NSNID</name>
                            <description>Indicates whether the system enables the trace unit to support Non-secure non-invasive debug:</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NSID</name>
                            <description>Indicates whether the trace unit supports Non-secure invasive debug:</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCDEVARCH</name>
                    <description>TRCDEVARCH</description>
                    <addressOffset>0x41FBC</addressOffset>
                    <resetValue>0x47724A13</resetValue>
                    <fields>
                        <field>
                            <name>ARCHITECT</name>
                            <description>reads as 0b01000111011</description>
                            <bitRange>[31:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PRESENT</name>
                            <description>reads as 0b1</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>REVISION</name>
                            <description>reads as 0b0000</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ARCHID</name>
                            <description>reads as 0b0100101000010011</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCDEVID</name>
                    <description>TRCDEVID</description>
                    <addressOffset>0x41FC8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRCDEVID</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCDEVTYPE</name>
                    <description>TRCDEVTYPE</description>
                    <addressOffset>0x41FCC</addressOffset>
                    <resetValue>0x00000013</resetValue>
                    <fields>
                        <field>
                            <name>SUB</name>
                            <description>reads as 0b0001</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>MAJOR</name>
                            <description>reads as 0b0011</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCPIDR4</name>
                    <description>TRCPIDR4</description>
                    <addressOffset>0x41FD0</addressOffset>
                    <resetValue>0x00000004</resetValue>
                    <fields>
                        <field>
                            <name>SIZE</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DES_2</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCPIDR5</name>
                    <description>TRCPIDR5</description>
                    <addressOffset>0x41FD4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRCPIDR5</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCPIDR6</name>
                    <description>TRCPIDR6</description>
                    <addressOffset>0x41FD8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRCPIDR6</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCPIDR7</name>
                    <description>TRCPIDR7</description>
                    <addressOffset>0x41FDC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRCPIDR7</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCPIDR0</name>
                    <description>TRCPIDR0</description>
                    <addressOffset>0x41FE0</addressOffset>
                    <resetValue>0x00000021</resetValue>
                    <fields>
                        <field>
                            <name>PART_0</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCPIDR1</name>
                    <description>TRCPIDR1</description>
                    <addressOffset>0x41FE4</addressOffset>
                    <resetValue>0x000000BD</resetValue>
                    <fields>
                        <field>
                            <name>DES_0</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PART_0</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCPIDR2</name>
                    <description>TRCPIDR2</description>
                    <addressOffset>0x41FE8</addressOffset>
                    <resetValue>0x0000002B</resetValue>
                    <fields>
                        <field>
                            <name>REVISION</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>JEDEC</name>
                            <description>reads as 0b1</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DES_0</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCPIDR3</name>
                    <description>TRCPIDR3</description>
                    <addressOffset>0x41FEC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>REVAND</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CMOD</name>
                            <description>reads as `ImpDef</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCCIDR0</name>
                    <description>TRCCIDR0</description>
                    <addressOffset>0x41FF0</addressOffset>
                    <resetValue>0x0000000D</resetValue>
                    <fields>
                        <field>
                            <name>PRMBL_0</name>
                            <description>reads as 0b00001101</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCCIDR1</name>
                    <description>TRCCIDR1</description>
                    <addressOffset>0x41FF4</addressOffset>
                    <resetValue>0x00000090</resetValue>
                    <fields>
                        <field>
                            <name>CLASS</name>
                            <description>reads as 0b1001</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PRMBL_1</name>
                            <description>reads as 0b0000</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCCIDR2</name>
                    <description>TRCCIDR2</description>
                    <addressOffset>0x41FF8</addressOffset>
                    <resetValue>0x00000005</resetValue>
                    <fields>
                        <field>
                            <name>PRMBL_2</name>
                            <description>reads as 0b00000101</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRCCIDR3</name>
                    <description>TRCCIDR3</description>
                    <addressOffset>0x41FFC</addressOffset>
                    <resetValue>0x000000B1</resetValue>
                    <fields>
                        <field>
                            <name>PRMBL_3</name>
                            <description>reads as 0b10110001</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTICONTROL</name>
                    <description>CTI Control Register</description>
                    <addressOffset>0x42000</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GLBEN</name>
                            <description>Enables or disables the CTI</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIINTACK</name>
                    <description>CTI Interrupt Acknowledge Register</description>
                    <addressOffset>0x42010</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTACK</name>
                            <description>Acknowledges the corresponding ctitrigout output. There is one bit of the register for each ctitrigout output. When a 1 is written to a bit in this register, the corresponding ctitrigout is acknowledged, causing it to be cleared.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIAPPSET</name>
                    <description>CTI Application Trigger Set Register</description>
                    <addressOffset>0x42014</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>APPSET</name>
                            <description>Setting a bit HIGH generates a channel event for the selected channel. There is one bit of the register for each channel</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIAPPCLEAR</name>
                    <description>CTI Application Trigger Clear Register</description>
                    <addressOffset>0x42018</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>APPCLEAR</name>
                            <description>Sets the corresponding bits in the CTIAPPSET to 0. There is one bit of the register for each channel.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIAPPPULSE</name>
                    <description>CTI Application Pulse Register</description>
                    <addressOffset>0x4201C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>APPULSE</name>
                            <description>Setting a bit HIGH generates a channel event pulse for the selected channel. There is one bit of the register for each channel.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIINEN0</name>
                    <description>CTI Trigger to Channel Enable Registers</description>
                    <addressOffset>0x42020</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGINEN</name>
                            <description>Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIINEN1</name>
                    <description>CTI Trigger to Channel Enable Registers</description>
                    <addressOffset>0x42024</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGINEN</name>
                            <description>Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIINEN2</name>
                    <description>CTI Trigger to Channel Enable Registers</description>
                    <addressOffset>0x42028</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGINEN</name>
                            <description>Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIINEN3</name>
                    <description>CTI Trigger to Channel Enable Registers</description>
                    <addressOffset>0x4202C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGINEN</name>
                            <description>Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIINEN4</name>
                    <description>CTI Trigger to Channel Enable Registers</description>
                    <addressOffset>0x42030</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGINEN</name>
                            <description>Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIINEN5</name>
                    <description>CTI Trigger to Channel Enable Registers</description>
                    <addressOffset>0x42034</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGINEN</name>
                            <description>Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIINEN6</name>
                    <description>CTI Trigger to Channel Enable Registers</description>
                    <addressOffset>0x42038</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGINEN</name>
                            <description>Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIINEN7</name>
                    <description>CTI Trigger to Channel Enable Registers</description>
                    <addressOffset>0x4203C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGINEN</name>
                            <description>Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIOUTEN0</name>
                    <description>CTI Trigger to Channel Enable Registers</description>
                    <addressOffset>0x420A0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGOUTEN</name>
                            <description>Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIOUTEN1</name>
                    <description>CTI Trigger to Channel Enable Registers</description>
                    <addressOffset>0x420A4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGOUTEN</name>
                            <description>Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIOUTEN2</name>
                    <description>CTI Trigger to Channel Enable Registers</description>
                    <addressOffset>0x420A8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGOUTEN</name>
                            <description>Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIOUTEN3</name>
                    <description>CTI Trigger to Channel Enable Registers</description>
                    <addressOffset>0x420AC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGOUTEN</name>
                            <description>Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIOUTEN4</name>
                    <description>CTI Trigger to Channel Enable Registers</description>
                    <addressOffset>0x420B0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGOUTEN</name>
                            <description>Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIOUTEN5</name>
                    <description>CTI Trigger to Channel Enable Registers</description>
                    <addressOffset>0x420B4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGOUTEN</name>
                            <description>Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIOUTEN6</name>
                    <description>CTI Trigger to Channel Enable Registers</description>
                    <addressOffset>0x420B8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGOUTEN</name>
                            <description>Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIOUTEN7</name>
                    <description>CTI Trigger to Channel Enable Registers</description>
                    <addressOffset>0x420BC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGOUTEN</name>
                            <description>Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTITRIGINSTATUS</name>
                    <description>CTI Trigger to Channel Enable Registers</description>
                    <addressOffset>0x42130</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGINSTATUS</name>
                            <description>Shows the status of the ctitrigin inputs. There is one bit of the field for each trigger input.Because the register provides a view of the raw ctitrigin inputs, the reset value is UNKNOWN.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTITRIGOUTSTATUS</name>
                    <description>CTI Trigger In Status Register</description>
                    <addressOffset>0x42134</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGOUTSTATUS</name>
                            <description>Shows the status of the ctitrigout outputs. There is one bit of the field for each trigger output.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTICHINSTATUS</name>
                    <description>CTI Channel In Status Register</description>
                    <addressOffset>0x42138</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CTICHOUTSTATUS</name>
                            <description>Shows the status of the ctichout outputs. There is one bit of the field for each channel output</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTIGATE</name>
                    <description>Enable CTI Channel Gate register</description>
                    <addressOffset>0x42140</addressOffset>
                    <resetValue>0x0000000F</resetValue>
                    <fields>
                        <field>
                            <name>CTIGATEEN3</name>
                            <description>Enable ctichout3. Set to 0 to disable channel propagation.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CTIGATEEN2</name>
                            <description>Enable ctichout2. Set to 0 to disable channel propagation.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CTIGATEEN1</name>
                            <description>Enable ctichout1. Set to 0 to disable channel propagation.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CTIGATEEN0</name>
                            <description>Enable ctichout0. Set to 0 to disable channel propagation.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ASICCTL</name>
                    <description>External Multiplexer Control register</description>
                    <addressOffset>0x42144</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ASICCTL</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITCHOUT</name>
                    <description>Integration Test Channel Output register</description>
                    <addressOffset>0x42EE4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CTCHOUT</name>
                            <description>Sets the value of the ctichout outputs</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITTRIGOUT</name>
                    <description>Integration Test Trigger Output register</description>
                    <addressOffset>0x42EE8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CTTRIGOUT</name>
                            <description>Sets the value of the ctitrigout outputs</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITCHIN</name>
                    <description>Integration Test Channel Input register</description>
                    <addressOffset>0x42EF4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CTCHIN</name>
                            <description>Reads the value of the ctichin inputs.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ITCTRL</name>
                    <description>Integration Mode Control register</description>
                    <addressOffset>0x42F00</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>IME</name>
                            <description>Integration Mode Enable</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DEVARCH</name>
                    <description>Device Architecture register</description>
                    <addressOffset>0x42FBC</addressOffset>
                    <resetValue>0x47701A14</resetValue>
                    <fields>
                        <field>
                            <name>ARCHITECT</name>
                            <description>Indicates the component architect</description>
                            <bitRange>[31:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PRESENT</name>
                            <description>Indicates whether the DEVARCH register is present</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>REVISION</name>
                            <description>Indicates the architecture revision</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ARCHID</name>
                            <description>Indicates the component</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DEVID</name>
                    <description>Device Configuration register</description>
                    <addressOffset>0x42FC8</addressOffset>
                    <resetValue>0x00040800</resetValue>
                    <fields>
                        <field>
                            <name>NUMCH</name>
                            <description>Number of ECT channels available</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NUMTRIG</name>
                            <description>Number of ECT triggers available.</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EXTMUXNUM</name>
                            <description>Indicates the number of multiplexers available on Trigger Inputs and Trigger Outputs that are using asicctl. The default value of 0b00000 indicates that no multiplexing is present. This value of this bit depends on the Verilog define EXTMUXNUM that you must change accordingly.</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DEVTYPE</name>
                    <description>Device Type Identifier register</description>
                    <addressOffset>0x42FCC</addressOffset>
                    <resetValue>0x00000014</resetValue>
                    <fields>
                        <field>
                            <name>SUB</name>
                            <description>Sub-classification of the type of the debug component as specified in the ARM Architecture Specification within the major classification as specified in the MAJOR field.</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>MAJOR</name>
                            <description>Major classification of the type of the debug component as specified in the ARM Architecture Specification for this debug and trace component.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PIDR4</name>
                    <description>CoreSight Peripheral ID4</description>
                    <addressOffset>0x42FD0</addressOffset>
                    <resetValue>0x00000004</resetValue>
                    <fields>
                        <field>
                            <name>SIZE</name>
                            <description>Always 0b0000. Indicates that the device only occupies 4KB of memory</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DES_2</name>
                            <description>Together, PIDR1.DES_0, PIDR2.DES_1, and PIDR4.DES_2 identify the designer of the component.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PIDR5</name>
                    <description>CoreSight Peripheral ID5</description>
                    <addressOffset>0x42FD4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PIDR5</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PIDR6</name>
                    <description>CoreSight Peripheral ID6</description>
                    <addressOffset>0x42FD8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PIDR6</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PIDR7</name>
                    <description>CoreSight Peripheral ID7</description>
                    <addressOffset>0x42FDC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PIDR7</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PIDR0</name>
                    <description>CoreSight Peripheral ID0</description>
                    <addressOffset>0x42FE0</addressOffset>
                    <resetValue>0x00000021</resetValue>
                    <fields>
                        <field>
                            <name>PART_0</name>
                            <description>Bits[7:0] of the 12-bit part number of the component. The designer of the component assigns this part number.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PIDR1</name>
                    <description>CoreSight Peripheral ID1</description>
                    <addressOffset>0x42FE4</addressOffset>
                    <resetValue>0x000000BD</resetValue>
                    <fields>
                        <field>
                            <name>DES_0</name>
                            <description>Together, PIDR1.DES_0, PIDR2.DES_1, and PIDR4.DES_2 identify the designer of the component.</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PART_1</name>
                            <description>Bits[11:8] of the 12-bit part number of the component. The designer of the component assigns this part number.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PIDR2</name>
                    <description>CoreSight Peripheral ID2</description>
                    <addressOffset>0x42FE8</addressOffset>
                    <resetValue>0x0000000B</resetValue>
                    <fields>
                        <field>
                            <name>REVISION</name>
                            <description>This device is at r1p0</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>JEDEC</name>
                            <description>Always 1. Indicates that the JEDEC-assigned designer ID is used.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DES_1</name>
                            <description>Together, PIDR1.DES_0, PIDR2.DES_1, and PIDR4.DES_2 identify the designer of the component.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PIDR3</name>
                    <description>CoreSight Peripheral ID3</description>
                    <addressOffset>0x42FEC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>REVAND</name>
                            <description>Indicates minor errata fixes specific to the revision of the component being used, for example metal fixes after implementation. In most cases, this field is 0b0000. ARM recommends that the component designers ensure that a metal fix can change this field if required, for example, by driving it from registers that reset to 0b0000.</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CMOD</name>
                            <description>Customer Modified. Indicates whether the customer has modified the behavior of the component. In most cases, this field is 0b0000. Customers change this value when they make authorized modifications to this component.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CIDR0</name>
                    <description>CoreSight Component ID0</description>
                    <addressOffset>0x42FF0</addressOffset>
                    <resetValue>0x0000000D</resetValue>
                    <fields>
                        <field>
                            <name>PRMBL_0</name>
                            <description>Preamble[0]. Contains bits[7:0] of the component identification code</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CIDR1</name>
                    <description>CoreSight Component ID1</description>
                    <addressOffset>0x42FF4</addressOffset>
                    <resetValue>0x00000090</resetValue>
                    <fields>
                        <field>
                            <name>CLASS</name>
                            <description>Class of the component, for example, whether the component is a ROM table or a generic CoreSight component. Contains bits[15:12] of the component identification code.</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PRMBL_1</name>
                            <description>Preamble[1]. Contains bits[11:8] of the component identification code.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CIDR2</name>
                    <description>CoreSight Component ID2</description>
                    <addressOffset>0x42FF8</addressOffset>
                    <resetValue>0x00000005</resetValue>
                    <fields>
                        <field>
                            <name>PRMBL_2</name>
                            <description>Preamble[2]. Contains bits[23:16] of the component identification code.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CIDR3</name>
                    <description>CoreSight Component ID3</description>
                    <addressOffset>0x42FFC</addressOffset>
                    <resetValue>0x000000B1</resetValue>
                    <fields>
                        <field>
                            <name>PRMBL_3</name>
                            <description>Preamble[3]. Contains bits[31:24] of the component identification code.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral derivedFrom="PPB">
            <name>PPB_NS</name>
            <baseAddress>0xE0020000</baseAddress>
        </peripheral>
        <peripheral>
            <name>QMI</name>
            <description>QSPI Memory Interface.

                Provides a memory-mapped interface to up to two SPI/DSPI/QSPI flash or PSRAM devices. Also provides a serial interface for programming and configuration of the external device.</description>
            <baseAddress>0x400D0000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x54</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>DIRECT_CSR</name>
                    <description>Control and status for direct serial mode

                        Direct serial mode allows the processor to send and receive raw serial frames, for programming, configuration and control of the external memory devices. Only SPI mode 0 (CPOL=0 CPHA=0) is supported.</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x01800000</resetValue>
                    <fields>
                        <field>
                            <name>RXDELAY</name>
                            <description>Delay the read data sample timing, in units of one half of a system clock cycle. (Not necessarily half of an SCK cycle.)</description>
                            <bitRange>[31:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLKDIV</name>
                            <description>Clock divisor for direct serial mode. Divisors of 1..255 are encoded directly, and the maximum divisor of 256 is encoded by a value of CLKDIV=0.

                                The clock divisor can be changed on-the-fly by software, without halting or otherwise coordinating with the serial interface. The serial interface will sample the latest clock divisor each time it begins the transmission of a new byte.</description>
                            <bitRange>[29:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RXLEVEL</name>
                            <description>Current level of DIRECT_RX FIFO</description>
                            <bitRange>[20:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RXFULL</name>
                            <description>When 1, the DIRECT_RX FIFO is currently full. The serial interface will be stalled until data is popped; the interface will not begin a new serial frame when the DIRECT_TX FIFO is empty or the DIRECT_RX FIFO is full.</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RXEMPTY</name>
                            <description>When 1, the DIRECT_RX FIFO is currently empty. If the processor attempts to read more data, the FIFO state is not affected, but the value returned to the processor is undefined.</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TXLEVEL</name>
                            <description>Current level of DIRECT_TX FIFO</description>
                            <bitRange>[14:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TXEMPTY</name>
                            <description>When 1, the DIRECT_TX FIFO is currently empty. Unless the processor pushes more data, transmission will stop and BUSY will go low once the current 8-bit serial frame completes.</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TXFULL</name>
                            <description>When 1, the DIRECT_TX FIFO is currently full. If the processor tries to write more data, that data will be ignored.</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>AUTO_CS1N</name>
                            <description>When 1, automatically assert the CS1n chip select line whenever the BUSY flag is set.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AUTO_CS0N</name>
                            <description>When 1, automatically assert the CS0n chip select line whenever the BUSY flag is set.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ASSERT_CS1N</name>
                            <description>When 1, assert (i.e. drive low) the CS1n chip select line.

                                Note that this applies even when DIRECT_CSR_EN is 0.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ASSERT_CS0N</name>
                            <description>When 1, assert (i.e. drive low) the CS0n chip select line.

                                Note that this applies even when DIRECT_CSR_EN is 0.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BUSY</name>
                            <description>Direct mode busy flag. If 1, data is currently being shifted in/out (or would be if the interface were not stalled on the RX FIFO), and the chip select must not yet be deasserted.

                                The busy flag will also be set to 1 if a memory-mapped transfer is still in progress when direct mode is enabled. Direct mode blocks new memory-mapped transfers, but can't halt a transfer that is already in progress. If there is a chance that memory-mapped transfers may be in progress, the busy flag should be polled for 0 before asserting the chip select.

                                (In practice you will usually discover this timing condition through other means, because any subsequent memory-mapped transfers when direct mode is enabled will return bus errors, which are difficult to ignore.)</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>Enable direct mode.

                                In direct mode, software controls the chip select lines, and can perform direct SPI transfers by pushing data to the DIRECT_TX FIFO, and popping the same amount of data from the DIRECT_RX FIFO.

                                Memory-mapped accesses will generate bus errors when direct serial mode is enabled.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DIRECT_TX</name>
                    <description>Transmit FIFO for direct mode</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NOPUSH</name>
                            <description>Inhibit the RX FIFO push that would correspond to this TX FIFO entry.

                                Useful to avoid garbage appearing in the RX FIFO when pushing the command at the beginning of a SPI transfer.</description>
                            <bitRange>[20:20]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>OE</name>
                            <description>Output enable (active-high). For single width (SPI), this field is ignored, and SD0 is always set to output, with SD1 always set to input.

                                For dual and quad width (DSPI/QSPI), this sets whether the relevant SDx pads are set to output whilst transferring this FIFO record. In this case the command/address should have OE set, and the data transfer should have OE set or clear depending on the direction of the transfer.</description>
                            <bitRange>[19:19]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>DWIDTH</name>
                            <description>Data width. If 0, hardware will transmit the 8 LSBs of the DIRECT_TX DATA field, and return an 8-bit value in the 8 LSBs of DIRECT_RX. If 1, the full 16-bit width is used. 8-bit and 16-bit transfers can be mixed freely.</description>
                            <bitRange>[18:18]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>IWIDTH</name>
                            <description>Configure whether this FIFO record is transferred with single/dual/quad interface width (0/1/2). Different widths can be mixed freely.</description>
                            <bitRange>[17:16]</bitRange>
                            <access>write-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DATA</name>
                            <description>Data pushed here will be clocked out falling edges of SCK (or before the very first rising edge of SCK, if this is the first pulse). For each byte clocked out, the interface will simultaneously sample one byte, on rising edges of SCK, and push this to the DIRECT_RX FIFO.

                                For 16-bit data, the least-significant byte is transmitted first.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DIRECT_RX</name>
                    <description>Receive FIFO for direct mode</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DIRECT_RX</name>
                            <description>With each byte clocked out on the serial interface, one byte will simultaneously be clocked in, and will appear in this FIFO. The serial interface will stall when this FIFO is full, to avoid dropping data.

                                When 16-bit data is pushed into the TX FIFO, the corresponding RX FIFO push will also contain 16 bits of data. The least-significant byte is the first one received.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>M0_TIMING</name>
                    <description>Timing configuration register for memory address window 0.</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x40000004</resetValue>
                    <fields>
                        <field>
                            <name>COOLDOWN</name>
                            <description>Chip select cooldown period. When a memory transfer finishes, the chip select remains asserted for 64 x COOLDOWN system clock cycles, plus half an SCK clock period (rounded up for odd SCK divisors). After this cooldown expires, the chip select is always deasserted to save power.

                                If the next memory access arrives within the cooldown period, the QMI may be able to append more SCK cycles to the currently ongoing SPI transfer, rather than starting a new transfer. This reduces access latency and increases bus throughput.

                                Specifically, the next access must be in the same direction (read/write), access the same memory window (chip select 0/1), and follow sequentially the address of the last transfer. If any of these are false, the new access will first deassert the chip select, then begin a new transfer.

                                If COOLDOWN is 0, the address alignment configured by PAGEBREAK has been reached, or the total chip select assertion limit MAX_SELECT has been reached, the cooldown period is skipped, and the chip select will always be deasserted one half SCK period after the transfer finishes.</description>
                            <bitRange>[31:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PAGEBREAK</name>
                            <description>When page break is enabled, chip select will automatically deassert when crossing certain power-of-2-aligned address boundaries. The next access will always begin a new read/write SPI burst, even if the address of the next access follows in sequence with the last access before the page boundary.

                                Some flash and PSRAM devices forbid crossing page boundaries with a single read/write transfer, or restrict the operating frequency for transfers that do cross page a boundary. This option allows the QMI to safely support those devices.

                                This field has no effect when COOLDOWN is disabled.</description>
                            <bitRange>[29:28]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NONE</name>
                                    <description>No page boundary is enforced</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>256</name>
                                    <description>Break bursts crossing a 256-byte page boundary</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>1024</name>
                                    <description>Break bursts crossing a 1024-byte quad-page boundary</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4096</name>
                                    <description>Break bursts crossing a 4096-byte sector boundary</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SELECT_SETUP</name>
                            <description>Add up to one additional system clock cycle of setup between chip select assertion and the first rising edge of SCK.

                                The default setup time is one half SCK period, which is usually sufficient except for very high SCK frequencies with some flash devices.</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SELECT_HOLD</name>
                            <description>Add up to three additional system clock cycles of active hold between the last falling edge of SCK and the deassertion of this window's chip select.

                                The default hold time is one system clock cycle. Note that flash datasheets usually give chip select active hold time from the last *rising* edge of SCK, and so even zero hold from the last falling edge would be safe.

                                Note that this is a minimum hold time guaranteed by the QMI: the actual chip select active hold may be slightly longer for read transfers with low clock divisors and/or high sample delays. Specifically, if the point two cycles after the last RX data sample is later than the last SCK falling edge, then the hold time is measured from *this* point.

                                Note also that, in case the final SCK pulse is masked to save energy (true for non-DTR reads when COOLDOWN is disabled or PAGE_BREAK is reached), all of QMI's timing logic behaves as though the clock pulse were still present. The SELECT_HOLD time is applied from the point where the last SCK falling edge would be if the clock pulse were not masked.</description>
                            <bitRange>[24:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MAX_SELECT</name>
                            <description>Enforce a maximum assertion duration for this window's chip select, in units of 64 system clock cycles. If 0, the QMI is permitted to keep the chip select asserted indefinitely when servicing sequential memory accesses (see COOLDOWN).

                                This feature is required to meet timing constraints of PSRAM devices, which specify a maximum chip select assertion so they can perform DRAM refresh cycles. See also MIN_DESELECT, which can enforce a minimum deselect time.

                                If a memory access is in progress at the time MAX_SELECT is reached, the QMI will wait for the access to complete before deasserting the chip select. This additional time must be accounted for to calculate a safe MAX_SELECT value. In the worst case, this may be a fully-formed serial transfer, including command prefix and address, with a data payload as large as one cache line.</description>
                            <bitRange>[22:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MIN_DESELECT</name>
                            <description>After this window's chip select is deasserted, it remains deasserted for half an SCK cycle (rounded up to an integer number of system clock cycles), plus MIN_DESELECT additional system clock cycles, before the QMI reasserts either chip select pin.

                                Nonzero values may be required for PSRAM devices which enforce a longer minimum CS deselect time, so that they can perform internal DRAM refresh cycles whilst deselected.</description>
                            <bitRange>[16:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RXDELAY</name>
                            <description>Delay the read data sample timing, in units of one half of a system clock cycle. (Not necessarily half of an SCK cycle.) An RXDELAY of 0 means the sample is captured at the SDI input registers simultaneously with the rising edge of SCK launched from the SCK output register.

                                At higher SCK frequencies, RXDELAY may need to be increased to account for the round trip delay of the pads, and the clock-to-Q delay of the QSPI memory device.</description>
                            <bitRange>[10:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLKDIV</name>
                            <description>Clock divisor. Odd and even divisors are supported. Defines the SCK clock period in units of 1 system clock cycle. Divisors 1..255 are encoded directly, and a divisor of 256 is encoded with a value of CLKDIV=0.

                                The clock divisor can be changed on-the-fly, even when the QMI is currently accessing memory in this address window. All other parameters must only be changed when the QMI is idle.

                                If software is increasing CLKDIV in anticipation of an increase in the system clock frequency, a dummy access to either memory window (and appropriate processor barriers/fences) must be inserted after the Mx_TIMING write to ensure the SCK divisor change is in effect _before_ the system clock is changed.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>M0_RFMT</name>
                    <description>Read transfer format configuration for memory address window 0.

                        Configure the bus width of each transfer phase individually, and configure the length or presence of the command prefix, command suffix and dummy/turnaround transfer phases. Only 24-bit addresses are supported.

                        The reset value of the M0_RFMT register is configured to support a basic 03h serial read transfer with no additional configuration.</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00001000</resetValue>
                    <fields>
                        <field>
                            <name>DTR</name>
                            <description>Enable double transfer rate (DTR) for read commands: address, suffix and read data phases are active on both edges of SCK. SDO data is launched centre-aligned on each SCK edge, and SDI data is captured on the SCK edge that follows its launch.

                                DTR is implemented by halving the clock rate; SCK has a period of 2 x CLK_DIV throughout the transfer. The prefix and dummy phases are still single transfer rate.

                                If the suffix is quad-width, it must be 0 or 8 bits in length, to ensure an even number of SCK edges.</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DUMMY_LEN</name>
                            <description>Length of dummy phase between command suffix and data phase, in units of 4 bits. (i.e. 1 cycle for quad width, 2 for dual, 4 for single)</description>
                            <bitRange>[18:16]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NONE</name>
                                    <description>No dummy phase</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4</name>
                                    <description>4 dummy bits</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8</name>
                                    <description>8 dummy bits</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>12</name>
                                    <description>12 dummy bits</description>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>16</name>
                                    <description>16 dummy bits</description>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>20</name>
                                    <description>20 dummy bits</description>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>24</name>
                                    <description>24 dummy bits</description>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>28</name>
                                    <description>28 dummy bits</description>
                                    <value>7</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SUFFIX_LEN</name>
                            <description>Length of post-address command suffix, in units of 4 bits. (i.e. 1 cycle for quad width, 2 for dual, 4 for single)

                                Only values of 0 and 8 bits are supported.</description>
                            <bitRange>[15:14]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NONE</name>
                                    <description>No suffix</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8</name>
                                    <description>8-bit suffix</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>PREFIX_LEN</name>
                            <description>Length of command prefix, in units of 8 bits. (i.e. 2 cycles for quad width, 4 for dual, 8 for single)</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NONE</name>
                                    <description>No prefix</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8</name>
                                    <description>8-bit prefix</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DATA_WIDTH</name>
                            <description>The width used for the data transfer</description>
                            <bitRange>[9:8]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DUMMY_WIDTH</name>
                            <description>The width used for the dummy phase, if any.

                                If width is single, SD0/MOSI is held asserted low during the dummy phase, and SD1...SD3 are tristated. If width is dual/quad, all IOs are tristated during the dummy phase.</description>
                            <bitRange>[7:6]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SUFFIX_WIDTH</name>
                            <description>The width used for the post-address command suffix, if any</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ADDR_WIDTH</name>
                            <description>The transfer width used for the address. The address phase always transfers 24 bits in total.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>PREFIX_WIDTH</name>
                            <description>The transfer width used for the command prefix, if any</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>M0_RCMD</name>
                    <description>Command constants used for reads from memory address window 0.

                        The reset value of the M0_RCMD register is configured to support a basic 03h serial read transfer with no additional configuration.</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x0000A003</resetValue>
                    <fields>
                        <field>
                            <name>SUFFIX</name>
                            <description>The command suffix bits following the address, if Mx_RFMT_SUFFIX_LEN is nonzero.</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PREFIX</name>
                            <description>The command prefix bits to prepend on each new transfer, if Mx_RFMT_PREFIX_LEN is nonzero.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>M0_WFMT</name>
                    <description>Write transfer format configuration for memory address window 0.

                        Configure the bus width of each transfer phase individually, and configure the length or presence of the command prefix, command suffix and dummy/turnaround transfer phases. Only 24-bit addresses are supported.

                        The reset value of the M0_WFMT register is configured to support a basic 02h serial write transfer. However, writes to this window must first be enabled via the XIP_CTRL_WRITABLE_M0 bit, as XIP memory is read-only by default.</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x00001000</resetValue>
                    <fields>
                        <field>
                            <name>DTR</name>
                            <description>Enable double transfer rate (DTR) for write commands: address, suffix and write data phases are active on both edges of SCK. SDO data is launched centre-aligned on each SCK edge, and SDI data is captured on the SCK edge that follows its launch.

                                DTR is implemented by halving the clock rate; SCK has a period of 2 x CLK_DIV throughout the transfer. The prefix and dummy phases are still single transfer rate.

                                If the suffix is quad-width, it must be 0 or 8 bits in length, to ensure an even number of SCK edges.</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DUMMY_LEN</name>
                            <description>Length of dummy phase between command suffix and data phase, in units of 4 bits. (i.e. 1 cycle for quad width, 2 for dual, 4 for single)</description>
                            <bitRange>[18:16]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NONE</name>
                                    <description>No dummy phase</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4</name>
                                    <description>4 dummy bits</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8</name>
                                    <description>8 dummy bits</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>12</name>
                                    <description>12 dummy bits</description>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>16</name>
                                    <description>16 dummy bits</description>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>20</name>
                                    <description>20 dummy bits</description>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>24</name>
                                    <description>24 dummy bits</description>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>28</name>
                                    <description>28 dummy bits</description>
                                    <value>7</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SUFFIX_LEN</name>
                            <description>Length of post-address command suffix, in units of 4 bits. (i.e. 1 cycle for quad width, 2 for dual, 4 for single)

                                Only values of 0 and 8 bits are supported.</description>
                            <bitRange>[15:14]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NONE</name>
                                    <description>No suffix</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8</name>
                                    <description>8-bit suffix</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>PREFIX_LEN</name>
                            <description>Length of command prefix, in units of 8 bits. (i.e. 2 cycles for quad width, 4 for dual, 8 for single)</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NONE</name>
                                    <description>No prefix</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8</name>
                                    <description>8-bit prefix</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DATA_WIDTH</name>
                            <description>The width used for the data transfer</description>
                            <bitRange>[9:8]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DUMMY_WIDTH</name>
                            <description>The width used for the dummy phase, if any.

                                If width is single, SD0/MOSI is held asserted low during the dummy phase, and SD1...SD3 are tristated. If width is dual/quad, all IOs are tristated during the dummy phase.</description>
                            <bitRange>[7:6]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SUFFIX_WIDTH</name>
                            <description>The width used for the post-address command suffix, if any</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ADDR_WIDTH</name>
                            <description>The transfer width used for the address. The address phase always transfers 24 bits in total.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>PREFIX_WIDTH</name>
                            <description>The transfer width used for the command prefix, if any</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>M0_WCMD</name>
                    <description>Command constants used for writes to memory address window 0.

                        The reset value of the M0_WCMD register is configured to support a basic 02h serial write transfer with no additional configuration.</description>
                    <addressOffset>0x1C</addressOffset>
                    <resetValue>0x0000A002</resetValue>
                    <fields>
                        <field>
                            <name>SUFFIX</name>
                            <description>The command suffix bits following the address, if Mx_WFMT_SUFFIX_LEN is nonzero.</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PREFIX</name>
                            <description>The command prefix bits to prepend on each new transfer, if Mx_WFMT_PREFIX_LEN is nonzero.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>M1_TIMING</name>
                    <description>Timing configuration register for memory address window 1.</description>
                    <addressOffset>0x20</addressOffset>
                    <resetValue>0x40000004</resetValue>
                    <fields>
                        <field>
                            <name>COOLDOWN</name>
                            <description>Chip select cooldown period. When a memory transfer finishes, the chip select remains asserted for 64 x COOLDOWN system clock cycles, plus half an SCK clock period (rounded up for odd SCK divisors). After this cooldown expires, the chip select is always deasserted to save power.

                                If the next memory access arrives within the cooldown period, the QMI may be able to append more SCK cycles to the currently ongoing SPI transfer, rather than starting a new transfer. This reduces access latency and increases bus throughput.

                                Specifically, the next access must be in the same direction (read/write), access the same memory window (chip select 0/1), and follow sequentially the address of the last transfer. If any of these are false, the new access will first deassert the chip select, then begin a new transfer.

                                If COOLDOWN is 0, the address alignment configured by PAGEBREAK has been reached, or the total chip select assertion limit MAX_SELECT has been reached, the cooldown period is skipped, and the chip select will always be deasserted one half SCK period after the transfer finishes.</description>
                            <bitRange>[31:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PAGEBREAK</name>
                            <description>When page break is enabled, chip select will automatically deassert when crossing certain power-of-2-aligned address boundaries. The next access will always begin a new read/write SPI burst, even if the address of the next access follows in sequence with the last access before the page boundary.

                                Some flash and PSRAM devices forbid crossing page boundaries with a single read/write transfer, or restrict the operating frequency for transfers that do cross page a boundary. This option allows the QMI to safely support those devices.

                                This field has no effect when COOLDOWN is disabled.</description>
                            <bitRange>[29:28]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NONE</name>
                                    <description>No page boundary is enforced</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>256</name>
                                    <description>Break bursts crossing a 256-byte page boundary</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>1024</name>
                                    <description>Break bursts crossing a 1024-byte quad-page boundary</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4096</name>
                                    <description>Break bursts crossing a 4096-byte sector boundary</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SELECT_SETUP</name>
                            <description>Add up to one additional system clock cycle of setup between chip select assertion and the first rising edge of SCK.

                                The default setup time is one half SCK period, which is usually sufficient except for very high SCK frequencies with some flash devices.</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SELECT_HOLD</name>
                            <description>Add up to three additional system clock cycles of active hold between the last falling edge of SCK and the deassertion of this window's chip select.

                                The default hold time is one system clock cycle. Note that flash datasheets usually give chip select active hold time from the last *rising* edge of SCK, and so even zero hold from the last falling edge would be safe.

                                Note that this is a minimum hold time guaranteed by the QMI: the actual chip select active hold may be slightly longer for read transfers with low clock divisors and/or high sample delays. Specifically, if the point two cycles after the last RX data sample is later than the last SCK falling edge, then the hold time is measured from *this* point.

                                Note also that, in case the final SCK pulse is masked to save energy (true for non-DTR reads when COOLDOWN is disabled or PAGE_BREAK is reached), all of QMI's timing logic behaves as though the clock pulse were still present. The SELECT_HOLD time is applied from the point where the last SCK falling edge would be if the clock pulse were not masked.</description>
                            <bitRange>[24:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MAX_SELECT</name>
                            <description>Enforce a maximum assertion duration for this window's chip select, in units of 64 system clock cycles. If 0, the QMI is permitted to keep the chip select asserted indefinitely when servicing sequential memory accesses (see COOLDOWN).

                                This feature is required to meet timing constraints of PSRAM devices, which specify a maximum chip select assertion so they can perform DRAM refresh cycles. See also MIN_DESELECT, which can enforce a minimum deselect time.

                                If a memory access is in progress at the time MAX_SELECT is reached, the QMI will wait for the access to complete before deasserting the chip select. This additional time must be accounted for to calculate a safe MAX_SELECT value. In the worst case, this may be a fully-formed serial transfer, including command prefix and address, with a data payload as large as one cache line.</description>
                            <bitRange>[22:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MIN_DESELECT</name>
                            <description>After this window's chip select is deasserted, it remains deasserted for half an SCK cycle (rounded up to an integer number of system clock cycles), plus MIN_DESELECT additional system clock cycles, before the QMI reasserts either chip select pin.

                                Nonzero values may be required for PSRAM devices which enforce a longer minimum CS deselect time, so that they can perform internal DRAM refresh cycles whilst deselected.</description>
                            <bitRange>[16:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RXDELAY</name>
                            <description>Delay the read data sample timing, in units of one half of a system clock cycle. (Not necessarily half of an SCK cycle.) An RXDELAY of 0 means the sample is captured at the SDI input registers simultaneously with the rising edge of SCK launched from the SCK output register.

                                At higher SCK frequencies, RXDELAY may need to be increased to account for the round trip delay of the pads, and the clock-to-Q delay of the QSPI memory device.</description>
                            <bitRange>[10:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLKDIV</name>
                            <description>Clock divisor. Odd and even divisors are supported. Defines the SCK clock period in units of 1 system clock cycle. Divisors 1..255 are encoded directly, and a divisor of 256 is encoded with a value of CLKDIV=0.

                                The clock divisor can be changed on-the-fly, even when the QMI is currently accessing memory in this address window. All other parameters must only be changed when the QMI is idle.

                                If software is increasing CLKDIV in anticipation of an increase in the system clock frequency, a dummy access to either memory window (and appropriate processor barriers/fences) must be inserted after the Mx_TIMING write to ensure the SCK divisor change is in effect _before_ the system clock is changed.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>M1_RFMT</name>
                    <description>Read transfer format configuration for memory address window 1.

                        Configure the bus width of each transfer phase individually, and configure the length or presence of the command prefix, command suffix and dummy/turnaround transfer phases. Only 24-bit addresses are supported.

                        The reset value of the M1_RFMT register is configured to support a basic 03h serial read transfer with no additional configuration.</description>
                    <addressOffset>0x24</addressOffset>
                    <resetValue>0x00001000</resetValue>
                    <fields>
                        <field>
                            <name>DTR</name>
                            <description>Enable double transfer rate (DTR) for read commands: address, suffix and read data phases are active on both edges of SCK. SDO data is launched centre-aligned on each SCK edge, and SDI data is captured on the SCK edge that follows its launch.

                                DTR is implemented by halving the clock rate; SCK has a period of 2 x CLK_DIV throughout the transfer. The prefix and dummy phases are still single transfer rate.

                                If the suffix is quad-width, it must be 0 or 8 bits in length, to ensure an even number of SCK edges.</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DUMMY_LEN</name>
                            <description>Length of dummy phase between command suffix and data phase, in units of 4 bits. (i.e. 1 cycle for quad width, 2 for dual, 4 for single)</description>
                            <bitRange>[18:16]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NONE</name>
                                    <description>No dummy phase</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4</name>
                                    <description>4 dummy bits</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8</name>
                                    <description>8 dummy bits</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>12</name>
                                    <description>12 dummy bits</description>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>16</name>
                                    <description>16 dummy bits</description>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>20</name>
                                    <description>20 dummy bits</description>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>24</name>
                                    <description>24 dummy bits</description>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>28</name>
                                    <description>28 dummy bits</description>
                                    <value>7</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SUFFIX_LEN</name>
                            <description>Length of post-address command suffix, in units of 4 bits. (i.e. 1 cycle for quad width, 2 for dual, 4 for single)

                                Only values of 0 and 8 bits are supported.</description>
                            <bitRange>[15:14]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NONE</name>
                                    <description>No suffix</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8</name>
                                    <description>8-bit suffix</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>PREFIX_LEN</name>
                            <description>Length of command prefix, in units of 8 bits. (i.e. 2 cycles for quad width, 4 for dual, 8 for single)</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NONE</name>
                                    <description>No prefix</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8</name>
                                    <description>8-bit prefix</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DATA_WIDTH</name>
                            <description>The width used for the data transfer</description>
                            <bitRange>[9:8]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DUMMY_WIDTH</name>
                            <description>The width used for the dummy phase, if any.

                                If width is single, SD0/MOSI is held asserted low during the dummy phase, and SD1...SD3 are tristated. If width is dual/quad, all IOs are tristated during the dummy phase.</description>
                            <bitRange>[7:6]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SUFFIX_WIDTH</name>
                            <description>The width used for the post-address command suffix, if any</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ADDR_WIDTH</name>
                            <description>The transfer width used for the address. The address phase always transfers 24 bits in total.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>PREFIX_WIDTH</name>
                            <description>The transfer width used for the command prefix, if any</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>M1_RCMD</name>
                    <description>Command constants used for reads from memory address window 1.

                        The reset value of the M1_RCMD register is configured to support a basic 03h serial read transfer with no additional configuration.</description>
                    <addressOffset>0x28</addressOffset>
                    <resetValue>0x0000A003</resetValue>
                    <fields>
                        <field>
                            <name>SUFFIX</name>
                            <description>The command suffix bits following the address, if Mx_RFMT_SUFFIX_LEN is nonzero.</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PREFIX</name>
                            <description>The command prefix bits to prepend on each new transfer, if Mx_RFMT_PREFIX_LEN is nonzero.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>M1_WFMT</name>
                    <description>Write transfer format configuration for memory address window 1.

                        Configure the bus width of each transfer phase individually, and configure the length or presence of the command prefix, command suffix and dummy/turnaround transfer phases. Only 24-bit addresses are supported.

                        The reset value of the M1_WFMT register is configured to support a basic 02h serial write transfer. However, writes to this window must first be enabled via the XIP_CTRL_WRITABLE_M1 bit, as XIP memory is read-only by default.</description>
                    <addressOffset>0x2C</addressOffset>
                    <resetValue>0x00001000</resetValue>
                    <fields>
                        <field>
                            <name>DTR</name>
                            <description>Enable double transfer rate (DTR) for write commands: address, suffix and write data phases are active on both edges of SCK. SDO data is launched centre-aligned on each SCK edge, and SDI data is captured on the SCK edge that follows its launch.

                                DTR is implemented by halving the clock rate; SCK has a period of 2 x CLK_DIV throughout the transfer. The prefix and dummy phases are still single transfer rate.

                                If the suffix is quad-width, it must be 0 or 8 bits in length, to ensure an even number of SCK edges.</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DUMMY_LEN</name>
                            <description>Length of dummy phase between command suffix and data phase, in units of 4 bits. (i.e. 1 cycle for quad width, 2 for dual, 4 for single)</description>
                            <bitRange>[18:16]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NONE</name>
                                    <description>No dummy phase</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4</name>
                                    <description>4 dummy bits</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8</name>
                                    <description>8 dummy bits</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>12</name>
                                    <description>12 dummy bits</description>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>16</name>
                                    <description>16 dummy bits</description>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>20</name>
                                    <description>20 dummy bits</description>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>24</name>
                                    <description>24 dummy bits</description>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>28</name>
                                    <description>28 dummy bits</description>
                                    <value>7</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SUFFIX_LEN</name>
                            <description>Length of post-address command suffix, in units of 4 bits. (i.e. 1 cycle for quad width, 2 for dual, 4 for single)

                                Only values of 0 and 8 bits are supported.</description>
                            <bitRange>[15:14]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NONE</name>
                                    <description>No suffix</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8</name>
                                    <description>8-bit suffix</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>PREFIX_LEN</name>
                            <description>Length of command prefix, in units of 8 bits. (i.e. 2 cycles for quad width, 4 for dual, 8 for single)</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NONE</name>
                                    <description>No prefix</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8</name>
                                    <description>8-bit prefix</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DATA_WIDTH</name>
                            <description>The width used for the data transfer</description>
                            <bitRange>[9:8]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DUMMY_WIDTH</name>
                            <description>The width used for the dummy phase, if any.

                                If width is single, SD0/MOSI is held asserted low during the dummy phase, and SD1...SD3 are tristated. If width is dual/quad, all IOs are tristated during the dummy phase.</description>
                            <bitRange>[7:6]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SUFFIX_WIDTH</name>
                            <description>The width used for the post-address command suffix, if any</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ADDR_WIDTH</name>
                            <description>The transfer width used for the address. The address phase always transfers 24 bits in total.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>PREFIX_WIDTH</name>
                            <description>The transfer width used for the command prefix, if any</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>M1_WCMD</name>
                    <description>Command constants used for writes to memory address window 1.

                        The reset value of the M1_WCMD register is configured to support a basic 02h serial write transfer with no additional configuration.</description>
                    <addressOffset>0x30</addressOffset>
                    <resetValue>0x0000A002</resetValue>
                    <fields>
                        <field>
                            <name>SUFFIX</name>
                            <description>The command suffix bits following the address, if Mx_WFMT_SUFFIX_LEN is nonzero.</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PREFIX</name>
                            <description>The command prefix bits to prepend on each new transfer, if Mx_WFMT_PREFIX_LEN is nonzero.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ATRANS0</name>
                    <description>Configure address translation for XIP virtual addresses 0x000000 through 0x3fffff (a 4 MiB window starting at +0 MiB).

                        Address translation allows a program image to be executed in place at multiple physical flash addresses (for example, a double-buffered flash image for over-the-air updates), without the overhead of position-independent code.

                        At reset, the address translation registers are initialised to an identity mapping, so that they can be ignored if address translation is not required.

                        Note that the XIP cache is fully virtually addressed, so a cache flush is required after changing the address translation.</description>
                    <addressOffset>0x34</addressOffset>
                    <resetValue>0x04000000</resetValue>
                    <fields>
                        <field>
                            <name>SIZE</name>
                            <description>Translation aperture size for this virtual address range, in units of 4 kiB (one flash sector).

                                Bits 21:12 of the virtual address are compared to SIZE. Offsets greater than SIZE return a bus error, and do not cause a QSPI access.</description>
                            <bitRange>[26:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BASE</name>
                            <description>Physical address base for this virtual address range, in units of 4 kiB (one flash sector).

                                Taking a 24-bit virtual address, firstly bits 23:22 (the two MSBs) are masked to zero, and then BASE is added to bits 23:12 (the upper 12 bits) to form the physical address. Translation wraps on a 16 MiB boundary.</description>
                            <bitRange>[11:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ATRANS1</name>
                    <description>Configure address translation for XIP virtual addresses 0x400000 through 0x7fffff (a 4 MiB window starting at +4 MiB).

                        Address translation allows a program image to be executed in place at multiple physical flash addresses (for example, a double-buffered flash image for over-the-air updates), without the overhead of position-independent code.

                        At reset, the address translation registers are initialised to an identity mapping, so that they can be ignored if address translation is not required.

                        Note that the XIP cache is fully virtually addressed, so a cache flush is required after changing the address translation.</description>
                    <addressOffset>0x38</addressOffset>
                    <resetValue>0x04000400</resetValue>
                    <fields>
                        <field>
                            <name>SIZE</name>
                            <description>Translation aperture size for this virtual address range, in units of 4 kiB (one flash sector).

                                Bits 21:12 of the virtual address are compared to SIZE. Offsets greater than SIZE return a bus error, and do not cause a QSPI access.</description>
                            <bitRange>[26:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BASE</name>
                            <description>Physical address base for this virtual address range, in units of 4 kiB (one flash sector).

                                Taking a 24-bit virtual address, firstly bits 23:22 (the two MSBs) are masked to zero, and then BASE is added to bits 23:12 (the upper 12 bits) to form the physical address. Translation wraps on a 16 MiB boundary.</description>
                            <bitRange>[11:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ATRANS2</name>
                    <description>Configure address translation for XIP virtual addresses 0x800000 through 0xbfffff (a 4 MiB window starting at +8 MiB).

                        Address translation allows a program image to be executed in place at multiple physical flash addresses (for example, a double-buffered flash image for over-the-air updates), without the overhead of position-independent code.

                        At reset, the address translation registers are initialised to an identity mapping, so that they can be ignored if address translation is not required.

                        Note that the XIP cache is fully virtually addressed, so a cache flush is required after changing the address translation.</description>
                    <addressOffset>0x3C</addressOffset>
                    <resetValue>0x04000800</resetValue>
                    <fields>
                        <field>
                            <name>SIZE</name>
                            <description>Translation aperture size for this virtual address range, in units of 4 kiB (one flash sector).

                                Bits 21:12 of the virtual address are compared to SIZE. Offsets greater than SIZE return a bus error, and do not cause a QSPI access.</description>
                            <bitRange>[26:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BASE</name>
                            <description>Physical address base for this virtual address range, in units of 4 kiB (one flash sector).

                                Taking a 24-bit virtual address, firstly bits 23:22 (the two MSBs) are masked to zero, and then BASE is added to bits 23:12 (the upper 12 bits) to form the physical address. Translation wraps on a 16 MiB boundary.</description>
                            <bitRange>[11:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ATRANS3</name>
                    <description>Configure address translation for XIP virtual addresses 0xc00000 through 0xffffff (a 4 MiB window starting at +12 MiB).

                        Address translation allows a program image to be executed in place at multiple physical flash addresses (for example, a double-buffered flash image for over-the-air updates), without the overhead of position-independent code.

                        At reset, the address translation registers are initialised to an identity mapping, so that they can be ignored if address translation is not required.

                        Note that the XIP cache is fully virtually addressed, so a cache flush is required after changing the address translation.</description>
                    <addressOffset>0x40</addressOffset>
                    <resetValue>0x04000C00</resetValue>
                    <fields>
                        <field>
                            <name>SIZE</name>
                            <description>Translation aperture size for this virtual address range, in units of 4 kiB (one flash sector).

                                Bits 21:12 of the virtual address are compared to SIZE. Offsets greater than SIZE return a bus error, and do not cause a QSPI access.</description>
                            <bitRange>[26:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BASE</name>
                            <description>Physical address base for this virtual address range, in units of 4 kiB (one flash sector).

                                Taking a 24-bit virtual address, firstly bits 23:22 (the two MSBs) are masked to zero, and then BASE is added to bits 23:12 (the upper 12 bits) to form the physical address. Translation wraps on a 16 MiB boundary.</description>
                            <bitRange>[11:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ATRANS4</name>
                    <description>Configure address translation for XIP virtual addresses 0x1000000 through 0x13fffff (a 4 MiB window starting at +16 MiB).

                        Address translation allows a program image to be executed in place at multiple physical flash addresses (for example, a double-buffered flash image for over-the-air updates), without the overhead of position-independent code.

                        At reset, the address translation registers are initialised to an identity mapping, so that they can be ignored if address translation is not required.

                        Note that the XIP cache is fully virtually addressed, so a cache flush is required after changing the address translation.</description>
                    <addressOffset>0x44</addressOffset>
                    <resetValue>0x04000000</resetValue>
                    <fields>
                        <field>
                            <name>SIZE</name>
                            <description>Translation aperture size for this virtual address range, in units of 4 kiB (one flash sector).

                                Bits 21:12 of the virtual address are compared to SIZE. Offsets greater than SIZE return a bus error, and do not cause a QSPI access.</description>
                            <bitRange>[26:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BASE</name>
                            <description>Physical address base for this virtual address range, in units of 4 kiB (one flash sector).

                                Taking a 24-bit virtual address, firstly bits 23:22 (the two MSBs) are masked to zero, and then BASE is added to bits 23:12 (the upper 12 bits) to form the physical address. Translation wraps on a 16 MiB boundary.</description>
                            <bitRange>[11:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ATRANS5</name>
                    <description>Configure address translation for XIP virtual addresses 0x1400000 through 0x17fffff (a 4 MiB window starting at +20 MiB).

                        Address translation allows a program image to be executed in place at multiple physical flash addresses (for example, a double-buffered flash image for over-the-air updates), without the overhead of position-independent code.

                        At reset, the address translation registers are initialised to an identity mapping, so that they can be ignored if address translation is not required.

                        Note that the XIP cache is fully virtually addressed, so a cache flush is required after changing the address translation.</description>
                    <addressOffset>0x48</addressOffset>
                    <resetValue>0x04000400</resetValue>
                    <fields>
                        <field>
                            <name>SIZE</name>
                            <description>Translation aperture size for this virtual address range, in units of 4 kiB (one flash sector).

                                Bits 21:12 of the virtual address are compared to SIZE. Offsets greater than SIZE return a bus error, and do not cause a QSPI access.</description>
                            <bitRange>[26:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BASE</name>
                            <description>Physical address base for this virtual address range, in units of 4 kiB (one flash sector).

                                Taking a 24-bit virtual address, firstly bits 23:22 (the two MSBs) are masked to zero, and then BASE is added to bits 23:12 (the upper 12 bits) to form the physical address. Translation wraps on a 16 MiB boundary.</description>
                            <bitRange>[11:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ATRANS6</name>
                    <description>Configure address translation for XIP virtual addresses 0x1800000 through 0x1bfffff (a 4 MiB window starting at +24 MiB).

                        Address translation allows a program image to be executed in place at multiple physical flash addresses (for example, a double-buffered flash image for over-the-air updates), without the overhead of position-independent code.

                        At reset, the address translation registers are initialised to an identity mapping, so that they can be ignored if address translation is not required.

                        Note that the XIP cache is fully virtually addressed, so a cache flush is required after changing the address translation.</description>
                    <addressOffset>0x4C</addressOffset>
                    <resetValue>0x04000800</resetValue>
                    <fields>
                        <field>
                            <name>SIZE</name>
                            <description>Translation aperture size for this virtual address range, in units of 4 kiB (one flash sector).

                                Bits 21:12 of the virtual address are compared to SIZE. Offsets greater than SIZE return a bus error, and do not cause a QSPI access.</description>
                            <bitRange>[26:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BASE</name>
                            <description>Physical address base for this virtual address range, in units of 4 kiB (one flash sector).

                                Taking a 24-bit virtual address, firstly bits 23:22 (the two MSBs) are masked to zero, and then BASE is added to bits 23:12 (the upper 12 bits) to form the physical address. Translation wraps on a 16 MiB boundary.</description>
                            <bitRange>[11:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ATRANS7</name>
                    <description>Configure address translation for XIP virtual addresses 0x1c00000 through 0x1ffffff (a 4 MiB window starting at +28 MiB).

                        Address translation allows a program image to be executed in place at multiple physical flash addresses (for example, a double-buffered flash image for over-the-air updates), without the overhead of position-independent code.

                        At reset, the address translation registers are initialised to an identity mapping, so that they can be ignored if address translation is not required.

                        Note that the XIP cache is fully virtually addressed, so a cache flush is required after changing the address translation.</description>
                    <addressOffset>0x50</addressOffset>
                    <resetValue>0x04000C00</resetValue>
                    <fields>
                        <field>
                            <name>SIZE</name>
                            <description>Translation aperture size for this virtual address range, in units of 4 kiB (one flash sector).

                                Bits 21:12 of the virtual address are compared to SIZE. Offsets greater than SIZE return a bus error, and do not cause a QSPI access.</description>
                            <bitRange>[26:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BASE</name>
                            <description>Physical address base for this virtual address range, in units of 4 kiB (one flash sector).

                                Taking a 24-bit virtual address, firstly bits 23:22 (the two MSBs) are masked to zero, and then BASE is added to bits 23:12 (the upper 12 bits) to form the physical address. Translation wraps on a 16 MiB boundary.</description>
                            <bitRange>[11:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>XIP_CTRL</name>
            <description>QSPI flash execute-in-place block</description>
            <baseAddress>0x400C8000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x20</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>CTRL</name>
                    <description>Cache control register. Read-only from a Non-secure context.</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000083</resetValue>
                    <fields>
                        <field>
                            <name>WRITABLE_M1</name>
                            <description>If 1, enable writes to XIP memory window 1 (addresses 0x11000000 through 0x11ffffff, and their uncached mirrors). If 0, this region is read-only.

                                XIP memory is *read-only by default*. This bit must be set to enable writes if a RAM device is attached on QSPI chip select 1.

                                The default read-only behaviour avoids two issues with writing to a read-only QSPI device (e.g. flash). First, a write will initially appear to succeed due to caching, but the data will eventually be lost when the written line is evicted, causing unpredictable behaviour.

                                Second, when a written line is evicted, it will cause a write command to be issued to the flash, which can break the flash out of its continuous read mode. After this point, flash reads will return garbage. This is a security concern, as it allows Non-secure software to break Secure flash reads if it has permission to write to any flash address.

                                Note the read-only behaviour is implemented by downgrading writes to reads, so writes will still cause allocation of an address, but have no other effect.</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>WRITABLE_M0</name>
                            <description>If 1, enable writes to XIP memory window 0 (addresses 0x10000000 through 0x10ffffff, and their uncached mirrors). If 0, this region is read-only.

                                XIP memory is *read-only by default*. This bit must be set to enable writes if a RAM device is attached on QSPI chip select 0.

                                The default read-only behaviour avoids two issues with writing to a read-only QSPI device (e.g. flash). First, a write will initially appear to succeed due to caching, but the data will eventually be lost when the written line is evicted, causing unpredictable behaviour.

                                Second, when a written line is evicted, it will cause a write command to be issued to the flash, which can break the flash out of its continuous read mode. After this point, flash reads will return garbage. This is a security concern, as it allows Non-secure software to break Secure flash reads if it has permission to write to any flash address.

                                Note the read-only behaviour is implemented by downgrading writes to reads, so writes will still cause allocation of an address, but have no other effect.</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SPLIT_WAYS</name>
                            <description>When 1, route all cached+Secure accesses to way 0 of the cache, and route all cached+Non-secure accesses to way 1 of the cache.

                                This partitions the cache into two half-sized direct-mapped regions, such that Non-secure code can not observe cache line state changes caused by Secure execution.

                                A full cache flush is required when changing the value of SPLIT_WAYS. The flush should be performed whilst SPLIT_WAYS is 0, so that both cache ways are accessible for invalidation.</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MAINT_NONSEC</name>
                            <description>When 0, Non-secure accesses to the cache maintenance address window (addr[27] == 1, addr[26] == 0) will generate a bus error. When 1, Non-secure accesses can perform cache maintenance operations by writing to the cache maintenance address window.

                                Cache maintenance operations may be used to corrupt Secure data by invalidating cache lines inappropriately, or map Secure content into a Non-secure region by pinning cache lines. Therefore this bit should generally be set to 0, unless Secure code is not using the cache.

                                Care should also be taken to clear the cache data memory and tag memory before granting maintenance operations to Non-secure code.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NO_UNTRANSLATED_NONSEC</name>
                            <description>When 1, Non-secure accesses to the uncached, untranslated window (addr[27:26] == 3) will generate a bus error.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NO_UNTRANSLATED_SEC</name>
                            <description>When 1, Secure accesses to the uncached, untranslated window (addr[27:26] == 3) will generate a bus error.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NO_UNCACHED_NONSEC</name>
                            <description>When 1, Non-secure accesses to the uncached window (addr[27:26] == 1) will generate a bus error. This may reduce the number of SAU/MPU/PMP regions required to protect flash contents.

                                Note this does not disable access to the uncached, untranslated window -- see NO_UNTRANSLATED_SEC.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NO_UNCACHED_SEC</name>
                            <description>When 1, Secure accesses to the uncached window (addr[27:26] == 1) will generate a bus error. This may reduce the number of SAU/MPU/PMP regions required to protect flash contents.

                                Note this does not disable access to the uncached, untranslated window -- see NO_UNTRANSLATED_SEC.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>POWER_DOWN</name>
                            <description>When 1, the cache memories are powered down. They retain state, but can not be accessed. This reduces static power dissipation. Writing 1 to this bit forces CTRL_EN_SECURE and CTRL_EN_NONSECURE to 0, i.e. the cache cannot be enabled when powered down.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN_NONSECURE</name>
                            <description>When 1, enable the cache for Non-secure accesses. When enabled, Non-secure XIP accesses to the cached (addr[26] == 0) window will query the cache, and QSPI accesses are performed only if the requested data is not present. When disabled, Secure access ignore the cache contents, and always access the QSPI interface.

                                Accesses to the uncached (addr[26] == 1) window will never query the cache, irrespective of this bit.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN_SECURE</name>
                            <description>When 1, enable the cache for Secure accesses. When enabled, Secure XIP accesses to the cached (addr[26] == 0) window will query the cache, and QSPI accesses are performed only if the requested data is not present. When disabled, Secure access ignore the cache contents, and always access the QSPI interface.

                                Accesses to the uncached (addr[26] == 1) window will never query the cache, irrespective of this bit.

                                There is no cache-as-SRAM address window. Cache lines are allocated for SRAM-like use by individually pinning them, and keeping the cache enabled.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>STAT</name>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000002</resetValue>
                    <fields>
                        <field>
                            <name>FIFO_FULL</name>
                            <description>When 1, indicates the XIP streaming FIFO is completely full.
                                The streaming FIFO is 2 entries deep, so the full and empty
                                flag allow its level to be ascertained.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FIFO_EMPTY</name>
                            <description>When 1, indicates the XIP streaming FIFO is completely empty.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTR_HIT</name>
                    <description>Cache Hit counter</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CTR_HIT</name>
                            <description>A 32 bit saturating counter that increments upon each cache hit,
                                i.e. when an XIP access is serviced directly from cached data.
                                Write any value to clear.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CTR_ACC</name>
                    <description>Cache Access counter</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CTR_ACC</name>
                            <description>A 32 bit saturating counter that increments upon each XIP access,
                                whether the cache is hit or not. This includes noncacheable accesses.
                                Write any value to clear.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>STREAM_ADDR</name>
                    <description>FIFO stream address</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STREAM_ADDR</name>
                            <description>The address of the next word to be streamed from flash to the streaming FIFO.
                                Increments automatically after each flash access.
                                Write the initial access address here before starting a streaming read.</description>
                            <bitRange>[31:2]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>STREAM_CTR</name>
                    <description>FIFO stream control</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STREAM_CTR</name>
                            <description>Write a nonzero value to start a streaming read. This will then
                                progress in the background, using flash idle cycles to transfer
                                a linear data block from flash to the streaming FIFO.
                                Decrements automatically (1 at a time) as the stream
                                progresses, and halts on reaching 0.
                                Write 0 to halt an in-progress stream, and discard any in-flight
                                read, so that a new stream can immediately be started (after
                                draining the FIFO and reinitialising STREAM_ADDR)</description>
                            <bitRange>[21:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>STREAM_FIFO</name>
                    <description>FIFO stream data</description>
                    <addressOffset>0x1C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STREAM_FIFO</name>
                            <description>Streamed data is buffered here, for retrieval by the system DMA.
                                This FIFO can also be accessed via the XIP_AUX slave, to avoid exposing
                                the DMA to bus stalls caused by other XIP traffic.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>XIP_AUX</name>
            <description>Auxiliary DMA access to XIP FIFOs, via fast AHB bus access</description>
            <baseAddress>0x50500000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0xC</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>STREAM</name>
                    <description>Read the XIP stream FIFO (fast bus access to XIP_CTRL_STREAM_FIFO)</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STREAM</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>QMI_DIRECT_TX</name>
                    <description>Write to the QMI direct-mode TX FIFO (fast bus access to QMI_DIRECT_TX)</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NOPUSH</name>
                            <description>Inhibit the RX FIFO push that would correspond to this TX FIFO entry.

                                Useful to avoid garbage appearing in the RX FIFO when pushing the command at the beginning of a SPI transfer.</description>
                            <bitRange>[20:20]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>OE</name>
                            <description>Output enable (active-high). For single width (SPI), this field is ignored, and SD0 is always set to output, with SD1 always set to input.

                                For dual and quad width (DSPI/QSPI), this sets whether the relevant SDx pads are set to output whilst transferring this FIFO record. In this case the command/address should have OE set, and the data transfer should have OE set or clear depending on the direction of the transfer.</description>
                            <bitRange>[19:19]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>DWIDTH</name>
                            <description>Data width. If 0, hardware will transmit the 8 LSBs of the DIRECT_TX DATA field, and return an 8-bit value in the 8 LSBs of DIRECT_RX. If 1, the full 16-bit width is used. 8-bit and 16-bit transfers can be mixed freely.</description>
                            <bitRange>[18:18]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>IWIDTH</name>
                            <description>Configure whether this FIFO record is transferred with single/dual/quad interface width (0/1/2). Different widths can be mixed freely.</description>
                            <bitRange>[17:16]</bitRange>
                            <access>write-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>S</name>
                                    <description>Single width</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>D</name>
                                    <description>Dual width</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Q</name>
                                    <description>Quad width</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DATA</name>
                            <description>Data pushed here will be clocked out falling edges of SCK (or before the very first rising edge of SCK, if this is the first pulse). For each byte clocked out, the interface will simultaneously sample one byte, on rising edges of SCK, and push this to the DIRECT_RX FIFO.

                                For 16-bit data, the least-significant byte is transmitted first.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>QMI_DIRECT_RX</name>
                    <description>Read from the QMI direct-mode RX FIFO (fast bus access to QMI_DIRECT_RX)</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>QMI_DIRECT_RX</name>
                            <description>With each byte clocked out on the serial interface, one byte will simultaneously be clocked in, and will appear in this FIFO. The serial interface will stall when this FIFO is full, to avoid dropping data.

                                When 16-bit data is pushed into the TX FIFO, the corresponding RX FIFO push will also contain 16 bits of data. The least-significant byte is the first one received.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>SYSCFG</name>
            <description>Register block for various chip control signals</description>
            <baseAddress>0x40008000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x18</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>PROC_CONFIG</name>
                    <description>Configuration for processors</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PROC1_HALTED</name>
                            <description>Indication that proc1 has halted</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PROC0_HALTED</name>
                            <description>Indication that proc0 has halted</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PROC_IN_SYNC_BYPASS</name>
                    <description>For each bit, if 1, bypass the input synchronizer between that GPIO
                        and the GPIO input register in the SIO. The input synchronizers should
                        generally be unbypassed, to avoid injecting metastabilities into processors.
                        If you're feeling brave, you can bypass to save two cycles of input
                        latency. This register applies to GPIO 0...31.</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PROC_IN_SYNC_BYPASS_HI</name>
                    <description>For each bit, if 1, bypass the input synchronizer between that GPIO
                        and the GPIO input register in the SIO. The input synchronizers should
                        generally be unbypassed, to avoid injecting metastabilities into processors.
                        If you're feeling brave, you can bypass to save two cycles of input
                        latency. This register applies to GPIO 32...47. USB GPIO 56..57 QSPI GPIO 58..63</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>QSPI_SD</name>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>QSPI_CSN</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>QSPI_SCK</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USB_DM</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USB_DP</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DBGFORCE</name>
                    <description>Directly control the chip SWD debug port</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00000006</resetValue>
                    <fields>
                        <field>
                            <name>ATTACH</name>
                            <description>Attach chip debug port to syscfg controls, and disconnect it from external SWD pads.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SWCLK</name>
                            <description>Directly drive SWCLK, if ATTACH is set</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SWDI</name>
                            <description>Directly drive SWDIO input, if ATTACH is set</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SWDO</name>
                            <description>Observe the value of SWDIO output.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MEMPOWERDOWN</name>
                    <description>Control PD pins to memories.
                        Set high to put memories to a low power state. In this state the memories will retain contents but not be accessible
                        Use with caution</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BOOTRAM</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ROM</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USB</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM9</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM8</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM7</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM6</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM5</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM4</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SRAM0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>AUXCTRL</name>
                    <description>Auxiliary system control register</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>AUXCTRL</name>
                            <description>* Bits 7:2: Reserved

                                * Bit 1: When clear, the LPOSC output is XORed into the TRNG ROSC output as an additional, uncorrelated entropy source. When set, this behaviour is disabled.

                                * Bit 0: Force POWMAN clock to switch to LPOSC, by asserting its WDRESET input. This must be set before initiating a watchdog reset of the RSM from a stage that includes CLOCKS, if POWMAN is running from clk_ref at the point that the watchdog reset takes place. Otherwise, the short pulse generated on clk_ref by the reset of the CLOCKS block may affect POWMAN register state.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>XOSC</name>
            <description>Controls the crystal oscillator</description>
            <baseAddress>0x40048000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x14</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>CTRL</name>
                    <description>Crystal Oscillator Control</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ENABLE</name>
                            <description>On power-up this field is initialised to DISABLE and the chip runs from the ROSC.
                                If the chip has subsequently been programmed to run from the XOSC then setting this field to DISABLE may lock-up the chip. If  this is a concern then run the clk_ref from the ROSC and enable the clk_sys RESUS feature.
                                The 12-bit code is intended to give some protection against accidental writes. An invalid setting will retain the previous value. The actual value being used can be read from STATUS_ENABLED</description>
                            <bitRange>[23:12]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>DISABLE</name>
                                    <value>3358</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLE</name>
                                    <value>4011</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>FREQ_RANGE</name>
                            <description>The 12-bit code is intended to give some protection against accidental writes. An invalid setting will retain the previous value. The actual value being used can be read from STATUS_FREQ_RANGE</description>
                            <bitRange>[11:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>1_15MHZ</name>
                                    <value>2720</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>10_30MHZ</name>
                                    <value>2721</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>25_60MHZ</name>
                                    <value>2722</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>40_100MHZ</name>
                                    <value>2723</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>STATUS</name>
                    <description>Crystal Oscillator Status</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STABLE</name>
                            <description>Oscillator is running and stable</description>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BADWRITE</name>
                            <description>An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE or DORMANT</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>ENABLED</name>
                            <description>Oscillator is enabled but not necessarily running and stable, resets to 0</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FREQ_RANGE</name>
                            <description>The current frequency range setting</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>1_15MHZ</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>10_30MHZ</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>25_60MHZ</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>40_100MHZ</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DORMANT</name>
                    <description>Crystal Oscillator pause control</description>
                    <addressOffset>0x8</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>DORMANT</name>
                            <description>This is used to save power by pausing the XOSC
                                On power-up this field is initialised to WAKE
                                An invalid write will also select WAKE
                                Warning: stop the PLLs before selecting dormant mode
                                Warning: setup the irq before selecting dormant mode</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>dormant</name>
                                    <value>1668246881</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>WAKE</name>
                                    <value>2002873189</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>STARTUP</name>
                    <description>Controls the startup delay</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>X4</name>
                            <description>Multiplies the startup_delay by 4, just in case. The reset value is controlled by a mask-programmable tiecell and is provided in case we are booting from XOSC and the default startup delay is insufficient. The reset value is 0x0.</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DELAY</name>
                            <description>in multiples of 256*xtal_period. The reset value of 0xc4 corresponds to approx 50 000 cycles.</description>
                            <bitRange>[13:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>COUNT</name>
                    <description>A down counter running at the xosc frequency which counts to zero and stops.
                        Can be used for short software pauses when setting up time sensitive hardware.
                        To start the counter, write a non-zero value. Reads will return 1 while the count is running and 0 when it has finished.
                        Minimum count value is 4. Count values &lt;4 will be treated as count value =4.
                        Note that synchronisation to the register clock domain costs 2 register clock cycles and the counter cannot compensate for that.</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>COUNT</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>PLL_SYS</name>
            <baseAddress>0x40050000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x20</size>
                <usage>registers</usage>
            </addressBlock>
            <interrupt>
                <name>PLL_SYS_IRQ</name>
                <value>42</value>
            </interrupt>
            <registers>
                <register>
                    <name>CS</name>
                    <description>Control and Status
                        GENERAL CONSTRAINTS:
                        Reference clock frequency min=5MHz, max=800MHz
                        Feedback divider min=16, max=320
                        VCO frequency min=750MHz, max=1600MHz</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>LOCK</name>
                            <description>PLL is locked</description>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_N</name>
                            <description>PLL is not locked
                                Ideally this is cleared when PLL lock is seen and this should never normally be set</description>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>BYPASS</name>
                            <description>Passes the reference clock to the output instead of the divided VCO. The VCO continues to run so the user can switch between the reference clock and the divided VCO but the output will glitch when doing so.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>REFDIV</name>
                            <description>Divides the PLL input reference clock.
                                Behaviour is undefined for div=0.
                                PLL output will be unpredictable during refdiv changes, wait for lock=1 before using it.</description>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PWR</name>
                    <description>Controls the PLL power modes.</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x0000002D</resetValue>
                    <fields>
                        <field>
                            <name>VCOPD</name>
                            <description>PLL VCO powerdown
                                To save power set high when PLL output not required or bypass=1.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>POSTDIVPD</name>
                            <description>PLL post divider powerdown
                                To save power set high when PLL output not required or bypass=1.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DSMPD</name>
                            <description>PLL DSM powerdown
                                Nothing is achieved by setting this low.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PD</name>
                            <description>PLL powerdown
                                To save power set high when PLL output not required.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FBDIV_INT</name>
                    <description>Feedback divisor
                        (note: this PLL does not support fractional division)</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FBDIV_INT</name>
                            <description>see ctrl reg description for constraints</description>
                            <bitRange>[11:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PRIM</name>
                    <description>Controls the PLL post dividers for the primary output
                        (note: this PLL does not have a secondary output)
                        the primary output is driven from VCO divided by postdiv1*postdiv2</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00077000</resetValue>
                    <fields>
                        <field>
                            <name>POSTDIV1</name>
                            <description>divide by 1-7</description>
                            <bitRange>[18:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>POSTDIV2</name>
                            <description>divide by 1-7</description>
                            <bitRange>[14:12]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTR</name>
                    <description>Raw Interrupts</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>LOCK_N_STICKY</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTE</name>
                    <description>Interrupt Enable</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>LOCK_N_STICKY</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTF</name>
                    <description>Interrupt Force</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>LOCK_N_STICKY</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTS</name>
                    <description>Interrupt status after masking &amp; forcing</description>
                    <addressOffset>0x1C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>LOCK_N_STICKY</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral derivedFrom="PLL_SYS">
            <name>PLL_USB</name>
            <baseAddress>0x40058000</baseAddress>
            <interrupt>
                <name>PLL_USB_IRQ</name>
                <value>43</value>
            </interrupt>
        </peripheral>
        <peripheral>
            <name>ACCESSCTRL</name>
            <description>Hardware access control registers</description>
            <baseAddress>0x40060000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0xEC</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>LOCK</name>
                    <description>Once a LOCK bit is written to 1, ACCESSCTRL silently ignores writes from that master. LOCK is writable only by a Secure, Privileged processor or debugger.

                        LOCK bits are only writable when their value is zero. Once set, they can never be cleared, except by a full reset of ACCESSCTRL

                        Setting the LOCK bit does not affect whether an access raises a bus error. Unprivileged writes, or writes from the DMA, will continue to raise bus errors. All other accesses will continue not to.</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000004</resetValue>
                    <fields>
                        <field>
                            <name>DEBUG</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FORCE_CORE_NS</name>
                    <description>Force core 1's bus accesses to always be Non-secure, no matter the core's internal state.

                        Useful for schemes where one core is designated as the Non-secure core, since some peripherals may filter individual registers internally based on security state but not on master ID.</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CORE1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CFGRESET</name>
                    <description>Write 1 to reset all ACCESSCTRL configuration, except for the LOCK and FORCE_CORE_NS registers.

                        This bit is used in the RP2350 bootrom to quickly restore ACCESSCTRL to a known state during the boot path.

                        Note that, like all registers in ACCESSCTRL, this register is not writable when the writer's corresponding LOCK bit is set, therefore a master which has been locked out of ACCESSCTRL can not use the CFGRESET register to disturb its contents.</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CFGRESET</name>
                            <bitRange>[0:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_NSMASK0</name>
                    <description>Control whether GPIO0...31 are accessible to Non-secure code. Writable only by a Secure, Privileged processor or debugger.

                        0 -&gt; Secure access only

                        1 -&gt; Secure + Non-secure access</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_NSMASK0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_NSMASK1</name>
                    <description>Control whether GPIO32..47 are accessible to Non-secure code, and whether QSPI and USB bitbang are accessible through the Non-secure SIO. Writable only by a Secure, Privileged processor or debugger.</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>QSPI_SD</name>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>QSPI_CSN</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>QSPI_SCK</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USB_DM</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USB_DP</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ROM</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access ROM, and at what security/privilege levels they can do so.

                        Defaults to fully open access.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x000000FF</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, ROM can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, ROM can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, ROM can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, ROM can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, ROM can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, ROM can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, ROM can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, ROM can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>XIP_MAIN</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access XIP_MAIN, and at what security/privilege levels they can do so.

                        Defaults to fully open access.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x000000FF</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, XIP_MAIN can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, XIP_MAIN can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, XIP_MAIN can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, XIP_MAIN can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, XIP_MAIN can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, XIP_MAIN can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, XIP_MAIN can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, XIP_MAIN can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SRAM0</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access SRAM0, and at what security/privilege levels they can do so.

                        Defaults to fully open access.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x1C</addressOffset>
                    <resetValue>0x000000FF</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, SRAM0 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, SRAM0 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, SRAM0 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, SRAM0 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, SRAM0 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, SRAM0 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, SRAM0 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, SRAM0 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SRAM1</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access SRAM1, and at what security/privilege levels they can do so.

                        Defaults to fully open access.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x20</addressOffset>
                    <resetValue>0x000000FF</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, SRAM1 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, SRAM1 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, SRAM1 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, SRAM1 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, SRAM1 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, SRAM1 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, SRAM1 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, SRAM1 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SRAM2</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access SRAM2, and at what security/privilege levels they can do so.

                        Defaults to fully open access.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x24</addressOffset>
                    <resetValue>0x000000FF</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, SRAM2 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, SRAM2 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, SRAM2 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, SRAM2 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, SRAM2 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, SRAM2 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, SRAM2 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, SRAM2 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SRAM3</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access SRAM3, and at what security/privilege levels they can do so.

                        Defaults to fully open access.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x28</addressOffset>
                    <resetValue>0x000000FF</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, SRAM3 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, SRAM3 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, SRAM3 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, SRAM3 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, SRAM3 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, SRAM3 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, SRAM3 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, SRAM3 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SRAM4</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access SRAM4, and at what security/privilege levels they can do so.

                        Defaults to fully open access.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x2C</addressOffset>
                    <resetValue>0x000000FF</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, SRAM4 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, SRAM4 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, SRAM4 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, SRAM4 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, SRAM4 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, SRAM4 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, SRAM4 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, SRAM4 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SRAM5</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access SRAM5, and at what security/privilege levels they can do so.

                        Defaults to fully open access.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x30</addressOffset>
                    <resetValue>0x000000FF</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, SRAM5 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, SRAM5 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, SRAM5 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, SRAM5 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, SRAM5 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, SRAM5 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, SRAM5 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, SRAM5 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SRAM6</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access SRAM6, and at what security/privilege levels they can do so.

                        Defaults to fully open access.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x34</addressOffset>
                    <resetValue>0x000000FF</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, SRAM6 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, SRAM6 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, SRAM6 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, SRAM6 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, SRAM6 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, SRAM6 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, SRAM6 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, SRAM6 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SRAM7</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access SRAM7, and at what security/privilege levels they can do so.

                        Defaults to fully open access.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x38</addressOffset>
                    <resetValue>0x000000FF</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, SRAM7 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, SRAM7 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, SRAM7 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, SRAM7 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, SRAM7 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, SRAM7 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, SRAM7 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, SRAM7 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SRAM8</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access SRAM8, and at what security/privilege levels they can do so.

                        Defaults to fully open access.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x3C</addressOffset>
                    <resetValue>0x000000FF</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, SRAM8 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, SRAM8 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, SRAM8 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, SRAM8 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, SRAM8 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, SRAM8 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, SRAM8 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, SRAM8 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SRAM9</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access SRAM9, and at what security/privilege levels they can do so.

                        Defaults to fully open access.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x40</addressOffset>
                    <resetValue>0x000000FF</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, SRAM9 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, SRAM9 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, SRAM9 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, SRAM9 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, SRAM9 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, SRAM9 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, SRAM9 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, SRAM9 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DMA</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access DMA, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x44</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, DMA can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, DMA can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, DMA can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, DMA can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, DMA can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, DMA can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, DMA can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, DMA can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>USBCTRL</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access USBCTRL, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x48</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, USBCTRL can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, USBCTRL can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, USBCTRL can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, USBCTRL can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, USBCTRL can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, USBCTRL can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, USBCTRL can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, USBCTRL can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PIO0</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access PIO0, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x4C</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, PIO0 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, PIO0 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, PIO0 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, PIO0 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, PIO0 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, PIO0 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, PIO0 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, PIO0 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PIO1</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access PIO1, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x50</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, PIO1 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, PIO1 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, PIO1 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, PIO1 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, PIO1 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, PIO1 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, PIO1 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, PIO1 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PIO2</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access PIO2, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x54</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, PIO2 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, PIO2 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, PIO2 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, PIO2 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, PIO2 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, PIO2 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, PIO2 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, PIO2 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CORESIGHT_TRACE</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access CORESIGHT_TRACE, and at what security/privilege levels they can do so.

                        Defaults to Secure, Privileged processor or debug access only.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x58</addressOffset>
                    <resetValue>0x000000B8</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, CORESIGHT_TRACE can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, CORESIGHT_TRACE can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, CORESIGHT_TRACE can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, CORESIGHT_TRACE can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, CORESIGHT_TRACE can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, CORESIGHT_TRACE can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, CORESIGHT_TRACE can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, CORESIGHT_TRACE can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CORESIGHT_PERIPH</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access CORESIGHT_PERIPH, and at what security/privilege levels they can do so.

                        Defaults to Secure, Privileged processor or debug access only.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x5C</addressOffset>
                    <resetValue>0x000000B8</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, CORESIGHT_PERIPH can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, CORESIGHT_PERIPH can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, CORESIGHT_PERIPH can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, CORESIGHT_PERIPH can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, CORESIGHT_PERIPH can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, CORESIGHT_PERIPH can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, CORESIGHT_PERIPH can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, CORESIGHT_PERIPH can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SYSINFO</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access SYSINFO, and at what security/privilege levels they can do so.

                        Defaults to fully open access.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x60</addressOffset>
                    <resetValue>0x000000FF</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, SYSINFO can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, SYSINFO can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, SYSINFO can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, SYSINFO can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, SYSINFO can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, SYSINFO can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, SYSINFO can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, SYSINFO can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RESETS</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access RESETS, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x64</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, RESETS can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, RESETS can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, RESETS can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, RESETS can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, RESETS can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, RESETS can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, RESETS can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, RESETS can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IO_BANK0</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access IO_BANK0, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x68</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, IO_BANK0 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, IO_BANK0 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, IO_BANK0 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, IO_BANK0 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, IO_BANK0 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, IO_BANK0 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, IO_BANK0 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, IO_BANK0 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IO_BANK1</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access IO_BANK1, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x6C</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, IO_BANK1 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, IO_BANK1 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, IO_BANK1 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, IO_BANK1 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, IO_BANK1 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, IO_BANK1 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, IO_BANK1 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, IO_BANK1 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PADS_BANK0</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access PADS_BANK0, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x70</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, PADS_BANK0 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, PADS_BANK0 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, PADS_BANK0 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, PADS_BANK0 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, PADS_BANK0 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, PADS_BANK0 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, PADS_BANK0 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, PADS_BANK0 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PADS_QSPI</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access PADS_QSPI, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x74</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, PADS_QSPI can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, PADS_QSPI can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, PADS_QSPI can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, PADS_QSPI can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, PADS_QSPI can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, PADS_QSPI can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, PADS_QSPI can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, PADS_QSPI can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BUSCTRL</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access BUSCTRL, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x78</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, BUSCTRL can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, BUSCTRL can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, BUSCTRL can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, BUSCTRL can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, BUSCTRL can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, BUSCTRL can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, BUSCTRL can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, BUSCTRL can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ADC0</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access ADC0, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x7C</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, ADC0 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, ADC0 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, ADC0 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, ADC0 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, ADC0 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, ADC0 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, ADC0 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, ADC0 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>HSTX</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access HSTX, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x80</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, HSTX can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, HSTX can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, HSTX can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, HSTX can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, HSTX can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, HSTX can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, HSTX can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, HSTX can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>I2C0</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access I2C0, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x84</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, I2C0 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, I2C0 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, I2C0 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, I2C0 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, I2C0 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, I2C0 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, I2C0 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, I2C0 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>I2C1</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access I2C1, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x88</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, I2C1 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, I2C1 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, I2C1 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, I2C1 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, I2C1 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, I2C1 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, I2C1 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, I2C1 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PWM</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access PWM, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x8C</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, PWM can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, PWM can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, PWM can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, PWM can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, PWM can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, PWM can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, PWM can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, PWM can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SPI0</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access SPI0, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x90</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, SPI0 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, SPI0 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, SPI0 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, SPI0 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, SPI0 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, SPI0 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, SPI0 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, SPI0 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SPI1</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access SPI1, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x94</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, SPI1 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, SPI1 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, SPI1 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, SPI1 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, SPI1 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, SPI1 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, SPI1 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, SPI1 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TIMER0</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access TIMER0, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x98</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, TIMER0 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, TIMER0 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, TIMER0 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, TIMER0 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, TIMER0 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, TIMER0 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, TIMER0 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, TIMER0 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TIMER1</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access TIMER1, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0x9C</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, TIMER1 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, TIMER1 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, TIMER1 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, TIMER1 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, TIMER1 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, TIMER1 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, TIMER1 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, TIMER1 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UART0</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access UART0, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xA0</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, UART0 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, UART0 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, UART0 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, UART0 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, UART0 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, UART0 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, UART0 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, UART0 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UART1</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access UART1, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xA4</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, UART1 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, UART1 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, UART1 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, UART1 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, UART1 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, UART1 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, UART1 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, UART1 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>OTP</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access OTP, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xA8</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, OTP can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, OTP can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, OTP can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, OTP can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, OTP can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, OTP can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, OTP can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, OTP can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TBMAN</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access TBMAN, and at what security/privilege levels they can do so.

                        Defaults to Secure access from any master.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xAC</addressOffset>
                    <resetValue>0x000000FC</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, TBMAN can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, TBMAN can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, TBMAN can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, TBMAN can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, TBMAN can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, TBMAN can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, TBMAN can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, TBMAN can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>POWMAN</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access POWMAN, and at what security/privilege levels they can do so.

                        Defaults to Secure, Privileged processor or debug access only.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xB0</addressOffset>
                    <resetValue>0x000000B8</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, POWMAN can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, POWMAN can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, POWMAN can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, POWMAN can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, POWMAN can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, POWMAN can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, POWMAN can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, POWMAN can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRNG</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access TRNG, and at what security/privilege levels they can do so.

                        Defaults to Secure, Privileged processor or debug access only.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xB4</addressOffset>
                    <resetValue>0x000000B8</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, TRNG can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, TRNG can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, TRNG can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, TRNG can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, TRNG can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, TRNG can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, TRNG can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, TRNG can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SHA256</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access SHA256, and at what security/privilege levels they can do so.

                        Defaults to Secure, Privileged access only.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xB8</addressOffset>
                    <resetValue>0x000000F8</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, SHA256 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, SHA256 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, SHA256 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, SHA256 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, SHA256 can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, SHA256 can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, SHA256 can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, SHA256 can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SYSCFG</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access SYSCFG, and at what security/privilege levels they can do so.

                        Defaults to Secure, Privileged processor or debug access only.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xBC</addressOffset>
                    <resetValue>0x000000B8</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, SYSCFG can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, SYSCFG can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, SYSCFG can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, SYSCFG can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, SYSCFG can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, SYSCFG can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, SYSCFG can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, SYSCFG can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CLOCKS</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access CLOCKS, and at what security/privilege levels they can do so.

                        Defaults to Secure, Privileged processor or debug access only.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xC0</addressOffset>
                    <resetValue>0x000000B8</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, CLOCKS can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, CLOCKS can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, CLOCKS can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, CLOCKS can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, CLOCKS can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, CLOCKS can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, CLOCKS can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, CLOCKS can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>XOSC</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access XOSC, and at what security/privilege levels they can do so.

                        Defaults to Secure, Privileged processor or debug access only.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xC4</addressOffset>
                    <resetValue>0x000000B8</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, XOSC can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, XOSC can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, XOSC can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, XOSC can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, XOSC can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, XOSC can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, XOSC can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, XOSC can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ROSC</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access ROSC, and at what security/privilege levels they can do so.

                        Defaults to Secure, Privileged processor or debug access only.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xC8</addressOffset>
                    <resetValue>0x000000B8</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, ROSC can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, ROSC can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, ROSC can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, ROSC can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, ROSC can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, ROSC can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, ROSC can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, ROSC can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PLL_SYS</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access PLL_SYS, and at what security/privilege levels they can do so.

                        Defaults to Secure, Privileged processor or debug access only.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xCC</addressOffset>
                    <resetValue>0x000000B8</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, PLL_SYS can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, PLL_SYS can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, PLL_SYS can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, PLL_SYS can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, PLL_SYS can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, PLL_SYS can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, PLL_SYS can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, PLL_SYS can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PLL_USB</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access PLL_USB, and at what security/privilege levels they can do so.

                        Defaults to Secure, Privileged processor or debug access only.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xD0</addressOffset>
                    <resetValue>0x000000B8</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, PLL_USB can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, PLL_USB can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, PLL_USB can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, PLL_USB can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, PLL_USB can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, PLL_USB can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, PLL_USB can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, PLL_USB can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TICKS</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access TICKS, and at what security/privilege levels they can do so.

                        Defaults to Secure, Privileged processor or debug access only.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xD4</addressOffset>
                    <resetValue>0x000000B8</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, TICKS can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, TICKS can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, TICKS can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, TICKS can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, TICKS can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, TICKS can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, TICKS can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, TICKS can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>WATCHDOG</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access WATCHDOG, and at what security/privilege levels they can do so.

                        Defaults to Secure, Privileged processor or debug access only.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xD8</addressOffset>
                    <resetValue>0x000000B8</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, WATCHDOG can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, WATCHDOG can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, WATCHDOG can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, WATCHDOG can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, WATCHDOG can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, WATCHDOG can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, WATCHDOG can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, WATCHDOG can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RSM</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access RSM, and at what security/privilege levels they can do so.

                        Defaults to Secure, Privileged processor or debug access only.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xDC</addressOffset>
                    <resetValue>0x000000B8</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, RSM can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, RSM can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, RSM can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, RSM can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, RSM can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, RSM can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, RSM can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, RSM can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>XIP_CTRL</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access XIP_CTRL, and at what security/privilege levels they can do so.

                        Defaults to Secure, Privileged processor or debug access only.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xE0</addressOffset>
                    <resetValue>0x000000B8</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, XIP_CTRL can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, XIP_CTRL can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, XIP_CTRL can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, XIP_CTRL can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, XIP_CTRL can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, XIP_CTRL can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, XIP_CTRL can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, XIP_CTRL can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>XIP_QMI</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access XIP_QMI, and at what security/privilege levels they can do so.

                        Defaults to Secure, Privileged processor or debug access only.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xE4</addressOffset>
                    <resetValue>0x000000B8</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, XIP_QMI can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, XIP_QMI can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, XIP_QMI can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, XIP_QMI can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, XIP_QMI can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, XIP_QMI can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, XIP_QMI can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, XIP_QMI can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>XIP_AUX</name>
                    <description>Control whether debugger, DMA, core 0 and core 1 can access XIP_AUX, and at what security/privilege levels they can do so.

                        Defaults to Secure, Privileged access only.

                        This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set.</description>
                    <addressOffset>0xE8</addressOffset>
                    <resetValue>0x000000F8</resetValue>
                    <fields>
                        <field>
                            <name>DBG</name>
                            <description>If 1, XIP_AUX can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA</name>
                            <description>If 1, XIP_AUX can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1</name>
                            <description>If 1, XIP_AUX can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>If 1, XIP_AUX can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SP</name>
                            <description>If 1, XIP_AUX can be accessed from a Secure, Privileged context.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SU</name>
                            <description>If 1, and SP is also set, XIP_AUX can be accessed from a Secure, Unprivileged context.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSP</name>
                            <description>If 1, XIP_AUX can be accessed from a Non-secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NSU</name>
                            <description>If 1, and NSP is also set, XIP_AUX can be accessed from a Non-secure, Unprivileged context.

                                This bit is writable from a Non-secure, Privileged context, if and only if the NSP bit is set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>UART0</name>
            <baseAddress>0x40070000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x1000</size>
                <usage>registers</usage>
            </addressBlock>
            <interrupt>
                <name>UART0_IRQ</name>
                <value>33</value>
            </interrupt>
            <registers>
                <register>
                    <name>UARTDR</name>
                    <description>Data Register, UARTDR</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>OE</name>
                            <description>Overrun error. This bit is set to 1 if data is received and the receive FIFO is already full. This is cleared to 0 once there is an empty space in the FIFO and a new character can be written to it.</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BE</name>
                            <description>Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop bits). In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state), and the next valid start bit is received.</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PE</name>
                            <description>Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. In FIFO mode, this error is associated with the character at the top of the FIFO.</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FE</name>
                            <description>Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). In FIFO mode, this error is associated with the character at the top of the FIFO.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DATA</name>
                            <description>Receive (read) data character. Transmit (write) data character.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTRSR</name>
                    <description>Receive Status Register/Error Clear Register, UARTRSR/UARTECR</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>OE</name>
                            <description>Overrun error. This bit is set to 1 if data is received and the FIFO is already full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must now read the data, to empty the FIFO.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>BE</name>
                            <description>Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity, and stop bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>PE</name>
                            <description>Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>FE</name>
                            <description>Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTFR</name>
                    <description>Flag Register, UARTFR</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x00000090</resetValue>
                    <fields>
                        <field>
                            <name>RI</name>
                            <description>Ring indicator. This bit is the complement of the UART ring indicator, nUARTRI, modem status input. That is, the bit is 1 when nUARTRI is LOW.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TXFE</name>
                            <description>Transmit FIFO empty. The meaning of this bit depends on the state of the FEN bit in the Line Control Register, UARTLCR_H. If the FIFO is disabled, this bit is set when the transmit holding register is empty. If the FIFO is enabled, the TXFE bit is set when the transmit FIFO is empty. This bit does not indicate if there is data in the transmit shift register.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RXFF</name>
                            <description>Receive FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is full. If the FIFO is enabled, the RXFF bit is set when the receive FIFO is full.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TXFF</name>
                            <description>Transmit FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the transmit holding register is full. If the FIFO is enabled, the TXFF bit is set when the transmit FIFO is full.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RXFE</name>
                            <description>Receive FIFO empty. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is empty. If the FIFO is enabled, the RXFE bit is set when the receive FIFO is empty.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BUSY</name>
                            <description>UART busy. If this bit is set to 1, the UART is busy transmitting data. This bit remains set until the complete byte, including all the stop bits, has been sent from the shift register. This bit is set as soon as the transmit FIFO becomes non-empty, regardless of whether the UART is enabled or not.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DCD</name>
                            <description>Data carrier detect. This bit is the complement of the UART data carrier detect, nUARTDCD, modem status input. That is, the bit is 1 when nUARTDCD is LOW.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DSR</name>
                            <description>Data set ready. This bit is the complement of the UART data set ready, nUARTDSR, modem status input. That is, the bit is 1 when nUARTDSR is LOW.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CTS</name>
                            <description>Clear to send. This bit is the complement of the UART clear to send, nUARTCTS, modem status input. That is, the bit is 1 when nUARTCTS is LOW.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTILPR</name>
                    <description>IrDA Low-Power Counter Register, UARTILPR</description>
                    <addressOffset>0x20</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ILPDVSR</name>
                            <description>8-bit low-power divisor value. These bits are cleared to 0 at reset.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTIBRD</name>
                    <description>Integer Baud Rate Register, UARTIBRD</description>
                    <addressOffset>0x24</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BAUD_DIVINT</name>
                            <description>The integer baud rate divisor. These bits are cleared to 0 on reset.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTFBRD</name>
                    <description>Fractional Baud Rate Register, UARTFBRD</description>
                    <addressOffset>0x28</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BAUD_DIVFRAC</name>
                            <description>The fractional baud rate divisor. These bits are cleared to 0 on reset.</description>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTLCR_H</name>
                    <description>Line Control Register, UARTLCR_H</description>
                    <addressOffset>0x2C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SPS</name>
                            <description>Stick parity select. 0 = stick parity is disabled 1 = either: * if the EPS bit is 0 then the parity bit is transmitted and checked as a 1 * if the EPS bit is 1 then the parity bit is transmitted and checked as a 0. This bit has no effect when the PEN bit disables parity checking and generation.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>WLEN</name>
                            <description>Word length. These bits indicate the number of data bits transmitted or received in a frame as follows: b11 = 8 bits b10 = 7 bits b01 = 6 bits b00 = 5 bits.</description>
                            <bitRange>[6:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FEN</name>
                            <description>Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs become 1-byte-deep holding registers 1 = transmit and receive FIFO buffers are enabled (FIFO mode).</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>STP2</name>
                            <description>Two stop bits select. If this bit is set to 1, two stop bits are transmitted at the end of the frame. The receive logic does not check for two stop bits being received.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EPS</name>
                            <description>Even parity select. Controls the type of parity the UART uses during transmission and reception: 0 = odd parity. The UART generates or checks for an odd number of 1s in the data and parity bits. 1 = even parity. The UART generates or checks for an even number of 1s in the data and parity bits. This bit has no effect when the PEN bit disables parity checking and generation.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PEN</name>
                            <description>Parity enable: 0 = parity is disabled and no parity bit added to the data frame 1 = parity checking and generation is enabled.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BRK</name>
                            <description>Send break. If this bit is set to 1, a low-level is continually output on the UARTTXD output, after completing transmission of the current character. For the proper execution of the break command, the software must set this bit for at least two complete frames. For normal use, this bit must be cleared to 0.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTCR</name>
                    <description>Control Register, UARTCR</description>
                    <addressOffset>0x30</addressOffset>
                    <resetValue>0x00000300</resetValue>
                    <fields>
                        <field>
                            <name>CTSEN</name>
                            <description>CTS hardware flow control enable. If this bit is set to 1, CTS hardware flow control is enabled. Data is only transmitted when the nUARTCTS signal is asserted.</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RTSEN</name>
                            <description>RTS hardware flow control enable. If this bit is set to 1, RTS hardware flow control is enabled. Data is only requested when there is space in the receive FIFO for it to be received.</description>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>OUT2</name>
                            <description>This bit is the complement of the UART Out2 (nUARTOut2) modem status output. That is, when the bit is programmed to a 1, the output is 0. For DTE this can be used as Ring Indicator (RI).</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>OUT1</name>
                            <description>This bit is the complement of the UART Out1 (nUARTOut1) modem status output. That is, when the bit is programmed to a 1 the output is 0. For DTE this can be used as Data Carrier Detect (DCD).</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RTS</name>
                            <description>Request to send. This bit is the complement of the UART request to send, nUARTRTS, modem status output. That is, when the bit is programmed to a 1 then nUARTRTS is LOW.</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DTR</name>
                            <description>Data transmit ready. This bit is the complement of the UART data transmit ready, nUARTDTR, modem status output. That is, when the bit is programmed to a 1 then nUARTDTR is LOW.</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RXE</name>
                            <description>Receive enable. If this bit is set to 1, the receive section of the UART is enabled. Data reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of reception, it completes the current character before stopping.</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TXE</name>
                            <description>Transmit enable. If this bit is set to 1, the transmit section of the UART is enabled. Data transmission occurs for either UART signals, or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of transmission, it completes the current character before stopping.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>LBE</name>
                            <description>Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1 and the SIRTEST bit in the Test Control Register, UARTTCR is set to 1, then the nSIROUT path is inverted, and fed through to the SIRIN path. The SIRTEST bit in the test register must be set to 1 to override the normal half-duplex SIR operation. This must be the requirement for accessing the test registers during normal operation, and SIRTEST must be cleared to 0 when loopback testing is finished. This feature reduces the amount of external coupling required during system test. If this bit is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path is fed through to the UARTRXD path. In either SIR mode or UART mode, when this bit is set, the modem outputs are also fed through to the modem inputs. This bit is cleared to 0 on reset, to disable loopback.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SIRLP</name>
                            <description>SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If this bit is cleared to 0, low-level bits are transmitted as an active high pulse with a width of 3 / 16th of the bit period. If this bit is set to 1, low-level bits are transmitted with a pulse width that is 3 times the period of the IrLPBaud16 input signal, regardless of the selected bit rate. Setting this bit uses less power, but might reduce transmission distances.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SIREN</name>
                            <description>SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no light pulse generated), and signal transitions on SIRIN have no effect. 1 = IrDA SIR ENDEC is enabled. Data is transmitted and received on nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal transitions on UARTRXD or modem status inputs have no effect. This bit has no effect if the UARTEN bit disables the UART.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>UARTEN</name>
                            <description>UART enable: 0 = UART is disabled. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. 1 = the UART is enabled. Data transmission and reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTIFLS</name>
                    <description>Interrupt FIFO Level Select Register, UARTIFLS</description>
                    <addressOffset>0x34</addressOffset>
                    <resetValue>0x00000012</resetValue>
                    <fields>
                        <field>
                            <name>RXIFLSEL</name>
                            <description>Receive interrupt FIFO level select. The trigger points for the receive interrupt are as follows: b000 = Receive FIFO becomes &gt;= 1 / 8 full b001 = Receive FIFO becomes &gt;= 1 / 4 full b010 = Receive FIFO becomes &gt;= 1 / 2 full b011 = Receive FIFO becomes &gt;= 3 / 4 full b100 = Receive FIFO becomes &gt;= 7 / 8 full b101-b111 = reserved.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TXIFLSEL</name>
                            <description>Transmit interrupt FIFO level select. The trigger points for the transmit interrupt are as follows: b000 = Transmit FIFO becomes &lt;= 1 / 8 full b001 = Transmit FIFO becomes &lt;= 1 / 4 full b010 = Transmit FIFO becomes &lt;= 1 / 2 full b011 = Transmit FIFO becomes &lt;= 3 / 4 full b100 = Transmit FIFO becomes &lt;= 7 / 8 full b101-b111 = reserved.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTIMSC</name>
                    <description>Interrupt Mask Set/Clear Register, UARTIMSC</description>
                    <addressOffset>0x38</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>OEIM</name>
                            <description>Overrun error interrupt mask. A read returns the current mask for the UARTOEINTR interrupt. On a write of 1, the mask of the UARTOEINTR interrupt is set. A write of 0 clears the mask.</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BEIM</name>
                            <description>Break error interrupt mask. A read returns the current mask for the UARTBEINTR interrupt. On a write of 1, the mask of the UARTBEINTR interrupt is set. A write of 0 clears the mask.</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PEIM</name>
                            <description>Parity error interrupt mask. A read returns the current mask for the UARTPEINTR interrupt. On a write of 1, the mask of the UARTPEINTR interrupt is set. A write of 0 clears the mask.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FEIM</name>
                            <description>Framing error interrupt mask. A read returns the current mask for the UARTFEINTR interrupt. On a write of 1, the mask of the UARTFEINTR interrupt is set. A write of 0 clears the mask.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RTIM</name>
                            <description>Receive timeout interrupt mask. A read returns the current mask for the UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR interrupt is set. A write of 0 clears the mask.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TXIM</name>
                            <description>Transmit interrupt mask. A read returns the current mask for the UARTTXINTR interrupt. On a write of 1, the mask of the UARTTXINTR interrupt is set. A write of 0 clears the mask.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RXIM</name>
                            <description>Receive interrupt mask. A read returns the current mask for the UARTRXINTR interrupt. On a write of 1, the mask of the UARTRXINTR interrupt is set. A write of 0 clears the mask.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DSRMIM</name>
                            <description>nUARTDSR modem interrupt mask. A read returns the current mask for the UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR interrupt is set. A write of 0 clears the mask.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DCDMIM</name>
                            <description>nUARTDCD modem interrupt mask. A read returns the current mask for the UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR interrupt is set. A write of 0 clears the mask.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CTSMIM</name>
                            <description>nUARTCTS modem interrupt mask. A read returns the current mask for the UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR interrupt is set. A write of 0 clears the mask.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RIMIM</name>
                            <description>nUARTRI modem interrupt mask. A read returns the current mask for the UARTRIINTR interrupt. On a write of 1, the mask of the UARTRIINTR interrupt is set. A write of 0 clears the mask.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTRIS</name>
                    <description>Raw Interrupt Status Register, UARTRIS</description>
                    <addressOffset>0x3C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>OERIS</name>
                            <description>Overrun error interrupt status. Returns the raw interrupt state of the UARTOEINTR interrupt.</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BERIS</name>
                            <description>Break error interrupt status. Returns the raw interrupt state of the UARTBEINTR interrupt.</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PERIS</name>
                            <description>Parity error interrupt status. Returns the raw interrupt state of the UARTPEINTR interrupt.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FERIS</name>
                            <description>Framing error interrupt status. Returns the raw interrupt state of the UARTFEINTR interrupt.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RTRIS</name>
                            <description>Receive timeout interrupt status. Returns the raw interrupt state of the UARTRTINTR interrupt. a</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TXRIS</name>
                            <description>Transmit interrupt status. Returns the raw interrupt state of the UARTTXINTR interrupt.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RXRIS</name>
                            <description>Receive interrupt status. Returns the raw interrupt state of the UARTRXINTR interrupt.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DSRRMIS</name>
                            <description>nUARTDSR modem interrupt status. Returns the raw interrupt state of the UARTDSRINTR interrupt.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DCDRMIS</name>
                            <description>nUARTDCD modem interrupt status. Returns the raw interrupt state of the UARTDCDINTR interrupt.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CTSRMIS</name>
                            <description>nUARTCTS modem interrupt status. Returns the raw interrupt state of the UARTCTSINTR interrupt.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RIRMIS</name>
                            <description>nUARTRI modem interrupt status. Returns the raw interrupt state of the UARTRIINTR interrupt.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTMIS</name>
                    <description>Masked Interrupt Status Register, UARTMIS</description>
                    <addressOffset>0x40</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>OEMIS</name>
                            <description>Overrun error masked interrupt status. Returns the masked interrupt state of the UARTOEINTR interrupt.</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BEMIS</name>
                            <description>Break error masked interrupt status. Returns the masked interrupt state of the UARTBEINTR interrupt.</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PEMIS</name>
                            <description>Parity error masked interrupt status. Returns the masked interrupt state of the UARTPEINTR interrupt.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FEMIS</name>
                            <description>Framing error masked interrupt status. Returns the masked interrupt state of the UARTFEINTR interrupt.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RTMIS</name>
                            <description>Receive timeout masked interrupt status. Returns the masked interrupt state of the UARTRTINTR interrupt.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TXMIS</name>
                            <description>Transmit masked interrupt status. Returns the masked interrupt state of the UARTTXINTR interrupt.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RXMIS</name>
                            <description>Receive masked interrupt status. Returns the masked interrupt state of the UARTRXINTR interrupt.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DSRMMIS</name>
                            <description>nUARTDSR modem masked interrupt status. Returns the masked interrupt state of the UARTDSRINTR interrupt.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DCDMMIS</name>
                            <description>nUARTDCD modem masked interrupt status. Returns the masked interrupt state of the UARTDCDINTR interrupt.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CTSMMIS</name>
                            <description>nUARTCTS modem masked interrupt status. Returns the masked interrupt state of the UARTCTSINTR interrupt.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RIMMIS</name>
                            <description>nUARTRI modem masked interrupt status. Returns the masked interrupt state of the UARTRIINTR interrupt.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTICR</name>
                    <description>Interrupt Clear Register, UARTICR</description>
                    <addressOffset>0x44</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>OEIC</name>
                            <description>Overrun error interrupt clear. Clears the UARTOEINTR interrupt.</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>BEIC</name>
                            <description>Break error interrupt clear. Clears the UARTBEINTR interrupt.</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>PEIC</name>
                            <description>Parity error interrupt clear. Clears the UARTPEINTR interrupt.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>FEIC</name>
                            <description>Framing error interrupt clear. Clears the UARTFEINTR interrupt.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>RTIC</name>
                            <description>Receive timeout interrupt clear. Clears the UARTRTINTR interrupt.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>TXIC</name>
                            <description>Transmit interrupt clear. Clears the UARTTXINTR interrupt.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>RXIC</name>
                            <description>Receive interrupt clear. Clears the UARTRXINTR interrupt.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>DSRMIC</name>
                            <description>nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>DCDMIC</name>
                            <description>nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>CTSMIC</name>
                            <description>nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>RIMIC</name>
                            <description>nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTDMACR</name>
                    <description>DMA Control Register, UARTDMACR</description>
                    <addressOffset>0x48</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DMAONERR</name>
                            <description>DMA on error. If this bit is set to 1, the DMA receive request outputs, UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error interrupt is asserted.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TXDMAE</name>
                            <description>Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RXDMAE</name>
                            <description>Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is enabled.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTPERIPHID0</name>
                    <description>UARTPeriphID0 Register</description>
                    <addressOffset>0xFE0</addressOffset>
                    <resetValue>0x00000011</resetValue>
                    <fields>
                        <field>
                            <name>PARTNUMBER0</name>
                            <description>These bits read back as 0x11</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTPERIPHID1</name>
                    <description>UARTPeriphID1 Register</description>
                    <addressOffset>0xFE4</addressOffset>
                    <resetValue>0x00000010</resetValue>
                    <fields>
                        <field>
                            <name>DESIGNER0</name>
                            <description>These bits read back as 0x1</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PARTNUMBER1</name>
                            <description>These bits read back as 0x0</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTPERIPHID2</name>
                    <description>UARTPeriphID2 Register</description>
                    <addressOffset>0xFE8</addressOffset>
                    <resetValue>0x00000034</resetValue>
                    <fields>
                        <field>
                            <name>REVISION</name>
                            <description>This field depends on the revision of the UART: r1p0 0x0 r1p1 0x1 r1p3 0x2 r1p4 0x2 r1p5 0x3</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DESIGNER1</name>
                            <description>These bits read back as 0x4</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTPERIPHID3</name>
                    <description>UARTPeriphID3 Register</description>
                    <addressOffset>0xFEC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CONFIGURATION</name>
                            <description>These bits read back as 0x00</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTPCELLID0</name>
                    <description>UARTPCellID0 Register</description>
                    <addressOffset>0xFF0</addressOffset>
                    <resetValue>0x0000000D</resetValue>
                    <fields>
                        <field>
                            <name>UARTPCELLID0</name>
                            <description>These bits read back as 0x0D</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTPCELLID1</name>
                    <description>UARTPCellID1 Register</description>
                    <addressOffset>0xFF4</addressOffset>
                    <resetValue>0x000000F0</resetValue>
                    <fields>
                        <field>
                            <name>UARTPCELLID1</name>
                            <description>These bits read back as 0xF0</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTPCELLID2</name>
                    <description>UARTPCellID2 Register</description>
                    <addressOffset>0xFF8</addressOffset>
                    <resetValue>0x00000005</resetValue>
                    <fields>
                        <field>
                            <name>UARTPCELLID2</name>
                            <description>These bits read back as 0x05</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>UARTPCELLID3</name>
                    <description>UARTPCellID3 Register</description>
                    <addressOffset>0xFFC</addressOffset>
                    <resetValue>0x000000B1</resetValue>
                    <fields>
                        <field>
                            <name>UARTPCELLID3</name>
                            <description>These bits read back as 0xB1</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral derivedFrom="UART0">
            <name>UART1</name>
            <baseAddress>0x40078000</baseAddress>
            <interrupt>
                <name>UART1_IRQ</name>
                <value>34</value>
            </interrupt>
        </peripheral>
        <peripheral>
            <name>ROSC</name>
            <baseAddress>0x400E8000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x28</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>CTRL</name>
                    <description>Ring Oscillator control</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000AA0</resetValue>
                    <fields>
                        <field>
                            <name>ENABLE</name>
                            <description>On power-up this field is initialised to ENABLE
                                The system clock must be switched to another source before setting this field to DISABLE otherwise the chip will lock up
                                The 12-bit code is intended to give some protection against accidental writes. An invalid setting will enable the oscillator.</description>
                            <bitRange>[23:12]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>DISABLE</name>
                                    <value>3358</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLE</name>
                                    <value>4011</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>FREQ_RANGE</name>
                            <description>Controls the number of delay stages in the ROSC ring
                                LOW uses stages 0 to 7
                                MEDIUM uses stages 2 to 7
                                HIGH uses stages 4 to 7
                                TOOHIGH uses stages 6 to 7 and should not be used because its frequency exceeds design specifications
                                The clock output will not glitch when changing the range up one step at a time
                                The clock output will glitch when changing the range down
                                Note: the values here are gray coded which is why HIGH comes before TOOHIGH</description>
                            <bitRange>[11:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>LOW</name>
                                    <value>4004</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>MEDIUM</name>
                                    <value>4005</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>HIGH</name>
                                    <value>4007</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>TOOHIGH</name>
                                    <value>4006</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FREQA</name>
                    <description>The FREQA &amp; FREQB registers control the frequency by controlling the drive strength of each stage
                        The drive strength has 4 levels determined by the number of bits set
                        Increasing the number of bits set increases the drive strength and increases the oscillation frequency
                        0 bits set is the default drive strength
                        1 bit set doubles the drive strength
                        2 bits set triples drive strength
                        3 bits set quadruples drive strength
                        For frequency randomisation set both DS0_RANDOM=1 &amp; DS1_RANDOM=1</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PASSWD</name>
                            <description>Set to 0x9696 to apply the settings
                                Any other value in this field will set all drive strengths to 0</description>
                            <bitRange>[31:16]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>PASS</name>
                                    <value>38550</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DS3</name>
                            <description>Stage 3 drive strength</description>
                            <bitRange>[14:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DS2</name>
                            <description>Stage 2 drive strength</description>
                            <bitRange>[10:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DS1_RANDOM</name>
                            <description>Randomises the stage 1 drive strength</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DS1</name>
                            <description>Stage 1 drive strength</description>
                            <bitRange>[6:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DS0_RANDOM</name>
                            <description>Randomises the stage 0 drive strength</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DS0</name>
                            <description>Stage 0 drive strength</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FREQB</name>
                    <description>For a detailed description see freqa register</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PASSWD</name>
                            <description>Set to 0x9696 to apply the settings
                                Any other value in this field will set all drive strengths to 0</description>
                            <bitRange>[31:16]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>PASS</name>
                                    <value>38550</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DS7</name>
                            <description>Stage 7 drive strength</description>
                            <bitRange>[14:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DS6</name>
                            <description>Stage 6 drive strength</description>
                            <bitRange>[10:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DS5</name>
                            <description>Stage 5 drive strength</description>
                            <bitRange>[6:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DS4</name>
                            <description>Stage 4 drive strength</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RANDOM</name>
                    <description>Loads a value to the LFSR randomiser</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x3F04B16D</resetValue>
                    <fields>
                        <field>
                            <name>SEED</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DORMANT</name>
                    <description>Ring Oscillator pause control</description>
                    <addressOffset>0x10</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>DORMANT</name>
                            <description>This is used to save power by pausing the ROSC
                                On power-up this field is initialised to WAKE
                                An invalid write will also select WAKE
                                Warning: setup the irq before selecting dormant mode</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>dormant</name>
                                    <value>1668246881</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>WAKE</name>
                                    <value>2002873189</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DIV</name>
                    <description>Controls the output divider</description>
                    <addressOffset>0x14</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>DIV</name>
                            <description>set to 0xaa00 + div where
                                div = 0 divides by 128
                                div = 1-127 divides by div
                                any other value sets div=128
                                this register resets to div=32</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>PASS</name>
                                    <value>43520</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PHASE</name>
                    <description>Controls the phase shifted output</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x00000008</resetValue>
                    <fields>
                        <field>
                            <name>PASSWD</name>
                            <description>set to 0xaa
                                any other value enables the output with shift=0</description>
                            <bitRange>[11:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>enable the phase-shifted output
                                this can be changed on-the-fly</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FLIP</name>
                            <description>invert the phase-shifted output
                                this is ignored when div=1</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SHIFT</name>
                            <description>phase shift the phase-shifted output by SHIFT input clocks
                                this can be changed on-the-fly
                                must be set to 0 before setting div=1</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>STATUS</name>
                    <description>Ring Oscillator Status</description>
                    <addressOffset>0x1C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>STABLE</name>
                            <description>Oscillator is running and stable</description>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BADWRITE</name>
                            <description>An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE or FREQA or FREQB or DIV or PHASE or DORMANT</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>DIV_RUNNING</name>
                            <description>post-divider is running
                                this resets to 0 but transitions to 1 during chip startup</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ENABLED</name>
                            <description>Oscillator is enabled but not necessarily running and stable
                                this resets to 0 but transitions to 1 during chip startup</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RANDOMBIT</name>
                    <description>This just reads the state of the oscillator output so randomness is compromised if the ring oscillator is stopped or run at a harmonic of the bus frequency</description>
                    <addressOffset>0x20</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>RANDOMBIT</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>COUNT</name>
                    <description>A down counter running at the ROSC frequency which counts to zero and stops.
                        To start the counter write a non-zero value.
                        Can be used for short software pauses when setting up time sensitive hardware.</description>
                    <addressOffset>0x24</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>COUNT</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>POWMAN</name>
            <description>Controls vreg, bor, lposc, chip resets &amp; xosc startup, powman and provides scratch register for general use and for bootcode use</description>
            <baseAddress>0x40100000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0xF0</size>
                <usage>registers</usage>
            </addressBlock>
            <interrupt>
                <name>POWMAN_IRQ_POW</name>
                <value>44</value>
            </interrupt>
            <interrupt>
                <name>POWMAN_IRQ_TIMER</name>
                <value>45</value>
            </interrupt>
            <registers>
                <register>
                    <name>BADPASSWD</name>
                    <description>Indicates a bad password has been used</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BADPASSWD</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>VREG_CTRL</name>
                    <description>Voltage Regulator Control</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00008050</resetValue>
                    <fields>
                        <field>
                            <name>RST_N</name>
                            <description>returns the regulator to its startup settings
                                0 - reset
                                1 - not reset (default)</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>UNLOCK</name>
                            <description>unlocks the VREG control interface after power up
                                0 - Locked (default)
                                1 - Unlocked
                                It cannot be relocked when it is unlocked.</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ISOLATE</name>
                            <description>isolates the VREG control interface
                                0 - not isolated (default)
                                1 - isolated</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DISABLE_VOLTAGE_LIMIT</name>
                            <description>0=not disabled, 1=enabled</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HT_TH</name>
                            <description>high temperature protection threshold
                                regulator power transistors are disabled when junction temperature exceeds threshold
                                000 - 100C
                                001 - 105C
                                010 - 110C
                                011 - 115C
                                100 - 120C
                                101 - 125C
                                110 - 135C
                                111 - 150C</description>
                            <bitRange>[6:4]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>VREG_STS</name>
                    <description>Voltage Regulator Status</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>VOUT_OK</name>
                            <description>output regulation status
                                0=not in regulation, 1=in regulation</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>STARTUP</name>
                            <description>startup status
                                0=startup complete, 1=starting up</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>VREG</name>
                    <description>Voltage Regulator Settings</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x000000B0</resetValue>
                    <fields>
                        <field>
                            <name>UPDATE_IN_PROGRESS</name>
                            <description>regulator state is being updated
                                writes to the vreg register will be ignored when this field is set</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VSEL</name>
                            <description>output voltage select
                                the regulator output voltage is limited to 1.3V unless the voltage limit
                                is disabled using the disable_voltage_limit field in the vreg_ctrl register
                                00000 - 0.55V
                                00001 - 0.60V
                                00010 - 0.65V
                                00011 - 0.70V
                                00100 - 0.75V
                                00101 - 0.80V
                                00110 - 0.85V
                                00111 - 0.90V
                                01000 - 0.95V
                                01001 - 1.00V
                                01010 - 1.05V
                                01011 - 1.10V (default)
                                01100 - 1.15V
                                01101 - 1.20V
                                01110 - 1.25V
                                01111 - 1.30V
                                10000 - 1.35V
                                10001 - 1.40V
                                10010 - 1.50V
                                10011 - 1.60V
                                10100 - 1.65V
                                10101 - 1.70V
                                10110 - 1.80V
                                10111 - 1.90V
                                11000 - 2.00V
                                11001 - 2.35V
                                11010 - 2.50V
                                11011 - 2.65V
                                11100 - 2.80V
                                11101 - 3.00V
                                11110 - 3.15V
                                11111 - 3.30V</description>
                            <bitRange>[8:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HIZ</name>
                            <description>high impedance mode select
                                0=not in high impedance mode, 1=in high impedance mode</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>VREG_LP_ENTRY</name>
                    <description>Voltage Regulator Low Power Entry Settings</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x000000B4</resetValue>
                    <fields>
                        <field>
                            <name>VSEL</name>
                            <description>output voltage select
                                the regulator output voltage is limited to 1.3V unless the voltage limit
                                is disabled using the disable_voltage_limit field in the vreg_ctrl register
                                00000 - 0.55V
                                00001 - 0.60V
                                00010 - 0.65V
                                00011 - 0.70V
                                00100 - 0.75V
                                00101 - 0.80V
                                00110 - 0.85V
                                00111 - 0.90V
                                01000 - 0.95V
                                01001 - 1.00V
                                01010 - 1.05V
                                01011 - 1.10V (default)
                                01100 - 1.15V
                                01101 - 1.20V
                                01110 - 1.25V
                                01111 - 1.30V
                                10000 - 1.35V
                                10001 - 1.40V
                                10010 - 1.50V
                                10011 - 1.60V
                                10100 - 1.65V
                                10101 - 1.70V
                                10110 - 1.80V
                                10111 - 1.90V
                                11000 - 2.00V
                                11001 - 2.35V
                                11010 - 2.50V
                                11011 - 2.65V
                                11100 - 2.80V
                                11101 - 3.00V
                                11110 - 3.15V
                                11111 - 3.30V</description>
                            <bitRange>[8:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MODE</name>
                            <description>selects either normal (switching) mode or low power (linear) mode
                                low power mode can only be selected for output voltages up to 1.3V
                                0 = normal mode (switching)
                                1 = low power mode (linear)</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HIZ</name>
                            <description>high impedance mode select
                                0=not in high impedance mode, 1=in high impedance mode</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>VREG_LP_EXIT</name>
                    <description>Voltage Regulator Low Power Exit Settings</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x000000B0</resetValue>
                    <fields>
                        <field>
                            <name>VSEL</name>
                            <description>output voltage select
                                the regulator output voltage is limited to 1.3V unless the voltage limit
                                is disabled using the disable_voltage_limit field in the vreg_ctrl register
                                00000 - 0.55V
                                00001 - 0.60V
                                00010 - 0.65V
                                00011 - 0.70V
                                00100 - 0.75V
                                00101 - 0.80V
                                00110 - 0.85V
                                00111 - 0.90V
                                01000 - 0.95V
                                01001 - 1.00V
                                01010 - 1.05V
                                01011 - 1.10V (default)
                                01100 - 1.15V
                                01101 - 1.20V
                                01110 - 1.25V
                                01111 - 1.30V
                                10000 - 1.35V
                                10001 - 1.40V
                                10010 - 1.50V
                                10011 - 1.60V
                                10100 - 1.65V
                                10101 - 1.70V
                                10110 - 1.80V
                                10111 - 1.90V
                                11000 - 2.00V
                                11001 - 2.35V
                                11010 - 2.50V
                                11011 - 2.65V
                                11100 - 2.80V
                                11101 - 3.00V
                                11110 - 3.15V
                                11111 - 3.30V</description>
                            <bitRange>[8:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MODE</name>
                            <description>selects either normal (switching) mode or low power (linear) mode
                                low power mode can only be selected for output voltages up to 1.3V
                                0 = normal mode (switching)
                                1 = low power mode (linear)</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HIZ</name>
                            <description>high impedance mode select
                                0=not in high impedance mode, 1=in high impedance mode</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOD_CTRL</name>
                    <description>Brown-out Detection Control</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ISOLATE</name>
                            <description>isolates the brown-out detection control interface
                                0 - not isolated (default)
                                1 - isolated</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOD</name>
                    <description>Brown-out Detection Settings</description>
                    <addressOffset>0x1C</addressOffset>
                    <resetValue>0x000000B1</resetValue>
                    <fields>
                        <field>
                            <name>VSEL</name>
                            <description>threshold select
                                00000 - 0.473V
                                00001 - 0.516V
                                00010 - 0.559V
                                00011 - 0.602V
                                00100 - 0.645VS
                                00101 - 0.688V
                                00110 - 0.731V
                                00111 - 0.774V
                                01000 - 0.817V
                                01001 - 0.860V (default)
                                01010 - 0.903V
                                01011 - 0.946V
                                01100 - 0.989V
                                01101 - 1.032V
                                01110 - 1.075V
                                01111 - 1.118V
                                10000 - 1.161
                                10001 - 1.204V</description>
                            <bitRange>[8:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>enable brown-out detection
                                0=not enabled, 1=enabled</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOD_LP_ENTRY</name>
                    <description>Brown-out Detection Low Power Entry Settings</description>
                    <addressOffset>0x20</addressOffset>
                    <resetValue>0x000000B0</resetValue>
                    <fields>
                        <field>
                            <name>VSEL</name>
                            <description>threshold select
                                00000 - 0.473V
                                00001 - 0.516V
                                00010 - 0.559V
                                00011 - 0.602V
                                00100 - 0.645VS
                                00101 - 0.688V
                                00110 - 0.731V
                                00111 - 0.774V
                                01000 - 0.817V
                                01001 - 0.860V (default)
                                01010 - 0.903V
                                01011 - 0.946V
                                01100 - 0.989V
                                01101 - 1.032V
                                01110 - 1.075V
                                01111 - 1.118V
                                10000 - 1.161
                                10001 - 1.204V</description>
                            <bitRange>[8:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>enable brown-out detection
                                0=not enabled, 1=enabled</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOD_LP_EXIT</name>
                    <description>Brown-out Detection Low Power Exit Settings</description>
                    <addressOffset>0x24</addressOffset>
                    <resetValue>0x000000B1</resetValue>
                    <fields>
                        <field>
                            <name>VSEL</name>
                            <description>threshold select
                                00000 - 0.473V
                                00001 - 0.516V
                                00010 - 0.559V
                                00011 - 0.602V
                                00100 - 0.645VS
                                00101 - 0.688V
                                00110 - 0.731V
                                00111 - 0.774V
                                01000 - 0.817V
                                01001 - 0.860V (default)
                                01010 - 0.903V
                                01011 - 0.946V
                                01100 - 0.989V
                                01101 - 1.032V
                                01110 - 1.075V
                                01111 - 1.118V
                                10000 - 1.161
                                10001 - 1.204V</description>
                            <bitRange>[8:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>enable brown-out detection
                                0=not enabled, 1=enabled</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>LPOSC</name>
                    <description>Low power oscillator control register.</description>
                    <addressOffset>0x28</addressOffset>
                    <resetValue>0x00000203</resetValue>
                    <fields>
                        <field>
                            <name>TRIM</name>
                            <description>Frequency trim - the trim step is typically 1% of the reset frequency, but can be up to 3%</description>
                            <bitRange>[9:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MODE</name>
                            <description>This feature has been removed</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CHIP_RESET</name>
                    <description>Chip reset control and status</description>
                    <addressOffset>0x2C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>HAD_WATCHDOG_RESET_RSM</name>
                            <description>Last reset was a watchdog timeout which was configured to reset the power-on state machine
                                This resets:
                                double_tap flag    no
                                DP                 no
                                RPAP               no
                                rescue_flag        no
                                timer              no
                                powman             no
                                swcore             no
                                psm                yes
                                and does not change the power state</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HAD_HZD_SYS_RESET_REQ</name>
                            <description>Last reset was a system reset from the hazard debugger
                                This resets:
                                double_tap flag    no
                                DP                 no
                                RPAP               no
                                rescue_flag        no
                                timer              no
                                powman             no
                                swcore             no
                                psm                yes
                                and does not change the power state</description>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HAD_GLITCH_DETECT</name>
                            <description>Last reset was due to a power supply glitch
                                This resets:
                                double_tap flag    no
                                DP                 no
                                RPAP               no
                                rescue_flag        no
                                timer              no
                                powman             no
                                swcore             no
                                psm                yes
                                and does not change the power state</description>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HAD_SWCORE_PD</name>
                            <description>Last reset was a switched core powerdown
                                This resets:
                                double_tap flag    no
                                DP                 no
                                RPAP               no
                                rescue_flag        no
                                timer              no
                                powman             no
                                swcore             yes
                                psm                yes
                                then starts the power sequencer</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HAD_WATCHDOG_RESET_SWCORE</name>
                            <description>Last reset was a watchdog timeout which was configured to reset the switched-core
                                This resets:
                                double_tap flag    no
                                DP                 no
                                RPAP               no
                                rescue_flag        no
                                timer              no
                                powman             no
                                swcore             yes
                                psm                yes
                                then starts the power sequencer</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HAD_WATCHDOG_RESET_POWMAN</name>
                            <description>Last reset was a watchdog timeout which was configured to reset the power manager
                                This resets:
                                double_tap flag    no
                                DP                 no
                                RPAP               no
                                rescue_flag        no
                                timer              yes
                                powman             yes
                                swcore             yes
                                psm                yes
                                then starts the power sequencer</description>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HAD_WATCHDOG_RESET_POWMAN_ASYNC</name>
                            <description>Last reset was a watchdog timeout which was configured to reset the power manager asynchronously
                                This resets:
                                double_tap flag    no
                                DP                 no
                                RPAP               no
                                rescue_flag        no
                                timer              yes
                                powman             yes
                                swcore             yes
                                psm                yes
                                then starts the power sequencer</description>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HAD_RESCUE</name>
                            <description>Last reset was a rescue reset from the debugger
                                This resets:
                                double_tap flag    no
                                DP                 no
                                RPAP               no
                                rescue_flag        no, it sets this flag
                                timer              yes
                                powman             yes
                                swcore             yes
                                psm                yes
                                then starts the power sequencer</description>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HAD_DP_RESET_REQ</name>
                            <description>Last reset was an reset request from the arm debugger
                                This resets:
                                double_tap flag    no
                                DP                 no
                                RPAP               no
                                rescue_flag        yes
                                timer              yes
                                powman             yes
                                swcore             yes
                                psm                yes
                                then starts the power sequencer</description>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HAD_RUN_LOW</name>
                            <description>Last reset was from the RUN pin
                                This resets:
                                double_tap flag    no
                                DP                 yes
                                RPAP               yes
                                rescue_flag        yes
                                timer              yes
                                powman             yes
                                swcore             yes
                                psm                yes
                                then starts the power sequencer</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HAD_BOR</name>
                            <description>Last reset was from the brown-out detection block
                                This resets:
                                double_tap flag    yes
                                DP                 yes
                                RPAP               yes
                                rescue_flag        yes
                                timer              yes
                                powman             yes
                                swcore             yes
                                psm                yes
                                then starts the power sequencer</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HAD_POR</name>
                            <description>Last reset was from the power-on reset
                                This resets:
                                double_tap flag    yes
                                DP                 yes
                                RPAP               yes
                                rescue_flag        yes
                                timer              yes
                                powman             yes
                                swcore             yes
                                psm                yes
                                then starts the power sequencer</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RESCUE_FLAG</name>
                            <description>This is set by a rescue reset from the RP-AP.
                                Its purpose is to halt before the bootrom before booting from flash in order to recover from a boot lock-up.
                                The debugger can then attach once the bootrom has been halted and flash some working code that does not lock up.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>DOUBLE_TAP</name>
                            <description>This flag is set by double-tapping RUN. It tells bootcode to go into the bootloader.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>WDSEL</name>
                    <description>Allows a watchdog reset to reset the internal state of powman in addition to the power-on state machine (PSM).
                        Note that powman ignores watchdog resets that do not select at least the CLOCKS stage or earlier stages in the PSM. If using these bits, it's recommended to set PSM_WDSEL to all-ones in addition to the desired bits in this register. Failing to select CLOCKS or earlier will result in the POWMAN_WDSEL register having no effect.</description>
                    <addressOffset>0x30</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RESET_RSM</name>
                            <description>If set to 1, a watchdog reset will run the full power-on state machine (PSM) sequence
                                From a user perspective it is the same as setting RSM_WDSEL_PROC_COLD
                                From a hardware debug perspective it has the same effect as a reset from a glitch detector</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RESET_SWCORE</name>
                            <description>If set to 1, a watchdog reset will reset the switched core power domain and run the full power-on state machine (PSM) sequence
                                From a user perspective it is the same as setting RSM_WDSEL_PROC_COLD
                                From a hardware debug perspective it has the same effect as a power-on reset for the switched core power domain</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RESET_POWMAN</name>
                            <description>If set to 1, a watchdog reset will restore powman defaults, reset the timer, reset the switched core power domain
                                and run the full power-on state machine (PSM) sequence
                                This relies on clk_ref running. Use reset_powman_async if that may not be true</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RESET_POWMAN_ASYNC</name>
                            <description>If set to 1, a watchdog reset will restore powman defaults, reset the timer,
                                reset the switched core domain and run the full power-on state machine (PSM) sequence
                                This does not rely on clk_ref running</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SEQ_CFG</name>
                    <description>For configuration of the power sequencer
                        Writes are ignored while POWMAN_STATE_CHANGING=1</description>
                    <addressOffset>0x34</addressOffset>
                    <resetValue>0x001011F0</resetValue>
                    <fields>
                        <field>
                            <name>USING_FAST_POWCK</name>
                            <description>0 indicates the POWMAN clock is running from the low power oscillator (32kHz)
                                1 indicates the POWMAN clock is running from the reference clock (2-50MHz)</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USING_BOD_LP</name>
                            <description>Indicates the brown-out detector (BOD) mode
                                0 = BOD high power mode which is the default
                                1 = BOD low power mode</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USING_VREG_LP</name>
                            <description>Indicates the voltage regulator (VREG) mode
                                0 = VREG high power mode which is the default
                                1 = VREG low power mode</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USE_FAST_POWCK</name>
                            <description>selects the reference clock (clk_ref) as the source of the POWMAN clock when switched-core is powered. The POWMAN clock always switches to the slow clock (lposc) when switched-core is powered down because the fast clock stops running.
                                0 always run the POWMAN clock from the slow clock (lposc)
                                1 run the POWMAN clock from the fast clock when available
                                This setting takes effect when a power up sequence is next run</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RUN_LPOSC_IN_LP</name>
                            <description>Set to 0 to stop the low power osc when the switched-core is powered down, which is unwise if using it to clock the timer
                                This setting takes effect when the swcore is next powered down</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USE_BOD_HP</name>
                            <description>Set to 0 to prevent automatic switching to bod high power mode when switched-core is powered up
                                This setting takes effect when the swcore is next powered up</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USE_BOD_LP</name>
                            <description>Set to 0 to prevent automatic switching to bod low power mode when switched-core is powered down
                                This setting takes effect when the swcore is next powered down</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USE_VREG_HP</name>
                            <description>Set to 0 to prevent automatic switching to vreg high power mode when switched-core is powered up
                                This setting takes effect when the swcore is next powered up</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USE_VREG_LP</name>
                            <description>Set to 0 to prevent automatic switching to vreg low power mode when switched-core is powered down
                                This setting takes effect when the swcore is next powered down</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HW_PWRUP_SRAM0</name>
                            <description>Specifies the power state of SRAM0 when powering up swcore from a low power state (P1.xxx) to a high power state (P0.0xx).
                                0=power-up
                                1=no change</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HW_PWRUP_SRAM1</name>
                            <description>Specifies the power state of SRAM1 when powering up swcore from a low power state (P1.xxx) to a high power state (P0.0xx).
                                0=power-up
                                1=no change</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>STATE</name>
                    <description>This register controls the power state of the 4 power domains.
                        The current power state is indicated in POWMAN_STATE_CURRENT which is read-only.
                        To change the state, write to POWMAN_STATE_REQ.
                        The coding of POWMAN_STATE_CURRENT &amp; POWMAN_STATE_REQ corresponds to the power states
                        defined in the datasheet:
                        bit 3 = SWCORE
                        bit 2 = XIP cache
                        bit 1 = SRAM0
                        bit 0 = SRAM1
                        0 = powered up
                        1 = powered down
                        When POWMAN_STATE_REQ is written, the POWMAN_STATE_WAITING flag is set while the Power Manager determines what is required. If an invalid transition is requested the Power Manager will still register the request in POWMAN_STATE_REQ but will also set the POWMAN_BAD_REQ flag. It will then implement the power-up requests and ignore the power down requests. To do nothing would risk entering an unrecoverable lock-up state. Invalid requests are: any combination of power up and power down requests any request that results in swcore boing powered and xip unpowered If the request is to power down the switched-core domain then POWMAN_STATE_WAITING stays active until the processors halt. During this time the POWMAN_STATE_REQ field can be re-written to change or cancel the request. When the power state transition begins the POWMAN_STATE_WAITING_flag is cleared, the POWMAN_STATE_CHANGING flag is set and POWMAN register writes are ignored until the transition completes.</description>
                    <addressOffset>0x38</addressOffset>
                    <resetValue>0x0000000F</resetValue>
                    <fields>
                        <field>
                            <name>CHANGING</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WAITING</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BAD_HW_REQ</name>
                            <description>Bad hardware initiated state request. Went back to state 0 (i.e. everything powered up)</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BAD_SW_REQ</name>
                            <description>Bad software initiated state request. No action taken.</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PWRUP_WHILE_WAITING</name>
                            <description>Request ignored because of a pending pwrup request. See current_pwrup_req. Note this blocks powering up AND powering down.</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>REQ_IGNORED</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>REQ</name>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CURRENT</name>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>POW_FASTDIV</name>
                    <addressOffset>0x3C</addressOffset>
                    <resetValue>0x00000040</resetValue>
                    <fields>
                        <field>
                            <name>POW_FASTDIV</name>
                            <description>divides the POWMAN clock to provide a tick for the delay module and state machines
                                when clk_pow is running from the slow clock it is not divided
                                when clk_pow is running from the fast clock it is divided by tick_div</description>
                            <bitRange>[10:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>POW_DELAY</name>
                    <description>power state machine delays</description>
                    <addressOffset>0x40</addressOffset>
                    <resetValue>0x00002011</resetValue>
                    <fields>
                        <field>
                            <name>SRAM_STEP</name>
                            <description>timing between the sram0 and sram1 power state machine steps
                                measured in units of the powman tick period (&gt;=1us), 0 gives a delay of 1 unit</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>XIP_STEP</name>
                            <description>timing between the xip power state machine steps
                                measured in units of the lposc period, 0 gives a delay of 1 unit</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SWCORE_STEP</name>
                            <description>timing between the swcore power state machine steps
                                measured in units of the lposc period, 0 gives a delay of 1 unit</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>EXT_CTRL0</name>
                    <description>Configures a gpio as a power mode aware control output</description>
                    <addressOffset>0x44</addressOffset>
                    <resetValue>0x0000003F</resetValue>
                    <fields>
                        <field>
                            <name>LP_EXIT_STATE</name>
                            <description>output level when exiting the low power state</description>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>LP_ENTRY_STATE</name>
                            <description>output level when entering the low power state</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INIT_STATE</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INIT</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_SELECT</name>
                            <description>selects from gpio 0-&gt;30
                                set to 31 to disable this feature</description>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>EXT_CTRL1</name>
                    <description>Configures a gpio as a power mode aware control output</description>
                    <addressOffset>0x48</addressOffset>
                    <resetValue>0x0000003F</resetValue>
                    <fields>
                        <field>
                            <name>LP_EXIT_STATE</name>
                            <description>output level when exiting the low power state</description>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>LP_ENTRY_STATE</name>
                            <description>output level when entering the low power state</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INIT_STATE</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INIT</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO_SELECT</name>
                            <description>selects from gpio 0-&gt;30
                                set to 31 to disable this feature</description>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>EXT_TIME_REF</name>
                    <description>Select a GPIO to use as a time reference, the source can be used to drive the low power clock at 32kHz, or to provide a 1ms tick to the timer, or provide a 1Hz tick to the timer. The tick selection is controlled by the POWMAN_TIMER register.</description>
                    <addressOffset>0x4C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DRIVE_LPCK</name>
                            <description>Use the selected GPIO to drive the 32kHz low power clock, in place of LPOSC. This field must only be written when POWMAN_TIMER_RUN=0</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SOURCE_SEL</name>
                            <description>0 -&gt;  gpio12
                                1 -&gt;  gpio20
                                2 -&gt;  gpio14
                                3 -&gt;  gpio22</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>LPOSC_FREQ_KHZ_INT</name>
                    <description>Informs the AON Timer of the integer component of the clock frequency when running off the LPOSC.</description>
                    <addressOffset>0x50</addressOffset>
                    <resetValue>0x00000020</resetValue>
                    <fields>
                        <field>
                            <name>LPOSC_FREQ_KHZ_INT</name>
                            <description>Integer component of the LPOSC or GPIO clock source frequency in kHz. Default = 32 This field must only be written when POWMAN_TIMER_RUN=0 or POWMAN_TIMER_USING_XOSC=1</description>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>LPOSC_FREQ_KHZ_FRAC</name>
                    <description>Informs the AON Timer of the fractional component of the clock frequency when running off the LPOSC.</description>
                    <addressOffset>0x54</addressOffset>
                    <resetValue>0x0000C49C</resetValue>
                    <fields>
                        <field>
                            <name>LPOSC_FREQ_KHZ_FRAC</name>
                            <description>Fractional component of the LPOSC or GPIO clock source frequency in kHz. Default = 0.768 This field must only be written when POWMAN_TIMER_RUN=0 or POWMAN_TIMER_USING_XOSC=1</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>XOSC_FREQ_KHZ_INT</name>
                    <description>Informs the AON Timer of the integer component of the clock frequency when running off the XOSC.</description>
                    <addressOffset>0x58</addressOffset>
                    <resetValue>0x00002EE0</resetValue>
                    <fields>
                        <field>
                            <name>XOSC_FREQ_KHZ_INT</name>
                            <description>Integer component of the XOSC frequency in kHz. Default = 12000 Must be &gt;1 This field must only be written when POWMAN_TIMER_RUN=0 or POWMAN_TIMER_USING_XOSC=0</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>XOSC_FREQ_KHZ_FRAC</name>
                    <description>Informs the AON Timer of the fractional component of the clock frequency when running off the XOSC.</description>
                    <addressOffset>0x5C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>XOSC_FREQ_KHZ_FRAC</name>
                            <description>Fractional component of the XOSC frequency in kHz. This field must only be written when POWMAN_TIMER_RUN=0 or POWMAN_TIMER_USING_XOSC=0</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SET_TIME_63TO48</name>
                    <addressOffset>0x60</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SET_TIME_63TO48</name>
                            <description>For setting the time, do not use for reading the time, use POWMAN_READ_TIME_UPPER and POWMAN_READ_TIME_LOWER. This field must only be written when POWMAN_TIMER_RUN=0</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SET_TIME_47TO32</name>
                    <addressOffset>0x64</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SET_TIME_47TO32</name>
                            <description>For setting the time, do not use for reading the time, use POWMAN_READ_TIME_UPPER and POWMAN_READ_TIME_LOWER. This field must only be written when POWMAN_TIMER_RUN=0</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SET_TIME_31TO16</name>
                    <addressOffset>0x68</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SET_TIME_31TO16</name>
                            <description>For setting the time, do not use for reading the time, use POWMAN_READ_TIME_UPPER and POWMAN_READ_TIME_LOWER. This field must only be written when POWMAN_TIMER_RUN=0</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SET_TIME_15TO0</name>
                    <addressOffset>0x6C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SET_TIME_15TO0</name>
                            <description>For setting the time, do not use for reading the time, use POWMAN_READ_TIME_UPPER and POWMAN_READ_TIME_LOWER. This field must only be written when POWMAN_TIMER_RUN=0</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>READ_TIME_UPPER</name>
                    <addressOffset>0x70</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>READ_TIME_UPPER</name>
                            <description>For reading bits 63:32 of the timer. When reading all 64 bits it is possible for the LOWER count to rollover during the read. It is recommended to read UPPER, then LOWER, then re-read UPPER and, if it has changed, re-read LOWER.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>READ_TIME_LOWER</name>
                    <addressOffset>0x74</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>READ_TIME_LOWER</name>
                            <description>For reading bits 31:0 of the timer.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ALARM_TIME_63TO48</name>
                    <addressOffset>0x78</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ALARM_TIME_63TO48</name>
                            <description>This field must only be written when POWMAN_ALARM_ENAB=0</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ALARM_TIME_47TO32</name>
                    <addressOffset>0x7C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ALARM_TIME_47TO32</name>
                            <description>This field must only be written when POWMAN_ALARM_ENAB=0</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ALARM_TIME_31TO16</name>
                    <addressOffset>0x80</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ALARM_TIME_31TO16</name>
                            <description>This field must only be written when POWMAN_ALARM_ENAB=0</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ALARM_TIME_15TO0</name>
                    <addressOffset>0x84</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ALARM_TIME_15TO0</name>
                            <description>This field must only be written when POWMAN_ALARM_ENAB=0</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TIMER</name>
                    <addressOffset>0x88</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>USING_GPIO_1HZ</name>
                            <description>Timer is synchronised to a 1hz gpio source</description>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USING_GPIO_1KHZ</name>
                            <description>Timer is running from a 1khz gpio source</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USING_LPOSC</name>
                            <description>Timer is running from lposc</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USING_XOSC</name>
                            <description>Timer is running from xosc</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USE_GPIO_1HZ</name>
                            <description>Selects the gpio source as the reference for the sec counter. The msec counter will continue to use the lposc or xosc reference.</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USE_GPIO_1KHZ</name>
                            <description>switch to gpio as the source of the 1kHz timer tick</description>
                            <bitRange>[10:10]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>USE_XOSC</name>
                            <description>switch to xosc as the source of the 1kHz timer tick</description>
                            <bitRange>[9:9]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>USE_LPOSC</name>
                            <description>Switch to lposc as the source of the 1kHz timer tick</description>
                            <bitRange>[8:8]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>ALARM</name>
                            <description>Alarm has fired. Write to 1 to clear the alarm.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>PWRUP_ON_ALARM</name>
                            <description>Alarm wakes the chip from low power mode</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ALARM_ENAB</name>
                            <description>Enables the alarm. The alarm must be disabled while writing the alarm time.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CLEAR</name>
                            <description>Clears the timer, does not disable the timer and does not affect the alarm. This control can be written at any time.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>RUN</name>
                            <description>Timer enable. Setting this bit causes the timer to begin counting up from its current value. Clearing this bit stops the timer from counting.

                                Before enabling the timer, set the POWMAN_LPOSC_FREQ* and POWMAN_XOSC_FREQ* registers to configure the count rate, and initialise the current time by writing to SET_TIME_63TO48 through SET_TIME_15TO0. You must not write to the SET_TIME_x registers when the timer is running.

                                Once configured, start the timer by setting POWMAN_TIMER_RUN=1. This will start the timer running from the LPOSC. When the XOSC is available switch the reference clock to XOSC then select it as the timer clock by setting POWMAN_TIMER_USE_XOSC=1</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NONSEC_WRITE</name>
                            <description>Control whether Non-secure software can write to the timer registers. All other registers are hardwired to be inaccessible to Non-secure.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PWRUP0</name>
                    <description>4 GPIO powerup events can be configured to wake the chip up from a low power state.
                        The pwrups are level/edge sensitive and can be set to trigger on a high/rising or low/falling event
                        The number of gpios available depends on the package option. An invalid selection will be ignored
                        source = 0 selects gpio0
                        .
                        .
                        source = 47 selects gpio47
                        source = 48 selects qspi_ss
                        source = 49 selects qspi_sd0
                        source = 50 selects qspi_sd1
                        source = 51 selects qspi_sd2
                        source = 52 selects qspi_sd3
                        source = 53 selects qspi_sclk
                        level  = 0 triggers the pwrup when the source is low
                        level  = 1 triggers the pwrup when the source is high</description>
                    <addressOffset>0x8C</addressOffset>
                    <resetValue>0x0000003F</resetValue>
                    <fields>
                        <field>
                            <name>RAW_STATUS</name>
                            <description>Value of selected gpio pin (only if enable == 1)</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>STATUS</name>
                            <description>Status of gpio wakeup. Write to 1 to clear a latched edge detect.</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>MODE</name>
                            <description>Edge or level detect. Edge will detect a 0 to 1 transition (or 1 to 0 transition). Level will detect a 1 or 0. Both types of event get latched into the current_pwrup_req register.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>level</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>edge</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DIRECTION</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>low_falling</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>high_rising</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>Set to 1 to enable the wakeup source. Set to 0 to disable the wakeup source and clear a pending wakeup event.
                                If using edge detect a latched edge needs to be cleared by writing 1 to the status register also.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SOURCE</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PWRUP1</name>
                    <description>4 GPIO powerup events can be configured to wake the chip up from a low power state.
                        The pwrups are level/edge sensitive and can be set to trigger on a high/rising or low/falling event
                        The number of gpios available depends on the package option. An invalid selection will be ignored
                        source = 0 selects gpio0
                        .
                        .
                        source = 47 selects gpio47
                        source = 48 selects qspi_ss
                        source = 49 selects qspi_sd0
                        source = 50 selects qspi_sd1
                        source = 51 selects qspi_sd2
                        source = 52 selects qspi_sd3
                        source = 53 selects qspi_sclk
                        level  = 0 triggers the pwrup when the source is low
                        level  = 1 triggers the pwrup when the source is high</description>
                    <addressOffset>0x90</addressOffset>
                    <resetValue>0x0000003F</resetValue>
                    <fields>
                        <field>
                            <name>RAW_STATUS</name>
                            <description>Value of selected gpio pin (only if enable == 1)</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>STATUS</name>
                            <description>Status of gpio wakeup. Write to 1 to clear a latched edge detect.</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>MODE</name>
                            <description>Edge or level detect. Edge will detect a 0 to 1 transition (or 1 to 0 transition). Level will detect a 1 or 0. Both types of event get latched into the current_pwrup_req register.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>level</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>edge</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DIRECTION</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>low_falling</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>high_rising</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>Set to 1 to enable the wakeup source. Set to 0 to disable the wakeup source and clear a pending wakeup event.
                                If using edge detect a latched edge needs to be cleared by writing 1 to the status register also.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SOURCE</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PWRUP2</name>
                    <description>4 GPIO powerup events can be configured to wake the chip up from a low power state.
                        The pwrups are level/edge sensitive and can be set to trigger on a high/rising or low/falling event
                        The number of gpios available depends on the package option. An invalid selection will be ignored
                        source = 0 selects gpio0
                        .
                        .
                        source = 47 selects gpio47
                        source = 48 selects qspi_ss
                        source = 49 selects qspi_sd0
                        source = 50 selects qspi_sd1
                        source = 51 selects qspi_sd2
                        source = 52 selects qspi_sd3
                        source = 53 selects qspi_sclk
                        level  = 0 triggers the pwrup when the source is low
                        level  = 1 triggers the pwrup when the source is high</description>
                    <addressOffset>0x94</addressOffset>
                    <resetValue>0x0000003F</resetValue>
                    <fields>
                        <field>
                            <name>RAW_STATUS</name>
                            <description>Value of selected gpio pin (only if enable == 1)</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>STATUS</name>
                            <description>Status of gpio wakeup. Write to 1 to clear a latched edge detect.</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>MODE</name>
                            <description>Edge or level detect. Edge will detect a 0 to 1 transition (or 1 to 0 transition). Level will detect a 1 or 0. Both types of event get latched into the current_pwrup_req register.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>level</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>edge</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DIRECTION</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>low_falling</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>high_rising</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>Set to 1 to enable the wakeup source. Set to 0 to disable the wakeup source and clear a pending wakeup event.
                                If using edge detect a latched edge needs to be cleared by writing 1 to the status register also.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SOURCE</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PWRUP3</name>
                    <description>4 GPIO powerup events can be configured to wake the chip up from a low power state.
                        The pwrups are level/edge sensitive and can be set to trigger on a high/rising or low/falling event
                        The number of gpios available depends on the package option. An invalid selection will be ignored
                        source = 0 selects gpio0
                        .
                        .
                        source = 47 selects gpio47
                        source = 48 selects qspi_ss
                        source = 49 selects qspi_sd0
                        source = 50 selects qspi_sd1
                        source = 51 selects qspi_sd2
                        source = 52 selects qspi_sd3
                        source = 53 selects qspi_sclk
                        level  = 0 triggers the pwrup when the source is low
                        level  = 1 triggers the pwrup when the source is high</description>
                    <addressOffset>0x98</addressOffset>
                    <resetValue>0x0000003F</resetValue>
                    <fields>
                        <field>
                            <name>RAW_STATUS</name>
                            <description>Value of selected gpio pin (only if enable == 1)</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>STATUS</name>
                            <description>Status of gpio wakeup. Write to 1 to clear a latched edge detect.</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>MODE</name>
                            <description>Edge or level detect. Edge will detect a 0 to 1 transition (or 1 to 0 transition). Level will detect a 1 or 0. Both types of event get latched into the current_pwrup_req register.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>level</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>edge</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DIRECTION</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>low_falling</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>high_rising</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>Set to 1 to enable the wakeup source. Set to 0 to disable the wakeup source and clear a pending wakeup event.
                                If using edge detect a latched edge needs to be cleared by writing 1 to the status register also.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SOURCE</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CURRENT_PWRUP_REQ</name>
                    <description>Indicates current powerup request state
                        pwrup events can be cleared by removing the enable from the pwrup register. The alarm pwrup req can be cleared by clearing timer.alarm_enab
                        0 = chip reset, for the source of the last reset see POWMAN_CHIP_RESET
                        1 = pwrup0
                        2 = pwrup1
                        3 = pwrup2
                        4 = pwrup3
                        5 = coresight_pwrup
                        6 = alarm_pwrup</description>
                    <addressOffset>0x9C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CURRENT_PWRUP_REQ</name>
                            <bitRange>[6:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>LAST_SWCORE_PWRUP</name>
                    <description>Indicates which pwrup source triggered the last switched-core power up
                        0 = chip reset, for the source of the last reset see POWMAN_CHIP_RESET
                        1 = pwrup0
                        2 = pwrup1
                        3 = pwrup2
                        4 = pwrup3
                        5 = coresight_pwrup
                        6 = alarm_pwrup</description>
                    <addressOffset>0xA0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>LAST_SWCORE_PWRUP</name>
                            <bitRange>[6:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DBG_PWRCFG</name>
                    <addressOffset>0xA4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>IGNORE</name>
                            <description>Ignore pwrup req from debugger. If pwrup req is asserted then this will prevent power down and set powerdown blocked. Set ignore to stop paying attention to pwrup_req</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTDIS</name>
                    <description>Tell the bootrom to ignore the BOOT0..3 registers following the next RSM reset (e.g. the next core power down/up).

                        If an early boot stage has soft-locked some OTP pages in order to protect their contents from later stages, there is a risk that Secure code running at a later stage can unlock the pages by powering the core up and down.

                        This register can be used to ensure that the bootloader runs as normal on the next power up, preventing Secure code at a later stage from accessing OTP in its unlocked state.

                        Should be used in conjunction with the OTP BOOTDIS register.</description>
                    <addressOffset>0xA8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NEXT</name>
                            <description>This flag always ORs writes into its current contents. It can be set but not cleared by software.

                                The BOOTDIS_NEXT bit is OR'd into the BOOTDIS_NOW bit when the core is powered down. Simultaneously, the BOOTDIS_NEXT bit is cleared. Setting this bit means that the BOOT0..3 registers will be ignored following the next reset of the RSM by powman.

                                This flag should be set by an early boot stage that has soft-locked OTP pages, to prevent later stages from unlocking it by power cycling.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NOW</name>
                            <description>When powman resets the RSM, the current value of BOOTDIS_NEXT is OR'd into BOOTDIS_NOW, and BOOTDIS_NEXT is cleared.

                                The bootrom checks this flag before reading the BOOT0..3 registers. If it is set, the bootrom clears it, and ignores the BOOT registers. This prevents Secure software from diverting the boot path before a bootloader has had the chance to soft lock OTP pages containing sensitive data.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DBGCONFIG</name>
                    <addressOffset>0xAC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DP_INSTID</name>
                            <description>Configure DP instance ID for SWD multidrop selection.
                                Recommend that this is NOT changed until you require debug access in multi-chip environment</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SCRATCH0</name>
                    <description>Scratch register. Information persists in low power mode</description>
                    <addressOffset>0xB0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SCRATCH0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SCRATCH1</name>
                    <description>Scratch register. Information persists in low power mode</description>
                    <addressOffset>0xB4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SCRATCH1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SCRATCH2</name>
                    <description>Scratch register. Information persists in low power mode</description>
                    <addressOffset>0xB8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SCRATCH2</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SCRATCH3</name>
                    <description>Scratch register. Information persists in low power mode</description>
                    <addressOffset>0xBC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SCRATCH3</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SCRATCH4</name>
                    <description>Scratch register. Information persists in low power mode</description>
                    <addressOffset>0xC0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SCRATCH4</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SCRATCH5</name>
                    <description>Scratch register. Information persists in low power mode</description>
                    <addressOffset>0xC4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SCRATCH5</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SCRATCH6</name>
                    <description>Scratch register. Information persists in low power mode</description>
                    <addressOffset>0xC8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SCRATCH6</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SCRATCH7</name>
                    <description>Scratch register. Information persists in low power mode</description>
                    <addressOffset>0xCC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SCRATCH7</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOT0</name>
                    <description>Scratch register. Information persists in low power mode</description>
                    <addressOffset>0xD0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BOOT0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOT1</name>
                    <description>Scratch register. Information persists in low power mode</description>
                    <addressOffset>0xD4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BOOT1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOT2</name>
                    <description>Scratch register. Information persists in low power mode</description>
                    <addressOffset>0xD8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BOOT2</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOT3</name>
                    <description>Scratch register. Information persists in low power mode</description>
                    <addressOffset>0xDC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BOOT3</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTR</name>
                    <description>Raw Interrupts</description>
                    <addressOffset>0xE0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PWRUP_WHILE_WAITING</name>
                            <description>Source is state.pwrup_while_waiting</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>STATE_REQ_IGNORED</name>
                            <description>Source is state.req_ignored</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TIMER</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VREG_OUTPUT_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTE</name>
                    <description>Interrupt Enable</description>
                    <addressOffset>0xE4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PWRUP_WHILE_WAITING</name>
                            <description>Source is state.pwrup_while_waiting</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>STATE_REQ_IGNORED</name>
                            <description>Source is state.req_ignored</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TIMER</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VREG_OUTPUT_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTF</name>
                    <description>Interrupt Force</description>
                    <addressOffset>0xE8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PWRUP_WHILE_WAITING</name>
                            <description>Source is state.pwrup_while_waiting</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>STATE_REQ_IGNORED</name>
                            <description>Source is state.req_ignored</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TIMER</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VREG_OUTPUT_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTS</name>
                    <description>Interrupt status after masking &amp; forcing</description>
                    <addressOffset>0xEC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PWRUP_WHILE_WAITING</name>
                            <description>Source is state.pwrup_while_waiting</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>STATE_REQ_IGNORED</name>
                            <description>Source is state.req_ignored</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TIMER</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VREG_OUTPUT_LOW</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>WATCHDOG</name>
            <baseAddress>0x400D8000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x2C</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>CTRL</name>
                    <description>Watchdog control
                        The rst_wdsel register determines which subsystems are reset when the watchdog is triggered.
                        The watchdog can be triggered in software.</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x07000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIGGER</name>
                            <description>Trigger a watchdog reset</description>
                            <bitRange>[31:31]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>When not enabled the watchdog timer is paused</description>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PAUSE_DBG1</name>
                            <description>Pause the watchdog timer when processor 1 is in debug mode</description>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PAUSE_DBG0</name>
                            <description>Pause the watchdog timer when processor 0 is in debug mode</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PAUSE_JTAG</name>
                            <description>Pause the watchdog timer when JTAG is accessing the bus fabric</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TIME</name>
                            <description>Indicates the time in usec before a watchdog reset will be triggered</description>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>LOAD</name>
                    <description>Load the watchdog timer. The maximum setting is 0xffffff which corresponds to approximately 16 seconds.</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>LOAD</name>
                            <bitRange>[23:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>REASON</name>
                    <description>Logs the reason for the last reset. Both bits are zero for the case of a hardware reset.

                        Additionally, as of RP2350, a debugger warm reset of either core (SYSRESETREQ or hartreset) will also clear the watchdog reason register, so that software loaded under the debugger following a watchdog timeout will not continue to see the timeout condition.</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FORCE</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TIMER</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SCRATCH0</name>
                    <description>Scratch register. Information persists through soft reset of the chip.</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SCRATCH0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SCRATCH1</name>
                    <description>Scratch register. Information persists through soft reset of the chip.</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SCRATCH1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SCRATCH2</name>
                    <description>Scratch register. Information persists through soft reset of the chip.</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SCRATCH2</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SCRATCH3</name>
                    <description>Scratch register. Information persists through soft reset of the chip.</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SCRATCH3</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SCRATCH4</name>
                    <description>Scratch register. Information persists through soft reset of the chip.</description>
                    <addressOffset>0x1C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SCRATCH4</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SCRATCH5</name>
                    <description>Scratch register. Information persists through soft reset of the chip.</description>
                    <addressOffset>0x20</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SCRATCH5</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SCRATCH6</name>
                    <description>Scratch register. Information persists through soft reset of the chip.</description>
                    <addressOffset>0x24</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SCRATCH6</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SCRATCH7</name>
                    <description>Scratch register. Information persists through soft reset of the chip.</description>
                    <addressOffset>0x28</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SCRATCH7</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>DMA</name>
            <description>DMA with separate read and write masters</description>
            <baseAddress>0x50000000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0xBC8</size>
                <usage>registers</usage>
            </addressBlock>
            <interrupt>
                <name>DMA_IRQ_0</name>
                <value>10</value>
            </interrupt>
            <interrupt>
                <name>DMA_IRQ_1</name>
                <value>11</value>
            </interrupt>
            <interrupt>
                <name>DMA_IRQ_2</name>
                <value>12</value>
            </interrupt>
            <interrupt>
                <name>DMA_IRQ_3</name>
                <value>13</value>
            </interrupt>
            <registers>
                <cluster>
                    <dim>16</dim>
                    <dimIncrement>0x40</dimIncrement>
                    <dimIndex>0-15</dimIndex>
                    <name>CH%s</name>
                    <description>Cluster CH%s, containing CH?_READ_ADDR,CH??_READ_ADDR, CH?_WRITE_ADDR,CH??_WRITE_ADDR, CH?_TRANS_COUNT,CH??_TRANS_COUNT, CH?_CTRL_TRIG,CH??_CTRL_TRIG, CH?_AL1_CTRL,CH??_AL1_CTRL, CH?_AL1_READ_ADDR,CH??_AL1_READ_ADDR, CH?_AL1_WRITE_ADDR,CH??_AL1_WRITE_ADDR, CH?_AL1_TRANS_COUNT_TRIG,CH??_AL1_TRANS_COUNT_TRIG, CH?_AL2_CTRL,CH??_AL2_CTRL, CH?_AL2_TRANS_COUNT,CH??_AL2_TRANS_COUNT, CH?_AL2_READ_ADDR,CH??_AL2_READ_ADDR, CH?_AL2_WRITE_ADDR_TRIG,CH??_AL2_WRITE_ADDR_TRIG, CH?_AL3_CTRL,CH??_AL3_CTRL, CH?_AL3_WRITE_ADDR,CH??_AL3_WRITE_ADDR, CH?_AL3_TRANS_COUNT,CH??_AL3_TRANS_COUNT, CH?_AL3_READ_ADDR_TRIG,CH??_AL3_READ_ADDR_TRIG</description>
                    <addressOffset>0x0</addressOffset>
                    <register>
                        <name>CH_READ_ADDR</name>
                        <description>DMA Channel 0 Read Address pointer</description>
                        <addressOffset>0x0</addressOffset>
                        <resetValue>0x00000000</resetValue>
                        <fields>
                            <field>
                                <name>CH0_READ_ADDR</name>
                                <description>This register updates automatically each time a read completes. The current value is the next address to be read by this channel.</description>
                                <bitRange>[31:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>CH_WRITE_ADDR</name>
                        <description>DMA Channel 0 Write Address pointer</description>
                        <addressOffset>0x4</addressOffset>
                        <resetValue>0x00000000</resetValue>
                        <fields>
                            <field>
                                <name>CH0_WRITE_ADDR</name>
                                <description>This register updates automatically each time a write completes. The current value is the next address to be written by this channel.</description>
                                <bitRange>[31:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>CH_TRANS_COUNT</name>
                        <description>DMA Channel 0 Transfer Count</description>
                        <addressOffset>0x8</addressOffset>
                        <resetValue>0x00000000</resetValue>
                        <fields>
                            <field>
                                <name>MODE</name>
                                <description>When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO.

                                    When MODE is 0x1, the transfer count decrements with each transfer until 0, and then the channel re-triggers itself, in addition to the trigger indicated by CTRL_CHAIN_TO. This is useful for e.g. an endless ring-buffer DMA with periodic interrupts.

                                    When MODE is 0xf, the transfer count does not decrement. The DMA channel performs an endless sequence of transfers, never triggering other channels or raising interrupts, until an ABORT is raised.

                                    All other values are reserved.</description>
                                <bitRange>[31:28]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>NORMAL</name>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>TRIGGER_SELF</name>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>ENDLESS</name>
                                        <value>15</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>COUNT</name>
                                <description>28-bit transfer count (256 million transfers maximum).

                                    Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).

                                    When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.

                                    Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.

                                    The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.</description>
                                <bitRange>[27:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>CH_CTRL_TRIG</name>
                        <description>DMA Channel 0 Control and Status</description>
                        <addressOffset>0xC</addressOffset>
                        <resetValue>0x00000000</resetValue>
                        <fields>
                            <field>
                                <name>AHB_ERROR</name>
                                <description>Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.</description>
                                <bitRange>[31:31]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>READ_ERROR</name>
                                <description>If 1, the channel received a read bus error. Write one to clear.
                                    READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)</description>
                                <bitRange>[30:30]</bitRange>
                                <access>read-write</access>
                                <modifiedWriteValues>oneToClear</modifiedWriteValues>
                            </field>
                            <field>
                                <name>WRITE_ERROR</name>
                                <description>If 1, the channel received a write bus error. Write one to clear.
                                    WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)</description>
                                <bitRange>[29:29]</bitRange>
                                <access>read-write</access>
                                <modifiedWriteValues>oneToClear</modifiedWriteValues>
                            </field>
                            <field>
                                <name>BUSY</name>
                                <description>This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.

                                    To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.</description>
                                <bitRange>[26:26]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SNIFF_EN</name>
                                <description>If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.

                                    This allows checksum to be enabled or disabled on a per-control- block basis.</description>
                                <bitRange>[25:25]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>BSWAP</name>
                                <description>Apply byte-swap transformation to DMA data.
                                    For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.</description>
                                <bitRange>[24:24]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>IRQ_QUIET</name>
                                <description>In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.

                                    This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.</description>
                                <bitRange>[23:23]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>TREQ_SEL</name>
                                <description>Select a Transfer Request signal.
                                    The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).
                                    0x0 to 0x3a -&gt; select DREQ n as TREQ</description>
                                <bitRange>[22:17]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <name>TREQ_SEL</name>
                                    <enumeratedValue>
                                        <name>PIO0_TX0</name>
                                        <description>Select PIO0's TX FIFO 0 as TREQ</description>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_TX1</name>
                                        <description>Select PIO0's TX FIFO 1 as TREQ</description>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_TX2</name>
                                        <description>Select PIO0's TX FIFO 2 as TREQ</description>
                                        <value>2</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_TX3</name>
                                        <description>Select PIO0's TX FIFO 3 as TREQ</description>
                                        <value>3</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_RX0</name>
                                        <description>Select PIO0's RX FIFO 0 as TREQ</description>
                                        <value>4</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_RX1</name>
                                        <description>Select PIO0's RX FIFO 1 as TREQ</description>
                                        <value>5</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_RX2</name>
                                        <description>Select PIO0's RX FIFO 2 as TREQ</description>
                                        <value>6</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_RX3</name>
                                        <description>Select PIO0's RX FIFO 3 as TREQ</description>
                                        <value>7</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_TX0</name>
                                        <description>Select PIO1's TX FIFO 0 as TREQ</description>
                                        <value>8</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_TX1</name>
                                        <description>Select PIO1's TX FIFO 1 as TREQ</description>
                                        <value>9</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_TX2</name>
                                        <description>Select PIO1's TX FIFO 2 as TREQ</description>
                                        <value>10</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_TX3</name>
                                        <description>Select PIO1's TX FIFO 3 as TREQ</description>
                                        <value>11</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_RX0</name>
                                        <description>Select PIO1's RX FIFO 0 as TREQ</description>
                                        <value>12</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_RX1</name>
                                        <description>Select PIO1's RX FIFO 1 as TREQ</description>
                                        <value>13</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_RX2</name>
                                        <description>Select PIO1's RX FIFO 2 as TREQ</description>
                                        <value>14</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_RX3</name>
                                        <description>Select PIO1's RX FIFO 3 as TREQ</description>
                                        <value>15</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_TX0</name>
                                        <description>Select PIO2's TX FIFO 0 as TREQ</description>
                                        <value>16</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_TX1</name>
                                        <description>Select PIO2's TX FIFO 1 as TREQ</description>
                                        <value>17</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_TX2</name>
                                        <description>Select PIO2's TX FIFO 2 as TREQ</description>
                                        <value>18</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_TX3</name>
                                        <description>Select PIO2's TX FIFO 3 as TREQ</description>
                                        <value>19</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_RX0</name>
                                        <description>Select PIO2's RX FIFO 0 as TREQ</description>
                                        <value>20</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_RX1</name>
                                        <description>Select PIO2's RX FIFO 1 as TREQ</description>
                                        <value>21</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_RX2</name>
                                        <description>Select PIO2's RX FIFO 2 as TREQ</description>
                                        <value>22</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_RX3</name>
                                        <description>Select PIO2's RX FIFO 3 as TREQ</description>
                                        <value>23</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SPI0_TX</name>
                                        <description>Select SPI0's TX FIFO as TREQ</description>
                                        <value>24</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SPI0_RX</name>
                                        <description>Select SPI0's RX FIFO as TREQ</description>
                                        <value>25</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SPI1_TX</name>
                                        <description>Select SPI1's TX FIFO as TREQ</description>
                                        <value>26</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SPI1_RX</name>
                                        <description>Select SPI1's RX FIFO as TREQ</description>
                                        <value>27</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>UART0_TX</name>
                                        <description>Select UART0's TX FIFO as TREQ</description>
                                        <value>28</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>UART0_RX</name>
                                        <description>Select UART0's RX FIFO as TREQ</description>
                                        <value>29</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>UART1_TX</name>
                                        <description>Select UART1's TX FIFO as TREQ</description>
                                        <value>30</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>UART1_RX</name>
                                        <description>Select UART1's RX FIFO as TREQ</description>
                                        <value>31</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP0</name>
                                        <description>Select PWM Counter 0's Wrap Value as TREQ</description>
                                        <value>32</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP1</name>
                                        <description>Select PWM Counter 1's Wrap Value as TREQ</description>
                                        <value>33</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP2</name>
                                        <description>Select PWM Counter 2's Wrap Value as TREQ</description>
                                        <value>34</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP3</name>
                                        <description>Select PWM Counter 3's Wrap Value as TREQ</description>
                                        <value>35</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP4</name>
                                        <description>Select PWM Counter 4's Wrap Value as TREQ</description>
                                        <value>36</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP5</name>
                                        <description>Select PWM Counter 5's Wrap Value as TREQ</description>
                                        <value>37</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP6</name>
                                        <description>Select PWM Counter 6's Wrap Value as TREQ</description>
                                        <value>38</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP7</name>
                                        <description>Select PWM Counter 7's Wrap Value as TREQ</description>
                                        <value>39</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP8</name>
                                        <description>Select PWM Counter 8's Wrap Value as TREQ</description>
                                        <value>40</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP9</name>
                                        <description>Select PWM Counter 9's Wrap Value as TREQ</description>
                                        <value>41</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP10</name>
                                        <description>Select PWM Counter 10's Wrap Value as TREQ</description>
                                        <value>42</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP11</name>
                                        <description>Select PWM Counter 11's Wrap Value as TREQ</description>
                                        <value>43</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>I2C0_TX</name>
                                        <description>Select I2C0's TX FIFO as TREQ</description>
                                        <value>44</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>I2C0_RX</name>
                                        <description>Select I2C0's RX FIFO as TREQ</description>
                                        <value>45</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>I2C1_TX</name>
                                        <description>Select I2C1's TX FIFO as TREQ</description>
                                        <value>46</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>I2C1_RX</name>
                                        <description>Select I2C1's RX FIFO as TREQ</description>
                                        <value>47</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>ADC</name>
                                        <description>Select ADC as TREQ</description>
                                        <value>48</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>XIP_STREAM</name>
                                        <description>Select XIP_STREAM as TREQ</description>
                                        <value>49</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>XIP_QMITX</name>
                                        <description>Select XIP_QMI's TX FIFO as TREQ</description>
                                        <value>50</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>XIP_QMIRX</name>
                                        <description>Select XIP_QMI's RX FIFO as TREQ</description>
                                        <value>51</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>HSTX</name>
                                        <description>Select HSTX as TREQ</description>
                                        <value>52</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>CORESIGHT</name>
                                        <description>Select CORESIGHT as TREQ</description>
                                        <value>53</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SHA256</name>
                                        <description>Select SHA256 as TREQ</description>
                                        <value>54</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>TIMER0</name>
                                        <description>Select Timer 0 as TREQ</description>
                                        <value>59</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>TIMER1</name>
                                        <description>Select Timer 1 as TREQ</description>
                                        <value>60</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>TIMER2</name>
                                        <description>Select Timer 2 as TREQ (Optional)</description>
                                        <value>61</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>TIMER3</name>
                                        <description>Select Timer 3 as TREQ (Optional)</description>
                                        <value>62</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PERMANENT</name>
                                        <description>Permanent request, for unpaced transfers.</description>
                                        <value>63</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>CHAIN_TO</name>
                                <description>When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. \n Reset value is 0, which means for channels 1 and above the default will be to chain to channel 0 - set this field to avoid this behaviour.</description>
                                <bitRange>[16:13]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>RING_SEL</name>
                                <description>Select whether RING_SIZE applies to read or write addresses.
                                    If 0, read addresses are wrapped on a (1 &lt;&lt; RING_SIZE) boundary. If 1, write addresses are wrapped.</description>
                                <bitRange>[12:12]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>RING_SIZE</name>
                                <description>Size of address wrap region. If 0, don't wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.

                                    Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.</description>
                                <bitRange>[11:8]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>RING_NONE</name>
                                        <value>0</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>INCR_WRITE_REV</name>
                                <description>If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.

                                    If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.</description>
                                <bitRange>[7:7]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>INCR_WRITE</name>
                                <description>If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.

                                    Generally this should be disabled for memory-to-peripheral transfers.</description>
                                <bitRange>[6:6]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>INCR_READ_REV</name>
                                <description>If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.

                                    If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.</description>
                                <bitRange>[5:5]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>INCR_READ</name>
                                <description>If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.

                                    Generally this should be disabled for peripheral-to-memory transfers.</description>
                                <bitRange>[4:4]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>DATA_SIZE</name>
                                <description>Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.</description>
                                <bitRange>[3:2]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>SIZE_BYTE</name>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SIZE_HALFWORD</name>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SIZE_WORD</name>
                                        <value>2</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>HIGH_PRIORITY</name>
                                <description>HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.

                                    This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.</description>
                                <bitRange>[1:1]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>EN</name>
                                <description>DMA Channel Enable.
                                    When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)</description>
                                <bitRange>[0:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>CH_AL1_CTRL</name>
                        <description>DMA Channel 0 Control and Status</description>
                        <addressOffset>0x10</addressOffset>
                        <resetValue>0x00000000</resetValue>
                        <fields>
                            <field>
                                <name>AHB_ERROR</name>
                                <description>Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.</description>
                                <bitRange>[31:31]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>READ_ERROR</name>
                                <description>If 1, the channel received a read bus error. Write one to clear.
                                    READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)</description>
                                <bitRange>[30:30]</bitRange>
                                <access>read-write</access>
                                <modifiedWriteValues>oneToClear</modifiedWriteValues>
                            </field>
                            <field>
                                <name>WRITE_ERROR</name>
                                <description>If 1, the channel received a write bus error. Write one to clear.
                                    WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)</description>
                                <bitRange>[29:29]</bitRange>
                                <access>read-write</access>
                                <modifiedWriteValues>oneToClear</modifiedWriteValues>
                            </field>
                            <field>
                                <name>BUSY</name>
                                <description>This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.

                                    To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.</description>
                                <bitRange>[26:26]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SNIFF_EN</name>
                                <description>If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.

                                    This allows checksum to be enabled or disabled on a per-control- block basis.</description>
                                <bitRange>[25:25]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>BSWAP</name>
                                <description>Apply byte-swap transformation to DMA data.
                                    For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.</description>
                                <bitRange>[24:24]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>IRQ_QUIET</name>
                                <description>In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.

                                    This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.</description>
                                <bitRange>[23:23]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>TREQ_SEL</name>
                                <description>Select a Transfer Request signal.
                                    The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).
                                    0x0 to 0x3a -&gt; select DREQ n as TREQ</description>
                                <bitRange>[22:17]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <name>TREQ_SEL</name>
                                    <enumeratedValue>
                                        <name>PIO0_TX0</name>
                                        <description>Select PIO0's TX FIFO 0 as TREQ</description>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_TX1</name>
                                        <description>Select PIO0's TX FIFO 1 as TREQ</description>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_TX2</name>
                                        <description>Select PIO0's TX FIFO 2 as TREQ</description>
                                        <value>2</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_TX3</name>
                                        <description>Select PIO0's TX FIFO 3 as TREQ</description>
                                        <value>3</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_RX0</name>
                                        <description>Select PIO0's RX FIFO 0 as TREQ</description>
                                        <value>4</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_RX1</name>
                                        <description>Select PIO0's RX FIFO 1 as TREQ</description>
                                        <value>5</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_RX2</name>
                                        <description>Select PIO0's RX FIFO 2 as TREQ</description>
                                        <value>6</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_RX3</name>
                                        <description>Select PIO0's RX FIFO 3 as TREQ</description>
                                        <value>7</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_TX0</name>
                                        <description>Select PIO1's TX FIFO 0 as TREQ</description>
                                        <value>8</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_TX1</name>
                                        <description>Select PIO1's TX FIFO 1 as TREQ</description>
                                        <value>9</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_TX2</name>
                                        <description>Select PIO1's TX FIFO 2 as TREQ</description>
                                        <value>10</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_TX3</name>
                                        <description>Select PIO1's TX FIFO 3 as TREQ</description>
                                        <value>11</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_RX0</name>
                                        <description>Select PIO1's RX FIFO 0 as TREQ</description>
                                        <value>12</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_RX1</name>
                                        <description>Select PIO1's RX FIFO 1 as TREQ</description>
                                        <value>13</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_RX2</name>
                                        <description>Select PIO1's RX FIFO 2 as TREQ</description>
                                        <value>14</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_RX3</name>
                                        <description>Select PIO1's RX FIFO 3 as TREQ</description>
                                        <value>15</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_TX0</name>
                                        <description>Select PIO2's TX FIFO 0 as TREQ</description>
                                        <value>16</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_TX1</name>
                                        <description>Select PIO2's TX FIFO 1 as TREQ</description>
                                        <value>17</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_TX2</name>
                                        <description>Select PIO2's TX FIFO 2 as TREQ</description>
                                        <value>18</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_TX3</name>
                                        <description>Select PIO2's TX FIFO 3 as TREQ</description>
                                        <value>19</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_RX0</name>
                                        <description>Select PIO2's RX FIFO 0 as TREQ</description>
                                        <value>20</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_RX1</name>
                                        <description>Select PIO2's RX FIFO 1 as TREQ</description>
                                        <value>21</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_RX2</name>
                                        <description>Select PIO2's RX FIFO 2 as TREQ</description>
                                        <value>22</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_RX3</name>
                                        <description>Select PIO2's RX FIFO 3 as TREQ</description>
                                        <value>23</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SPI0_TX</name>
                                        <description>Select SPI0's TX FIFO as TREQ</description>
                                        <value>24</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SPI0_RX</name>
                                        <description>Select SPI0's RX FIFO as TREQ</description>
                                        <value>25</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SPI1_TX</name>
                                        <description>Select SPI1's TX FIFO as TREQ</description>
                                        <value>26</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SPI1_RX</name>
                                        <description>Select SPI1's RX FIFO as TREQ</description>
                                        <value>27</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>UART0_TX</name>
                                        <description>Select UART0's TX FIFO as TREQ</description>
                                        <value>28</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>UART0_RX</name>
                                        <description>Select UART0's RX FIFO as TREQ</description>
                                        <value>29</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>UART1_TX</name>
                                        <description>Select UART1's TX FIFO as TREQ</description>
                                        <value>30</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>UART1_RX</name>
                                        <description>Select UART1's RX FIFO as TREQ</description>
                                        <value>31</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP0</name>
                                        <description>Select PWM Counter 0's Wrap Value as TREQ</description>
                                        <value>32</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP1</name>
                                        <description>Select PWM Counter 1's Wrap Value as TREQ</description>
                                        <value>33</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP2</name>
                                        <description>Select PWM Counter 2's Wrap Value as TREQ</description>
                                        <value>34</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP3</name>
                                        <description>Select PWM Counter 3's Wrap Value as TREQ</description>
                                        <value>35</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP4</name>
                                        <description>Select PWM Counter 4's Wrap Value as TREQ</description>
                                        <value>36</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP5</name>
                                        <description>Select PWM Counter 5's Wrap Value as TREQ</description>
                                        <value>37</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP6</name>
                                        <description>Select PWM Counter 6's Wrap Value as TREQ</description>
                                        <value>38</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP7</name>
                                        <description>Select PWM Counter 7's Wrap Value as TREQ</description>
                                        <value>39</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP8</name>
                                        <description>Select PWM Counter 8's Wrap Value as TREQ</description>
                                        <value>40</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP9</name>
                                        <description>Select PWM Counter 9's Wrap Value as TREQ</description>
                                        <value>41</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP10</name>
                                        <description>Select PWM Counter 10's Wrap Value as TREQ</description>
                                        <value>42</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP11</name>
                                        <description>Select PWM Counter 11's Wrap Value as TREQ</description>
                                        <value>43</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>I2C0_TX</name>
                                        <description>Select I2C0's TX FIFO as TREQ</description>
                                        <value>44</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>I2C0_RX</name>
                                        <description>Select I2C0's RX FIFO as TREQ</description>
                                        <value>45</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>I2C1_TX</name>
                                        <description>Select I2C1's TX FIFO as TREQ</description>
                                        <value>46</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>I2C1_RX</name>
                                        <description>Select I2C1's RX FIFO as TREQ</description>
                                        <value>47</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>ADC</name>
                                        <description>Select ADC as TREQ</description>
                                        <value>48</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>XIP_STREAM</name>
                                        <description>Select XIP_STREAM as TREQ</description>
                                        <value>49</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>XIP_QMITX</name>
                                        <description>Select XIP_QMI's TX FIFO as TREQ</description>
                                        <value>50</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>XIP_QMIRX</name>
                                        <description>Select XIP_QMI's RX FIFO as TREQ</description>
                                        <value>51</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>HSTX</name>
                                        <description>Select HSTX as TREQ</description>
                                        <value>52</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>CORESIGHT</name>
                                        <description>Select CORESIGHT as TREQ</description>
                                        <value>53</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SHA256</name>
                                        <description>Select SHA256 as TREQ</description>
                                        <value>54</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>TIMER0</name>
                                        <description>Select Timer 0 as TREQ</description>
                                        <value>59</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>TIMER1</name>
                                        <description>Select Timer 1 as TREQ</description>
                                        <value>60</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>TIMER2</name>
                                        <description>Select Timer 2 as TREQ (Optional)</description>
                                        <value>61</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>TIMER3</name>
                                        <description>Select Timer 3 as TREQ (Optional)</description>
                                        <value>62</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PERMANENT</name>
                                        <description>Permanent request, for unpaced transfers.</description>
                                        <value>63</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>CHAIN_TO</name>
                                <description>When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. \n Reset value is 0, which means for channels 1 and above the default will be to chain to channel 0 - set this field to avoid this behaviour.</description>
                                <bitRange>[16:13]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>RING_SEL</name>
                                <description>Select whether RING_SIZE applies to read or write addresses.
                                    If 0, read addresses are wrapped on a (1 &lt;&lt; RING_SIZE) boundary. If 1, write addresses are wrapped.</description>
                                <bitRange>[12:12]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>RING_SIZE</name>
                                <description>Size of address wrap region. If 0, don't wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.

                                    Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.</description>
                                <bitRange>[11:8]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>RING_NONE</name>
                                        <value>0</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>INCR_WRITE_REV</name>
                                <description>If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.

                                    If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.</description>
                                <bitRange>[7:7]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>INCR_WRITE</name>
                                <description>If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.

                                    Generally this should be disabled for memory-to-peripheral transfers.</description>
                                <bitRange>[6:6]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>INCR_READ_REV</name>
                                <description>If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.

                                    If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.</description>
                                <bitRange>[5:5]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>INCR_READ</name>
                                <description>If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.

                                    Generally this should be disabled for peripheral-to-memory transfers.</description>
                                <bitRange>[4:4]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>DATA_SIZE</name>
                                <description>Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.</description>
                                <bitRange>[3:2]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>SIZE_BYTE</name>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SIZE_HALFWORD</name>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SIZE_WORD</name>
                                        <value>2</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>HIGH_PRIORITY</name>
                                <description>HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.

                                    This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.</description>
                                <bitRange>[1:1]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>EN</name>
                                <description>DMA Channel Enable.
                                    When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)</description>
                                <bitRange>[0:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>CH_AL1_READ_ADDR</name>
                        <description>Alias for channel 0 READ_ADDR register</description>
                        <addressOffset>0x14</addressOffset>
                        <resetMask>0x00000000</resetMask>
                        <fields>
                            <field>
                                <name>CH0_AL1_READ_ADDR</name>
                                <bitRange>[31:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>CH_AL1_WRITE_ADDR</name>
                        <description>Alias for channel 0 WRITE_ADDR register</description>
                        <addressOffset>0x18</addressOffset>
                        <resetMask>0x00000000</resetMask>
                        <fields>
                            <field>
                                <name>CH0_AL1_WRITE_ADDR</name>
                                <bitRange>[31:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>CH_AL1_TRANS_COUNT_TRIG</name>
                        <description>Alias for channel 0 TRANS_COUNT register
                            This is a trigger register (0xc). Writing a nonzero value will
                            reload the channel counter and start the channel.</description>
                        <addressOffset>0x1C</addressOffset>
                        <resetMask>0x00000000</resetMask>
                        <fields>
                            <field>
                                <name>CH0_AL1_TRANS_COUNT_TRIG</name>
                                <bitRange>[31:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>CH_AL2_CTRL</name>
                        <description>DMA Channel 0 Control and Status</description>
                        <addressOffset>0x20</addressOffset>
                        <resetValue>0x00000000</resetValue>
                        <fields>
                            <field>
                                <name>AHB_ERROR</name>
                                <description>Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.</description>
                                <bitRange>[31:31]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>READ_ERROR</name>
                                <description>If 1, the channel received a read bus error. Write one to clear.
                                    READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)</description>
                                <bitRange>[30:30]</bitRange>
                                <access>read-write</access>
                                <modifiedWriteValues>oneToClear</modifiedWriteValues>
                            </field>
                            <field>
                                <name>WRITE_ERROR</name>
                                <description>If 1, the channel received a write bus error. Write one to clear.
                                    WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)</description>
                                <bitRange>[29:29]</bitRange>
                                <access>read-write</access>
                                <modifiedWriteValues>oneToClear</modifiedWriteValues>
                            </field>
                            <field>
                                <name>BUSY</name>
                                <description>This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.

                                    To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.</description>
                                <bitRange>[26:26]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SNIFF_EN</name>
                                <description>If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.

                                    This allows checksum to be enabled or disabled on a per-control- block basis.</description>
                                <bitRange>[25:25]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>BSWAP</name>
                                <description>Apply byte-swap transformation to DMA data.
                                    For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.</description>
                                <bitRange>[24:24]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>IRQ_QUIET</name>
                                <description>In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.

                                    This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.</description>
                                <bitRange>[23:23]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>TREQ_SEL</name>
                                <description>Select a Transfer Request signal.
                                    The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).
                                    0x0 to 0x3a -&gt; select DREQ n as TREQ</description>
                                <bitRange>[22:17]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <name>TREQ_SEL</name>
                                    <enumeratedValue>
                                        <name>PIO0_TX0</name>
                                        <description>Select PIO0's TX FIFO 0 as TREQ</description>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_TX1</name>
                                        <description>Select PIO0's TX FIFO 1 as TREQ</description>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_TX2</name>
                                        <description>Select PIO0's TX FIFO 2 as TREQ</description>
                                        <value>2</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_TX3</name>
                                        <description>Select PIO0's TX FIFO 3 as TREQ</description>
                                        <value>3</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_RX0</name>
                                        <description>Select PIO0's RX FIFO 0 as TREQ</description>
                                        <value>4</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_RX1</name>
                                        <description>Select PIO0's RX FIFO 1 as TREQ</description>
                                        <value>5</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_RX2</name>
                                        <description>Select PIO0's RX FIFO 2 as TREQ</description>
                                        <value>6</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_RX3</name>
                                        <description>Select PIO0's RX FIFO 3 as TREQ</description>
                                        <value>7</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_TX0</name>
                                        <description>Select PIO1's TX FIFO 0 as TREQ</description>
                                        <value>8</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_TX1</name>
                                        <description>Select PIO1's TX FIFO 1 as TREQ</description>
                                        <value>9</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_TX2</name>
                                        <description>Select PIO1's TX FIFO 2 as TREQ</description>
                                        <value>10</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_TX3</name>
                                        <description>Select PIO1's TX FIFO 3 as TREQ</description>
                                        <value>11</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_RX0</name>
                                        <description>Select PIO1's RX FIFO 0 as TREQ</description>
                                        <value>12</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_RX1</name>
                                        <description>Select PIO1's RX FIFO 1 as TREQ</description>
                                        <value>13</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_RX2</name>
                                        <description>Select PIO1's RX FIFO 2 as TREQ</description>
                                        <value>14</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_RX3</name>
                                        <description>Select PIO1's RX FIFO 3 as TREQ</description>
                                        <value>15</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_TX0</name>
                                        <description>Select PIO2's TX FIFO 0 as TREQ</description>
                                        <value>16</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_TX1</name>
                                        <description>Select PIO2's TX FIFO 1 as TREQ</description>
                                        <value>17</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_TX2</name>
                                        <description>Select PIO2's TX FIFO 2 as TREQ</description>
                                        <value>18</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_TX3</name>
                                        <description>Select PIO2's TX FIFO 3 as TREQ</description>
                                        <value>19</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_RX0</name>
                                        <description>Select PIO2's RX FIFO 0 as TREQ</description>
                                        <value>20</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_RX1</name>
                                        <description>Select PIO2's RX FIFO 1 as TREQ</description>
                                        <value>21</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_RX2</name>
                                        <description>Select PIO2's RX FIFO 2 as TREQ</description>
                                        <value>22</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_RX3</name>
                                        <description>Select PIO2's RX FIFO 3 as TREQ</description>
                                        <value>23</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SPI0_TX</name>
                                        <description>Select SPI0's TX FIFO as TREQ</description>
                                        <value>24</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SPI0_RX</name>
                                        <description>Select SPI0's RX FIFO as TREQ</description>
                                        <value>25</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SPI1_TX</name>
                                        <description>Select SPI1's TX FIFO as TREQ</description>
                                        <value>26</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SPI1_RX</name>
                                        <description>Select SPI1's RX FIFO as TREQ</description>
                                        <value>27</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>UART0_TX</name>
                                        <description>Select UART0's TX FIFO as TREQ</description>
                                        <value>28</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>UART0_RX</name>
                                        <description>Select UART0's RX FIFO as TREQ</description>
                                        <value>29</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>UART1_TX</name>
                                        <description>Select UART1's TX FIFO as TREQ</description>
                                        <value>30</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>UART1_RX</name>
                                        <description>Select UART1's RX FIFO as TREQ</description>
                                        <value>31</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP0</name>
                                        <description>Select PWM Counter 0's Wrap Value as TREQ</description>
                                        <value>32</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP1</name>
                                        <description>Select PWM Counter 1's Wrap Value as TREQ</description>
                                        <value>33</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP2</name>
                                        <description>Select PWM Counter 2's Wrap Value as TREQ</description>
                                        <value>34</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP3</name>
                                        <description>Select PWM Counter 3's Wrap Value as TREQ</description>
                                        <value>35</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP4</name>
                                        <description>Select PWM Counter 4's Wrap Value as TREQ</description>
                                        <value>36</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP5</name>
                                        <description>Select PWM Counter 5's Wrap Value as TREQ</description>
                                        <value>37</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP6</name>
                                        <description>Select PWM Counter 6's Wrap Value as TREQ</description>
                                        <value>38</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP7</name>
                                        <description>Select PWM Counter 7's Wrap Value as TREQ</description>
                                        <value>39</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP8</name>
                                        <description>Select PWM Counter 8's Wrap Value as TREQ</description>
                                        <value>40</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP9</name>
                                        <description>Select PWM Counter 9's Wrap Value as TREQ</description>
                                        <value>41</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP10</name>
                                        <description>Select PWM Counter 10's Wrap Value as TREQ</description>
                                        <value>42</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP11</name>
                                        <description>Select PWM Counter 11's Wrap Value as TREQ</description>
                                        <value>43</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>I2C0_TX</name>
                                        <description>Select I2C0's TX FIFO as TREQ</description>
                                        <value>44</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>I2C0_RX</name>
                                        <description>Select I2C0's RX FIFO as TREQ</description>
                                        <value>45</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>I2C1_TX</name>
                                        <description>Select I2C1's TX FIFO as TREQ</description>
                                        <value>46</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>I2C1_RX</name>
                                        <description>Select I2C1's RX FIFO as TREQ</description>
                                        <value>47</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>ADC</name>
                                        <description>Select ADC as TREQ</description>
                                        <value>48</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>XIP_STREAM</name>
                                        <description>Select XIP_STREAM as TREQ</description>
                                        <value>49</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>XIP_QMITX</name>
                                        <description>Select XIP_QMI's TX FIFO as TREQ</description>
                                        <value>50</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>XIP_QMIRX</name>
                                        <description>Select XIP_QMI's RX FIFO as TREQ</description>
                                        <value>51</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>HSTX</name>
                                        <description>Select HSTX as TREQ</description>
                                        <value>52</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>CORESIGHT</name>
                                        <description>Select CORESIGHT as TREQ</description>
                                        <value>53</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SHA256</name>
                                        <description>Select SHA256 as TREQ</description>
                                        <value>54</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>TIMER0</name>
                                        <description>Select Timer 0 as TREQ</description>
                                        <value>59</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>TIMER1</name>
                                        <description>Select Timer 1 as TREQ</description>
                                        <value>60</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>TIMER2</name>
                                        <description>Select Timer 2 as TREQ (Optional)</description>
                                        <value>61</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>TIMER3</name>
                                        <description>Select Timer 3 as TREQ (Optional)</description>
                                        <value>62</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PERMANENT</name>
                                        <description>Permanent request, for unpaced transfers.</description>
                                        <value>63</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>CHAIN_TO</name>
                                <description>When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. \n Reset value is 0, which means for channels 1 and above the default will be to chain to channel 0 - set this field to avoid this behaviour.</description>
                                <bitRange>[16:13]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>RING_SEL</name>
                                <description>Select whether RING_SIZE applies to read or write addresses.
                                    If 0, read addresses are wrapped on a (1 &lt;&lt; RING_SIZE) boundary. If 1, write addresses are wrapped.</description>
                                <bitRange>[12:12]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>RING_SIZE</name>
                                <description>Size of address wrap region. If 0, don't wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.

                                    Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.</description>
                                <bitRange>[11:8]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>RING_NONE</name>
                                        <value>0</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>INCR_WRITE_REV</name>
                                <description>If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.

                                    If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.</description>
                                <bitRange>[7:7]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>INCR_WRITE</name>
                                <description>If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.

                                    Generally this should be disabled for memory-to-peripheral transfers.</description>
                                <bitRange>[6:6]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>INCR_READ_REV</name>
                                <description>If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.

                                    If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.</description>
                                <bitRange>[5:5]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>INCR_READ</name>
                                <description>If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.

                                    Generally this should be disabled for peripheral-to-memory transfers.</description>
                                <bitRange>[4:4]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>DATA_SIZE</name>
                                <description>Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.</description>
                                <bitRange>[3:2]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>SIZE_BYTE</name>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SIZE_HALFWORD</name>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SIZE_WORD</name>
                                        <value>2</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>HIGH_PRIORITY</name>
                                <description>HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.

                                    This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.</description>
                                <bitRange>[1:1]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>EN</name>
                                <description>DMA Channel Enable.
                                    When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)</description>
                                <bitRange>[0:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>CH_AL2_TRANS_COUNT</name>
                        <description>Alias for channel 0 TRANS_COUNT register</description>
                        <addressOffset>0x24</addressOffset>
                        <resetMask>0x00000000</resetMask>
                        <fields>
                            <field>
                                <name>CH0_AL2_TRANS_COUNT</name>
                                <bitRange>[31:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>CH_AL2_READ_ADDR</name>
                        <description>Alias for channel 0 READ_ADDR register</description>
                        <addressOffset>0x28</addressOffset>
                        <resetMask>0x00000000</resetMask>
                        <fields>
                            <field>
                                <name>CH0_AL2_READ_ADDR</name>
                                <bitRange>[31:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>CH_AL2_WRITE_ADDR_TRIG</name>
                        <description>Alias for channel 0 WRITE_ADDR register
                            This is a trigger register (0xc). Writing a nonzero value will
                            reload the channel counter and start the channel.</description>
                        <addressOffset>0x2C</addressOffset>
                        <resetMask>0x00000000</resetMask>
                        <fields>
                            <field>
                                <name>CH0_AL2_WRITE_ADDR_TRIG</name>
                                <bitRange>[31:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>CH_AL3_CTRL</name>
                        <description>DMA Channel 0 Control and Status</description>
                        <addressOffset>0x30</addressOffset>
                        <resetValue>0x00000000</resetValue>
                        <fields>
                            <field>
                                <name>AHB_ERROR</name>
                                <description>Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.</description>
                                <bitRange>[31:31]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>READ_ERROR</name>
                                <description>If 1, the channel received a read bus error. Write one to clear.
                                    READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)</description>
                                <bitRange>[30:30]</bitRange>
                                <access>read-write</access>
                                <modifiedWriteValues>oneToClear</modifiedWriteValues>
                            </field>
                            <field>
                                <name>WRITE_ERROR</name>
                                <description>If 1, the channel received a write bus error. Write one to clear.
                                    WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)</description>
                                <bitRange>[29:29]</bitRange>
                                <access>read-write</access>
                                <modifiedWriteValues>oneToClear</modifiedWriteValues>
                            </field>
                            <field>
                                <name>BUSY</name>
                                <description>This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.

                                    To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.</description>
                                <bitRange>[26:26]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SNIFF_EN</name>
                                <description>If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.

                                    This allows checksum to be enabled or disabled on a per-control- block basis.</description>
                                <bitRange>[25:25]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>BSWAP</name>
                                <description>Apply byte-swap transformation to DMA data.
                                    For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.</description>
                                <bitRange>[24:24]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>IRQ_QUIET</name>
                                <description>In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.

                                    This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.</description>
                                <bitRange>[23:23]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>TREQ_SEL</name>
                                <description>Select a Transfer Request signal.
                                    The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).
                                    0x0 to 0x3a -&gt; select DREQ n as TREQ</description>
                                <bitRange>[22:17]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <name>TREQ_SEL</name>
                                    <enumeratedValue>
                                        <name>PIO0_TX0</name>
                                        <description>Select PIO0's TX FIFO 0 as TREQ</description>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_TX1</name>
                                        <description>Select PIO0's TX FIFO 1 as TREQ</description>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_TX2</name>
                                        <description>Select PIO0's TX FIFO 2 as TREQ</description>
                                        <value>2</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_TX3</name>
                                        <description>Select PIO0's TX FIFO 3 as TREQ</description>
                                        <value>3</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_RX0</name>
                                        <description>Select PIO0's RX FIFO 0 as TREQ</description>
                                        <value>4</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_RX1</name>
                                        <description>Select PIO0's RX FIFO 1 as TREQ</description>
                                        <value>5</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_RX2</name>
                                        <description>Select PIO0's RX FIFO 2 as TREQ</description>
                                        <value>6</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO0_RX3</name>
                                        <description>Select PIO0's RX FIFO 3 as TREQ</description>
                                        <value>7</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_TX0</name>
                                        <description>Select PIO1's TX FIFO 0 as TREQ</description>
                                        <value>8</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_TX1</name>
                                        <description>Select PIO1's TX FIFO 1 as TREQ</description>
                                        <value>9</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_TX2</name>
                                        <description>Select PIO1's TX FIFO 2 as TREQ</description>
                                        <value>10</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_TX3</name>
                                        <description>Select PIO1's TX FIFO 3 as TREQ</description>
                                        <value>11</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_RX0</name>
                                        <description>Select PIO1's RX FIFO 0 as TREQ</description>
                                        <value>12</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_RX1</name>
                                        <description>Select PIO1's RX FIFO 1 as TREQ</description>
                                        <value>13</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_RX2</name>
                                        <description>Select PIO1's RX FIFO 2 as TREQ</description>
                                        <value>14</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO1_RX3</name>
                                        <description>Select PIO1's RX FIFO 3 as TREQ</description>
                                        <value>15</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_TX0</name>
                                        <description>Select PIO2's TX FIFO 0 as TREQ</description>
                                        <value>16</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_TX1</name>
                                        <description>Select PIO2's TX FIFO 1 as TREQ</description>
                                        <value>17</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_TX2</name>
                                        <description>Select PIO2's TX FIFO 2 as TREQ</description>
                                        <value>18</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_TX3</name>
                                        <description>Select PIO2's TX FIFO 3 as TREQ</description>
                                        <value>19</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_RX0</name>
                                        <description>Select PIO2's RX FIFO 0 as TREQ</description>
                                        <value>20</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_RX1</name>
                                        <description>Select PIO2's RX FIFO 1 as TREQ</description>
                                        <value>21</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_RX2</name>
                                        <description>Select PIO2's RX FIFO 2 as TREQ</description>
                                        <value>22</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PIO2_RX3</name>
                                        <description>Select PIO2's RX FIFO 3 as TREQ</description>
                                        <value>23</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SPI0_TX</name>
                                        <description>Select SPI0's TX FIFO as TREQ</description>
                                        <value>24</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SPI0_RX</name>
                                        <description>Select SPI0's RX FIFO as TREQ</description>
                                        <value>25</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SPI1_TX</name>
                                        <description>Select SPI1's TX FIFO as TREQ</description>
                                        <value>26</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SPI1_RX</name>
                                        <description>Select SPI1's RX FIFO as TREQ</description>
                                        <value>27</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>UART0_TX</name>
                                        <description>Select UART0's TX FIFO as TREQ</description>
                                        <value>28</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>UART0_RX</name>
                                        <description>Select UART0's RX FIFO as TREQ</description>
                                        <value>29</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>UART1_TX</name>
                                        <description>Select UART1's TX FIFO as TREQ</description>
                                        <value>30</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>UART1_RX</name>
                                        <description>Select UART1's RX FIFO as TREQ</description>
                                        <value>31</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP0</name>
                                        <description>Select PWM Counter 0's Wrap Value as TREQ</description>
                                        <value>32</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP1</name>
                                        <description>Select PWM Counter 1's Wrap Value as TREQ</description>
                                        <value>33</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP2</name>
                                        <description>Select PWM Counter 2's Wrap Value as TREQ</description>
                                        <value>34</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP3</name>
                                        <description>Select PWM Counter 3's Wrap Value as TREQ</description>
                                        <value>35</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP4</name>
                                        <description>Select PWM Counter 4's Wrap Value as TREQ</description>
                                        <value>36</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP5</name>
                                        <description>Select PWM Counter 5's Wrap Value as TREQ</description>
                                        <value>37</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP6</name>
                                        <description>Select PWM Counter 6's Wrap Value as TREQ</description>
                                        <value>38</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP7</name>
                                        <description>Select PWM Counter 7's Wrap Value as TREQ</description>
                                        <value>39</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP8</name>
                                        <description>Select PWM Counter 8's Wrap Value as TREQ</description>
                                        <value>40</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP9</name>
                                        <description>Select PWM Counter 9's Wrap Value as TREQ</description>
                                        <value>41</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP10</name>
                                        <description>Select PWM Counter 10's Wrap Value as TREQ</description>
                                        <value>42</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PWM_WRAP11</name>
                                        <description>Select PWM Counter 11's Wrap Value as TREQ</description>
                                        <value>43</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>I2C0_TX</name>
                                        <description>Select I2C0's TX FIFO as TREQ</description>
                                        <value>44</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>I2C0_RX</name>
                                        <description>Select I2C0's RX FIFO as TREQ</description>
                                        <value>45</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>I2C1_TX</name>
                                        <description>Select I2C1's TX FIFO as TREQ</description>
                                        <value>46</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>I2C1_RX</name>
                                        <description>Select I2C1's RX FIFO as TREQ</description>
                                        <value>47</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>ADC</name>
                                        <description>Select ADC as TREQ</description>
                                        <value>48</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>XIP_STREAM</name>
                                        <description>Select XIP_STREAM as TREQ</description>
                                        <value>49</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>XIP_QMITX</name>
                                        <description>Select XIP_QMI's TX FIFO as TREQ</description>
                                        <value>50</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>XIP_QMIRX</name>
                                        <description>Select XIP_QMI's RX FIFO as TREQ</description>
                                        <value>51</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>HSTX</name>
                                        <description>Select HSTX as TREQ</description>
                                        <value>52</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>CORESIGHT</name>
                                        <description>Select CORESIGHT as TREQ</description>
                                        <value>53</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SHA256</name>
                                        <description>Select SHA256 as TREQ</description>
                                        <value>54</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>TIMER0</name>
                                        <description>Select Timer 0 as TREQ</description>
                                        <value>59</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>TIMER1</name>
                                        <description>Select Timer 1 as TREQ</description>
                                        <value>60</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>TIMER2</name>
                                        <description>Select Timer 2 as TREQ (Optional)</description>
                                        <value>61</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>TIMER3</name>
                                        <description>Select Timer 3 as TREQ (Optional)</description>
                                        <value>62</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>PERMANENT</name>
                                        <description>Permanent request, for unpaced transfers.</description>
                                        <value>63</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>CHAIN_TO</name>
                                <description>When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. \n Reset value is 0, which means for channels 1 and above the default will be to chain to channel 0 - set this field to avoid this behaviour.</description>
                                <bitRange>[16:13]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>RING_SEL</name>
                                <description>Select whether RING_SIZE applies to read or write addresses.
                                    If 0, read addresses are wrapped on a (1 &lt;&lt; RING_SIZE) boundary. If 1, write addresses are wrapped.</description>
                                <bitRange>[12:12]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>RING_SIZE</name>
                                <description>Size of address wrap region. If 0, don't wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.

                                    Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.</description>
                                <bitRange>[11:8]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>RING_NONE</name>
                                        <value>0</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>INCR_WRITE_REV</name>
                                <description>If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.

                                    If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.</description>
                                <bitRange>[7:7]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>INCR_WRITE</name>
                                <description>If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.

                                    Generally this should be disabled for memory-to-peripheral transfers.</description>
                                <bitRange>[6:6]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>INCR_READ_REV</name>
                                <description>If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.

                                    If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.</description>
                                <bitRange>[5:5]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>INCR_READ</name>
                                <description>If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.

                                    Generally this should be disabled for peripheral-to-memory transfers.</description>
                                <bitRange>[4:4]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>DATA_SIZE</name>
                                <description>Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.</description>
                                <bitRange>[3:2]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>SIZE_BYTE</name>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SIZE_HALFWORD</name>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>SIZE_WORD</name>
                                        <value>2</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>HIGH_PRIORITY</name>
                                <description>HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.

                                    This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.</description>
                                <bitRange>[1:1]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>EN</name>
                                <description>DMA Channel Enable.
                                    When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)</description>
                                <bitRange>[0:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>CH_AL3_WRITE_ADDR</name>
                        <description>Alias for channel 0 WRITE_ADDR register</description>
                        <addressOffset>0x34</addressOffset>
                        <resetMask>0x00000000</resetMask>
                        <fields>
                            <field>
                                <name>CH0_AL3_WRITE_ADDR</name>
                                <bitRange>[31:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>CH_AL3_TRANS_COUNT</name>
                        <description>Alias for channel 0 TRANS_COUNT register</description>
                        <addressOffset>0x38</addressOffset>
                        <resetMask>0x00000000</resetMask>
                        <fields>
                            <field>
                                <name>CH0_AL3_TRANS_COUNT</name>
                                <bitRange>[31:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>CH_AL3_READ_ADDR_TRIG</name>
                        <description>Alias for channel 0 READ_ADDR register
                            This is a trigger register (0xc). Writing a nonzero value will
                            reload the channel counter and start the channel.</description>
                        <addressOffset>0x3C</addressOffset>
                        <resetMask>0x00000000</resetMask>
                        <fields>
                            <field>
                                <name>CH0_AL3_READ_ADDR_TRIG</name>
                                <bitRange>[31:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                </cluster>
                <register>
                    <name>INTR</name>
                    <description>Interrupt Status (raw)</description>
                    <addressOffset>0x400</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTR</name>
                            <description>Raw interrupt status for DMA Channels 0..15. Bit n corresponds to channel n. Ignores any masking or forcing. Channel interrupts can be cleared by writing a bit mask to INTR or INTS0/1/2/3.

                                Channel interrupts can be routed to either of four system-level IRQs based on INTE0, INTE1, INTE2 and INTE3.

                                The multiple system-level interrupts might be used to allow NVIC IRQ preemption for more time-critical channels, to spread IRQ load across different cores, or to target IRQs to different security domains.

                                It is also valid to ignore the multiple IRQs, and just use INTE0/INTS0/IRQ 0.

                                If this register is accessed at a security/privilege level less than that of a given channel (as defined by that channel's SECCFG_CHx register), then that channel's interrupt status will read as 0, ignore writes.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTE0</name>
                    <description>Interrupt Enables for IRQ 0</description>
                    <addressOffset>0x404</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTE0</name>
                            <description>Set bit n to pass interrupts from channel n to DMA IRQ 0.

                                Note this bit has no effect if the channel security/privilege level, defined by SECCFG_CHx, is greater than the IRQ security/privilege defined by SECCFG_IRQ0.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTF0</name>
                    <description>Force Interrupts</description>
                    <addressOffset>0x408</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTF0</name>
                            <description>Write 1s to force the corresponding bits in INTS0. The interrupt remains asserted until INTF0 is cleared.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTS0</name>
                    <description>Interrupt Status for IRQ 0</description>
                    <addressOffset>0x40C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTS0</name>
                            <description>Indicates active channel interrupt requests which are currently causing IRQ 0 to be asserted.
                                Channel interrupts can be cleared by writing a bit mask here.

                                Channels with a security/privilege (SECCFG_CHx) greater SECCFG_IRQ0) read as 0 in this register, and ignore writes.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTR1</name>
                    <description>Interrupt Status (raw)</description>
                    <addressOffset>0x410</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTR1</name>
                            <description>Raw interrupt status for DMA Channels 0..15. Bit n corresponds to channel n. Ignores any masking or forcing. Channel interrupts can be cleared by writing a bit mask to INTR or INTS0/1/2/3.

                                Channel interrupts can be routed to either of four system-level IRQs based on INTE0, INTE1, INTE2 and INTE3.

                                The multiple system-level interrupts might be used to allow NVIC IRQ preemption for more time-critical channels, to spread IRQ load across different cores, or to target IRQs to different security domains.

                                It is also valid to ignore the multiple IRQs, and just use INTE0/INTS0/IRQ 0.

                                If this register is accessed at a security/privilege level less than that of a given channel (as defined by that channel's SECCFG_CHx register), then that channel's interrupt status will read as 0, ignore writes.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTE1</name>
                    <description>Interrupt Enables for IRQ 1</description>
                    <addressOffset>0x414</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTE1</name>
                            <description>Set bit n to pass interrupts from channel n to DMA IRQ 1.

                                Note this bit has no effect if the channel security/privilege level, defined by SECCFG_CHx, is greater than the IRQ security/privilege defined by SECCFG_IRQ1.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTF1</name>
                    <description>Force Interrupts</description>
                    <addressOffset>0x418</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTF1</name>
                            <description>Write 1s to force the corresponding bits in INTS1. The interrupt remains asserted until INTF1 is cleared.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTS1</name>
                    <description>Interrupt Status for IRQ 1</description>
                    <addressOffset>0x41C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTS1</name>
                            <description>Indicates active channel interrupt requests which are currently causing IRQ 1 to be asserted.
                                Channel interrupts can be cleared by writing a bit mask here.

                                Channels with a security/privilege (SECCFG_CHx) greater SECCFG_IRQ1) read as 0 in this register, and ignore writes.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTR2</name>
                    <description>Interrupt Status (raw)</description>
                    <addressOffset>0x420</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTR2</name>
                            <description>Raw interrupt status for DMA Channels 0..15. Bit n corresponds to channel n. Ignores any masking or forcing. Channel interrupts can be cleared by writing a bit mask to INTR or INTS0/1/2/3.

                                Channel interrupts can be routed to either of four system-level IRQs based on INTE0, INTE1, INTE2 and INTE3.

                                The multiple system-level interrupts might be used to allow NVIC IRQ preemption for more time-critical channels, to spread IRQ load across different cores, or to target IRQs to different security domains.

                                It is also valid to ignore the multiple IRQs, and just use INTE0/INTS0/IRQ 0.

                                If this register is accessed at a security/privilege level less than that of a given channel (as defined by that channel's SECCFG_CHx register), then that channel's interrupt status will read as 0, ignore writes.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTE2</name>
                    <description>Interrupt Enables for IRQ 2</description>
                    <addressOffset>0x424</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTE2</name>
                            <description>Set bit n to pass interrupts from channel n to DMA IRQ 2.

                                Note this bit has no effect if the channel security/privilege level, defined by SECCFG_CHx, is greater than the IRQ security/privilege defined by SECCFG_IRQ2.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTF2</name>
                    <description>Force Interrupts</description>
                    <addressOffset>0x428</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTF2</name>
                            <description>Write 1s to force the corresponding bits in INTS2. The interrupt remains asserted until INTF2 is cleared.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTS2</name>
                    <description>Interrupt Status for IRQ 2</description>
                    <addressOffset>0x42C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTS2</name>
                            <description>Indicates active channel interrupt requests which are currently causing IRQ 2 to be asserted.
                                Channel interrupts can be cleared by writing a bit mask here.

                                Channels with a security/privilege (SECCFG_CHx) greater SECCFG_IRQ2) read as 0 in this register, and ignore writes.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTR3</name>
                    <description>Interrupt Status (raw)</description>
                    <addressOffset>0x430</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTR3</name>
                            <description>Raw interrupt status for DMA Channels 0..15. Bit n corresponds to channel n. Ignores any masking or forcing. Channel interrupts can be cleared by writing a bit mask to INTR or INTS0/1/2/3.

                                Channel interrupts can be routed to either of four system-level IRQs based on INTE0, INTE1, INTE2 and INTE3.

                                The multiple system-level interrupts might be used to allow NVIC IRQ preemption for more time-critical channels, to spread IRQ load across different cores, or to target IRQs to different security domains.

                                It is also valid to ignore the multiple IRQs, and just use INTE0/INTS0/IRQ 0.

                                If this register is accessed at a security/privilege level less than that of a given channel (as defined by that channel's SECCFG_CHx register), then that channel's interrupt status will read as 0, ignore writes.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTE3</name>
                    <description>Interrupt Enables for IRQ 3</description>
                    <addressOffset>0x434</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTE3</name>
                            <description>Set bit n to pass interrupts from channel n to DMA IRQ 3.

                                Note this bit has no effect if the channel security/privilege level, defined by SECCFG_CHx, is greater than the IRQ security/privilege defined by SECCFG_IRQ3.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTF3</name>
                    <description>Force Interrupts</description>
                    <addressOffset>0x438</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTF3</name>
                            <description>Write 1s to force the corresponding bits in INTS3. The interrupt remains asserted until INTF3 is cleared.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTS3</name>
                    <description>Interrupt Status for IRQ 3</description>
                    <addressOffset>0x43C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTS3</name>
                            <description>Indicates active channel interrupt requests which are currently causing IRQ 3 to be asserted.
                                Channel interrupts can be cleared by writing a bit mask here.

                                Channels with a security/privilege (SECCFG_CHx) greater SECCFG_IRQ3) read as 0 in this register, and ignore writes.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TIMER0</name>
                    <description>Pacing (X/Y) fractional timer
                        The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.</description>
                    <addressOffset>0x440</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>X</name>
                            <description>Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.</description>
                            <bitRange>[31:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>Y</name>
                            <description>Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TIMER1</name>
                    <description>Pacing (X/Y) fractional timer
                        The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.</description>
                    <addressOffset>0x444</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>X</name>
                            <description>Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.</description>
                            <bitRange>[31:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>Y</name>
                            <description>Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TIMER2</name>
                    <description>Pacing (X/Y) fractional timer
                        The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.</description>
                    <addressOffset>0x448</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>X</name>
                            <description>Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.</description>
                            <bitRange>[31:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>Y</name>
                            <description>Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TIMER3</name>
                    <description>Pacing (X/Y) fractional timer
                        The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.</description>
                    <addressOffset>0x44C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>X</name>
                            <description>Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.</description>
                            <bitRange>[31:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>Y</name>
                            <description>Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MULTI_CHAN_TRIGGER</name>
                    <description>Trigger one or more channels simultaneously</description>
                    <addressOffset>0x450</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>MULTI_CHAN_TRIGGER</name>
                            <description>Each bit in this register corresponds to a DMA channel. Writing a 1 to the relevant bit is the same as writing to that channel's trigger register; the channel will start if it is currently enabled and not already busy.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SNIFF_CTRL</name>
                    <description>Sniffer Control</description>
                    <addressOffset>0x454</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>OUT_INV</name>
                            <description>If set, the result appears inverted (bitwise complement) when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus.</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>OUT_REV</name>
                            <description>If set, the result appears bit-reversed when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus.</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BSWAP</name>
                            <description>Locally perform a byte reverse on the sniffed data, before feeding into checksum.

                                Note that the sniff hardware is downstream of the DMA channel byteswap performed in the read master: if channel CTRL_BSWAP and SNIFF_CTRL_BSWAP are both enabled, their effects cancel from the sniffer's point of view.</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CALC</name>
                            <bitRange>[8:5]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>CRC32</name>
                                    <description>Calculate a CRC-32 (IEEE802.3 polynomial)</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>CRC32R</name>
                                    <description>Calculate a CRC-32 (IEEE802.3 polynomial) with bit reversed data</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>CRC16</name>
                                    <description>Calculate a CRC-16-CCITT</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>CRC16R</name>
                                    <description>Calculate a CRC-16-CCITT with bit reversed data</description>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>EVEN</name>
                                    <description>XOR reduction over all data. == 1 if the total 1 population count is odd.</description>
                                    <value>14</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>SUM</name>
                                    <description>Calculate a simple 32-bit checksum (addition with a 32 bit accumulator)</description>
                                    <value>15</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DMACH</name>
                            <description>DMA channel for Sniffer to observe</description>
                            <bitRange>[4:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>Enable sniffer</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SNIFF_DATA</name>
                    <description>Data accumulator for sniff hardware</description>
                    <addressOffset>0x458</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SNIFF_DATA</name>
                            <description>Write an initial seed value here before starting a DMA transfer on the channel indicated by SNIFF_CTRL_DMACH. The hardware will update this register each time it observes a read from the indicated channel. Once the channel completes, the final result can be read from this register.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FIFO_LEVELS</name>
                    <description>Debug RAF, WAF, TDF levels</description>
                    <addressOffset>0x460</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RAF_LVL</name>
                            <description>Current Read-Address-FIFO fill level</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WAF_LVL</name>
                            <description>Current Write-Address-FIFO fill level</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TDF_LVL</name>
                            <description>Current Transfer-Data-FIFO fill level</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CHAN_ABORT</name>
                    <description>Abort an in-progress transfer sequence on one or more channels</description>
                    <addressOffset>0x464</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CHAN_ABORT</name>
                            <description>Each bit corresponds to a channel. Writing a 1 aborts whatever transfer sequence is in progress on that channel. The bit will remain high until any in-flight transfers have been flushed through the address and data FIFOs.

                                After writing, this register must be polled until it returns all-zero. Until this point, it is unsafe to restart the channel.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>N_CHANNELS</name>
                    <description>The number of channels this DMA instance is equipped with. This DMA supports up to 16 hardware channels, but can be configured with as few as one, to minimise silicon area.</description>
                    <addressOffset>0x468</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>N_CHANNELS</name>
                            <bitRange>[4:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_CH0</name>
                    <description>Security configuration for channel 0. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.

                        If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P &gt; S+U &gt; NS+P &gt; NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.

                        This register automatically locks down (becomes read-only) once software starts to configure the channel.

                        This register is world-readable, but is writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x480</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>LOCK</name>
                            <description>LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.

                                Once its LOCK bit is set, this register becomes read-only.

                                A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.

                                If 1, this channel is controllable only from a Secure context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.

                                If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_CH1</name>
                    <description>Security configuration for channel 1. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.

                        If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P &gt; S+U &gt; NS+P &gt; NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.

                        This register automatically locks down (becomes read-only) once software starts to configure the channel.

                        This register is world-readable, but is writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x484</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>LOCK</name>
                            <description>LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.

                                Once its LOCK bit is set, this register becomes read-only.

                                A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.

                                If 1, this channel is controllable only from a Secure context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.

                                If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_CH2</name>
                    <description>Security configuration for channel 2. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.

                        If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P &gt; S+U &gt; NS+P &gt; NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.

                        This register automatically locks down (becomes read-only) once software starts to configure the channel.

                        This register is world-readable, but is writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x488</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>LOCK</name>
                            <description>LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.

                                Once its LOCK bit is set, this register becomes read-only.

                                A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.

                                If 1, this channel is controllable only from a Secure context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.

                                If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_CH3</name>
                    <description>Security configuration for channel 3. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.

                        If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P &gt; S+U &gt; NS+P &gt; NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.

                        This register automatically locks down (becomes read-only) once software starts to configure the channel.

                        This register is world-readable, but is writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x48C</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>LOCK</name>
                            <description>LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.

                                Once its LOCK bit is set, this register becomes read-only.

                                A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.

                                If 1, this channel is controllable only from a Secure context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.

                                If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_CH4</name>
                    <description>Security configuration for channel 4. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.

                        If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P &gt; S+U &gt; NS+P &gt; NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.

                        This register automatically locks down (becomes read-only) once software starts to configure the channel.

                        This register is world-readable, but is writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x490</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>LOCK</name>
                            <description>LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.

                                Once its LOCK bit is set, this register becomes read-only.

                                A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.

                                If 1, this channel is controllable only from a Secure context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.

                                If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_CH5</name>
                    <description>Security configuration for channel 5. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.

                        If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P &gt; S+U &gt; NS+P &gt; NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.

                        This register automatically locks down (becomes read-only) once software starts to configure the channel.

                        This register is world-readable, but is writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x494</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>LOCK</name>
                            <description>LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.

                                Once its LOCK bit is set, this register becomes read-only.

                                A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.

                                If 1, this channel is controllable only from a Secure context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.

                                If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_CH6</name>
                    <description>Security configuration for channel 6. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.

                        If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P &gt; S+U &gt; NS+P &gt; NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.

                        This register automatically locks down (becomes read-only) once software starts to configure the channel.

                        This register is world-readable, but is writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x498</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>LOCK</name>
                            <description>LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.

                                Once its LOCK bit is set, this register becomes read-only.

                                A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.

                                If 1, this channel is controllable only from a Secure context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.

                                If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_CH7</name>
                    <description>Security configuration for channel 7. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.

                        If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P &gt; S+U &gt; NS+P &gt; NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.

                        This register automatically locks down (becomes read-only) once software starts to configure the channel.

                        This register is world-readable, but is writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x49C</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>LOCK</name>
                            <description>LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.

                                Once its LOCK bit is set, this register becomes read-only.

                                A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.

                                If 1, this channel is controllable only from a Secure context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.

                                If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_CH8</name>
                    <description>Security configuration for channel 8. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.

                        If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P &gt; S+U &gt; NS+P &gt; NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.

                        This register automatically locks down (becomes read-only) once software starts to configure the channel.

                        This register is world-readable, but is writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x4A0</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>LOCK</name>
                            <description>LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.

                                Once its LOCK bit is set, this register becomes read-only.

                                A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.

                                If 1, this channel is controllable only from a Secure context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.

                                If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_CH9</name>
                    <description>Security configuration for channel 9. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.

                        If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P &gt; S+U &gt; NS+P &gt; NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.

                        This register automatically locks down (becomes read-only) once software starts to configure the channel.

                        This register is world-readable, but is writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x4A4</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>LOCK</name>
                            <description>LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.

                                Once its LOCK bit is set, this register becomes read-only.

                                A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.

                                If 1, this channel is controllable only from a Secure context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.

                                If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_CH10</name>
                    <description>Security configuration for channel 10. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.

                        If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P &gt; S+U &gt; NS+P &gt; NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.

                        This register automatically locks down (becomes read-only) once software starts to configure the channel.

                        This register is world-readable, but is writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x4A8</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>LOCK</name>
                            <description>LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.

                                Once its LOCK bit is set, this register becomes read-only.

                                A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.

                                If 1, this channel is controllable only from a Secure context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.

                                If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_CH11</name>
                    <description>Security configuration for channel 11. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.

                        If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P &gt; S+U &gt; NS+P &gt; NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.

                        This register automatically locks down (becomes read-only) once software starts to configure the channel.

                        This register is world-readable, but is writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x4AC</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>LOCK</name>
                            <description>LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.

                                Once its LOCK bit is set, this register becomes read-only.

                                A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.

                                If 1, this channel is controllable only from a Secure context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.

                                If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_CH12</name>
                    <description>Security configuration for channel 12. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.

                        If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P &gt; S+U &gt; NS+P &gt; NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.

                        This register automatically locks down (becomes read-only) once software starts to configure the channel.

                        This register is world-readable, but is writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x4B0</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>LOCK</name>
                            <description>LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.

                                Once its LOCK bit is set, this register becomes read-only.

                                A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.

                                If 1, this channel is controllable only from a Secure context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.

                                If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_CH13</name>
                    <description>Security configuration for channel 13. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.

                        If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P &gt; S+U &gt; NS+P &gt; NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.

                        This register automatically locks down (becomes read-only) once software starts to configure the channel.

                        This register is world-readable, but is writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x4B4</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>LOCK</name>
                            <description>LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.

                                Once its LOCK bit is set, this register becomes read-only.

                                A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.

                                If 1, this channel is controllable only from a Secure context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.

                                If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_CH14</name>
                    <description>Security configuration for channel 14. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.

                        If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P &gt; S+U &gt; NS+P &gt; NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.

                        This register automatically locks down (becomes read-only) once software starts to configure the channel.

                        This register is world-readable, but is writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x4B8</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>LOCK</name>
                            <description>LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.

                                Once its LOCK bit is set, this register becomes read-only.

                                A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.

                                If 1, this channel is controllable only from a Secure context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.

                                If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_CH15</name>
                    <description>Security configuration for channel 15. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.

                        If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P &gt; S+U &gt; NS+P &gt; NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.

                        This register automatically locks down (becomes read-only) once software starts to configure the channel.

                        This register is world-readable, but is writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x4BC</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>LOCK</name>
                            <description>LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.

                                Once its LOCK bit is set, this register becomes read-only.

                                A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.

                                If 1, this channel is controllable only from a Secure context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.

                                If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_IRQ0</name>
                    <description>Security configuration for IRQ 0. Control whether the IRQ permits configuration by Non-secure/Unprivileged contexts, and whether it can observe Secure/Privileged channel interrupt flags.</description>
                    <addressOffset>0x4C0</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>S</name>
                            <description>Secure IRQ. If 1, this IRQ's control registers can only be accessed from a Secure context.

                                If 0, this IRQ's control registers can be accessed from a Non-secure context, but Secure channels (as per SECCFG_CHx) are masked from the IRQ status, and this IRQ's registers can not be used to acknowledge the channel interrupts of Secure channels.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged IRQ. If 1, this IRQ's control registers can only be accessed from a Privileged context.

                                If 0, this IRQ's control registers can be accessed from an Unprivileged context, but Privileged channels (as per SECCFG_CHx) are masked from the IRQ status, and this IRQ's registers can not be used to acknowledge the channel interrupts of Privileged channels.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_IRQ1</name>
                    <description>Security configuration for IRQ 1. Control whether the IRQ permits configuration by Non-secure/Unprivileged contexts, and whether it can observe Secure/Privileged channel interrupt flags.</description>
                    <addressOffset>0x4C4</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>S</name>
                            <description>Secure IRQ. If 1, this IRQ's control registers can only be accessed from a Secure context.

                                If 0, this IRQ's control registers can be accessed from a Non-secure context, but Secure channels (as per SECCFG_CHx) are masked from the IRQ status, and this IRQ's registers can not be used to acknowledge the channel interrupts of Secure channels.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged IRQ. If 1, this IRQ's control registers can only be accessed from a Privileged context.

                                If 0, this IRQ's control registers can be accessed from an Unprivileged context, but Privileged channels (as per SECCFG_CHx) are masked from the IRQ status, and this IRQ's registers can not be used to acknowledge the channel interrupts of Privileged channels.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_IRQ2</name>
                    <description>Security configuration for IRQ 2. Control whether the IRQ permits configuration by Non-secure/Unprivileged contexts, and whether it can observe Secure/Privileged channel interrupt flags.</description>
                    <addressOffset>0x4C8</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>S</name>
                            <description>Secure IRQ. If 1, this IRQ's control registers can only be accessed from a Secure context.

                                If 0, this IRQ's control registers can be accessed from a Non-secure context, but Secure channels (as per SECCFG_CHx) are masked from the IRQ status, and this IRQ's registers can not be used to acknowledge the channel interrupts of Secure channels.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged IRQ. If 1, this IRQ's control registers can only be accessed from a Privileged context.

                                If 0, this IRQ's control registers can be accessed from an Unprivileged context, but Privileged channels (as per SECCFG_CHx) are masked from the IRQ status, and this IRQ's registers can not be used to acknowledge the channel interrupts of Privileged channels.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_IRQ3</name>
                    <description>Security configuration for IRQ 3. Control whether the IRQ permits configuration by Non-secure/Unprivileged contexts, and whether it can observe Secure/Privileged channel interrupt flags.</description>
                    <addressOffset>0x4CC</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>S</name>
                            <description>Secure IRQ. If 1, this IRQ's control registers can only be accessed from a Secure context.

                                If 0, this IRQ's control registers can be accessed from a Non-secure context, but Secure channels (as per SECCFG_CHx) are masked from the IRQ status, and this IRQ's registers can not be used to acknowledge the channel interrupts of Secure channels.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Privileged IRQ. If 1, this IRQ's control registers can only be accessed from a Privileged context.

                                If 0, this IRQ's control registers can be accessed from an Unprivileged context, but Privileged channels (as per SECCFG_CHx) are masked from the IRQ status, and this IRQ's registers can not be used to acknowledge the channel interrupts of Privileged channels.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SECCFG_MISC</name>
                    <description>Miscellaneous security configuration</description>
                    <addressOffset>0x4D0</addressOffset>
                    <resetValue>0x000003FF</resetValue>
                    <fields>
                        <field>
                            <name>TIMER3_S</name>
                            <description>If 1, the TIMER3 register is only accessible from a Secure context, and timer DREQ 3 is only visible to Secure channels.</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TIMER3_P</name>
                            <description>If 1, the TIMER3 register is only accessible from a Privileged (or more Secure) context, and timer DREQ 3 is only visible to Privileged (or more Secure) channels.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TIMER2_S</name>
                            <description>If 1, the TIMER2 register is only accessible from a Secure context, and timer DREQ 2 is only visible to Secure channels.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TIMER2_P</name>
                            <description>If 1, the TIMER2 register is only accessible from a Privileged (or more Secure) context, and timer DREQ 2 is only visible to Privileged (or more Secure) channels.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TIMER1_S</name>
                            <description>If 1, the TIMER1 register is only accessible from a Secure context, and timer DREQ 1 is only visible to Secure channels.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TIMER1_P</name>
                            <description>If 1, the TIMER1 register is only accessible from a Privileged (or more Secure) context, and timer DREQ 1 is only visible to Privileged (or more Secure) channels.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TIMER0_S</name>
                            <description>If 1, the TIMER0 register is only accessible from a Secure context, and timer DREQ 0 is only visible to Secure channels.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TIMER0_P</name>
                            <description>If 1, the TIMER0 register is only accessible from a Privileged (or more Secure) context, and timer DREQ 0 is only visible to Privileged (or more Secure) channels.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SNIFF_S</name>
                            <description>If 1, the sniffer can see data transfers from Secure channels, and can itself only be accessed from a Secure context.

                                If 0, the sniffer can be accessed from either a Secure or Non-secure context, but can not see data transfers of Secure channels.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SNIFF_P</name>
                            <description>If 1, the sniffer can see data transfers from Privileged channels, and can itself only be accessed from a privileged context, or from a Secure context when SNIFF_S is 0.

                                If 0, the sniffer can be accessed from either a Privileged or Unprivileged context (with sufficient security level) but can not see transfers from Privileged channels.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_CTRL</name>
                    <description>Control register for DMA MPU. Accessible only from a Privileged context.</description>
                    <addressOffset>0x500</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NS_HIDE_ADDR</name>
                            <description>By default, when a region's S bit is clear, Non-secure-Privileged reads can see the region's base address and limit address. Set this bit to make the addresses appear as 0 to Non-secure reads, even when the region is Non-secure, to avoid leaking information about the processor SAU map.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Determine whether an address not covered by an active MPU region is Secure (1) or Non-secure (0)</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Determine whether an address not covered by an active MPU region is Privileged (1) or Unprivileged (0)</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_BAR0</name>
                    <description>Base address register for MPU region 0. Writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x504</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDR</name>
                            <description>This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR.

                                Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_LAR0</name>
                    <description>Limit address register for MPU region 0. Writable only from a Secure, Privileged context, with the exception of the P bit.</description>
                    <addressOffset>0x508</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDR</name>
                            <description>Limit address bits 31:5. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_BAR1</name>
                    <description>Base address register for MPU region 1. Writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x50C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDR</name>
                            <description>This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR.

                                Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_LAR1</name>
                    <description>Limit address register for MPU region 1. Writable only from a Secure, Privileged context, with the exception of the P bit.</description>
                    <addressOffset>0x510</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDR</name>
                            <description>Limit address bits 31:5. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_BAR2</name>
                    <description>Base address register for MPU region 2. Writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x514</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDR</name>
                            <description>This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR.

                                Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_LAR2</name>
                    <description>Limit address register for MPU region 2. Writable only from a Secure, Privileged context, with the exception of the P bit.</description>
                    <addressOffset>0x518</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDR</name>
                            <description>Limit address bits 31:5. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_BAR3</name>
                    <description>Base address register for MPU region 3. Writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x51C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDR</name>
                            <description>This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR.

                                Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_LAR3</name>
                    <description>Limit address register for MPU region 3. Writable only from a Secure, Privileged context, with the exception of the P bit.</description>
                    <addressOffset>0x520</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDR</name>
                            <description>Limit address bits 31:5. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_BAR4</name>
                    <description>Base address register for MPU region 4. Writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x524</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDR</name>
                            <description>This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR.

                                Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_LAR4</name>
                    <description>Limit address register for MPU region 4. Writable only from a Secure, Privileged context, with the exception of the P bit.</description>
                    <addressOffset>0x528</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDR</name>
                            <description>Limit address bits 31:5. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_BAR5</name>
                    <description>Base address register for MPU region 5. Writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x52C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDR</name>
                            <description>This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR.

                                Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_LAR5</name>
                    <description>Limit address register for MPU region 5. Writable only from a Secure, Privileged context, with the exception of the P bit.</description>
                    <addressOffset>0x530</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDR</name>
                            <description>Limit address bits 31:5. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_BAR6</name>
                    <description>Base address register for MPU region 6. Writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x534</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDR</name>
                            <description>This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR.

                                Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_LAR6</name>
                    <description>Limit address register for MPU region 6. Writable only from a Secure, Privileged context, with the exception of the P bit.</description>
                    <addressOffset>0x538</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDR</name>
                            <description>Limit address bits 31:5. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_BAR7</name>
                    <description>Base address register for MPU region 7. Writable only from a Secure, Privileged context.</description>
                    <addressOffset>0x53C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDR</name>
                            <description>This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR.

                                Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MPU_LAR7</name>
                    <description>Limit address register for MPU region 7. Writable only from a Secure, Privileged context, with the exception of the P bit.</description>
                    <addressOffset>0x540</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ADDR</name>
                            <description>Limit address bits 31:5. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.</description>
                            <bitRange>[31:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>S</name>
                            <description>Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>P</name>
                            <description>Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH0_DBG_CTDREQ</name>
                    <description>Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.</description>
                    <addressOffset>0x800</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH0_DBG_CTDREQ</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH0_DBG_TCR</name>
                    <description>Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer</description>
                    <addressOffset>0x804</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH0_DBG_TCR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH1_DBG_CTDREQ</name>
                    <description>Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.</description>
                    <addressOffset>0x840</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH1_DBG_CTDREQ</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH1_DBG_TCR</name>
                    <description>Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer</description>
                    <addressOffset>0x844</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH1_DBG_TCR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH2_DBG_CTDREQ</name>
                    <description>Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.</description>
                    <addressOffset>0x880</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH2_DBG_CTDREQ</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH2_DBG_TCR</name>
                    <description>Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer</description>
                    <addressOffset>0x884</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH2_DBG_TCR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH3_DBG_CTDREQ</name>
                    <description>Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.</description>
                    <addressOffset>0x8C0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH3_DBG_CTDREQ</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH3_DBG_TCR</name>
                    <description>Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer</description>
                    <addressOffset>0x8C4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH3_DBG_TCR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH4_DBG_CTDREQ</name>
                    <description>Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.</description>
                    <addressOffset>0x900</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH4_DBG_CTDREQ</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH4_DBG_TCR</name>
                    <description>Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer</description>
                    <addressOffset>0x904</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH4_DBG_TCR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH5_DBG_CTDREQ</name>
                    <description>Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.</description>
                    <addressOffset>0x940</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH5_DBG_CTDREQ</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH5_DBG_TCR</name>
                    <description>Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer</description>
                    <addressOffset>0x944</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH5_DBG_TCR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH6_DBG_CTDREQ</name>
                    <description>Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.</description>
                    <addressOffset>0x980</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH6_DBG_CTDREQ</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH6_DBG_TCR</name>
                    <description>Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer</description>
                    <addressOffset>0x984</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH6_DBG_TCR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH7_DBG_CTDREQ</name>
                    <description>Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.</description>
                    <addressOffset>0x9C0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH7_DBG_CTDREQ</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH7_DBG_TCR</name>
                    <description>Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer</description>
                    <addressOffset>0x9C4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH7_DBG_TCR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH8_DBG_CTDREQ</name>
                    <description>Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.</description>
                    <addressOffset>0xA00</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH8_DBG_CTDREQ</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH8_DBG_TCR</name>
                    <description>Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer</description>
                    <addressOffset>0xA04</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH8_DBG_TCR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH9_DBG_CTDREQ</name>
                    <description>Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.</description>
                    <addressOffset>0xA40</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH9_DBG_CTDREQ</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH9_DBG_TCR</name>
                    <description>Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer</description>
                    <addressOffset>0xA44</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH9_DBG_TCR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH10_DBG_CTDREQ</name>
                    <description>Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.</description>
                    <addressOffset>0xA80</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH10_DBG_CTDREQ</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH10_DBG_TCR</name>
                    <description>Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer</description>
                    <addressOffset>0xA84</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH10_DBG_TCR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH11_DBG_CTDREQ</name>
                    <description>Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.</description>
                    <addressOffset>0xAC0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH11_DBG_CTDREQ</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH11_DBG_TCR</name>
                    <description>Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer</description>
                    <addressOffset>0xAC4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH11_DBG_TCR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH12_DBG_CTDREQ</name>
                    <description>Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.</description>
                    <addressOffset>0xB00</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH12_DBG_CTDREQ</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH12_DBG_TCR</name>
                    <description>Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer</description>
                    <addressOffset>0xB04</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH12_DBG_TCR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH13_DBG_CTDREQ</name>
                    <description>Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.</description>
                    <addressOffset>0xB40</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH13_DBG_CTDREQ</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH13_DBG_TCR</name>
                    <description>Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer</description>
                    <addressOffset>0xB44</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH13_DBG_TCR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH14_DBG_CTDREQ</name>
                    <description>Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.</description>
                    <addressOffset>0xB80</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH14_DBG_CTDREQ</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH14_DBG_TCR</name>
                    <description>Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer</description>
                    <addressOffset>0xB84</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH14_DBG_TCR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH15_DBG_CTDREQ</name>
                    <description>Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.</description>
                    <addressOffset>0xBC0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH15_DBG_CTDREQ</name>
                            <bitRange>[5:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CH15_DBG_TCR</name>
                    <description>Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer</description>
                    <addressOffset>0xBC4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH15_DBG_TCR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>TIMER0</name>
            <description>Controls time and alarms

                time is a 64 bit value indicating the time since power-on

                timeh is the top 32 bits of time &amp; timel is the bottom 32 bits to change time write to timelw before timehw to read time read from timelr before timehr

                An alarm is set by setting alarm_enable and writing to the corresponding alarm register When an alarm is pending, the corresponding alarm_running signal will be high An alarm can be cancelled before it has finished by clearing the alarm_enable When an alarm fires, the corresponding alarm_irq is set and alarm_running is cleared To clear the interrupt write a 1 to the corresponding alarm_irq The timer can be locked to prevent writing</description>
            <baseAddress>0x400B0000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x4C</size>
                <usage>registers</usage>
            </addressBlock>
            <interrupt>
                <name>TIMER0_IRQ_0</name>
                <value>0</value>
            </interrupt>
            <interrupt>
                <name>TIMER0_IRQ_1</name>
                <value>1</value>
            </interrupt>
            <interrupt>
                <name>TIMER0_IRQ_2</name>
                <value>2</value>
            </interrupt>
            <interrupt>
                <name>TIMER0_IRQ_3</name>
                <value>3</value>
            </interrupt>
            <registers>
                <register>
                    <name>TIMEHW</name>
                    <description>Write to bits 63:32 of time always write timelw before timehw</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TIMEHW</name>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TIMELW</name>
                    <description>Write to bits 31:0 of time writes do not get copied to time until timehw is written</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TIMELW</name>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TIMEHR</name>
                    <description>Read from bits 63:32 of time always read timelr before timehr</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TIMEHR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TIMELR</name>
                    <description>Read from bits 31:0 of time</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TIMELR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ALARM0</name>
                    <description>Arm alarm 0, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM0 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ALARM0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ALARM1</name>
                    <description>Arm alarm 1, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM1 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ALARM1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ALARM2</name>
                    <description>Arm alarm 2, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM2 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ALARM2</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ALARM3</name>
                    <description>Arm alarm 3, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM3 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.</description>
                    <addressOffset>0x1C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ALARM3</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ARMED</name>
                    <description>Indicates the armed/disarmed status of each alarm. A write to the corresponding ALARMx register arms the alarm. Alarms automatically disarm upon firing, but writing ones here will disarm immediately without waiting to fire.</description>
                    <addressOffset>0x20</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ARMED</name>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TIMERAWH</name>
                    <description>Raw read from bits 63:32 of time (no side effects)</description>
                    <addressOffset>0x24</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TIMERAWH</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TIMERAWL</name>
                    <description>Raw read from bits 31:0 of time (no side effects)</description>
                    <addressOffset>0x28</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TIMERAWL</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DBGPAUSE</name>
                    <description>Set bits high to enable pause when the corresponding debug ports are active</description>
                    <addressOffset>0x2C</addressOffset>
                    <resetValue>0x00000007</resetValue>
                    <fields>
                        <field>
                            <name>DBG1</name>
                            <description>Pause when processor 1 is in debug mode</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DBG0</name>
                            <description>Pause when processor 0 is in debug mode</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAUSE</name>
                    <description>Set high to pause the timer</description>
                    <addressOffset>0x30</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PAUSE</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>LOCKED</name>
                    <description>Set locked bit to disable write access to timer Once set, cannot be cleared (without a reset)</description>
                    <addressOffset>0x34</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>LOCKED</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SOURCE</name>
                    <description>Selects the source for the timer. Defaults to the normal tick configured in the ticks block (typically configured to 1 microsecond). Writing to 1 will ignore the tick and count clk_sys cycles instead.</description>
                    <addressOffset>0x38</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLK_SYS</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>TICK</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>CLK_SYS</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTR</name>
                    <description>Raw Interrupts</description>
                    <addressOffset>0x3C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ALARM_3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>ALARM_2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>ALARM_1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>ALARM_0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTE</name>
                    <description>Interrupt Enable</description>
                    <addressOffset>0x40</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ALARM_3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ALARM_2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ALARM_1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ALARM_0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTF</name>
                    <description>Interrupt Force</description>
                    <addressOffset>0x44</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ALARM_3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ALARM_2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ALARM_1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ALARM_0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTS</name>
                    <description>Interrupt status after masking &amp; forcing</description>
                    <addressOffset>0x48</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ALARM_3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ALARM_2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ALARM_1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ALARM_0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral derivedFrom="TIMER0">
            <name>TIMER1</name>
            <baseAddress>0x400B8000</baseAddress>
            <interrupt>
                <name>TIMER1_IRQ_0</name>
                <value>4</value>
            </interrupt>
            <interrupt>
                <name>TIMER1_IRQ_1</name>
                <value>5</value>
            </interrupt>
            <interrupt>
                <name>TIMER1_IRQ_2</name>
                <value>6</value>
            </interrupt>
            <interrupt>
                <name>TIMER1_IRQ_3</name>
                <value>7</value>
            </interrupt>
        </peripheral>
        <peripheral>
            <name>PWM</name>
            <description>Simple PWM</description>
            <baseAddress>0x400A8000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x110</size>
                <usage>registers</usage>
            </addressBlock>
            <interrupt>
                <name>PWM_IRQ_WRAP_0</name>
                <value>8</value>
            </interrupt>
            <interrupt>
                <name>PWM_IRQ_WRAP_1</name>
                <value>9</value>
            </interrupt>
            <registers>
                <cluster>
                    <dim>12</dim>
                    <dimIncrement>0x14</dimIncrement>
                    <dimIndex>0-11</dimIndex>
                    <name>CH%s</name>
                    <description>Cluster CH%s, containing CH*_CC, CH*_CSR, CH*_CTR, CH*_DIV, CH*_TOP</description>
                    <addressOffset>0x0</addressOffset>
                    <register>
                        <name>CC</name>
                        <description>Counter compare values</description>
                        <addressOffset>0xC</addressOffset>
                        <resetValue>0x00000000</resetValue>
                        <fields>
                            <field>
                                <name>B</name>
                                <bitRange>[31:16]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>A</name>
                                <bitRange>[15:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>CSR</name>
                        <description>Control and status register</description>
                        <addressOffset>0x0</addressOffset>
                        <resetValue>0x00000000</resetValue>
                        <fields>
                            <field>
                                <name>PH_ADV</name>
                                <description>Advance the phase of the counter by 1 count, while it is running.
                                    Self-clearing. Write a 1, and poll until low. Counter must be running
                                    at less than full speed (div_int + div_frac / 16 &gt; 1)</description>
                                <bitRange>[7:7]</bitRange>
                                <access>write-only</access>
                            </field>
                            <field>
                                <name>PH_RET</name>
                                <description>Retard the phase of the counter by 1 count, while it is running.
                                    Self-clearing. Write a 1, and poll until low. Counter must be running.</description>
                                <bitRange>[6:6]</bitRange>
                                <access>write-only</access>
                            </field>
                            <field>
                                <name>DIVMODE</name>
                                <bitRange>[5:4]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>div</name>
                                        <description>Free-running counting at rate dictated by fractional divider</description>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>level</name>
                                        <description>Fractional divider operation is gated by the PWM B pin.</description>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>rise</name>
                                        <description>Counter advances with each rising edge of the PWM B pin.</description>
                                        <value>2</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>fall</name>
                                        <description>Counter advances with each falling edge of the PWM B pin.</description>
                                        <value>3</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>B_INV</name>
                                <description>Invert output B</description>
                                <bitRange>[3:3]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>A_INV</name>
                                <description>Invert output A</description>
                                <bitRange>[2:2]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>PH_CORRECT</name>
                                <description>1: Enable phase-correct modulation. 0: Trailing-edge</description>
                                <bitRange>[1:1]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>EN</name>
                                <description>Enable the PWM channel.</description>
                                <bitRange>[0:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>CTR</name>
                        <description>Direct access to the PWM counter</description>
                        <addressOffset>0x8</addressOffset>
                        <resetValue>0x00000000</resetValue>
                        <fields>
                            <field>
                                <name>CTR</name>
                                <bitRange>[15:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>DIV</name>
                        <description>INT and FRAC form a fixed-point fractional number.
                            Counting rate is system clock frequency divided by this number.
                            Fractional division uses simple 1st-order sigma-delta.</description>
                        <addressOffset>0x4</addressOffset>
                        <resetValue>0x00000010</resetValue>
                        <fields>
                            <field>
                                <name>INT</name>
                                <bitRange>[11:4]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>FRAC</name>
                                <bitRange>[3:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>TOP</name>
                        <description>Counter wrap value</description>
                        <addressOffset>0x10</addressOffset>
                        <resetValue>0x0000FFFF</resetValue>
                        <fields>
                            <field>
                                <name>TOP</name>
                                <bitRange>[15:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                </cluster>
                <register>
                    <name>EN</name>
                    <description>This register aliases the CSR_EN bits for all channels.
                        Writing to this register allows multiple channels to be enabled
                        or disabled simultaneously, so they can run in perfect sync.
                        For each channel, there is only one physical EN register bit,
                        which can be accessed through here or CHx_CSR.</description>
                    <addressOffset>0xF0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH11</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH10</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH9</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH8</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH7</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH6</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH5</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH4</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTR</name>
                    <description>Raw Interrupts</description>
                    <addressOffset>0xF4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH11</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>CH10</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>CH9</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>CH8</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>CH7</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>CH6</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>CH5</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>CH4</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>CH3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>CH2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>CH1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>CH0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQ0_INTE</name>
                    <description>Interrupt Enable for irq0</description>
                    <addressOffset>0xF8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH11</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH10</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH9</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH8</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH7</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH6</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH5</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH4</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQ0_INTF</name>
                    <description>Interrupt Force for irq0</description>
                    <addressOffset>0xFC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH11</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH10</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH9</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH8</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH7</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH6</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH5</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH4</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQ0_INTS</name>
                    <description>Interrupt status after masking &amp; forcing for irq0</description>
                    <addressOffset>0x100</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH11</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH10</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH9</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH8</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH7</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH6</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH5</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH4</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQ1_INTE</name>
                    <description>Interrupt Enable for irq1</description>
                    <addressOffset>0x104</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH11</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH10</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH9</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH8</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH7</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH6</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH5</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH4</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQ1_INTF</name>
                    <description>Interrupt Force for irq1</description>
                    <addressOffset>0x108</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH11</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH10</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH9</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH8</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH7</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH6</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH5</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH4</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CH0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQ1_INTS</name>
                    <description>Interrupt status after masking &amp; forcing for irq1</description>
                    <addressOffset>0x10C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CH11</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH10</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH9</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH8</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH7</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH6</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH5</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH4</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CH0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>ADC</name>
            <description>Control and data interface to SAR ADC</description>
            <baseAddress>0x400A0000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x24</size>
                <usage>registers</usage>
            </addressBlock>
            <interrupt>
                <name>ADC_IRQ_FIFO</name>
                <value>35</value>
            </interrupt>
            <registers>
                <register>
                    <name>CS</name>
                    <description>ADC Control and Status</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RROBIN</name>
                            <description>Round-robin sampling. 1 bit per channel. Set all bits to 0 to disable.
                                Otherwise, the ADC will cycle through each enabled channel in a round-robin fashion.
                                The first channel to be sampled will be the one currently indicated by AINSEL.
                                AINSEL will be updated after each conversion with the newly-selected channel.</description>
                            <bitRange>[24:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AINSEL</name>
                            <description>Select analog mux input. Updated automatically in round-robin mode.
                                This is corrected for the package option so only ADC channels which are bonded are available, and in the correct order</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ERR_STICKY</name>
                            <description>Some past ADC conversion encountered an error. Write 1 to clear.</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>ERR</name>
                            <description>The most recent ADC conversion encountered an error; result is undefined or noisy.</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>READY</name>
                            <description>1 if the ADC is ready to start a new conversion. Implies any previous conversion has completed.
                                0 whilst conversion in progress.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>START_MANY</name>
                            <description>Continuously perform conversions whilst this bit is 1. A new conversion will start immediately after the previous finishes.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>START_ONCE</name>
                            <description>Start a single conversion. Self-clearing. Ignored if start_many is asserted.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>TS_EN</name>
                            <description>Power on temperature sensor. 1 - enabled. 0 - disabled.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>Power on ADC and enable its clock.
                                1 - enabled. 0 - disabled.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RESULT</name>
                    <description>Result of most recent ADC conversion</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RESULT</name>
                            <bitRange>[11:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FCS</name>
                    <description>FIFO control and status</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>THRESH</name>
                            <description>DREQ/IRQ asserted when level &gt;= threshold</description>
                            <bitRange>[27:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>LEVEL</name>
                            <description>The number of conversion results currently waiting in the FIFO</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>OVER</name>
                            <description>1 if the FIFO has been overflowed. Write 1 to clear.</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>UNDER</name>
                            <description>1 if the FIFO has been underflowed. Write 1 to clear.</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>FULL</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EMPTY</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DREQ_EN</name>
                            <description>If 1: assert DMA requests when FIFO contains data</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ERR</name>
                            <description>If 1: conversion error bit appears in the FIFO alongside the result</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SHIFT</name>
                            <description>If 1: FIFO results are right-shifted to be one byte in size. Enables DMA to byte buffers.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>If 1: write result to the FIFO after each conversion.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FIFO</name>
                    <description>Conversion result FIFO</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ERR</name>
                            <description>1 if this particular sample experienced a conversion error. Remains in the same location if the sample is shifted.</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                        <field>
                            <name>VAL</name>
                            <bitRange>[11:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DIV</name>
                    <description>Clock divider. If non-zero, CS_START_MANY will start conversions
                        at regular intervals rather than back-to-back.
                        The divider is reset when either of these fields are written.
                        Total period is 1 + INT + FRAC / 256</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INT</name>
                            <description>Integer part of clock divisor.</description>
                            <bitRange>[23:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FRAC</name>
                            <description>Fractional part of clock divisor. First-order delta-sigma.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTR</name>
                    <description>Raw Interrupts</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FIFO</name>
                            <description>Triggered when the sample FIFO reaches a certain level.
                                This level can be programmed via the FCS_THRESH field.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTE</name>
                    <description>Interrupt Enable</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FIFO</name>
                            <description>Triggered when the sample FIFO reaches a certain level.
                                This level can be programmed via the FCS_THRESH field.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTF</name>
                    <description>Interrupt Force</description>
                    <addressOffset>0x1C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FIFO</name>
                            <description>Triggered when the sample FIFO reaches a certain level.
                                This level can be programmed via the FCS_THRESH field.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTS</name>
                    <description>Interrupt status after masking &amp; forcing</description>
                    <addressOffset>0x20</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FIFO</name>
                            <description>Triggered when the sample FIFO reaches a certain level.
                                This level can be programmed via the FCS_THRESH field.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>I2C0</name>
            <description>DW_apb_i2c address block

                List of configuration constants for the Synopsys I2C hardware (you may see references to these in I2C register header; these are *fixed* values, set at hardware design time):

                IC_ULTRA_FAST_MODE ................ 0x0
                IC_UFM_TBUF_CNT_DEFAULT ........... 0x8
                IC_UFM_SCL_LOW_COUNT .............. 0x0008
                IC_UFM_SCL_HIGH_COUNT ............. 0x0006
                IC_TX_TL .......................... 0x0
                IC_TX_CMD_BLOCK ................... 0x1
                IC_HAS_DMA ........................ 0x1
                IC_HAS_ASYNC_FIFO ................. 0x0
                IC_SMBUS_ARP ...................... 0x0
                IC_FIRST_DATA_BYTE_STATUS ......... 0x1
                IC_INTR_IO ........................ 0x1
                IC_MASTER_MODE .................... 0x1
                IC_DEFAULT_ACK_GENERAL_CALL ....... 0x1
                IC_INTR_POL ....................... 0x1
                IC_OPTIONAL_SAR ................... 0x0
                IC_DEFAULT_TAR_SLAVE_ADDR ......... 0x055
                IC_DEFAULT_SLAVE_ADDR ............. 0x055
                IC_DEFAULT_HS_SPKLEN .............. 0x1
                IC_FS_SCL_HIGH_COUNT .............. 0x0006
                IC_HS_SCL_LOW_COUNT ............... 0x0008
                IC_DEVICE_ID_VALUE ................ 0x0
                IC_10BITADDR_MASTER ............... 0x0
                IC_CLK_FREQ_OPTIMIZATION .......... 0x0
                IC_DEFAULT_FS_SPKLEN .............. 0x7
                IC_ADD_ENCODED_PARAMS ............. 0x0
                IC_DEFAULT_SDA_HOLD ............... 0x000001
                IC_DEFAULT_SDA_SETUP .............. 0x64
                IC_AVOID_RX_FIFO_FLUSH_ON_TX_ABRT . 0x0
                IC_CLOCK_PERIOD ................... 100
                IC_EMPTYFIFO_HOLD_MASTER_EN ....... 1
                IC_RESTART_EN ..................... 0x1
                IC_TX_CMD_BLOCK_DEFAULT ........... 0x0
                IC_BUS_CLEAR_FEATURE .............. 0x0
                IC_CAP_LOADING .................... 100
                IC_FS_SCL_LOW_COUNT ............... 0x000d
                APB_DATA_WIDTH .................... 32
                IC_SDA_STUCK_TIMEOUT_DEFAULT ...... 0xffffffff
                IC_SLV_DATA_NACK_ONLY ............. 0x1
                IC_10BITADDR_SLAVE ................ 0x0
                IC_CLK_TYPE ....................... 0x0
                IC_SMBUS_UDID_MSB ................. 0x0
                IC_SMBUS_SUSPEND_ALERT ............ 0x0
                IC_HS_SCL_HIGH_COUNT .............. 0x0006
                IC_SLV_RESTART_DET_EN ............. 0x1
                IC_SMBUS .......................... 0x0
                IC_OPTIONAL_SAR_DEFAULT ........... 0x0
                IC_PERSISTANT_SLV_ADDR_DEFAULT .... 0x0
                IC_USE_COUNTS ..................... 0x0
                IC_RX_BUFFER_DEPTH ................ 16
                IC_SCL_STUCK_TIMEOUT_DEFAULT ...... 0xffffffff
                IC_RX_FULL_HLD_BUS_EN ............. 0x1
                IC_SLAVE_DISABLE .................. 0x1
                IC_RX_TL .......................... 0x0
                IC_DEVICE_ID ...................... 0x0
                IC_HC_COUNT_VALUES ................ 0x0
                I2C_DYNAMIC_TAR_UPDATE ............ 0
                IC_SMBUS_CLK_LOW_MEXT_DEFAULT ..... 0xffffffff
                IC_SMBUS_CLK_LOW_SEXT_DEFAULT ..... 0xffffffff
                IC_HS_MASTER_CODE ................. 0x1
                IC_SMBUS_RST_IDLE_CNT_DEFAULT ..... 0xffff
                IC_SMBUS_UDID_LSB_DEFAULT ......... 0xffffffff
                IC_SS_SCL_HIGH_COUNT .............. 0x0028
                IC_SS_SCL_LOW_COUNT ............... 0x002f
                IC_MAX_SPEED_MODE ................. 0x2
                IC_STAT_FOR_CLK_STRETCH ........... 0x0
                IC_STOP_DET_IF_MASTER_ACTIVE ...... 0x0
                IC_DEFAULT_UFM_SPKLEN ............. 0x1
                IC_TX_BUFFER_DEPTH ................ 16</description>
            <baseAddress>0x40090000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x100</size>
                <usage>registers</usage>
            </addressBlock>
            <interrupt>
                <name>I2C0_IRQ</name>
                <value>36</value>
            </interrupt>
            <registers>
                <register>
                    <name>IC_CON</name>
                    <description>I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.

                        Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are read only.</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000065</resetValue>
                    <fields>
                        <field>
                            <name>STOP_DET_IF_MASTER_ACTIVE</name>
                            <description>Master issues the STOP_DET interrupt irrespective of whether master is active or not</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RX_FIFO_FULL_HLD_CTRL</name>
                            <description>This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH, as described in the IC_RX_FULL_HLD_BUS_EN parameter.

                                Reset value: 0x0.</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>Overflow when RX_FIFO is full</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>Hold bus when RX_FIFO is full</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>TX_EMPTY_CTRL</name>
                            <description>This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.

                                Reset value: 0x0.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>Default behaviour of TX_EMPTY interrupt</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>Controlled generation of TX_EMPTY interrupt</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>STOP_DET_IFADDRESSED</name>
                            <description>In slave mode: - 1'b1:  issues the STOP_DET interrupt only when it is addressed. - 1'b0:  issues the STOP_DET irrespective of whether it's addressed or not. Reset value: 0x0

                                NOTE: During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR).</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>slave issues STOP_DET intr always</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>slave issues STOP_DET intr only if addressed</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>IC_SLAVE_DISABLE</name>
                            <description>This bit controls whether I2C has its slave disabled, which means once the presetn signal is applied, then this bit is set and the slave is disabled.

                                If this bit is set (slave is disabled), DW_apb_i2c functions only as a master and does not perform any action that requires a slave.

                                NOTE: Software should ensure that if this bit is written with 0, then bit 0 should also be written with a 0.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>SLAVE_ENABLED</name>
                                    <description>Slave mode is enabled</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>SLAVE_DISABLED</name>
                                    <description>Slave mode is disabled</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>IC_RESTART_EN</name>
                            <description>Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several DW_apb_i2c operations. When RESTART is disabled, the master is prohibited from performing the following functions: - Sending a START BYTE - Performing any high-speed mode operation - High-speed mode operation - Performing direction changes in combined format mode - Performing a read operation with a 10-bit address By replacing RESTART condition followed by a STOP and a subsequent START condition, split operations are broken down into multiple DW_apb_i2c transfers. If the above operations are performed, it will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register.

                                Reset value: ENABLED</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>Master restart disabled</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>Master restart enabled</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>IC_10BITADDR_MASTER</name>
                            <description>Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ADDR_7BITS</name>
                                    <description>Master 7Bit addressing mode</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ADDR_10BITS</name>
                                    <description>Master 10Bit addressing mode</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>IC_10BITADDR_SLAVE</name>
                            <description>When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit addressing transfers that match the full 10 bits of the IC_SAR register.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ADDR_7BITS</name>
                                    <description>Slave 7Bit addressing</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ADDR_10BITS</name>
                                    <description>Slave 10Bit addressing</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SPEED</name>
                            <description>These bits control at which speed the DW_apb_i2c operates; its setting is relevant only if one is operating the DW_apb_i2c in master mode. Hardware protects against illegal values being programmed by software. These bits must be programmed appropriately for slave mode also, as it is used to capture correct value of spike filter as per the speed mode.

                                This register should be programmed only with a value in the range of 1 to IC_MAX_SPEED_MODE; otherwise, hardware updates this register with the value of IC_MAX_SPEED_MODE.

                                1: standard mode (100 kbit/s)

                                2: fast mode (&lt;=400 kbit/s) or fast mode plus (&lt;=1000Kbit/s)

                                3: high speed mode (3.4 Mbit/s)

                                Note: This field is not applicable when IC_ULTRA_FAST_MODE=1</description>
                            <bitRange>[2:1]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>STANDARD</name>
                                    <description>Standard Speed mode of operation</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>FAST</name>
                                    <description>Fast or Fast Plus mode of operation</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>HIGH</name>
                                    <description>High Speed mode of operation</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>MASTER_MODE</name>
                            <description>This bit controls whether the DW_apb_i2c master is enabled.

                                NOTE: Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>Master mode is disabled</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>Master mode is enabled</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_TAR</name>
                    <description>I2C Target Address Register

                        This register is 12 bits wide, and bits 31:12 are reserved. This register can be written to only when IC_ENABLE[0] is set to 0.

                        Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any write to this register if DW_apb_i2c is enabled as an I2C slave only.</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000055</resetValue>
                    <fields>
                        <field>
                            <name>SPECIAL</name>
                            <description>This bit indicates whether software performs a Device-ID or General Call or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1: perform special I2C command as specified in Device_ID or GC_OR_START bit Reset value: 0x0</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>Disables programming of GENERAL_CALL or START_BYTE transmission</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>Enables programming of GENERAL_CALL or START_BYTE transmission</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>GC_OR_START</name>
                            <description>If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit indicates whether a General Call or START byte command is to be performed by the DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>GENERAL_CALL</name>
                                    <description>GENERAL_CALL byte transmission</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>START_BYTE</name>
                                    <description>START byte transmission</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>IC_TAR</name>
                            <description>This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.

                                If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave.</description>
                            <bitRange>[9:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_SAR</name>
                    <description>I2C Slave Address Register</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000055</resetValue>
                    <fields>
                        <field>
                            <name>IC_SAR</name>
                            <description>The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used.

                                This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.

                                Note: The default values cannot be any of the reserved address locations: that is, 0x00 to 0x07, or 0x78 to 0x7f. The correct operation of the device is not guaranteed if you program the IC_SAR or IC_TAR to a reserved value. Refer to &lt;&lt;table_I2C_firstbyte_bit_defs&gt;&gt; for a complete list of these reserved values.</description>
                            <bitRange>[9:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_DATA_CMD</name>
                    <description>I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO.

                        The size of the register changes as follows:

                        Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a read command should be written for every byte that is to be received; otherwise the DW_apb_i2c will stop acknowledging.</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FIRST_DATA_BYTE</name>
                            <description>Indicates the first data byte received after the address phase for receive transfer in Master receiver or Slave receiver mode.

                                Reset value : 0x0

                                NOTE:  In case of APB_DATA_WIDTH=8,

                                1. The user has to perform two APB Reads to IC_DATA_CMD in order to get status on 11 bit.

                                2. In order to read the 11 bit, the user has to perform the first data byte read [7:0] (offset 0x10) and then perform the second read [15:8] (offset 0x11) in order to know the status of 11 bit (whether the data received in previous read is a first data byte or not).

                                3. The 11th bit is an optional read field, user can ignore 2nd byte read [15:8] (offset 0x11) if not interested in FIRST_DATA_BYTE status.</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>Sequential data byte received</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>Non sequential data byte received</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>RESTART</name>
                            <description>This bit controls whether a RESTART is issued before the byte is sent or received.

                                1 - If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.

                                0 - If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.

                                Reset value: 0x0</description>
                            <bitRange>[10:10]</bitRange>
                            <access>write-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>DISABLE</name>
                                    <description>Don't Issue RESTART before this command</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLE</name>
                                    <description>Issue RESTART before this command</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>STOP</name>
                            <description>This bit controls whether a STOP is issued after the byte is sent or received.

                                - 1 - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. - 0 - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. Reset value: 0x0</description>
                            <bitRange>[9:9]</bitRange>
                            <access>write-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>DISABLE</name>
                                    <description>Don't Issue STOP after this command</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLE</name>
                                    <description>Issue STOP after this command</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>CMD</name>
                            <description>This bit controls whether a read or a write is performed. This bit does not control the direction when the DW_apb_i2con acts as a slave. It controls only the direction when it acts as a master.

                                When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a 'don't care' because writes to this register are not required. In slave-transmitter mode, a '0' indicates that the data in IC_DATA_CMD is to be transmitted.

                                When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the IC_RAW_INTR_STAT register), unless bit 11 (SPECIAL) in the IC_TAR register has been cleared. If a '1' is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.

                                Reset value: 0x0</description>
                            <bitRange>[8:8]</bitRange>
                            <access>write-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>WRITE</name>
                                    <description>Master Write Command</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>READ</name>
                                    <description>Master Read Command</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DAT</name>
                            <description>This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the DW_apb_i2c. However, when you read this register, these bits return the value of data received on the DW_apb_i2c interface.

                                Reset value: 0x0</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_SS_SCL_HCNT</name>
                    <description>Standard Speed I2C Clock SCL High Count Register</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x00000028</resetValue>
                    <fields>
                        <field>
                            <name>IC_SS_SCL_HCNT</name>
                            <description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'.

                                This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.

                                The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed.

                                NOTE: This register must not be programmed to a value higher than 65525, because DW_apb_i2c uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_SS_SCL_LCNT</name>
                    <description>Standard Speed I2C Clock SCL Low Count Register</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x0000002F</resetValue>
                    <fields>
                        <field>
                            <name>IC_SS_SCL_LCNT</name>
                            <description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'

                                This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.

                                The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of DW_apb_i2c. The lower byte must be programmed first, and then the upper byte is programmed.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_FS_SCL_HCNT</name>
                    <description>Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register</description>
                    <addressOffset>0x1C</addressOffset>
                    <resetValue>0x00000006</resetValue>
                    <fields>
                        <field>
                            <name>IC_FS_SCL_HCNT</name>
                            <description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast mode or fast mode plus. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'.

                                This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.

                                The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_FS_SCL_LCNT</name>
                    <description>Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register</description>
                    <addressOffset>0x20</addressOffset>
                    <resetValue>0x0000000D</resetValue>
                    <fields>
                        <field>
                            <name>IC_FS_SCL_LCNT</name>
                            <description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'.

                                This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard.

                                This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.

                                The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_INTR_STAT</name>
                    <description>I2C Interrupt Status Register

                        Each bit in this register has a corresponding mask bit in the IC_INTR_MASK register. These bits are cleared by reading the matching interrupt clear register. The unmasked raw versions of these bits are available in the IC_RAW_INTR_STAT register.</description>
                    <addressOffset>0x2C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R_RESTART_DET</name>
                            <description>See IC_RAW_INTR_STAT for a detailed description of R_RESTART_DET bit.

                                Reset value: 0x0</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>R_RESTART_DET interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>R_RESTART_DET interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>R_GEN_CALL</name>
                            <description>See IC_RAW_INTR_STAT for a detailed description of R_GEN_CALL bit.

                                Reset value: 0x0</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>R_GEN_CALL interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>R_GEN_CALL interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>R_START_DET</name>
                            <description>See IC_RAW_INTR_STAT for a detailed description of R_START_DET bit.

                                Reset value: 0x0</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>R_START_DET interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>R_START_DET interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>R_STOP_DET</name>
                            <description>See IC_RAW_INTR_STAT for a detailed description of R_STOP_DET bit.

                                Reset value: 0x0</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>R_STOP_DET interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>R_STOP_DET interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>R_ACTIVITY</name>
                            <description>See IC_RAW_INTR_STAT for a detailed description of R_ACTIVITY bit.

                                Reset value: 0x0</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>R_ACTIVITY interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>R_ACTIVITY interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>R_RX_DONE</name>
                            <description>See IC_RAW_INTR_STAT for a detailed description of R_RX_DONE bit.

                                Reset value: 0x0</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>R_RX_DONE interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>R_RX_DONE interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>R_TX_ABRT</name>
                            <description>See IC_RAW_INTR_STAT for a detailed description of R_TX_ABRT bit.

                                Reset value: 0x0</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>R_TX_ABRT interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>R_TX_ABRT interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>R_RD_REQ</name>
                            <description>See IC_RAW_INTR_STAT for a detailed description of R_RD_REQ bit.

                                Reset value: 0x0</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>R_RD_REQ interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>R_RD_REQ interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>R_TX_EMPTY</name>
                            <description>See IC_RAW_INTR_STAT for a detailed description of R_TX_EMPTY bit.

                                Reset value: 0x0</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>R_TX_EMPTY interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>R_TX_EMPTY interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>R_TX_OVER</name>
                            <description>See IC_RAW_INTR_STAT for a detailed description of R_TX_OVER bit.

                                Reset value: 0x0</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>R_TX_OVER interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>R_TX_OVER interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>R_RX_FULL</name>
                            <description>See IC_RAW_INTR_STAT for a detailed description of R_RX_FULL bit.

                                Reset value: 0x0</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>R_RX_FULL interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>R_RX_FULL interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>R_RX_OVER</name>
                            <description>See IC_RAW_INTR_STAT for a detailed description of R_RX_OVER bit.

                                Reset value: 0x0</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>R_RX_OVER interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>R_RX_OVER interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>R_RX_UNDER</name>
                            <description>See IC_RAW_INTR_STAT for a detailed description of R_RX_UNDER bit.

                                Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>RX_UNDER interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>RX_UNDER interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_INTR_MASK</name>
                    <description>I2C Interrupt Mask Register.

                        These bits mask their corresponding interrupt status bits. This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt.</description>
                    <addressOffset>0x30</addressOffset>
                    <resetValue>0x000008FF</resetValue>
                    <fields>
                        <field>
                            <name>M_RESTART_DET</name>
                            <description>This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.

                                Reset value: 0x0</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>RESTART_DET interrupt is masked</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>RESTART_DET interrupt is unmasked</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>M_GEN_CALL</name>
                            <description>This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.

                                Reset value: 0x1</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>GEN_CALL interrupt is masked</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>GEN_CALL interrupt is unmasked</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>M_START_DET</name>
                            <description>This bit masks the R_START_DET interrupt in IC_INTR_STAT register.

                                Reset value: 0x0</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>START_DET interrupt is masked</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>START_DET interrupt is unmasked</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>M_STOP_DET</name>
                            <description>This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.

                                Reset value: 0x0</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>STOP_DET interrupt is masked</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>STOP_DET interrupt is unmasked</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>M_ACTIVITY</name>
                            <description>This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.

                                Reset value: 0x0</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>ACTIVITY interrupt is masked</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>ACTIVITY interrupt is unmasked</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>M_RX_DONE</name>
                            <description>This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.

                                Reset value: 0x1</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>RX_DONE interrupt is masked</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>RX_DONE interrupt is unmasked</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>M_TX_ABRT</name>
                            <description>This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.

                                Reset value: 0x1</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>TX_ABORT interrupt is masked</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>TX_ABORT interrupt is unmasked</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>M_RD_REQ</name>
                            <description>This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.

                                Reset value: 0x1</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>RD_REQ interrupt is masked</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>RD_REQ interrupt is unmasked</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>M_TX_EMPTY</name>
                            <description>This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.

                                Reset value: 0x1</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>TX_EMPTY interrupt is masked</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>TX_EMPTY interrupt is unmasked</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>M_TX_OVER</name>
                            <description>This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.

                                Reset value: 0x1</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>TX_OVER interrupt is masked</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>TX_OVER interrupt is unmasked</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>M_RX_FULL</name>
                            <description>This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.

                                Reset value: 0x1</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>RX_FULL interrupt is masked</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>RX_FULL interrupt is unmasked</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>M_RX_OVER</name>
                            <description>This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.

                                Reset value: 0x1</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>RX_OVER interrupt is masked</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>RX_OVER interrupt is unmasked</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>M_RX_UNDER</name>
                            <description>This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.

                                Reset value: 0x1</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>RX_UNDER interrupt is masked</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>RX_UNDER interrupt is unmasked</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_RAW_INTR_STAT</name>
                    <description>I2C Raw Interrupt Status Register

                        Unlike the IC_INTR_STAT register, these bits are not masked so they always show the true status of the DW_apb_i2c.</description>
                    <addressOffset>0x34</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RESTART_DET</name>
                            <description>Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed. Enabled only when IC_SLV_RESTART_DET_EN=1.

                                Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt.

                                Reset value: 0x0</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>RESTART_DET interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>RESTART_DET interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>GEN_CALL</name>
                            <description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling DW_apb_i2c or when the CPU reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores the received data in the Rx buffer.

                                Reset value: 0x0</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>GEN_CALL interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>GEN_CALL interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>START_DET</name>
                            <description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.

                                Reset value: 0x0</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>START_DET interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>START_DET interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>STOP_DET</name>
                            <description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.

                                In Slave Mode: - If IC_CON[7]=1'b1  (STOP_DET_IFADDRESSED), the STOP_DET interrupt will be issued only if slave is addressed. Note: During a general call address, this slave does not issue a STOP_DET interrupt if STOP_DET_IF_ADDRESSED=1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR). - If IC_CON[7]=1'b0 (STOP_DET_IFADDRESSED), the STOP_DET interrupt is issued irrespective of whether it is being addressed. In Master Mode: - If IC_CON[10]=1'b1  (STOP_DET_IF_MASTER_ACTIVE),the STOP_DET interrupt will be issued only if Master is active. - If IC_CON[10]=1'b0  (STOP_DET_IFADDRESSED),the STOP_DET interrupt will be issued irrespective of whether master is active or not. Reset value: 0x0</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>STOP_DET interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>STOP_DET interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ACTIVITY</name>
                            <description>This bit captures DW_apb_i2c activity and stays set until it is cleared. There are four ways to clear it: - Disabling the DW_apb_i2c - Reading the IC_CLR_ACTIVITY register - Reading the IC_CLR_INTR register - System reset Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the DW_apb_i2c module is idle, this bit remains set until cleared, indicating that there was activity on the bus.

                                Reset value: 0x0</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>RAW_INTR_ACTIVITY interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>RAW_INTR_ACTIVITY interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>RX_DONE</name>
                            <description>When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done.

                                Reset value: 0x0</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>RX_DONE interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>RX_DONE interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>TX_ABRT</name>
                            <description>This bit indicates if DW_apb_i2c, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a 'transmit abort'. When this bit is set to 1, the IC_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.

                                Note:  The DW_apb_i2c flushes/resets/empties the TX_FIFO and RX_FIFO whenever there is a transmit abort caused by any of the events tracked by the IC_TX_ABRT_SOURCE register. The FIFOs remains in this flushed state until the register IC_CLR_TX_ABRT is read. Once this read is performed, the Tx FIFO is then ready to accept more data bytes from the APB interface.

                                Reset value: 0x0</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>TX_ABRT interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>TX_ABRT interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>RD_REQ</name>
                            <description>This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C master is attempting to read data from DW_apb_i2c. The DW_apb_i2c holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the IC_DATA_CMD register. This bit is set to 0 just after the processor reads the IC_CLR_RD_REQ register.

                                Reset value: 0x0</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>RD_REQ interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>RD_REQ interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>TX_EMPTY</name>
                            <description>The behavior of the TX_EMPTY interrupt status differs based on the TX_EMPTY_CTRL selection in the IC_CON register. - When TX_EMPTY_CTRL = 0: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register. - When TX_EMPTY_CTRL = 1: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register and the transmission of the address/data from the internal shift register for the most recently popped command is completed. It is automatically cleared by hardware when the buffer level goes above the threshold. When IC_ENABLE[0] is set to 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer any activity, then with ic_en=0, this bit is set to 0.

                                Reset value: 0x0.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>TX_EMPTY interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>TX_EMPTY interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>TX_OVER</name>
                            <description>Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.

                                Reset value: 0x0</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>TX_OVER interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>TX_OVER interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>RX_FULL</name>
                            <description>Set when the receive buffer reaches or goes above the RX_TL threshold in the IC_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (IC_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the IC_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues.

                                Reset value: 0x0</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>RX_FULL interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>RX_FULL interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>RX_OVER</name>
                            <description>Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and an additional byte is received from an external I2C device. The DW_apb_i2c acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.

                                Note:  If bit 9 of the IC_CON register (RX_FIFO_FULL_HLD_CTRL) is programmed to HIGH, then the RX_OVER interrupt never occurs, because the Rx FIFO never overflows.

                                Reset value: 0x0</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>RX_OVER interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>RX_OVER interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>RX_UNDER</name>
                            <description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.

                                Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>RX_UNDER interrupt is inactive</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>RX_UNDER interrupt is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_RX_TL</name>
                    <description>I2C Receive FIFO Threshold Register</description>
                    <addressOffset>0x38</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RX_TL</name>
                            <description>Receive FIFO Threshold Level.

                                Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 255 sets the threshold for 256 entries.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_TX_TL</name>
                    <description>I2C Transmit FIFO Threshold Register</description>
                    <addressOffset>0x3C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TX_TL</name>
                            <description>Transmit FIFO Threshold Level.

                                Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 255 sets the threshold for 255 entries.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_CLR_INTR</name>
                    <description>Clear Combined and Individual Interrupt Register</description>
                    <addressOffset>0x40</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLR_INTR</name>
                            <description>Read this register to clear the combined interrupt, all individual interrupts, and the IC_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.

                                Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_CLR_RX_UNDER</name>
                    <description>Clear RX_UNDER Interrupt Register</description>
                    <addressOffset>0x44</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLR_RX_UNDER</name>
                            <description>Read this register to clear the RX_UNDER interrupt (bit 0) of the IC_RAW_INTR_STAT register.

                                Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_CLR_RX_OVER</name>
                    <description>Clear RX_OVER Interrupt Register</description>
                    <addressOffset>0x48</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLR_RX_OVER</name>
                            <description>Read this register to clear the RX_OVER interrupt (bit 1) of the IC_RAW_INTR_STAT register.

                                Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_CLR_TX_OVER</name>
                    <description>Clear TX_OVER Interrupt Register</description>
                    <addressOffset>0x4C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLR_TX_OVER</name>
                            <description>Read this register to clear the TX_OVER interrupt (bit 3) of the IC_RAW_INTR_STAT register.

                                Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_CLR_RD_REQ</name>
                    <description>Clear RD_REQ Interrupt Register</description>
                    <addressOffset>0x50</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLR_RD_REQ</name>
                            <description>Read this register to clear the RD_REQ interrupt (bit 5) of the IC_RAW_INTR_STAT register.

                                Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_CLR_TX_ABRT</name>
                    <description>Clear TX_ABRT Interrupt Register</description>
                    <addressOffset>0x54</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLR_TX_ABRT</name>
                            <description>Read this register to clear the TX_ABRT interrupt (bit 6) of the IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.

                                Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_CLR_RX_DONE</name>
                    <description>Clear RX_DONE Interrupt Register</description>
                    <addressOffset>0x58</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLR_RX_DONE</name>
                            <description>Read this register to clear the RX_DONE interrupt (bit 7) of the IC_RAW_INTR_STAT register.

                                Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_CLR_ACTIVITY</name>
                    <description>Clear ACTIVITY Interrupt Register</description>
                    <addressOffset>0x5C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLR_ACTIVITY</name>
                            <description>Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register.

                                Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_CLR_STOP_DET</name>
                    <description>Clear STOP_DET Interrupt Register</description>
                    <addressOffset>0x60</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLR_STOP_DET</name>
                            <description>Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register.

                                Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_CLR_START_DET</name>
                    <description>Clear START_DET Interrupt Register</description>
                    <addressOffset>0x64</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLR_START_DET</name>
                            <description>Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register.

                                Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_CLR_GEN_CALL</name>
                    <description>Clear GEN_CALL Interrupt Register</description>
                    <addressOffset>0x68</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLR_GEN_CALL</name>
                            <description>Read this register to clear the GEN_CALL interrupt (bit 11) of IC_RAW_INTR_STAT register.

                                Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_ENABLE</name>
                    <description>I2C Enable Register</description>
                    <addressOffset>0x6C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TX_CMD_BLOCK</name>
                            <description>In Master mode: - 1'b1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit. - 1'b0: The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. Note: To block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value:  IC_TX_CMD_BLOCK_DEFAULT</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NOT_BLOCKED</name>
                                    <description>Tx Command execution not blocked</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>BLOCKED</name>
                                    <description>Tx Command execution blocked</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ABORT</name>
                            <description>When set, the controller initiates the transfer abort. - 0: ABORT not initiated or ABORT done - 1: ABORT operation in progress The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation.

                                For a detailed description on how to abort I2C transfers, refer to 'Aborting I2C Transfers'.

                                Reset value: 0x0</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>DISABLE</name>
                                    <description>ABORT operation not in progress</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>ABORT operation in progress</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <description>Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable DW_apb_i2c while it is active. However, it is important that care be taken to ensure that DW_apb_i2c is disabled properly. A recommended procedure is described in 'Disabling DW_apb_i2c'.

                                When DW_apb_i2c is disabled, the following occurs: - The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT register are still active until DW_apb_i2c goes into IDLE state. If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the DW_apb_i2c stops the current transfer at the end of the current byte and does not acknowledge the transfer.

                                In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to asynchronous (1), there is a two ic_clk delay when enabling or disabling the DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c, refer to 'Disabling DW_apb_i2c'

                                Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>I2C is disabled</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>I2C is enabled</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_STATUS</name>
                    <description>I2C Status Register

                        This is a read-only register used to indicate the current transfer status and FIFO status. The status register may be read at any time. None of the bits in this register request an interrupt.

                        When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state machines goes to idle and ic_en=0: - Bits 5 and 6 are set to 0</description>
                    <addressOffset>0x70</addressOffset>
                    <resetValue>0x00000006</resetValue>
                    <fields>
                        <field>
                            <name>SLV_ACTIVITY</name>
                            <description>Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Slave FSM is in IDLE state so the Slave part of DW_apb_i2c is not Active - 1: Slave FSM is not in IDLE state so the Slave part of DW_apb_i2c is Active Reset value: 0x0</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>IDLE</name>
                                    <description>Slave is idle</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>Slave not idle</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>MST_ACTIVITY</name>
                            <description>Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Master FSM is in IDLE state so the Master part of DW_apb_i2c is not Active - 1: Master FSM is not in IDLE state so the Master part of DW_apb_i2c is Active Note: IC_STATUS[0]-that is, ACTIVITY bit-is the OR of SLV_ACTIVITY and MST_ACTIVITY bits.

                                Reset value: 0x0</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>IDLE</name>
                                    <description>Master is idle</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>Master not idle</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>RFF</name>
                            <description>Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared. - 0: Receive FIFO is not full - 1: Receive FIFO is full Reset value: 0x0</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NOT_FULL</name>
                                    <description>Rx FIFO not full</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>FULL</name>
                                    <description>Rx FIFO is full</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>RFNE</name>
                            <description>Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty. - 0: Receive FIFO is empty - 1: Receive FIFO is not empty Reset value: 0x0</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>EMPTY</name>
                                    <description>Rx FIFO is empty</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>NOT_EMPTY</name>
                                    <description>Rx FIFO not empty</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>TFE</name>
                            <description>Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt. - 0: Transmit FIFO is not empty - 1: Transmit FIFO is empty Reset value: 0x1</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NON_EMPTY</name>
                                    <description>Tx FIFO not empty</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>EMPTY</name>
                                    <description>Tx FIFO is empty</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>TFNF</name>
                            <description>Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full. - 0: Transmit FIFO is full - 1: Transmit FIFO is not full Reset value: 0x1</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>FULL</name>
                                    <description>Tx FIFO is full</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>NOT_FULL</name>
                                    <description>Tx FIFO not full</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ACTIVITY</name>
                            <description>I2C Activity Status. Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>I2C is idle</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>I2C is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_TXFLR</name>
                    <description>I2C Transmit FIFO Level Register This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is disabled - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO.</description>
                    <addressOffset>0x74</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TXFLR</name>
                            <description>Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO.

                                Reset value: 0x0</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_RXFLR</name>
                    <description>I2C Receive FIFO Level Register This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever: - The I2C is disabled - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO.</description>
                    <addressOffset>0x78</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RXFLR</name>
                            <description>Receive FIFO Level. Contains the number of valid data entries in the receive FIFO.

                                Reset value: 0x0</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_SDA_HOLD</name>
                    <description>I2C SDA Hold Time Length Register

                        The bits [15:0] of this register are used to control the hold time of SDA during transmit in both slave and master mode (after SCL goes from HIGH to LOW).

                        The bits [23:16] of this register are used to extend the SDA transition (if any) whenever SCL is HIGH in the receiver in either master or slave mode.

                        Writes to this register succeed only when IC_ENABLE[0]=0.

                        The values in this register are in units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode (one cycle in master mode, seven cycles in slave mode) for the value to be implemented.

                        The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part of scl. Therefore the programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl period measured in ic_clk cycles.</description>
                    <addressOffset>0x7C</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>IC_SDA_RX_HOLD</name>
                            <description>Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a receiver.

                                Reset value: IC_DEFAULT_SDA_HOLD[23:16].</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>IC_SDA_TX_HOLD</name>
                            <description>Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a transmitter.

                                Reset value: IC_DEFAULT_SDA_HOLD[15:0].</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_TX_ABRT_SOURCE</name>
                    <description>I2C Transmit Abort Source Register

                        This register has 32 bits that indicate the source of the TX_ABRT bit. Except for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the IC_CLR_INTR register is read. To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]).

                        Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, Bit 9 clears for one cycle and is then re-asserted.</description>
                    <addressOffset>0x80</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TX_FLUSH_CNT</name>
                            <description>This field indicates the number of Tx FIFO Data Commands which are flushed due to TX_ABRT interrupt. It is cleared whenever I2C is disabled.

                                Reset value: 0x0

                                Role of DW_apb_i2c:  Master-Transmitter or Slave-Transmitter</description>
                            <bitRange>[31:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ABRT_USER_ABRT</name>
                            <description>This is a master-mode-only bit. Master has detected the transfer abort (IC_ENABLE[1])

                                Reset value: 0x0

                                Role of DW_apb_i2c:  Master-Transmitter</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ABRT_USER_ABRT_VOID</name>
                                    <description>Transfer abort detected by master- scenario not present</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ABRT_USER_ABRT_GENERATED</name>
                                    <description>Transfer abort detected by master</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ABRT_SLVRD_INTX</name>
                            <description>1: When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of IC_DATA_CMD register.

                                Reset value: 0x0

                                Role of DW_apb_i2c:  Slave-Transmitter</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ABRT_SLVRD_INTX_VOID</name>
                                    <description>Slave trying to transmit to remote master in read mode- scenario not present</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ABRT_SLVRD_INTX_GENERATED</name>
                                    <description>Slave trying to transmit to remote master in read mode</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ABRT_SLV_ARBLOST</name>
                            <description>This field indicates that a Slave has lost the bus while transmitting data to a remote master. IC_TX_ABRT_SOURCE[12] is set at the same time. Note:  Even though the slave never 'owns' the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then DW_apb_i2c no longer own the bus.

                                Reset value: 0x0

                                Role of DW_apb_i2c:  Slave-Transmitter</description>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ABRT_SLV_ARBLOST_VOID</name>
                                    <description>Slave lost arbitration to remote master- scenario not present</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ABRT_SLV_ARBLOST_GENERATED</name>
                                    <description>Slave lost arbitration to remote master</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ABRT_SLVFLUSH_TXFIFO</name>
                            <description>This field specifies that the Slave has received a read command and some data exists in the TX FIFO, so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.

                                Reset value: 0x0

                                Role of DW_apb_i2c:  Slave-Transmitter</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ABRT_SLVFLUSH_TXFIFO_VOID</name>
                                    <description>Slave flushes existing data in TX-FIFO upon getting read command- scenario not present</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ABRT_SLVFLUSH_TXFIFO_GENERATED</name>
                                    <description>Slave flushes existing data in TX-FIFO upon getting read command</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ARB_LOST</name>
                            <description>This field specifies that the Master has lost arbitration, or if IC_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration.

                                Reset value: 0x0

                                Role of DW_apb_i2c:  Master-Transmitter or Slave-Transmitter</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ABRT_LOST_VOID</name>
                                    <description>Master or Slave-Transmitter lost arbitration- scenario not present</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ABRT_LOST_GENERATED</name>
                                    <description>Master or Slave-Transmitter lost arbitration</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ABRT_MASTER_DIS</name>
                            <description>This field indicates that the User tries to initiate a Master operation with the Master mode disabled.

                                Reset value: 0x0

                                Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ABRT_MASTER_DIS_VOID</name>
                                    <description>User initiating master operation when MASTER disabled- scenario not present</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ABRT_MASTER_DIS_GENERATED</name>
                                    <description>User initiating master operation when MASTER disabled</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ABRT_10B_RD_NORSTRT</name>
                            <description>This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the master sends a read command in 10-bit addressing mode.

                                Reset value: 0x0

                                Role of DW_apb_i2c:  Master-Receiver</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ABRT_10B_RD_VOID</name>
                                    <description>Master not trying to read in 10Bit addressing mode when RESTART disabled</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ABRT_10B_RD_GENERATED</name>
                                    <description>Master trying to read in 10Bit addressing mode when RESTART disabled</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ABRT_SBYTE_NORSTRT</name>
                            <description>To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets reasserted. When this field is set to 1, the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to send a START Byte.

                                Reset value: 0x0

                                Role of DW_apb_i2c:  Master</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ABRT_SBYTE_NORSTRT_VOID</name>
                                    <description>User trying to send START byte when RESTART disabled- scenario not present</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ABRT_SBYTE_NORSTRT_GENERATED</name>
                                    <description>User trying to send START byte when RESTART disabled</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ABRT_HS_NORSTRT</name>
                            <description>This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to use the master to transfer data in High Speed mode.

                                Reset value: 0x0

                                Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ABRT_HS_NORSTRT_VOID</name>
                                    <description>User trying to switch Master to HS mode when RESTART disabled- scenario not present</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ABRT_HS_NORSTRT_GENERATED</name>
                                    <description>User trying to switch Master to HS mode when RESTART disabled</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ABRT_SBYTE_ACKDET</name>
                            <description>This field indicates that the Master has sent a START Byte and the START Byte was acknowledged (wrong behavior).

                                Reset value: 0x0

                                Role of DW_apb_i2c:  Master</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ABRT_SBYTE_ACKDET_VOID</name>
                                    <description>ACK detected for START byte- scenario not present</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ABRT_SBYTE_ACKDET_GENERATED</name>
                                    <description>ACK detected for START byte</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ABRT_HS_ACKDET</name>
                            <description>This field indicates that the Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).

                                Reset value: 0x0

                                Role of DW_apb_i2c:  Master</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ABRT_HS_ACK_VOID</name>
                                    <description>HS Master code ACKed in HS Mode- scenario not present</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ABRT_HS_ACK_GENERATED</name>
                                    <description>HS Master code ACKed in HS Mode</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ABRT_GCALL_READ</name>
                            <description>This field indicates that DW_apb_i2c in the master mode has sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1).

                                Reset value: 0x0

                                Role of DW_apb_i2c:  Master-Transmitter</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ABRT_GCALL_READ_VOID</name>
                                    <description>GCALL is followed by read from bus-scenario not present</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ABRT_GCALL_READ_GENERATED</name>
                                    <description>GCALL is followed by read from bus</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ABRT_GCALL_NOACK</name>
                            <description>This field indicates that DW_apb_i2c in master mode has sent a General Call and no slave on the bus acknowledged the General Call.

                                Reset value: 0x0

                                Role of DW_apb_i2c:  Master-Transmitter</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ABRT_GCALL_NOACK_VOID</name>
                                    <description>GCALL not ACKed by any slave-scenario not present</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ABRT_GCALL_NOACK_GENERATED</name>
                                    <description>GCALL not ACKed by any slave</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ABRT_TXDATA_NOACK</name>
                            <description>This field indicates the master-mode only bit. When the master receives an acknowledgement for the address, but when it sends data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).

                                Reset value: 0x0

                                Role of DW_apb_i2c:  Master-Transmitter</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>ABRT_TXDATA_NOACK_VOID</name>
                                    <description>Transmitted data non-ACKed by addressed slave-scenario not present</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ABRT_TXDATA_NOACK_GENERATED</name>
                                    <description>Transmitted data not ACKed by addressed slave</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ABRT_10ADDR2_NOACK</name>
                            <description>This field indicates that the Master is in 10-bit address mode and that the second address byte of the 10-bit address was not acknowledged by any slave.

                                Reset value: 0x0

                                Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>This abort is not generated</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>Byte 2 of 10Bit Address not ACKed by any slave</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ABRT_10ADDR1_NOACK</name>
                            <description>This field indicates that the Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.

                                Reset value: 0x0

                                Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>This abort is not generated</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>Byte 1 of 10Bit Address not ACKed by any slave</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>ABRT_7B_ADDR_NOACK</name>
                            <description>This field indicates that the Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.

                                Reset value: 0x0

                                Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>This abort is not generated</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>This abort is generated because of NOACK for 7-bit address</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_SLV_DATA_NACK_ONLY</name>
                    <description>Generate Slave Data NACK Register

                        The register is used to generate a NACK for the data part of a transfer when DW_apb_i2c is acting as a slave-receiver. This register only exists when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this parameter disabled, this register does not exist and writing to the register's address has no effect.

                        A write can occur on this register if both of the following conditions are met: - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) - Slave part is inactive (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register read-back location for the internal slv_activity signal; the user should poll this before writing the ic_slv_data_nack_only bit.</description>
                    <addressOffset>0x84</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NACK</name>
                            <description>Generate NACK. This NACK generation only occurs when DW_apb_i2c is a slave-receiver. If this register is set to a value of 1, it can only generate a NACK after a data byte is received; hence, the data transfer is aborted and the data received is not pushed to the receive buffer.

                                When the register is set to a value of 0, it generates NACK/ACK, depending on normal criteria. - 1: generate NACK after data byte received - 0: generate NACK/ACK normally Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>Slave receiver generates NACK normally</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>Slave receiver generates NACK upon data reception only</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_DMA_CR</name>
                    <description>DMA Control Register

                        The register is used to enable the DMA Controller interface operation. There is a separate bit for transmit and receive. This can be programmed regardless of the state of IC_ENABLE.</description>
                    <addressOffset>0x88</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TDMAE</name>
                            <description>Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. Reset value: 0x0</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>transmit FIFO DMA channel disabled</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>Transmit FIFO DMA channel enabled</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>RDMAE</name>
                            <description>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>Receive FIFO DMA channel disabled</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>Receive FIFO DMA channel enabled</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_DMA_TDLR</name>
                    <description>DMA Transmit Data Level Register</description>
                    <addressOffset>0x8C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DMATDL</name>
                            <description>Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.

                                Reset value: 0x0</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_DMA_RDLR</name>
                    <description>I2C Receive Data Level Register</description>
                    <addressOffset>0x90</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DMARDL</name>
                            <description>Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.

                                Reset value: 0x0</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_SDA_SETUP</name>
                    <description>I2C SDA Setup Register

                        This register controls the amount of time delay (in terms of number of ic_clk clock periods) introduced in the rising edge of SCL - relative to SDA changing - when DW_apb_i2c services a read request in a slave-transmitter operation. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.

                        Writes to this register succeed only when IC_ENABLE[0] = 0.

                        Note: The length of setup time is calculated using [(IC_SDA_SETUP - 1) * (ic_clk_period)], so if the user requires 10 ic_clk periods of setup time, they should program a value of 11. The IC_SDA_SETUP register is only used by the DW_apb_i2c when operating as a slave transmitter.</description>
                    <addressOffset>0x94</addressOffset>
                    <resetValue>0x00000064</resetValue>
                    <fields>
                        <field>
                            <name>SDA_SETUP</name>
                            <description>SDA Setup. It is recommended that if the required delay is 1000ns, then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11. IC_SDA_SETUP must be programmed with a minimum value of 2.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_ACK_GENERAL_CALL</name>
                    <description>I2C ACK General Call Register

                        The register controls whether DW_apb_i2c responds with a ACK or NACK when it receives an I2C General Call address.

                        This register is applicable only when the DW_apb_i2c is in slave mode.</description>
                    <addressOffset>0x98</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>ACK_GEN_CALL</name>
                            <description>ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with a NACK (by negating ic_data_oe).</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>Generate NACK for a General Call</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>Generate ACK for a General Call</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_ENABLE_STATUS</name>
                    <description>I2C Enable Status Register

                        The register is used to report the DW_apb_i2c hardware status when the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is disabled.

                        If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced to 1.

                        If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is read as '0'.

                        Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read as 0 because disabling the DW_apb_i2c depends on I2C bus activities.</description>
                    <addressOffset>0x9C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SLV_RX_DATA_LOST</name>
                            <description>Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting bit 0 of IC_ENABLE from 1 to 0. When read as 1, DW_apb_i2c is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK.

                                Note:  If the remote I2C master terminates the transfer with a STOP condition before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit is also set to 1.

                                When read as 0, DW_apb_i2c is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.

                                Note:  The CPU can safely read this bit when IC_EN (bit 0) is read as 0.

                                Reset value: 0x0</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>Slave RX Data is not lost</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>Slave RX Data is lost</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SLV_DISABLED_WHILE_BUSY</name>
                            <description>Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting bit 0 of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:

                                (a) DW_apb_i2c is receiving the address byte of the Slave-Transmitter operation from a remote master;

                                OR,

                                (b) address and data bytes of the Slave-Receiver operation from a remote master.

                                When read as 1, DW_apb_i2c is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in DW_apb_i2c (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.

                                Note:  If the remote I2C master terminates the transfer with a STOP condition before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit will also be set to 1.

                                When read as 0, DW_apb_i2c is deemed to have been disabled when there is master activity, or when the I2C bus is idle.

                                Note:  The CPU can safely read this bit when IC_EN (bit 0) is read as 0.

                                Reset value: 0x0</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INACTIVE</name>
                                    <description>Slave is disabled when it is idle</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ACTIVE</name>
                                    <description>Slave is disabled when it is active</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>IC_EN</name>
                            <description>ic_en Status. This bit always reflects the value driven on the output port ic_en. - When read as 1, DW_apb_i2c is deemed to be in an enabled state. - When read as 0, DW_apb_i2c is deemed completely inactive. Note:  The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1).

                                Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>DISABLED</name>
                                    <description>I2C disabled</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>ENABLED</name>
                                    <description>I2C enabled</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_FS_SPKLEN</name>
                    <description>I2C SS, FS or FM+ spike suppression limit

                        This register is used to store the duration, measured in ic_clk cycles, of the longest spike that is filtered out by the spike suppression logic when the component is operating in SS, FS or FM+ modes. The relevant I2C requirement is tSP (table 4) as detailed in the I2C Bus Specification. This register must be programmed with a minimum value of 1.</description>
                    <addressOffset>0xA0</addressOffset>
                    <resetValue>0x00000007</resetValue>
                    <fields>
                        <field>
                            <name>IC_FS_SPKLEN</name>
                            <description>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. or more information, refer to 'Spike Suppression'.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_CLR_RESTART_DET</name>
                    <description>Clear RESTART_DET Interrupt Register</description>
                    <addressOffset>0xA8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLR_RESTART_DET</name>
                            <description>Read this register to clear the RESTART_DET interrupt (bit 12) of IC_RAW_INTR_STAT register.

                                Reset value: 0x0</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_COMP_PARAM_1</name>
                    <description>Component Parameter Register 1

                        Note This register is not implemented and therefore reads as 0. If it was implemented it would be a constant read-only register that contains encoded information about the component's parameter settings. Fields shown below are the settings for those parameters</description>
                    <addressOffset>0xF4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TX_BUFFER_DEPTH</name>
                            <description>TX Buffer Depth = 16</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RX_BUFFER_DEPTH</name>
                            <description>RX Buffer Depth = 16</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ADD_ENCODED_PARAMS</name>
                            <description>Encoded parameters not visible</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HAS_DMA</name>
                            <description>DMA handshaking signals are enabled</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>INTR_IO</name>
                            <description>COMBINED Interrupt outputs</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HC_COUNT_VALUES</name>
                            <description>Programmable count values for each mode.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>MAX_SPEED_MODE</name>
                            <description>MAX SPEED MODE = FAST MODE</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>APB_DATA_WIDTH</name>
                            <description>APB data bus width is 32 bits</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_COMP_VERSION</name>
                    <description>I2C Component Version Register</description>
                    <addressOffset>0xF8</addressOffset>
                    <resetValue>0x3230312A</resetValue>
                    <fields>
                        <field>
                            <name>IC_COMP_VERSION</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IC_COMP_TYPE</name>
                    <description>I2C Component Type Register</description>
                    <addressOffset>0xFC</addressOffset>
                    <resetValue>0x44570140</resetValue>
                    <fields>
                        <field>
                            <name>IC_COMP_TYPE</name>
                            <description>Designware Component Type number = 0x44_57_01_40. This assigned unique hex value is constant and is derived from the two ASCII letters 'DW' followed by a 16-bit unsigned number.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral derivedFrom="I2C0">
            <name>I2C1</name>
            <baseAddress>0x40098000</baseAddress>
            <interrupt>
                <name>I2C1_IRQ</name>
                <value>37</value>
            </interrupt>
        </peripheral>
        <peripheral>
            <name>SPI0</name>
            <baseAddress>0x40080000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x1000</size>
                <usage>registers</usage>
            </addressBlock>
            <interrupt>
                <name>SPI0_IRQ</name>
                <value>31</value>
            </interrupt>
            <registers>
                <register>
                    <name>SSPCR0</name>
                    <description>Control register 0, SSPCR0 on page 3-4</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SCR</name>
                            <description>Serial clock rate. The value SCR is used to generate the transmit and receive bit rate of the PrimeCell SSP. The bit rate is: F SSPCLK CPSDVSR x (1+SCR) where CPSDVSR is an even value from 2-254, programmed through the SSPCPSR register and SCR is a value from 0-255.</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SPH</name>
                            <description>SSPCLKOUT phase, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SPO</name>
                            <description>SSPCLKOUT polarity, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FRF</name>
                            <description>Frame format.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <name>FRF</name>
                                <enumeratedValue>
                                    <name>Motorola</name>
                                    <description>Motorola SPI frame format</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Texas_Instruments</name>
                                    <description>Texas Instruments synchronous serial frame format</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>National_Semiconductor_Microwire</name>
                                    <description>National Semiconductor Microwire frame format</description>
                                    <value>2</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DSS</name>
                            <description>Data Size Select: 0000 Reserved, undefined operation. 0001 Reserved, undefined operation. 0010 Reserved, undefined operation. 0011 4-bit data. 0100 5-bit data. 0101 6-bit data. 0110 7-bit data. 0111 8-bit data. 1000 9-bit data. 1001 10-bit data. 1010 11-bit data. 1011 12-bit data. 1100 13-bit data. 1101 14-bit data. 1110 15-bit data. 1111 16-bit data.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SSPCR1</name>
                    <description>Control register 1, SSPCR1 on page 3-5</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SOD</name>
                            <description>Slave-mode output disable. This bit is relevant only in the slave mode, MS=1. In multiple-slave systems, it is possible for an PrimeCell SSP master to broadcast a message to all slaves in the system while ensuring that only one slave drives data onto its serial output line. In such systems the RXD lines from multiple slaves could be tied together. To operate in such systems, the SOD bit can be set if the PrimeCell SSP slave is not supposed to drive the SSPTXD line: 0 SSP can drive the SSPTXD output in slave mode. 1 SSP must not drive the SSPTXD output in slave mode.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MS</name>
                            <description>Master or slave mode select. This bit can be modified only when the PrimeCell SSP is disabled, SSE=0: 0 Device configured as master, default. 1 Device configured as slave.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SSE</name>
                            <description>Synchronous serial port enable: 0 SSP operation disabled. 1 SSP operation enabled.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>LBM</name>
                            <description>Loop back mode: 0 Normal serial port operation enabled. 1 Output of transmit serial shifter is connected to input of receive serial shifter internally.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SSPDR</name>
                    <description>Data register, SSPDR on page 3-6</description>
                    <addressOffset>0x8</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>DATA</name>
                            <description>Transmit/Receive FIFO: Read Receive FIFO. Write Transmit FIFO. You must right-justify data when the PrimeCell SSP is programmed for a data size that is less than 16 bits. Unused bits at the top are ignored by transmit logic. The receive logic automatically right-justifies.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SSPSR</name>
                    <description>Status register, SSPSR on page 3-7</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00000003</resetValue>
                    <fields>
                        <field>
                            <name>BSY</name>
                            <description>PrimeCell SSP busy flag, RO: 0 SSP is idle. 1 SSP is currently transmitting and/or receiving a frame or the transmit FIFO is not empty.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RFF</name>
                            <description>Receive FIFO full, RO: 0 Receive FIFO is not full. 1 Receive FIFO is full.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RNE</name>
                            <description>Receive FIFO not empty, RO: 0 Receive FIFO is empty. 1 Receive FIFO is not empty.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TNF</name>
                            <description>Transmit FIFO not full, RO: 0 Transmit FIFO is full. 1 Transmit FIFO is not full.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TFE</name>
                            <description>Transmit FIFO empty, RO: 0 Transmit FIFO is not empty. 1 Transmit FIFO is empty.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SSPCPSR</name>
                    <description>Clock prescale register, SSPCPSR on page 3-8</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CPSDVSR</name>
                            <description>Clock prescale divisor. Must be an even number from 2-254, depending on the frequency of SSPCLK. The least significant bit always returns zero on reads.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SSPIMSC</name>
                    <description>Interrupt mask set or clear register, SSPIMSC on page 3-9</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TXIM</name>
                            <description>Transmit FIFO interrupt mask: 0 Transmit FIFO half empty or less condition interrupt is masked. 1 Transmit FIFO half empty or less condition interrupt is not masked.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RXIM</name>
                            <description>Receive FIFO interrupt mask: 0 Receive FIFO half full or less condition interrupt is masked. 1 Receive FIFO half full or less condition interrupt is not masked.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RTIM</name>
                            <description>Receive timeout interrupt mask: 0 Receive FIFO not empty and no read prior to timeout period interrupt is masked. 1 Receive FIFO not empty and no read prior to timeout period interrupt is not masked.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RORIM</name>
                            <description>Receive overrun interrupt mask: 0 Receive FIFO written to while full condition interrupt is masked. 1 Receive FIFO written to while full condition interrupt is not masked.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SSPRIS</name>
                    <description>Raw interrupt status register, SSPRIS on page 3-10</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x00000008</resetValue>
                    <fields>
                        <field>
                            <name>TXRIS</name>
                            <description>Gives the raw interrupt state, prior to masking, of the SSPTXINTR interrupt</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RXRIS</name>
                            <description>Gives the raw interrupt state, prior to masking, of the SSPRXINTR interrupt</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RTRIS</name>
                            <description>Gives the raw interrupt state, prior to masking, of the SSPRTINTR interrupt</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RORRIS</name>
                            <description>Gives the raw interrupt state, prior to masking, of the SSPRORINTR interrupt</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SSPMIS</name>
                    <description>Masked interrupt status register, SSPMIS on page 3-11</description>
                    <addressOffset>0x1C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TXMIS</name>
                            <description>Gives the transmit FIFO masked interrupt state, after masking, of the SSPTXINTR interrupt</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RXMIS</name>
                            <description>Gives the receive FIFO masked interrupt state, after masking, of the SSPRXINTR interrupt</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RTMIS</name>
                            <description>Gives the receive timeout masked interrupt state, after masking, of the SSPRTINTR interrupt</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RORMIS</name>
                            <description>Gives the receive over run masked interrupt status, after masking, of the SSPRORINTR interrupt</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SSPICR</name>
                    <description>Interrupt clear register, SSPICR on page 3-11</description>
                    <addressOffset>0x20</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RTIC</name>
                            <description>Clears the SSPRTINTR interrupt</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>RORIC</name>
                            <description>Clears the SSPRORINTR interrupt</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SSPDMACR</name>
                    <description>DMA control register, SSPDMACR on page 3-12</description>
                    <addressOffset>0x24</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TXDMAE</name>
                            <description>Transmit DMA Enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RXDMAE</name>
                            <description>Receive DMA Enable. If this bit is set to 1, DMA for the receive FIFO is enabled.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SSPPERIPHID0</name>
                    <description>Peripheral identification registers, SSPPeriphID0-3 on page 3-13</description>
                    <addressOffset>0xFE0</addressOffset>
                    <resetValue>0x00000022</resetValue>
                    <fields>
                        <field>
                            <name>PARTNUMBER0</name>
                            <description>These bits read back as 0x22</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SSPPERIPHID1</name>
                    <description>Peripheral identification registers, SSPPeriphID0-3 on page 3-13</description>
                    <addressOffset>0xFE4</addressOffset>
                    <resetValue>0x00000010</resetValue>
                    <fields>
                        <field>
                            <name>DESIGNER0</name>
                            <description>These bits read back as 0x1</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PARTNUMBER1</name>
                            <description>These bits read back as 0x0</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SSPPERIPHID2</name>
                    <description>Peripheral identification registers, SSPPeriphID0-3 on page 3-13</description>
                    <addressOffset>0xFE8</addressOffset>
                    <resetValue>0x00000034</resetValue>
                    <fields>
                        <field>
                            <name>REVISION</name>
                            <description>These bits return the peripheral revision</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DESIGNER1</name>
                            <description>These bits read back as 0x4</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SSPPERIPHID3</name>
                    <description>Peripheral identification registers, SSPPeriphID0-3 on page 3-13</description>
                    <addressOffset>0xFEC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CONFIGURATION</name>
                            <description>These bits read back as 0x00</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SSPPCELLID0</name>
                    <description>PrimeCell identification registers, SSPPCellID0-3 on page 3-16</description>
                    <addressOffset>0xFF0</addressOffset>
                    <resetValue>0x0000000D</resetValue>
                    <fields>
                        <field>
                            <name>SSPPCELLID0</name>
                            <description>These bits read back as 0x0D</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SSPPCELLID1</name>
                    <description>PrimeCell identification registers, SSPPCellID0-3 on page 3-16</description>
                    <addressOffset>0xFF4</addressOffset>
                    <resetValue>0x000000F0</resetValue>
                    <fields>
                        <field>
                            <name>SSPPCELLID1</name>
                            <description>These bits read back as 0xF0</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SSPPCELLID2</name>
                    <description>PrimeCell identification registers, SSPPCellID0-3 on page 3-16</description>
                    <addressOffset>0xFF8</addressOffset>
                    <resetValue>0x00000005</resetValue>
                    <fields>
                        <field>
                            <name>SSPPCELLID2</name>
                            <description>These bits read back as 0x05</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SSPPCELLID3</name>
                    <description>PrimeCell identification registers, SSPPCellID0-3 on page 3-16</description>
                    <addressOffset>0xFFC</addressOffset>
                    <resetValue>0x000000B1</resetValue>
                    <fields>
                        <field>
                            <name>SSPPCELLID3</name>
                            <description>These bits read back as 0xB1</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral derivedFrom="SPI0">
            <name>SPI1</name>
            <baseAddress>0x40088000</baseAddress>
            <interrupt>
                <name>SPI1_IRQ</name>
                <value>32</value>
            </interrupt>
        </peripheral>
        <peripheral>
            <name>PIO0</name>
            <description>Programmable IO block</description>
            <baseAddress>0x50200000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x188</size>
                <usage>registers</usage>
            </addressBlock>
            <interrupt>
                <name>PIO0_IRQ_0</name>
                <value>15</value>
            </interrupt>
            <interrupt>
                <name>PIO0_IRQ_1</name>
                <value>16</value>
            </interrupt>
            <registers>
                <register>
                    <name>CTRL</name>
                    <description>PIO control register</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NEXTPREV_CLKDIV_RESTART</name>
                            <description>Write 1 to restart the clock dividers of state machines in neighbouring PIO blocks, as specified by NEXT_PIO_MASK and PREV_PIO_MASK in the same write.

                                This is equivalent to writing 1 to the corresponding CLKDIV_RESTART bits in those PIOs' CTRL registers.</description>
                            <bitRange>[26:26]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>NEXTPREV_SM_DISABLE</name>
                            <description>Write 1 to disable state machines in neighbouring PIO blocks, as specified by NEXT_PIO_MASK and PREV_PIO_MASK in the same write.

                                This is equivalent to clearing the corresponding SM_ENABLE bits in those PIOs' CTRL registers.</description>
                            <bitRange>[25:25]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>NEXTPREV_SM_ENABLE</name>
                            <description>Write 1 to enable state machines in neighbouring PIO blocks, as specified by NEXT_PIO_MASK and PREV_PIO_MASK in the same write.

                                This is equivalent to setting the corresponding SM_ENABLE bits in those PIOs' CTRL registers.

                                If both OTHERS_SM_ENABLE and OTHERS_SM_DISABLE are set, the disable takes precedence.</description>
                            <bitRange>[24:24]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>NEXT_PIO_MASK</name>
                            <description>A mask of state machines in the neighbouring higher-numbered PIO block in the system (or PIO block 0 if this is the highest-numbered PIO block) to which to apply the operations specified by NEXTPREV_CLKDIV_RESTART, NEXTPREV_SM_ENABLE, and NEXTPREV_SM_DISABLE in the same write.

                                This allows state machines in a neighbouring PIO block to be started/stopped/clock-synced exactly simultaneously with a write to this PIO block's CTRL register.

                                Note that in a system with two PIOs, NEXT_PIO_MASK and PREV_PIO_MASK actually indicate the same PIO block. In this case the effects are applied cumulatively (as though the masks were OR'd together).

                                Neighbouring PIO blocks are disconnected (status signals tied to 0 and control signals ignored) if one block is accessible to NonSecure code, and one is not.</description>
                            <bitRange>[23:20]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>PREV_PIO_MASK</name>
                            <description>A mask of state machines in the neighbouring lower-numbered PIO block in the system (or the highest-numbered PIO block if this is PIO block 0) to which to apply the operations specified by OP_CLKDIV_RESTART, OP_ENABLE, OP_DISABLE in the same write.

                                This allows state machines in a neighbouring PIO block to be started/stopped/clock-synced exactly simultaneously with a write to this PIO block's CTRL register.

                                Neighbouring PIO blocks are disconnected (status signals tied to 0 and control signals ignored) if one block is accessible to NonSecure code, and one is not.</description>
                            <bitRange>[19:16]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>CLKDIV_RESTART</name>
                            <description>Restart a state machine's clock divider from an initial phase of 0. Clock dividers are free-running, so once started, their output (including fractional jitter) is completely determined by the integer/fractional divisor configured in SMx_CLKDIV. This means that, if multiple clock dividers with the same divisor are restarted simultaneously, by writing multiple 1 bits to this field, the execution clocks of those state machines will run in precise lockstep.

                                Note that setting/clearing SM_ENABLE does not stop the clock divider from running, so once multiple state machines' clocks are synchronised, it is safe to disable/reenable a state machine, whilst keeping the clock dividers in sync.

                                Note also that CLKDIV_RESTART can be written to whilst the state machine is running, and this is useful to resynchronise clock dividers after the divisors (SMx_CLKDIV) have been changed on-the-fly.</description>
                            <bitRange>[11:8]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>SM_RESTART</name>
                            <description>Write 1 to instantly clear internal SM state which may be otherwise difficult to access and will affect future execution.

                                Specifically, the following are cleared: input and output shift counters; the contents of the input shift register; the delay counter; the waiting-on-IRQ state; any stalled instruction written to SMx_INSTR or run by OUT/MOV EXEC; any pin write left asserted due to OUT_STICKY.

                                The contents of the output shift register and the X/Y scratch registers are not affected.</description>
                            <bitRange>[7:4]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>SM_ENABLE</name>
                            <description>Enable/disable each of the four state machines by writing 1/0 to each of these four bits. When disabled, a state machine will cease executing instructions, except those written directly to SMx_INSTR by the system. Multiple bits can be set/cleared at once to run/halt multiple state machines simultaneously.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FSTAT</name>
                    <description>FIFO status register</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x0F000F00</resetValue>
                    <fields>
                        <field>
                            <name>TXEMPTY</name>
                            <description>State machine TX FIFO is empty</description>
                            <bitRange>[27:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TXFULL</name>
                            <description>State machine TX FIFO is full</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RXEMPTY</name>
                            <description>State machine RX FIFO is empty</description>
                            <bitRange>[11:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RXFULL</name>
                            <description>State machine RX FIFO is full</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FDEBUG</name>
                    <description>FIFO debug register</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TXSTALL</name>
                            <description>State machine has stalled on empty TX FIFO during a blocking PULL, or an OUT with autopull enabled. Write 1 to clear.</description>
                            <bitRange>[27:24]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>TXOVER</name>
                            <description>TX FIFO overflow (i.e. write-on-full by the system) has occurred. Write 1 to clear. Note that write-on-full does not alter the state or contents of the FIFO in any way, but the data that the system attempted to write is dropped, so if this flag is set, your software has quite likely dropped some data on the floor.</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>RXUNDER</name>
                            <description>RX FIFO underflow (i.e. read-on-empty by the system) has occurred. Write 1 to clear. Note that read-on-empty does not perturb the state of the FIFO in any way, but the data returned by reading from an empty FIFO is undefined, so this flag generally only becomes set due to some kind of software error.</description>
                            <bitRange>[11:8]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>RXSTALL</name>
                            <description>State machine has stalled on full RX FIFO during a blocking PUSH, or an IN with autopush enabled. This flag is also set when a nonblocking PUSH to a full FIFO took place, in which case the state machine has dropped data. Write 1 to clear.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FLEVEL</name>
                    <description>FIFO levels</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RX3</name>
                            <bitRange>[31:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TX3</name>
                            <bitRange>[27:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RX2</name>
                            <bitRange>[23:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TX2</name>
                            <bitRange>[19:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RX1</name>
                            <bitRange>[15:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TX1</name>
                            <bitRange>[11:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RX0</name>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TX0</name>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>4</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-3</dimIndex>
                    <name>TXF%s</name>
                    <description>Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TXF0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>4</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-3</dimIndex>
                    <name>RXF%s</name>
                    <description>Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.</description>
                    <addressOffset>0x20</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>RXF0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQ</name>
                    <description>State machine IRQ flags register. Write 1 to clear. There are eight state machine IRQ flags, which can be set, cleared, and waited on by the state machines. There's no fixed association between flags and state machines -- any state machine can use any flag.

                        Any of the eight flags can be used for timing synchronisation between state machines, using IRQ and WAIT instructions. Any combination of the eight flags can also routed out to either of the two system-level interrupt requests, alongside FIFO status interrupts -- see e.g. IRQ0_INTE.</description>
                    <addressOffset>0x30</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>IRQ</name>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>IRQ_FORCE</name>
                    <description>Writing a 1 to each of these bits will forcibly assert the corresponding IRQ. Note this is different to the INTF register: writing here affects PIO internal state. INTF just asserts the processor-facing IRQ signal for testing ISRs, and is not visible to the state machines.</description>
                    <addressOffset>0x34</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>IRQ_FORCE</name>
                            <bitRange>[7:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INPUT_SYNC_BYPASS</name>
                    <description>There is a 2-flipflop synchronizer on each GPIO input, which protects PIO logic from metastabilities. This increases input delay, and for fast synchronous IO (e.g. SPI) these synchronizers may need to be bypassed. Each bit in this register corresponds to one GPIO.
                        0 -&gt; input is synchronized (default)
                        1 -&gt; synchronizer is bypassed
                        If in doubt, leave this register as all zeroes.</description>
                    <addressOffset>0x38</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INPUT_SYNC_BYPASS</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DBG_PADOUT</name>
                    <description>Read to sample the pad output values PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.</description>
                    <addressOffset>0x3C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DBG_PADOUT</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DBG_PADOE</name>
                    <description>Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.</description>
                    <addressOffset>0x40</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DBG_PADOE</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DBG_CFGINFO</name>
                    <description>The PIO hardware has some free parameters that may vary between chip products.
                        These should be provided in the chip datasheet, but are also exposed here.</description>
                    <addressOffset>0x44</addressOffset>
                    <resetValue>0x10000000</resetValue>
                    <fields>
                        <field>
                            <name>VERSION</name>
                            <description>Version of the core PIO hardware.</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>v0</name>
                                    <description>Version 0 (RP2040)</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>v1</name>
                                    <description>Version 1 (RP2350)</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>IMEM_SIZE</name>
                            <description>The size of the instruction memory, measured in units of one instruction</description>
                            <bitRange>[21:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SM_COUNT</name>
                            <description>The number of state machines this PIO instance is equipped with.</description>
                            <bitRange>[11:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FIFO_DEPTH</name>
                            <description>The depth of the state machine TX/RX FIFOs, measured in words.
                                Joining fifos via SHIFTCTRL_FJOIN gives one FIFO with double
                                this depth.</description>
                            <bitRange>[5:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>32</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-31</dimIndex>
                    <name>INSTR_MEM%s</name>
                    <description>Write-only access to instruction memory location %s</description>
                    <addressOffset>0x48</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INSTR_MEM0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <cluster>
                    <dim>4</dim>
                    <dimIncrement>0x18</dimIncrement>
                    <dimIndex>0-3</dimIndex>
                    <name>SM%s</name>
                    <description>Cluster SM%s, containing SM*_CLKDIV, SM*_EXECCTRL, SM*_SHIFTCTRL, SM*_ADDR, SM*_INSTR, SM*_PINCTRL</description>
                    <addressOffset>0xC8</addressOffset>
                    <register>
                        <name>SM_CLKDIV</name>
                        <description>Clock divisor register for state machine 0
                            Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)</description>
                        <addressOffset>0x0</addressOffset>
                        <resetValue>0x00010000</resetValue>
                        <fields>
                            <field>
                                <name>INT</name>
                                <description>Effective frequency is sysclk/(int + frac/256).
                                    Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0.</description>
                                <bitRange>[31:16]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>FRAC</name>
                                <description>Fractional part of clock divisor</description>
                                <bitRange>[15:8]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>SM_EXECCTRL</name>
                        <description>Execution/behavioural settings for state machine 0</description>
                        <addressOffset>0x4</addressOffset>
                        <resetValue>0x0001F000</resetValue>
                        <fields>
                            <field>
                                <name>EXEC_STALLED</name>
                                <description>If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.</description>
                                <bitRange>[31:31]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SIDE_EN</name>
                                <description>If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.</description>
                                <bitRange>[30:30]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SIDE_PINDIR</name>
                                <description>If 1, side-set data is asserted to pin directions, instead of pin values</description>
                                <bitRange>[29:29]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>JMP_PIN</name>
                                <description>The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.</description>
                                <bitRange>[28:24]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>OUT_EN_SEL</name>
                                <description>Which data bit to use for inline OUT enable</description>
                                <bitRange>[23:19]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>INLINE_OUT_EN</name>
                                <description>If 1, use a bit of OUT data as an auxiliary write enable
                                    When used in conjunction with OUT_STICKY, writes with an enable of 0 will
                                    deassert the latest pin write. This can create useful masking/override behaviour
                                    due to the priority ordering of state machine pin writes (SM0 &lt; SM1 &lt; ...)</description>
                                <bitRange>[18:18]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>OUT_STICKY</name>
                                <description>Continuously assert the most recent OUT/SET to the pins</description>
                                <bitRange>[17:17]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>WRAP_TOP</name>
                                <description>After reaching this address, execution is wrapped to wrap_bottom.
                                    If the instruction is a jump, and the jump condition is true, the jump takes priority.</description>
                                <bitRange>[16:12]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>WRAP_BOTTOM</name>
                                <description>After reaching wrap_top, execution is wrapped to this address.</description>
                                <bitRange>[11:7]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>STATUS_SEL</name>
                                <description>Comparison used for the MOV x, STATUS instruction.</description>
                                <bitRange>[6:5]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>TXLEVEL</name>
                                        <description>All-ones if TX FIFO level &lt; N, otherwise all-zeroes</description>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>RXLEVEL</name>
                                        <description>All-ones if RX FIFO level &lt; N, otherwise all-zeroes</description>
                                        <value>1</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>IRQ</name>
                                        <description>All-ones if the indexed IRQ flag is raised, otherwise all-zeroes</description>
                                        <value>2</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                            <field>
                                <name>STATUS_N</name>
                                <description>Comparison level or IRQ index for the MOV x, STATUS instruction.

                                    If STATUS_SEL is TXLEVEL or RXLEVEL, then values of STATUS_N greater than the current FIFO depth are reserved, and have undefined behaviour.</description>
                                <bitRange>[4:0]</bitRange>
                                <access>read-write</access>
                                <enumeratedValues>
                                    <enumeratedValue>
                                        <name>IRQ</name>
                                        <description>Index 0-7 of an IRQ flag in this PIO block</description>
                                        <value>0</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>IRQ_PREVPIO</name>
                                        <description>Index 0-7 of an IRQ flag in the next lower-numbered PIO block</description>
                                        <value>8</value>
                                    </enumeratedValue>
                                    <enumeratedValue>
                                        <name>IRQ_NEXTPIO</name>
                                        <description>Index 0-7 of an IRQ flag in the next higher-numbered PIO block</description>
                                        <value>16</value>
                                    </enumeratedValue>
                                </enumeratedValues>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>SM_SHIFTCTRL</name>
                        <description>Control behaviour of the input/output shift registers for state machine 0</description>
                        <addressOffset>0x8</addressOffset>
                        <resetValue>0x000C0000</resetValue>
                        <fields>
                            <field>
                                <name>FJOIN_RX</name>
                                <description>When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.
                                    TX FIFO is disabled as a result (always reads as both full and empty).
                                    FIFOs are flushed when this bit is changed.</description>
                                <bitRange>[31:31]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>FJOIN_TX</name>
                                <description>When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.
                                    RX FIFO is disabled as a result (always reads as both full and empty).
                                    FIFOs are flushed when this bit is changed.</description>
                                <bitRange>[30:30]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>PULL_THRESH</name>
                                <description>Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place.
                                    Write 0 for value of 32.</description>
                                <bitRange>[29:25]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>PUSH_THRESH</name>
                                <description>Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place.
                                    Write 0 for value of 32.</description>
                                <bitRange>[24:20]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>OUT_SHIFTDIR</name>
                                <description>1 = shift out of output shift register to right. 0 = to left.</description>
                                <bitRange>[19:19]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>IN_SHIFTDIR</name>
                                <description>1 = shift input shift register to right (data enters from left). 0 = to left.</description>
                                <bitRange>[18:18]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>AUTOPULL</name>
                                <description>Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.</description>
                                <bitRange>[17:17]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>AUTOPUSH</name>
                                <description>Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.</description>
                                <bitRange>[16:16]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>FJOIN_RX_PUT</name>
                                <description>If 1, disable this state machine's RX FIFO, make its storage available for random write access by the state machine (using the `put` instruction) and, unless FJOIN_RX_GET is also set, random read access by the processor (through the RXFx_PUTGETy registers).

                                    If FJOIN_RX_PUT and FJOIN_RX_GET are both set, then the RX FIFO's registers can be randomly read/written by the state machine, but are completely inaccessible to the processor.

                                    Setting this bit will clear the FJOIN_TX and FJOIN_RX bits.</description>
                                <bitRange>[15:15]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>FJOIN_RX_GET</name>
                                <description>If 1, disable this state machine's RX FIFO, make its storage available for random read access by the state machine (using the `get` instruction) and, unless FJOIN_RX_PUT is also set, random write access by the processor (through the RXFx_PUTGETy registers).

                                    If FJOIN_RX_PUT and FJOIN_RX_GET are both set, then the RX FIFO's registers can be randomly read/written by the state machine, but are completely inaccessible to the processor.

                                    Setting this bit will clear the FJOIN_TX and FJOIN_RX bits.</description>
                                <bitRange>[14:14]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>IN_COUNT</name>
                                <description>Set the number of pins which are not masked to 0 when read by an IN PINS, WAIT PIN or MOV x, PINS instruction.

                                    For example, an IN_COUNT of 5 means that the 5 LSBs of the IN pin group are visible (bits 4:0), but the remaining 27 MSBs are masked to 0. A count of 32 is encoded with a field value of 0, so the default behaviour is to not perform any masking.

                                    Note this masking is applied in addition to the masking usually performed by the IN instruction. This is mainly useful for the MOV x, PINS instruction, which otherwise has no way of masking pins.</description>
                                <bitRange>[4:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>SM_ADDR</name>
                        <description>Current instruction address of state machine 0</description>
                        <addressOffset>0xC</addressOffset>
                        <resetValue>0x00000000</resetValue>
                        <fields>
                            <field>
                                <name>SM0_ADDR</name>
                                <bitRange>[4:0]</bitRange>
                                <access>read-only</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>SM_INSTR</name>
                        <description>Read to see the instruction currently addressed by state machine 0's program counter
                            Write to execute an instruction immediately (including jumps) and then resume execution.</description>
                        <addressOffset>0x10</addressOffset>
                        <resetMask>0x00000000</resetMask>
                        <fields>
                            <field>
                                <name>SM0_INSTR</name>
                                <bitRange>[15:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>SM_PINCTRL</name>
                        <description>State machine pin control</description>
                        <addressOffset>0x14</addressOffset>
                        <resetValue>0x14000000</resetValue>
                        <fields>
                            <field>
                                <name>SIDESET_COUNT</name>
                                <description>The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).</description>
                                <bitRange>[31:29]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SET_COUNT</name>
                                <description>The number of pins asserted by a SET. In the range 0 to 5 inclusive.</description>
                                <bitRange>[28:26]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>OUT_COUNT</name>
                                <description>The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.</description>
                                <bitRange>[25:20]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>IN_BASE</name>
                                <description>The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.</description>
                                <bitRange>[19:15]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SIDESET_BASE</name>
                                <description>The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.</description>
                                <bitRange>[14:10]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SET_BASE</name>
                                <description>The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.</description>
                                <bitRange>[9:5]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>OUT_BASE</name>
                                <description>The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.</description>
                                <bitRange>[4:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                </cluster>
                <register>
                    <dim>4</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-3</dimIndex>
                    <name>RXF0_PUTGET%s</name>
                    <description>Direct read/write access to entry %s of SM0's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.</description>
                    <addressOffset>0x128</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RXF0_PUTGET0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>4</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-3</dimIndex>
                    <name>RXF1_PUTGET%s</name>
                    <description>Direct read/write access to entry %s of SM1's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.</description>
                    <addressOffset>0x138</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RXF1_PUTGET0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>4</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-3</dimIndex>
                    <name>RXF2_PUTGET%s</name>
                    <description>Direct read/write access to entry %s of SM2's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.</description>
                    <addressOffset>0x148</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RXF2_PUTGET0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>4</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-3</dimIndex>
                    <name>RXF3_PUTGET%s</name>
                    <description>Direct read/write access to entry %s of SM3's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.</description>
                    <addressOffset>0x158</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RXF3_PUTGET0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIOBASE</name>
                    <description>Relocate GPIO 0 (from PIO's point of view) in the system GPIO numbering, to access more than 32 GPIOs from PIO.

                        Only the values 0 and 16 are supported (only bit 4 is writable).</description>
                    <addressOffset>0x168</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIOBASE</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTR</name>
                    <description>Raw Interrupts</description>
                    <addressOffset>0x16C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SM7</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SM6</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SM5</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SM4</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SM3</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SM2</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SM1</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SM0</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SM3_TXNFULL</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SM2_TXNFULL</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SM1_TXNFULL</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SM0_TXNFULL</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SM3_RXNEMPTY</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SM2_RXNEMPTY</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SM1_RXNEMPTY</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SM0_RXNEMPTY</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <cluster>
                    <dim>2</dim>
                    <dimIncrement>0xC</dimIncrement>
                    <dimIndex>0-1</dimIndex>
                    <name>SM_IRQ%s</name>
                    <description>Cluster SM_IRQ%s, containing IRQ*_INTE, IRQ*_INTF, IRQ*_INTS</description>
                    <addressOffset>0x170</addressOffset>
                    <register>
                        <name>IRQ_INTE</name>
                        <description>Interrupt Enable for irq0</description>
                        <addressOffset>0x0</addressOffset>
                        <resetValue>0x00000000</resetValue>
                        <fields>
                            <field>
                                <name>SM7</name>
                                <bitRange>[15:15]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM6</name>
                                <bitRange>[14:14]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM5</name>
                                <bitRange>[13:13]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM4</name>
                                <bitRange>[12:12]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM3</name>
                                <bitRange>[11:11]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM2</name>
                                <bitRange>[10:10]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM1</name>
                                <bitRange>[9:9]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM0</name>
                                <bitRange>[8:8]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM3_TXNFULL</name>
                                <bitRange>[7:7]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM2_TXNFULL</name>
                                <bitRange>[6:6]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM1_TXNFULL</name>
                                <bitRange>[5:5]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM0_TXNFULL</name>
                                <bitRange>[4:4]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM3_RXNEMPTY</name>
                                <bitRange>[3:3]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM2_RXNEMPTY</name>
                                <bitRange>[2:2]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM1_RXNEMPTY</name>
                                <bitRange>[1:1]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM0_RXNEMPTY</name>
                                <bitRange>[0:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>IRQ_INTF</name>
                        <description>Interrupt Force for irq0</description>
                        <addressOffset>0x4</addressOffset>
                        <resetValue>0x00000000</resetValue>
                        <fields>
                            <field>
                                <name>SM7</name>
                                <bitRange>[15:15]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM6</name>
                                <bitRange>[14:14]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM5</name>
                                <bitRange>[13:13]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM4</name>
                                <bitRange>[12:12]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM3</name>
                                <bitRange>[11:11]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM2</name>
                                <bitRange>[10:10]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM1</name>
                                <bitRange>[9:9]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM0</name>
                                <bitRange>[8:8]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM3_TXNFULL</name>
                                <bitRange>[7:7]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM2_TXNFULL</name>
                                <bitRange>[6:6]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM1_TXNFULL</name>
                                <bitRange>[5:5]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM0_TXNFULL</name>
                                <bitRange>[4:4]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM3_RXNEMPTY</name>
                                <bitRange>[3:3]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM2_RXNEMPTY</name>
                                <bitRange>[2:2]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM1_RXNEMPTY</name>
                                <bitRange>[1:1]</bitRange>
                                <access>read-write</access>
                            </field>
                            <field>
                                <name>SM0_RXNEMPTY</name>
                                <bitRange>[0:0]</bitRange>
                                <access>read-write</access>
                            </field>
                        </fields>
                    </register>
                    <register>
                        <name>IRQ_INTS</name>
                        <description>Interrupt status after masking &amp; forcing for irq0</description>
                        <addressOffset>0x8</addressOffset>
                        <resetValue>0x00000000</resetValue>
                        <fields>
                            <field>
                                <name>SM7</name>
                                <bitRange>[15:15]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SM6</name>
                                <bitRange>[14:14]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SM5</name>
                                <bitRange>[13:13]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SM4</name>
                                <bitRange>[12:12]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SM3</name>
                                <bitRange>[11:11]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SM2</name>
                                <bitRange>[10:10]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SM1</name>
                                <bitRange>[9:9]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SM0</name>
                                <bitRange>[8:8]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SM3_TXNFULL</name>
                                <bitRange>[7:7]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SM2_TXNFULL</name>
                                <bitRange>[6:6]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SM1_TXNFULL</name>
                                <bitRange>[5:5]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SM0_TXNFULL</name>
                                <bitRange>[4:4]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SM3_RXNEMPTY</name>
                                <bitRange>[3:3]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SM2_RXNEMPTY</name>
                                <bitRange>[2:2]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SM1_RXNEMPTY</name>
                                <bitRange>[1:1]</bitRange>
                                <access>read-only</access>
                            </field>
                            <field>
                                <name>SM0_RXNEMPTY</name>
                                <bitRange>[0:0]</bitRange>
                                <access>read-only</access>
                            </field>
                        </fields>
                    </register>
                </cluster>
            </registers>
        </peripheral>
        <peripheral derivedFrom="PIO0">
            <name>PIO1</name>
            <baseAddress>0x50300000</baseAddress>
            <interrupt>
                <name>PIO1_IRQ_0</name>
                <value>17</value>
            </interrupt>
            <interrupt>
                <name>PIO1_IRQ_1</name>
                <value>18</value>
            </interrupt>
        </peripheral>
        <peripheral derivedFrom="PIO0">
            <name>PIO2</name>
            <baseAddress>0x50400000</baseAddress>
            <interrupt>
                <name>PIO2_IRQ_0</name>
                <value>19</value>
            </interrupt>
            <interrupt>
                <name>PIO2_IRQ_1</name>
                <value>20</value>
            </interrupt>
        </peripheral>
        <peripheral>
            <name>BUSCTRL</name>
            <description>Register block for busfabric control signals and performance counters</description>
            <baseAddress>0x40068000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x2C</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>BUS_PRIORITY</name>
                    <description>Set the priority of each master for bus arbitration.</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DMA_W</name>
                            <description>0 - low priority, 1 - high priority</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DMA_R</name>
                            <description>0 - low priority, 1 - high priority</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PROC1</name>
                            <description>0 - low priority, 1 - high priority</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PROC0</name>
                            <description>0 - low priority, 1 - high priority</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BUS_PRIORITY_ACK</name>
                    <description>Bus priority acknowledge</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BUS_PRIORITY_ACK</name>
                            <description>Goes to 1 once all arbiters have registered the new global priority levels.
                                Arbiters update their local priority when servicing a new nonsequential access.
                                In normal circumstances this will happen almost immediately.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PERFCTR_EN</name>
                    <description>Enable the performance counters. If 0, the performance counters do not increment. This can be used to precisely start/stop event sampling around the profiled section of code.

                        The performance counters are initially disabled, to save energy.</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PERFCTR_EN</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PERFCTR0</name>
                    <description>Bus fabric performance counter 0</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PERFCTR0</name>
                            <description>Busfabric saturating performance counter 0
                                Count some event signal from the busfabric arbiters, if PERFCTR_EN is set.
                                Write any value to clear. Select an event to count using PERFSEL0</description>
                            <bitRange>[23:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PERFSEL0</name>
                    <description>Bus fabric performance event select for PERFCTR0</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x0000001F</resetValue>
                    <fields>
                        <field>
                            <name>PERFSEL0</name>
                            <description>Select an event for PERFCTR0. For each downstream port of the main crossbar, four events are available: ACCESS, an access took place; ACCESS_CONTESTED, an access took place that previously stalled due to contention from other masters; STALL_DOWNSTREAM, count cycles where any master stalled due to a stall on the downstream bus; STALL_UPSTREAM, count cycles where any master stalled for any reason, including contention from other masters.</description>
                            <bitRange>[6:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>siob_proc1_stall_upstream</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc1_stall_downstream</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc1_access_contested</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc1_access</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc0_stall_upstream</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc0_stall_downstream</name>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc0_access_contested</name>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc0_access</name>
                                    <value>7</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>apb_stall_upstream</name>
                                    <value>8</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>apb_stall_downstream</name>
                                    <value>9</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>apb_access_contested</name>
                                    <value>10</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>apb_access</name>
                                    <value>11</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>fastperi_stall_upstream</name>
                                    <value>12</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>fastperi_stall_downstream</name>
                                    <value>13</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>fastperi_access_contested</name>
                                    <value>14</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>fastperi_access</name>
                                    <value>15</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram9_stall_upstream</name>
                                    <value>16</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram9_stall_downstream</name>
                                    <value>17</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram9_access_contested</name>
                                    <value>18</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram9_access</name>
                                    <value>19</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram8_stall_upstream</name>
                                    <value>20</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram8_stall_downstream</name>
                                    <value>21</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram8_access_contested</name>
                                    <value>22</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram8_access</name>
                                    <value>23</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram7_stall_upstream</name>
                                    <value>24</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram7_stall_downstream</name>
                                    <value>25</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram7_access_contested</name>
                                    <value>26</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram7_access</name>
                                    <value>27</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram6_stall_upstream</name>
                                    <value>28</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram6_stall_downstream</name>
                                    <value>29</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram6_access_contested</name>
                                    <value>30</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram6_access</name>
                                    <value>31</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram5_stall_upstream</name>
                                    <value>32</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram5_stall_downstream</name>
                                    <value>33</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram5_access_contested</name>
                                    <value>34</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram5_access</name>
                                    <value>35</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram4_stall_upstream</name>
                                    <value>36</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram4_stall_downstream</name>
                                    <value>37</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram4_access_contested</name>
                                    <value>38</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram4_access</name>
                                    <value>39</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram3_stall_upstream</name>
                                    <value>40</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram3_stall_downstream</name>
                                    <value>41</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram3_access_contested</name>
                                    <value>42</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram3_access</name>
                                    <value>43</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram2_stall_upstream</name>
                                    <value>44</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram2_stall_downstream</name>
                                    <value>45</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram2_access_contested</name>
                                    <value>46</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram2_access</name>
                                    <value>47</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram1_stall_upstream</name>
                                    <value>48</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram1_stall_downstream</name>
                                    <value>49</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram1_access_contested</name>
                                    <value>50</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram1_access</name>
                                    <value>51</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram0_stall_upstream</name>
                                    <value>52</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram0_stall_downstream</name>
                                    <value>53</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram0_access_contested</name>
                                    <value>54</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram0_access</name>
                                    <value>55</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main1_stall_upstream</name>
                                    <value>56</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main1_stall_downstream</name>
                                    <value>57</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main1_access_contested</name>
                                    <value>58</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main1_access</name>
                                    <value>59</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main0_stall_upstream</name>
                                    <value>60</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main0_stall_downstream</name>
                                    <value>61</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main0_access_contested</name>
                                    <value>62</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main0_access</name>
                                    <value>63</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rom_stall_upstream</name>
                                    <value>64</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rom_stall_downstream</name>
                                    <value>65</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rom_access_contested</name>
                                    <value>66</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rom_access</name>
                                    <value>67</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PERFCTR1</name>
                    <description>Bus fabric performance counter 1</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PERFCTR1</name>
                            <description>Busfabric saturating performance counter 1
                                Count some event signal from the busfabric arbiters, if PERFCTR_EN is set.
                                Write any value to clear. Select an event to count using PERFSEL1</description>
                            <bitRange>[23:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PERFSEL1</name>
                    <description>Bus fabric performance event select for PERFCTR1</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x0000001F</resetValue>
                    <fields>
                        <field>
                            <name>PERFSEL1</name>
                            <description>Select an event for PERFCTR1. For each downstream port of the main crossbar, four events are available: ACCESS, an access took place; ACCESS_CONTESTED, an access took place that previously stalled due to contention from other masters; STALL_DOWNSTREAM, count cycles where any master stalled due to a stall on the downstream bus; STALL_UPSTREAM, count cycles where any master stalled for any reason, including contention from other masters.</description>
                            <bitRange>[6:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>siob_proc1_stall_upstream</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc1_stall_downstream</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc1_access_contested</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc1_access</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc0_stall_upstream</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc0_stall_downstream</name>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc0_access_contested</name>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc0_access</name>
                                    <value>7</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>apb_stall_upstream</name>
                                    <value>8</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>apb_stall_downstream</name>
                                    <value>9</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>apb_access_contested</name>
                                    <value>10</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>apb_access</name>
                                    <value>11</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>fastperi_stall_upstream</name>
                                    <value>12</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>fastperi_stall_downstream</name>
                                    <value>13</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>fastperi_access_contested</name>
                                    <value>14</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>fastperi_access</name>
                                    <value>15</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram9_stall_upstream</name>
                                    <value>16</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram9_stall_downstream</name>
                                    <value>17</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram9_access_contested</name>
                                    <value>18</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram9_access</name>
                                    <value>19</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram8_stall_upstream</name>
                                    <value>20</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram8_stall_downstream</name>
                                    <value>21</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram8_access_contested</name>
                                    <value>22</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram8_access</name>
                                    <value>23</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram7_stall_upstream</name>
                                    <value>24</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram7_stall_downstream</name>
                                    <value>25</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram7_access_contested</name>
                                    <value>26</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram7_access</name>
                                    <value>27</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram6_stall_upstream</name>
                                    <value>28</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram6_stall_downstream</name>
                                    <value>29</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram6_access_contested</name>
                                    <value>30</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram6_access</name>
                                    <value>31</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram5_stall_upstream</name>
                                    <value>32</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram5_stall_downstream</name>
                                    <value>33</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram5_access_contested</name>
                                    <value>34</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram5_access</name>
                                    <value>35</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram4_stall_upstream</name>
                                    <value>36</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram4_stall_downstream</name>
                                    <value>37</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram4_access_contested</name>
                                    <value>38</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram4_access</name>
                                    <value>39</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram3_stall_upstream</name>
                                    <value>40</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram3_stall_downstream</name>
                                    <value>41</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram3_access_contested</name>
                                    <value>42</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram3_access</name>
                                    <value>43</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram2_stall_upstream</name>
                                    <value>44</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram2_stall_downstream</name>
                                    <value>45</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram2_access_contested</name>
                                    <value>46</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram2_access</name>
                                    <value>47</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram1_stall_upstream</name>
                                    <value>48</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram1_stall_downstream</name>
                                    <value>49</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram1_access_contested</name>
                                    <value>50</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram1_access</name>
                                    <value>51</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram0_stall_upstream</name>
                                    <value>52</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram0_stall_downstream</name>
                                    <value>53</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram0_access_contested</name>
                                    <value>54</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram0_access</name>
                                    <value>55</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main1_stall_upstream</name>
                                    <value>56</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main1_stall_downstream</name>
                                    <value>57</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main1_access_contested</name>
                                    <value>58</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main1_access</name>
                                    <value>59</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main0_stall_upstream</name>
                                    <value>60</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main0_stall_downstream</name>
                                    <value>61</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main0_access_contested</name>
                                    <value>62</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main0_access</name>
                                    <value>63</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rom_stall_upstream</name>
                                    <value>64</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rom_stall_downstream</name>
                                    <value>65</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rom_access_contested</name>
                                    <value>66</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rom_access</name>
                                    <value>67</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PERFCTR2</name>
                    <description>Bus fabric performance counter 2</description>
                    <addressOffset>0x1C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PERFCTR2</name>
                            <description>Busfabric saturating performance counter 2
                                Count some event signal from the busfabric arbiters, if PERFCTR_EN is set.
                                Write any value to clear. Select an event to count using PERFSEL2</description>
                            <bitRange>[23:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PERFSEL2</name>
                    <description>Bus fabric performance event select for PERFCTR2</description>
                    <addressOffset>0x20</addressOffset>
                    <resetValue>0x0000001F</resetValue>
                    <fields>
                        <field>
                            <name>PERFSEL2</name>
                            <description>Select an event for PERFCTR2. For each downstream port of the main crossbar, four events are available: ACCESS, an access took place; ACCESS_CONTESTED, an access took place that previously stalled due to contention from other masters; STALL_DOWNSTREAM, count cycles where any master stalled due to a stall on the downstream bus; STALL_UPSTREAM, count cycles where any master stalled for any reason, including contention from other masters.</description>
                            <bitRange>[6:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>siob_proc1_stall_upstream</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc1_stall_downstream</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc1_access_contested</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc1_access</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc0_stall_upstream</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc0_stall_downstream</name>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc0_access_contested</name>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc0_access</name>
                                    <value>7</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>apb_stall_upstream</name>
                                    <value>8</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>apb_stall_downstream</name>
                                    <value>9</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>apb_access_contested</name>
                                    <value>10</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>apb_access</name>
                                    <value>11</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>fastperi_stall_upstream</name>
                                    <value>12</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>fastperi_stall_downstream</name>
                                    <value>13</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>fastperi_access_contested</name>
                                    <value>14</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>fastperi_access</name>
                                    <value>15</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram9_stall_upstream</name>
                                    <value>16</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram9_stall_downstream</name>
                                    <value>17</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram9_access_contested</name>
                                    <value>18</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram9_access</name>
                                    <value>19</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram8_stall_upstream</name>
                                    <value>20</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram8_stall_downstream</name>
                                    <value>21</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram8_access_contested</name>
                                    <value>22</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram8_access</name>
                                    <value>23</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram7_stall_upstream</name>
                                    <value>24</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram7_stall_downstream</name>
                                    <value>25</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram7_access_contested</name>
                                    <value>26</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram7_access</name>
                                    <value>27</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram6_stall_upstream</name>
                                    <value>28</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram6_stall_downstream</name>
                                    <value>29</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram6_access_contested</name>
                                    <value>30</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram6_access</name>
                                    <value>31</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram5_stall_upstream</name>
                                    <value>32</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram5_stall_downstream</name>
                                    <value>33</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram5_access_contested</name>
                                    <value>34</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram5_access</name>
                                    <value>35</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram4_stall_upstream</name>
                                    <value>36</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram4_stall_downstream</name>
                                    <value>37</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram4_access_contested</name>
                                    <value>38</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram4_access</name>
                                    <value>39</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram3_stall_upstream</name>
                                    <value>40</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram3_stall_downstream</name>
                                    <value>41</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram3_access_contested</name>
                                    <value>42</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram3_access</name>
                                    <value>43</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram2_stall_upstream</name>
                                    <value>44</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram2_stall_downstream</name>
                                    <value>45</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram2_access_contested</name>
                                    <value>46</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram2_access</name>
                                    <value>47</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram1_stall_upstream</name>
                                    <value>48</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram1_stall_downstream</name>
                                    <value>49</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram1_access_contested</name>
                                    <value>50</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram1_access</name>
                                    <value>51</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram0_stall_upstream</name>
                                    <value>52</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram0_stall_downstream</name>
                                    <value>53</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram0_access_contested</name>
                                    <value>54</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram0_access</name>
                                    <value>55</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main1_stall_upstream</name>
                                    <value>56</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main1_stall_downstream</name>
                                    <value>57</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main1_access_contested</name>
                                    <value>58</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main1_access</name>
                                    <value>59</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main0_stall_upstream</name>
                                    <value>60</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main0_stall_downstream</name>
                                    <value>61</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main0_access_contested</name>
                                    <value>62</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main0_access</name>
                                    <value>63</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rom_stall_upstream</name>
                                    <value>64</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rom_stall_downstream</name>
                                    <value>65</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rom_access_contested</name>
                                    <value>66</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rom_access</name>
                                    <value>67</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PERFCTR3</name>
                    <description>Bus fabric performance counter 3</description>
                    <addressOffset>0x24</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>PERFCTR3</name>
                            <description>Busfabric saturating performance counter 3
                                Count some event signal from the busfabric arbiters, if PERFCTR_EN is set.
                                Write any value to clear. Select an event to count using PERFSEL3</description>
                            <bitRange>[23:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PERFSEL3</name>
                    <description>Bus fabric performance event select for PERFCTR3</description>
                    <addressOffset>0x28</addressOffset>
                    <resetValue>0x0000001F</resetValue>
                    <fields>
                        <field>
                            <name>PERFSEL3</name>
                            <description>Select an event for PERFCTR3. For each downstream port of the main crossbar, four events are available: ACCESS, an access took place; ACCESS_CONTESTED, an access took place that previously stalled due to contention from other masters; STALL_DOWNSTREAM, count cycles where any master stalled due to a stall on the downstream bus; STALL_UPSTREAM, count cycles where any master stalled for any reason, including contention from other masters.</description>
                            <bitRange>[6:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>siob_proc1_stall_upstream</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc1_stall_downstream</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc1_access_contested</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc1_access</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc0_stall_upstream</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc0_stall_downstream</name>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc0_access_contested</name>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>siob_proc0_access</name>
                                    <value>7</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>apb_stall_upstream</name>
                                    <value>8</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>apb_stall_downstream</name>
                                    <value>9</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>apb_access_contested</name>
                                    <value>10</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>apb_access</name>
                                    <value>11</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>fastperi_stall_upstream</name>
                                    <value>12</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>fastperi_stall_downstream</name>
                                    <value>13</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>fastperi_access_contested</name>
                                    <value>14</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>fastperi_access</name>
                                    <value>15</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram9_stall_upstream</name>
                                    <value>16</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram9_stall_downstream</name>
                                    <value>17</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram9_access_contested</name>
                                    <value>18</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram9_access</name>
                                    <value>19</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram8_stall_upstream</name>
                                    <value>20</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram8_stall_downstream</name>
                                    <value>21</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram8_access_contested</name>
                                    <value>22</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram8_access</name>
                                    <value>23</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram7_stall_upstream</name>
                                    <value>24</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram7_stall_downstream</name>
                                    <value>25</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram7_access_contested</name>
                                    <value>26</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram7_access</name>
                                    <value>27</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram6_stall_upstream</name>
                                    <value>28</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram6_stall_downstream</name>
                                    <value>29</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram6_access_contested</name>
                                    <value>30</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram6_access</name>
                                    <value>31</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram5_stall_upstream</name>
                                    <value>32</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram5_stall_downstream</name>
                                    <value>33</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram5_access_contested</name>
                                    <value>34</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram5_access</name>
                                    <value>35</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram4_stall_upstream</name>
                                    <value>36</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram4_stall_downstream</name>
                                    <value>37</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram4_access_contested</name>
                                    <value>38</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram4_access</name>
                                    <value>39</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram3_stall_upstream</name>
                                    <value>40</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram3_stall_downstream</name>
                                    <value>41</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram3_access_contested</name>
                                    <value>42</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram3_access</name>
                                    <value>43</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram2_stall_upstream</name>
                                    <value>44</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram2_stall_downstream</name>
                                    <value>45</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram2_access_contested</name>
                                    <value>46</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram2_access</name>
                                    <value>47</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram1_stall_upstream</name>
                                    <value>48</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram1_stall_downstream</name>
                                    <value>49</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram1_access_contested</name>
                                    <value>50</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram1_access</name>
                                    <value>51</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram0_stall_upstream</name>
                                    <value>52</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram0_stall_downstream</name>
                                    <value>53</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram0_access_contested</name>
                                    <value>54</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>sram0_access</name>
                                    <value>55</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main1_stall_upstream</name>
                                    <value>56</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main1_stall_downstream</name>
                                    <value>57</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main1_access_contested</name>
                                    <value>58</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main1_access</name>
                                    <value>59</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main0_stall_upstream</name>
                                    <value>60</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main0_stall_downstream</name>
                                    <value>61</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main0_access_contested</name>
                                    <value>62</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>xip_main0_access</name>
                                    <value>63</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rom_stall_upstream</name>
                                    <value>64</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rom_stall_downstream</name>
                                    <value>65</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rom_access_contested</name>
                                    <value>66</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>rom_access</name>
                                    <value>67</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>SIO</name>
            <description>Single-cycle IO block
                Provides core-local and inter-core hardware for the two processors, with single-cycle access.</description>
            <baseAddress>0xD0000000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x1E8</size>
                <usage>registers</usage>
            </addressBlock>
            <interrupt>
                <name>SIO_IRQ_FIFO</name>
                <value>25</value>
            </interrupt>
            <interrupt>
                <name>SIO_IRQ_BELL</name>
                <value>26</value>
            </interrupt>
            <interrupt>
                <name>SIO_IRQ_FIFO_NS</name>
                <value>27</value>
            </interrupt>
            <interrupt>
                <name>SIO_IRQ_BELL_NS</name>
                <value>28</value>
            </interrupt>
            <interrupt>
                <name>SIO_IRQ_MTIMECMP</name>
                <value>29</value>
            </interrupt>
            <registers>
                <register>
                    <name>CPUID</name>
                    <description>Processor core identifier</description>
                    <addressOffset>0x0</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CPUID</name>
                            <description>Value is 0 when read from processor core 0, and 1 when read from processor core 1.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_IN</name>
                    <description>Input value for GPIO0...31.

                        In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) appear as zero.</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_IN</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_HI_IN</name>
                    <description>Input value on GPIO32...47, QSPI IOs and USB pins

                        In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) appear as zero.</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>QSPI_SD</name>
                            <description>Input value on QSPI SD0 (MOSI), SD1 (MISO), SD2 and SD3 pins</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>QSPI_CSN</name>
                            <description>Input value on QSPI CSn pin</description>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>QSPI_SCK</name>
                            <description>Input value on QSPI SCK pin</description>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USB_DM</name>
                            <description>Input value on USB D- pin</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>USB_DP</name>
                            <description>Input value on USB D+ pin</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GPIO</name>
                            <description>Input value on GPIO32...47</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_OUT</name>
                    <description>GPIO0...31 output value</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_OUT</name>
                            <description>Set output level (1/0 -&gt; high/low) for GPIO0...31. Reading back gives the last value written, NOT the input value from the pins.

                                If core 0 and core 1 both write to GPIO_OUT simultaneously (or to a SET/CLR/XOR alias), the result is as though the write from core 0 took place first, and the write from core 1 was then applied to that intermediate result.

                                In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) ignore writes, and their output status reads back as zero. This is also true for SET/CLR/XOR aliases of this register.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_HI_OUT</name>
                    <description>Output value for GPIO32...47, QSPI IOs and USB pins.

                        Write to set output level (1/0 -&gt; high/low). Reading back gives the last value written, NOT the input value from the pins. If core 0 and core 1 both write to GPIO_HI_OUT simultaneously (or to a SET/CLR/XOR alias), the result is as though the write from core 0 took place first, and the write from core 1 was then applied to that intermediate result.

                        In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) ignore writes, and their output status reads back as zero. This is also true for SET/CLR/XOR aliases of this register.</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>QSPI_SD</name>
                            <description>Output value for QSPI SD0 (MOSI), SD1 (MISO), SD2 and SD3 pins</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>QSPI_CSN</name>
                            <description>Output value for QSPI CSn pin</description>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>QSPI_SCK</name>
                            <description>Output value for QSPI SCK pin</description>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USB_DM</name>
                            <description>Output value for USB D- pin</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USB_DP</name>
                            <description>Output value for USB D+ pin</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO</name>
                            <description>Output value for GPIO32...47</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_OUT_SET</name>
                    <description>GPIO0...31 output value set</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_OUT_SET</name>
                            <description>Perform an atomic bit-set on GPIO_OUT, i.e. `GPIO_OUT |= wdata`</description>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_HI_OUT_SET</name>
                    <description>Output value set for GPIO32..47, QSPI IOs and USB pins.
                        Perform an atomic bit-set on GPIO_HI_OUT, i.e. `GPIO_HI_OUT |= wdata`</description>
                    <addressOffset>0x1C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>QSPI_SD</name>
                            <bitRange>[31:28]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>QSPI_CSN</name>
                            <bitRange>[27:27]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>QSPI_SCK</name>
                            <bitRange>[26:26]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>USB_DM</name>
                            <bitRange>[25:25]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>USB_DP</name>
                            <bitRange>[24:24]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>GPIO</name>
                            <bitRange>[15:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_OUT_CLR</name>
                    <description>GPIO0...31 output value clear</description>
                    <addressOffset>0x20</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_OUT_CLR</name>
                            <description>Perform an atomic bit-clear on GPIO_OUT, i.e. `GPIO_OUT &amp;= ~wdata`</description>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_HI_OUT_CLR</name>
                    <description>Output value clear for GPIO32..47, QSPI IOs and USB pins.
                        Perform an atomic bit-clear on GPIO_HI_OUT, i.e. `GPIO_HI_OUT &amp;= ~wdata`</description>
                    <addressOffset>0x24</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>QSPI_SD</name>
                            <bitRange>[31:28]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>QSPI_CSN</name>
                            <bitRange>[27:27]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>QSPI_SCK</name>
                            <bitRange>[26:26]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>USB_DM</name>
                            <bitRange>[25:25]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>USB_DP</name>
                            <bitRange>[24:24]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>GPIO</name>
                            <bitRange>[15:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_OUT_XOR</name>
                    <description>GPIO0...31 output value XOR</description>
                    <addressOffset>0x28</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_OUT_XOR</name>
                            <description>Perform an atomic bitwise XOR on GPIO_OUT, i.e. `GPIO_OUT ^= wdata`</description>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_HI_OUT_XOR</name>
                    <description>Output value XOR for GPIO32..47, QSPI IOs and USB pins.
                        Perform an atomic bitwise XOR on GPIO_HI_OUT, i.e. `GPIO_HI_OUT ^= wdata`</description>
                    <addressOffset>0x2C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>QSPI_SD</name>
                            <bitRange>[31:28]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>QSPI_CSN</name>
                            <bitRange>[27:27]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>QSPI_SCK</name>
                            <bitRange>[26:26]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>USB_DM</name>
                            <bitRange>[25:25]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>USB_DP</name>
                            <bitRange>[24:24]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>GPIO</name>
                            <bitRange>[15:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_OE</name>
                    <description>GPIO0...31 output enable</description>
                    <addressOffset>0x30</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_OE</name>
                            <description>Set output enable (1/0 -&gt; output/input) for GPIO0...31. Reading back gives the last value written.

                                If core 0 and core 1 both write to GPIO_OE simultaneously (or to a SET/CLR/XOR alias), the result is as though the write from core 0 took place first, and the write from core 1 was then applied to that intermediate result.

                                In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) ignore writes, and their output status reads back as zero. This is also true for SET/CLR/XOR aliases of this register.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_HI_OE</name>
                    <description>Output enable value for GPIO32...47, QSPI IOs and USB pins.

                        Write output enable (1/0 -&gt; output/input). Reading back gives the last value written. If core 0 and core 1 both write to GPIO_HI_OE simultaneously (or to a SET/CLR/XOR alias), the result is as though the write from core 0 took place first, and the write from core 1 was then applied to that intermediate result.

                        In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) ignore writes, and their output status reads back as zero. This is also true for SET/CLR/XOR aliases of this register.</description>
                    <addressOffset>0x34</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>QSPI_SD</name>
                            <description>Output enable value for QSPI SD0 (MOSI), SD1 (MISO), SD2 and SD3 pins</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>QSPI_CSN</name>
                            <description>Output enable value for QSPI CSn pin</description>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>QSPI_SCK</name>
                            <description>Output enable value for QSPI SCK pin</description>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USB_DM</name>
                            <description>Output enable value for USB D- pin</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USB_DP</name>
                            <description>Output enable value for USB D+ pin</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>GPIO</name>
                            <description>Output enable value for GPIO32...47</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_OE_SET</name>
                    <description>GPIO0...31 output enable set</description>
                    <addressOffset>0x38</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_OE_SET</name>
                            <description>Perform an atomic bit-set on GPIO_OE, i.e. `GPIO_OE |= wdata`</description>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_HI_OE_SET</name>
                    <description>Output enable set for GPIO32...47, QSPI IOs and USB pins.
                        Perform an atomic bit-set on GPIO_HI_OE, i.e. `GPIO_HI_OE |= wdata`</description>
                    <addressOffset>0x3C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>QSPI_SD</name>
                            <bitRange>[31:28]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>QSPI_CSN</name>
                            <bitRange>[27:27]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>QSPI_SCK</name>
                            <bitRange>[26:26]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>USB_DM</name>
                            <bitRange>[25:25]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>USB_DP</name>
                            <bitRange>[24:24]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>GPIO</name>
                            <bitRange>[15:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_OE_CLR</name>
                    <description>GPIO0...31 output enable clear</description>
                    <addressOffset>0x40</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_OE_CLR</name>
                            <description>Perform an atomic bit-clear on GPIO_OE, i.e. `GPIO_OE &amp;= ~wdata`</description>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_HI_OE_CLR</name>
                    <description>Output enable clear for GPIO32...47, QSPI IOs and USB pins.
                        Perform an atomic bit-clear on GPIO_HI_OE, i.e. `GPIO_HI_OE &amp;= ~wdata`</description>
                    <addressOffset>0x44</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>QSPI_SD</name>
                            <bitRange>[31:28]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>QSPI_CSN</name>
                            <bitRange>[27:27]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>QSPI_SCK</name>
                            <bitRange>[26:26]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>USB_DM</name>
                            <bitRange>[25:25]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>USB_DP</name>
                            <bitRange>[24:24]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>GPIO</name>
                            <bitRange>[15:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_OE_XOR</name>
                    <description>GPIO0...31 output enable XOR</description>
                    <addressOffset>0x48</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GPIO_OE_XOR</name>
                            <description>Perform an atomic bitwise XOR on GPIO_OE, i.e. `GPIO_OE ^= wdata`</description>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>GPIO_HI_OE_XOR</name>
                    <description>Output enable XOR for GPIO32...47, QSPI IOs and USB pins.
                        Perform an atomic bitwise XOR on GPIO_HI_OE, i.e. `GPIO_HI_OE ^= wdata`</description>
                    <addressOffset>0x4C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>QSPI_SD</name>
                            <bitRange>[31:28]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>QSPI_CSN</name>
                            <bitRange>[27:27]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>QSPI_SCK</name>
                            <bitRange>[26:26]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>USB_DM</name>
                            <bitRange>[25:25]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>USB_DP</name>
                            <bitRange>[24:24]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>GPIO</name>
                            <bitRange>[15:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FIFO_ST</name>
                    <description>Status register for inter-core FIFOs (mailboxes).
                        There is one FIFO in the core 0 -&gt; core 1 direction, and one core 1 -&gt; core 0. Both are 32 bits wide and 8 words deep.
                        Core 0 can see the read side of the 1-&gt;0 FIFO (RX), and the write side of 0-&gt;1 FIFO (TX).
                        Core 1 can see the read side of the 0-&gt;1 FIFO (RX), and the write side of 1-&gt;0 FIFO (TX).
                        The SIO IRQ for each core is the logical OR of the VLD, WOF and ROE fields of its FIFO_ST register.</description>
                    <addressOffset>0x50</addressOffset>
                    <resetValue>0x00000002</resetValue>
                    <fields>
                        <field>
                            <name>ROE</name>
                            <description>Sticky flag indicating the RX FIFO was read when empty. This read was ignored by the FIFO.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>WOF</name>
                            <description>Sticky flag indicating the TX FIFO was written when full. This write was ignored by the FIFO.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>RDY</name>
                            <description>Value is 1 if this core's TX FIFO is not full (i.e. if FIFO_WR is ready for more data)</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VLD</name>
                            <description>Value is 1 if this core's RX FIFO is not empty (i.e. if FIFO_RD is valid)</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FIFO_WR</name>
                    <description>Write access to this core's TX FIFO</description>
                    <addressOffset>0x54</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FIFO_WR</name>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FIFO_RD</name>
                    <description>Read access to this core's RX FIFO</description>
                    <addressOffset>0x58</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>FIFO_RD</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SPINLOCK_ST</name>
                    <description>Spinlock state
                        A bitmap containing the state of all 32 spinlocks (1=locked).
                        Mainly intended for debugging.</description>
                    <addressOffset>0x5C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SPINLOCK_ST</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP0_ACCUM0</name>
                    <description>Read/write access to accumulator 0</description>
                    <addressOffset>0x80</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP0_ACCUM0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP0_ACCUM1</name>
                    <description>Read/write access to accumulator 1</description>
                    <addressOffset>0x84</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP0_ACCUM1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP0_BASE0</name>
                    <description>Read/write access to BASE0 register.</description>
                    <addressOffset>0x88</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP0_BASE0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP0_BASE1</name>
                    <description>Read/write access to BASE1 register.</description>
                    <addressOffset>0x8C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP0_BASE1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP0_BASE2</name>
                    <description>Read/write access to BASE2 register.</description>
                    <addressOffset>0x90</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP0_BASE2</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP0_POP_LANE0</name>
                    <description>Read LANE0 result, and simultaneously write lane results to both accumulators (POP).</description>
                    <addressOffset>0x94</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP0_POP_LANE0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP0_POP_LANE1</name>
                    <description>Read LANE1 result, and simultaneously write lane results to both accumulators (POP).</description>
                    <addressOffset>0x98</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP0_POP_LANE1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP0_POP_FULL</name>
                    <description>Read FULL result, and simultaneously write lane results to both accumulators (POP).</description>
                    <addressOffset>0x9C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP0_POP_FULL</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP0_PEEK_LANE0</name>
                    <description>Read LANE0 result, without altering any internal state (PEEK).</description>
                    <addressOffset>0xA0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP0_PEEK_LANE0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP0_PEEK_LANE1</name>
                    <description>Read LANE1 result, without altering any internal state (PEEK).</description>
                    <addressOffset>0xA4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP0_PEEK_LANE1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP0_PEEK_FULL</name>
                    <description>Read FULL result, without altering any internal state (PEEK).</description>
                    <addressOffset>0xA8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP0_PEEK_FULL</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP0_CTRL_LANE0</name>
                    <description>Control register for lane 0</description>
                    <addressOffset>0xAC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>OVERF</name>
                            <description>Set if either OVERF0 or OVERF1 is set.</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>OVERF1</name>
                            <description>Indicates if any masked-off MSBs in ACCUM1 are set.</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>OVERF0</name>
                            <description>Indicates if any masked-off MSBs in ACCUM0 are set.</description>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BLEND</name>
                            <description>Only present on INTERP0 on each core. If BLEND mode is enabled:
                                - LANE1 result is a linear interpolation between BASE0 and BASE1, controlled
                                by the 8 LSBs of lane 1 shift and mask value (a fractional number between
                                0 and 255/256ths)
                                - LANE0 result does not have BASE0 added (yields only the 8 LSBs of lane 1 shift+mask value)
                                - FULL result does not have lane 1 shift+mask value added (BASE2 + lane 0 shift+mask)
                                LANE1 SIGNED flag controls whether the interpolation is signed or unsigned.</description>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FORCE_MSB</name>
                            <description>ORed into bits 29:28 of the lane result presented to the processor on the bus.
                                No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence
                                of pointers into flash or SRAM.</description>
                            <bitRange>[20:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ADD_RAW</name>
                            <description>If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result.</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CROSS_RESULT</name>
                            <description>If 1, feed the opposite lane's result into this lane's accumulator on POP.</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CROSS_INPUT</name>
                            <description>If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware.
                                Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SIGNED</name>
                            <description>If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits
                                before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read by processor.</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MASK_MSB</name>
                            <description>The most-significant bit allowed to pass by the mask (inclusive)
                                Setting MSB &lt; LSB may cause chip to turn inside-out</description>
                            <bitRange>[14:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MASK_LSB</name>
                            <description>The least-significant bit allowed to pass by the mask (inclusive)</description>
                            <bitRange>[9:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SHIFT</name>
                            <description>Right-rotate applied to accumulator before masking. By appropriately configuring the masks, left and right shifts can be synthesised.</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP0_CTRL_LANE1</name>
                    <description>Control register for lane 1</description>
                    <addressOffset>0xB0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FORCE_MSB</name>
                            <description>ORed into bits 29:28 of the lane result presented to the processor on the bus.
                                No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence
                                of pointers into flash or SRAM.</description>
                            <bitRange>[20:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ADD_RAW</name>
                            <description>If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL result.</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CROSS_RESULT</name>
                            <description>If 1, feed the opposite lane's result into this lane's accumulator on POP.</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CROSS_INPUT</name>
                            <description>If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware.
                                Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SIGNED</name>
                            <description>If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits
                                before adding to BASE1, and LANE1 PEEK/POP appear extended to 32 bits when read by processor.</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MASK_MSB</name>
                            <description>The most-significant bit allowed to pass by the mask (inclusive)
                                Setting MSB &lt; LSB may cause chip to turn inside-out</description>
                            <bitRange>[14:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MASK_LSB</name>
                            <description>The least-significant bit allowed to pass by the mask (inclusive)</description>
                            <bitRange>[9:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SHIFT</name>
                            <description>Right-rotate applied to accumulator before masking. By appropriately configuring the masks, left and right shifts can be synthesised.</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP0_ACCUM0_ADD</name>
                    <description>Values written here are atomically added to ACCUM0
                        Reading yields lane 0's raw shift and mask value (BASE0 not added).</description>
                    <addressOffset>0xB4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP0_ACCUM0_ADD</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP0_ACCUM1_ADD</name>
                    <description>Values written here are atomically added to ACCUM1
                        Reading yields lane 1's raw shift and mask value (BASE1 not added).</description>
                    <addressOffset>0xB8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP0_ACCUM1_ADD</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP0_BASE_1AND0</name>
                    <description>On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.
                        Each half is sign-extended to 32 bits if that lane's SIGNED flag is set.</description>
                    <addressOffset>0xBC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP0_BASE_1AND0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP1_ACCUM0</name>
                    <description>Read/write access to accumulator 0</description>
                    <addressOffset>0xC0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP1_ACCUM0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP1_ACCUM1</name>
                    <description>Read/write access to accumulator 1</description>
                    <addressOffset>0xC4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP1_ACCUM1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP1_BASE0</name>
                    <description>Read/write access to BASE0 register.</description>
                    <addressOffset>0xC8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP1_BASE0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP1_BASE1</name>
                    <description>Read/write access to BASE1 register.</description>
                    <addressOffset>0xCC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP1_BASE1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP1_BASE2</name>
                    <description>Read/write access to BASE2 register.</description>
                    <addressOffset>0xD0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP1_BASE2</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP1_POP_LANE0</name>
                    <description>Read LANE0 result, and simultaneously write lane results to both accumulators (POP).</description>
                    <addressOffset>0xD4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP1_POP_LANE0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP1_POP_LANE1</name>
                    <description>Read LANE1 result, and simultaneously write lane results to both accumulators (POP).</description>
                    <addressOffset>0xD8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP1_POP_LANE1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP1_POP_FULL</name>
                    <description>Read FULL result, and simultaneously write lane results to both accumulators (POP).</description>
                    <addressOffset>0xDC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP1_POP_FULL</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP1_PEEK_LANE0</name>
                    <description>Read LANE0 result, without altering any internal state (PEEK).</description>
                    <addressOffset>0xE0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP1_PEEK_LANE0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP1_PEEK_LANE1</name>
                    <description>Read LANE1 result, without altering any internal state (PEEK).</description>
                    <addressOffset>0xE4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP1_PEEK_LANE1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP1_PEEK_FULL</name>
                    <description>Read FULL result, without altering any internal state (PEEK).</description>
                    <addressOffset>0xE8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP1_PEEK_FULL</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP1_CTRL_LANE0</name>
                    <description>Control register for lane 0</description>
                    <addressOffset>0xEC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>OVERF</name>
                            <description>Set if either OVERF0 or OVERF1 is set.</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>OVERF1</name>
                            <description>Indicates if any masked-off MSBs in ACCUM1 are set.</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>OVERF0</name>
                            <description>Indicates if any masked-off MSBs in ACCUM0 are set.</description>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CLAMP</name>
                            <description>Only present on INTERP1 on each core. If CLAMP mode is enabled:
                                - LANE0 result is shifted and masked ACCUM0, clamped by a lower bound of
                                BASE0 and an upper bound of BASE1.
                                - Signedness of these comparisons is determined by LANE0_CTRL_SIGNED</description>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FORCE_MSB</name>
                            <description>ORed into bits 29:28 of the lane result presented to the processor on the bus.
                                No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence
                                of pointers into flash or SRAM.</description>
                            <bitRange>[20:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ADD_RAW</name>
                            <description>If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result.</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CROSS_RESULT</name>
                            <description>If 1, feed the opposite lane's result into this lane's accumulator on POP.</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CROSS_INPUT</name>
                            <description>If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware.
                                Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SIGNED</name>
                            <description>If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits
                                before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read by processor.</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MASK_MSB</name>
                            <description>The most-significant bit allowed to pass by the mask (inclusive)
                                Setting MSB &lt; LSB may cause chip to turn inside-out</description>
                            <bitRange>[14:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MASK_LSB</name>
                            <description>The least-significant bit allowed to pass by the mask (inclusive)</description>
                            <bitRange>[9:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SHIFT</name>
                            <description>Right-rotate applied to accumulator before masking. By appropriately configuring the masks, left and right shifts can be synthesised.</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP1_CTRL_LANE1</name>
                    <description>Control register for lane 1</description>
                    <addressOffset>0xF0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FORCE_MSB</name>
                            <description>ORed into bits 29:28 of the lane result presented to the processor on the bus.
                                No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence
                                of pointers into flash or SRAM.</description>
                            <bitRange>[20:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ADD_RAW</name>
                            <description>If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL result.</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CROSS_RESULT</name>
                            <description>If 1, feed the opposite lane's result into this lane's accumulator on POP.</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CROSS_INPUT</name>
                            <description>If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware.
                                Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SIGNED</name>
                            <description>If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits
                                before adding to BASE1, and LANE1 PEEK/POP appear extended to 32 bits when read by processor.</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MASK_MSB</name>
                            <description>The most-significant bit allowed to pass by the mask (inclusive)
                                Setting MSB &lt; LSB may cause chip to turn inside-out</description>
                            <bitRange>[14:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MASK_LSB</name>
                            <description>The least-significant bit allowed to pass by the mask (inclusive)</description>
                            <bitRange>[9:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SHIFT</name>
                            <description>Right-rotate applied to accumulator before masking. By appropriately configuring the masks, left and right shifts can be synthesised.</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP1_ACCUM0_ADD</name>
                    <description>Values written here are atomically added to ACCUM0
                        Reading yields lane 0's raw shift and mask value (BASE0 not added).</description>
                    <addressOffset>0xF4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP1_ACCUM0_ADD</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP1_ACCUM1_ADD</name>
                    <description>Values written here are atomically added to ACCUM1
                        Reading yields lane 1's raw shift and mask value (BASE1 not added).</description>
                    <addressOffset>0xF8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP1_ACCUM1_ADD</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTERP1_BASE_1AND0</name>
                    <description>On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.
                        Each half is sign-extended to 32 bits if that lane's SIGNED flag is set.</description>
                    <addressOffset>0xFC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTERP1_BASE_1AND0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>32</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-31</dimIndex>
                    <name>SPINLOCK%s</name>
                    <description>Reading from a spinlock address will:
                        - Return 0 if lock is already locked
                        - Otherwise return nonzero, and simultaneously claim the lock

                        Writing (any value) releases the lock.
                        If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.
                        The value returned on success is 0x1 &lt;&lt; lock number.</description>
                    <addressOffset>0x100</addressOffset>
                    <access>read-write</access>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SPINLOCK0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DOORBELL_OUT_SET</name>
                    <description>Trigger a doorbell interrupt on the opposite core.

                        Write 1 to a bit to set the corresponding bit in DOORBELL_IN on the opposite core. This raises the opposite core's doorbell interrupt.

                        Read to get the status of the doorbells currently asserted on the opposite core. This is equivalent to that core reading its own DOORBELL_IN status.</description>
                    <addressOffset>0x180</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DOORBELL_OUT_SET</name>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DOORBELL_OUT_CLR</name>
                    <description>Clear doorbells which have been posted to the opposite core. This register is intended for debugging and initialisation purposes.

                        Writing 1 to a bit in DOORBELL_OUT_CLR clears the corresponding bit in DOORBELL_IN on the opposite core. Clearing all bits will cause that core's doorbell interrupt to deassert. Since the usual order of events is for software to send events using DOORBELL_OUT_SET, and acknowledge incoming events by writing to DOORBELL_IN_CLR, this register should be used with caution to avoid race conditions.

                        Reading returns the status of the doorbells currently asserted on the other core, i.e. is equivalent to that core reading its own DOORBELL_IN status.</description>
                    <addressOffset>0x184</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DOORBELL_OUT_CLR</name>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DOORBELL_IN_SET</name>
                    <description>Write 1s to trigger doorbell interrupts on this core. Read to get status of doorbells currently asserted on this core.</description>
                    <addressOffset>0x188</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DOORBELL_IN_SET</name>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DOORBELL_IN_CLR</name>
                    <description>Check and acknowledge doorbells posted to this core. This core's doorbell interrupt is asserted when any bit in this register is 1.

                        Write 1 to each bit to clear that bit. The doorbell interrupt deasserts once all bits are cleared. Read to get status of doorbells currently asserted on this core.</description>
                    <addressOffset>0x18C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DOORBELL_IN_CLR</name>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PERI_NONSEC</name>
                    <description>Detach certain core-local peripherals from Secure SIO, and attach them to Non-secure SIO, so that Non-secure software can use them. Attempting to access one of these peripherals from the Secure SIO when it is attached to the Non-secure SIO, or vice versa, will generate a bus error.

                        This register is per-core, and is only present on the Secure SIO.

                        Most SIO hardware is duplicated across the Secure and Non-secure SIO, so is not listed in this register.</description>
                    <addressOffset>0x190</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TMDS</name>
                            <description>IF 1, detach TMDS encoder (of this core) from the Secure SIO, and attach to the Non-secure SIO.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INTERP1</name>
                            <description>If 1, detach interpolator 1 (of this core) from the Secure SIO, and attach to the Non-secure SIO.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INTERP0</name>
                            <description>If 1, detach interpolator 0 (of this core) from the Secure SIO, and attach to the Non-secure SIO.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RISCV_SOFTIRQ</name>
                    <description>Control the assertion of the standard software interrupt (MIP.MSIP) on the RISC-V cores.

                        Unlike the RISC-V timer, this interrupt is not routed to a normal system-level interrupt line, so can not be used by the Arm cores.

                        It is safe for both cores to write to this register on the same cycle. The set/clear effect is accumulated across both cores, and then applied. If a flag is both set and cleared on the same cycle, only the set takes effect.</description>
                    <addressOffset>0x1A0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CORE1_CLR</name>
                            <description>Write 1 to atomically clear the core 1 software interrupt flag. Read to get the status of this flag.</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0_CLR</name>
                            <description>Write 1 to atomically clear the core 0 software interrupt flag. Read to get the status of this flag.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE1_SET</name>
                            <description>Write 1 to atomically set the core 1 software interrupt flag. Read to get the status of this flag.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CORE0_SET</name>
                            <description>Write 1 to atomically set the core 0 software interrupt flag. Read to get the status of this flag.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MTIME_CTRL</name>
                    <description>Control register for the RISC-V 64-bit Machine-mode timer. This timer is only present in the Secure SIO, so is only accessible to an Arm core in Secure mode or a RISC-V core in Machine mode.

                        Note whilst this timer follows the RISC-V privileged specification, it is equally usable by the Arm cores. The interrupts are routed to normal system-level interrupt lines as well as to the MIP.MTIP inputs on the RISC-V cores.</description>
                    <addressOffset>0x1A4</addressOffset>
                    <resetValue>0x0000000D</resetValue>
                    <fields>
                        <field>
                            <name>DBGPAUSE_CORE1</name>
                            <description>If 1, the timer pauses when core 1 is in the debug halt state.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DBGPAUSE_CORE0</name>
                            <description>If 1, the timer pauses when core 0 is in the debug halt state.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FULLSPEED</name>
                            <description>If 1, increment the timer every cycle (i.e. run directly from the system clock), rather than incrementing on the system-level timer tick input.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EN</name>
                            <description>Timer enable bit. When 0, the timer will not increment automatically.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MTIME</name>
                    <description>Read/write access to the high half of RISC-V Machine-mode timer. This register is shared between both cores. If both cores write on the same cycle, core 1 takes precedence.</description>
                    <addressOffset>0x1B0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>MTIME</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MTIMEH</name>
                    <description>Read/write access to the high half of RISC-V Machine-mode timer. This register is shared between both cores. If both cores write on the same cycle, core 1 takes precedence.</description>
                    <addressOffset>0x1B4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>MTIMEH</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MTIMECMP</name>
                    <description>Low half of RISC-V Machine-mode timer comparator. This register is core-local, i.e., each core gets a copy of this register, with the comparison result routed to its own interrupt line.

                        The timer interrupt is asserted whenever MTIME is greater than or equal to MTIMECMP. This comparison is unsigned, and performed on the full 64-bit values.</description>
                    <addressOffset>0x1B8</addressOffset>
                    <resetValue>0xFFFFFFFF</resetValue>
                    <fields>
                        <field>
                            <name>MTIMECMP</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MTIMECMPH</name>
                    <description>High half of RISC-V Machine-mode timer comparator. This register is core-local.

                        The timer interrupt is asserted whenever MTIME is greater than or equal to MTIMECMP. This comparison is unsigned, and performed on the full 64-bit values.</description>
                    <addressOffset>0x1BC</addressOffset>
                    <resetValue>0xFFFFFFFF</resetValue>
                    <fields>
                        <field>
                            <name>MTIMECMPH</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TMDS_CTRL</name>
                    <description>Control register for TMDS encoder.</description>
                    <addressOffset>0x1C0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CLEAR_BALANCE</name>
                            <description>Clear the running DC balance state of the TMDS encoders. This bit should be written once at the beginning of each scanline.</description>
                            <bitRange>[28:28]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>PIX2_NOSHIFT</name>
                            <description>When encoding two pixels's worth of symbols in one cycle (a read of a PEEK/POP_DOUBLE register), the second encoder sees a shifted version of the colour data register.

                                This control disables that shift, so that both encoder layers see the same pixel data. This is used for pixel doubling.</description>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PIX_SHIFT</name>
                            <description>Shift applied to the colour data register with each read of a POP alias register.

                                Reading from the POP_SINGLE register, or reading from the POP_DOUBLE register with PIX2_NOSHIFT set (for pixel doubling), shifts by the indicated amount.

                                Reading from a POP_DOUBLE register when PIX2_NOSHIFT is clear will shift by double the indicated amount. (Shift by 32 means no shift.)</description>
                            <bitRange>[26:24]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>0</name>
                                    <description>Do not shift the colour data register.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>1</name>
                                    <description>Shift the colour data register by 1 bit</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>2</name>
                                    <description>Shift the colour data register by 2 bits</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4</name>
                                    <description>Shift the colour data register by 4 bits</description>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8</name>
                                    <description>Shift the colour data register by 8 bits</description>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>16</name>
                                    <description>Shift the colour data register by 16 bits</description>
                                    <value>5</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>INTERLEAVE</name>
                            <description>Enable lane interleaving for reads of PEEK_SINGLE/POP_SINGLE.

                                When interleaving is disabled, each of the 3 symbols appears as a contiguous 10-bit field, with lane 0 being the least-significant and starting at bit 0 of the register.

                                When interleaving is enabled, the symbols are packed into 5 chunks of 3 lanes times 2 bits (30 bits total). Each chunk contains two bits of a TMDS symbol per lane, with lane 0 being the least significant.</description>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>L2_NBITS</name>
                            <description>Number of valid colour MSBs for lane 2 (1-8 bits, encoded as 0 through 7). Remaining LSBs are masked to 0 after the rotate.</description>
                            <bitRange>[20:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>L1_NBITS</name>
                            <description>Number of valid colour MSBs for lane 1 (1-8 bits, encoded as 0 through 7). Remaining LSBs are masked to 0 after the rotate.</description>
                            <bitRange>[17:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>L0_NBITS</name>
                            <description>Number of valid colour MSBs for lane 0 (1-8 bits, encoded as 0 through 7). Remaining LSBs are masked to 0 after the rotate.</description>
                            <bitRange>[14:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>L2_ROT</name>
                            <description>Right-rotate the 16 LSBs of the colour accumulator by 0-15 bits, in order to get the MSB of the lane 2 (red) colour data aligned with the MSB of the 8-bit encoder input.

                                For example, for RGB565 (red most significant), red is bits 15:11, so should be right-rotated by 8 bits to align with bits 7:3 of the encoder input.</description>
                            <bitRange>[11:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>L1_ROT</name>
                            <description>Right-rotate the 16 LSBs of the colour accumulator by 0-15 bits, in order to get the MSB of the lane 1 (green) colour data aligned with the MSB of the 8-bit encoder input.

                                For example, for RGB565, green is bits 10:5, so should be right-rotated by 3 bits to align with bits 7:2 of the encoder input.</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>L0_ROT</name>
                            <description>Right-rotate the 16 LSBs of the colour accumulator by 0-15 bits, in order to get the MSB of the lane 0 (blue) colour data aligned with the MSB of the 8-bit encoder input.

                                For example, for RGB565 (red most significant), blue is bits 4:0, so should be right-rotated by 13 to align with bits 7:3 of the encoder input.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TMDS_WDATA</name>
                    <description>Write-only access to the TMDS colour data register.</description>
                    <addressOffset>0x1C4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TMDS_WDATA</name>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TMDS_PEEK_SINGLE</name>
                    <description>Get the encoding of one pixel's worth of colour data, packed into a 32-bit value (3x10-bit symbols).

                        The PEEK alias does not shift the colour register when read, but still advances the running DC balance state of each encoder. This is useful for pixel doubling.</description>
                    <addressOffset>0x1C8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TMDS_PEEK_SINGLE</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TMDS_POP_SINGLE</name>
                    <description>Get the encoding of one pixel's worth of colour data, packed into a 32-bit value. The packing is 5 chunks of 3 lanes times 2 bits (30 bits total). Each chunk contains two bits of a TMDS symbol per lane. This format is intended for shifting out with the HSTX peripheral on RP2350.

                        The POP alias shifts the colour register when read, as well as advancing the running DC balance state of each encoder.</description>
                    <addressOffset>0x1CC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TMDS_POP_SINGLE</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TMDS_PEEK_DOUBLE_L0</name>
                    <description>Get lane 0 of the encoding of two pixels' worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.

                        The PEEK alias does not shift the colour register when read, but still advances the lane 0 DC balance state. This is useful if all 3 lanes' worth of encode are to be read at once, rather than processing the entire scanline for one lane before moving to the next lane.</description>
                    <addressOffset>0x1D0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TMDS_PEEK_DOUBLE_L0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TMDS_POP_DOUBLE_L0</name>
                    <description>Get lane 0 of the encoding of two pixels' worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.

                        The POP alias shifts the colour register when read, according to the values of PIX_SHIFT and PIX2_NOSHIFT.</description>
                    <addressOffset>0x1D4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TMDS_POP_DOUBLE_L0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TMDS_PEEK_DOUBLE_L1</name>
                    <description>Get lane 1 of the encoding of two pixels' worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.

                        The PEEK alias does not shift the colour register when read, but still advances the lane 1 DC balance state. This is useful if all 3 lanes' worth of encode are to be read at once, rather than processing the entire scanline for one lane before moving to the next lane.</description>
                    <addressOffset>0x1D8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TMDS_PEEK_DOUBLE_L1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TMDS_POP_DOUBLE_L1</name>
                    <description>Get lane 1 of the encoding of two pixels' worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.

                        The POP alias shifts the colour register when read, according to the values of PIX_SHIFT and PIX2_NOSHIFT.</description>
                    <addressOffset>0x1DC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TMDS_POP_DOUBLE_L1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TMDS_PEEK_DOUBLE_L2</name>
                    <description>Get lane 2 of the encoding of two pixels' worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.

                        The PEEK alias does not shift the colour register when read, but still advances the lane 2 DC balance state. This is useful if all 3 lanes' worth of encode are to be read at once, rather than processing the entire scanline for one lane before moving to the next lane.</description>
                    <addressOffset>0x1E0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TMDS_PEEK_DOUBLE_L2</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TMDS_POP_DOUBLE_L2</name>
                    <description>Get lane 2 of the encoding of two pixels' worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.

                        The POP alias shifts the colour register when read, according to the values of PIX_SHIFT and PIX2_NOSHIFT.</description>
                    <addressOffset>0x1E4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TMDS_POP_DOUBLE_L2</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral derivedFrom="SIO">
            <name>SIO_NS</name>
            <baseAddress>0xD0020000</baseAddress>
        </peripheral>
        <peripheral>
            <name>BOOTRAM</name>
            <description>Additional registers mapped adjacent to the bootram, for use by the bootrom.</description>
            <baseAddress>0x400E0000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x82C</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>WRITE_ONCE0</name>
                    <description>This registers always ORs writes into its current contents. Once a bit is set, it can only be cleared by a reset.</description>
                    <addressOffset>0x800</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>WRITE_ONCE0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>WRITE_ONCE1</name>
                    <description>This registers always ORs writes into its current contents. Once a bit is set, it can only be cleared by a reset.</description>
                    <addressOffset>0x804</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>WRITE_ONCE1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTLOCK_STAT</name>
                    <description>Bootlock status register. 1=unclaimed, 0=claimed. These locks function identically to the SIO spinlocks, but are reserved for bootrom use.</description>
                    <addressOffset>0x808</addressOffset>
                    <resetValue>0x000000FF</resetValue>
                    <fields>
                        <field>
                            <name>BOOTLOCK_STAT</name>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTLOCK0</name>
                    <description>Read to claim and check. Write to unclaim. The value returned on successful claim is 1 &lt;&lt; n, and on failed claim is zero.</description>
                    <addressOffset>0x80C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BOOTLOCK0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTLOCK1</name>
                    <description>Read to claim and check. Write to unclaim. The value returned on successful claim is 1 &lt;&lt; n, and on failed claim is zero.</description>
                    <addressOffset>0x810</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BOOTLOCK1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTLOCK2</name>
                    <description>Read to claim and check. Write to unclaim. The value returned on successful claim is 1 &lt;&lt; n, and on failed claim is zero.</description>
                    <addressOffset>0x814</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BOOTLOCK2</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTLOCK3</name>
                    <description>Read to claim and check. Write to unclaim. The value returned on successful claim is 1 &lt;&lt; n, and on failed claim is zero.</description>
                    <addressOffset>0x818</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BOOTLOCK3</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTLOCK4</name>
                    <description>Read to claim and check. Write to unclaim. The value returned on successful claim is 1 &lt;&lt; n, and on failed claim is zero.</description>
                    <addressOffset>0x81C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BOOTLOCK4</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTLOCK5</name>
                    <description>Read to claim and check. Write to unclaim. The value returned on successful claim is 1 &lt;&lt; n, and on failed claim is zero.</description>
                    <addressOffset>0x820</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BOOTLOCK5</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTLOCK6</name>
                    <description>Read to claim and check. Write to unclaim. The value returned on successful claim is 1 &lt;&lt; n, and on failed claim is zero.</description>
                    <addressOffset>0x824</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BOOTLOCK6</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTLOCK7</name>
                    <description>Read to claim and check. Write to unclaim. The value returned on successful claim is 1 &lt;&lt; n, and on failed claim is zero.</description>
                    <addressOffset>0x828</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>BOOTLOCK7</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>CORESIGHT_TRACE</name>
            <description>Coresight block - RP specific registers</description>
            <baseAddress>0x50700000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x8</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>CTRL_STATUS</name>
                    <description>Control and status register</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>TRACE_CAPTURE_FIFO_OVERFLOW</name>
                            <description>This status flag is set high when trace data has been dropped due to the FIFO being full at the point trace data was sampled. Write 1 to acknowledge and clear the bit.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TRACE_CAPTURE_FIFO_FLUSH</name>
                            <description>Set to 1 to continuously hold the trace FIFO in a flushed state and prevent overflow.

                                Before clearing this flag, configure and start a DMA channel with the correct DREQ for the TRACE_CAPTURE_FIFO register.

                                Clear this flag to begin sampling trace data, and set once again once the trace capture buffer is full. You must configure the TPIU in order to generate trace packets to be captured, as well as components like the ETM further upstream to generate the event stream propagated to the TPIU.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRACE_CAPTURE_FIFO</name>
                    <description>FIFO for trace data captured from the TPIU</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RDATA</name>
                            <description>Read from an 8 x 32-bit FIFO containing trace data captured from the TPIU.

                                Hardware pushes to the FIFO on rising edges of clk_sys, when either of the following is true:

                                * TPIU TRACECTL output is low (normal trace data)

                                * TPIU TRACETCL output is high, and TPIU TRACEDATA0 and TRACEDATA1 are both low (trigger packet)

                                These conditions are in accordance with Arm Coresight Architecture Spec v3.0 section D3.3.3: Decoding requirements for Trace Capture Devices

                                The data captured into the FIFO is the full 32-bit TRACEDATA bus output by the TPIU. Note that the TPIU is a DDR output at half of clk_sys, therefore this interface can capture the full 32-bit TPIU DDR output bandwidth as it samples once per active edge of the TPIU output clock.</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>USB</name>
            <description>USB FS/LS controller device registers</description>
            <baseAddress>0x50110000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x118</size>
                <usage>registers</usage>
            </addressBlock>
            <interrupt>
                <name>USBCTRL_IRQ</name>
                <value>14</value>
            </interrupt>
            <registers>
                <register>
                    <name>ADDR_ENDP</name>
                    <description>Device address and endpoint control</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ENDPOINT</name>
                            <description>Device endpoint to send data to. Only valid for HOST mode.</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ADDRESS</name>
                            <description>In device mode, the address that the device should respond to. Set in response to a SET_ADDR setup packet from the host. In host mode set to the address of the device to communicate with.</description>
                            <bitRange>[6:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>15</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>1-15</dimIndex>
                    <name>HOST_ADDR_ENDP%s</name>
                    <description>Interrupt endpoints. Only valid in HOST mode.</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INTEP_PREAMBLE</name>
                            <description>Interrupt EP requires preamble (is a low speed device on a full speed hub)</description>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INTEP_DIR</name>
                            <description>Direction of the interrupt endpoint. In=0, Out=1</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENDPOINT</name>
                            <description>Endpoint number of the interrupt endpoint</description>
                            <bitRange>[19:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ADDRESS</name>
                            <description>Device address</description>
                            <bitRange>[6:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>MAIN_CTRL</name>
                    <description>Main control register</description>
                    <addressOffset>0x40</addressOffset>
                    <resetValue>0x00000004</resetValue>
                    <fields>
                        <field>
                            <name>SIM_TIMING</name>
                            <description>Reduced timings for simulation</description>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PHY_ISO</name>
                            <description>Isolates USB phy after controller power-up
                                Remove isolation once software has configured the controller
                                Not isolated = 0, Isolated = 1</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HOST_NDEVICE</name>
                            <description>Device mode = 0, Host mode = 1</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CONTROLLER_EN</name>
                            <description>Enable controller</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SOF_WR</name>
                    <description>Set the SOF (Start of Frame) frame number in the host controller. The SOF packet is sent every 1ms and the host will increment the frame number by 1 each time.</description>
                    <addressOffset>0x44</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>COUNT</name>
                            <bitRange>[10:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SOF_RD</name>
                    <description>Read the last SOF (Start of Frame) frame number seen. In device mode the last SOF received from the host. In host mode the last SOF sent by the host.</description>
                    <addressOffset>0x48</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>COUNT</name>
                            <bitRange>[10:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SIE_CTRL</name>
                    <description>SIE control register</description>
                    <addressOffset>0x4C</addressOffset>
                    <resetValue>0x00008000</resetValue>
                    <fields>
                        <field>
                            <name>EP0_INT_STALL</name>
                            <description>Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a STALL</description>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP0_DOUBLE_BUF</name>
                            <description>Device: EP0 single buffered = 0, double buffered = 1</description>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP0_INT_1BUF</name>
                            <description>Device: Set bit in BUFF_STATUS for every buffer completed on EP0</description>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP0_INT_2BUF</name>
                            <description>Device: Set bit in BUFF_STATUS for every 2 buffers completed on EP0</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP0_INT_NAK</name>
                            <description>Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a NAK</description>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DIRECT_EN</name>
                            <description>Direct bus drive enable</description>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DIRECT_DP</name>
                            <description>Direct control of DP</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DIRECT_DM</name>
                            <description>Direct control of DM</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP0_STOP_ON_SHORT_PACKET</name>
                            <description>Device: Stop EP0 on a short packet.</description>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TRANSCEIVER_PD</name>
                            <description>Power down bus transceiver</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RPU_OPT</name>
                            <description>Device: Pull-up strength (0=1K2, 1=2k3)</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PULLUP_EN</name>
                            <description>Device: Enable pull up resistor</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PULLDOWN_EN</name>
                            <description>Host: Enable pull down resistors</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RESET_BUS</name>
                            <description>Host: Reset bus</description>
                            <bitRange>[13:13]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>RESUME</name>
                            <description>Device: Remote wakeup. Device can initiate its own resume after suspend.</description>
                            <bitRange>[12:12]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>VBUS_EN</name>
                            <description>Host: Enable VBUS</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>KEEP_ALIVE_EN</name>
                            <description>Host: Enable keep alive packet (for low speed bus)</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SOF_EN</name>
                            <description>Host: Enable SOF generation (for full speed bus)</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SOF_SYNC</name>
                            <description>Host: Delay packet(s) until after SOF</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PREAMBLE_EN</name>
                            <description>Host: Preable enable for LS device on FS hub</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>STOP_TRANS</name>
                            <description>Host: Stop transaction</description>
                            <bitRange>[4:4]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>RECEIVE_DATA</name>
                            <description>Host: Receive transaction (IN to host)</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEND_DATA</name>
                            <description>Host: Send transaction (OUT from host)</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SEND_SETUP</name>
                            <description>Host: Send Setup packet</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>START_TRANS</name>
                            <description>Host: Start transaction</description>
                            <bitRange>[0:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SIE_STATUS</name>
                    <description>SIE status register</description>
                    <addressOffset>0x50</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DATA_SEQ_ERROR</name>
                            <description>Data Sequence Error.

                                The device can raise a sequence error in the following conditions:

                                * A SETUP packet is received followed by a DATA1 packet (data phase should always be DATA0) * An OUT packet is received from the host but doesn't match the data pid in the buffer control register read from DPSRAM

                                The host can raise a data sequence error in the following conditions:

                                * An IN packet from the device has the wrong data PID</description>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>ACK_REC</name>
                            <description>ACK received. Raised by both host and device.</description>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>STALL_REC</name>
                            <description>Host: STALL received</description>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>NAK_REC</name>
                            <description>Host: NAK received</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>RX_TIMEOUT</name>
                            <description>RX timeout is raised by both the host and device if an ACK is not received in the maximum time specified by the USB spec.</description>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>RX_OVERFLOW</name>
                            <description>RX overflow is raised by the Serial RX engine if the incoming data is too fast.</description>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>BIT_STUFF_ERROR</name>
                            <description>Bit Stuff Error. Raised by the Serial RX engine.</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>CRC_ERROR</name>
                            <description>CRC Error. Raised by the Serial RX engine.</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>ENDPOINT_ERROR</name>
                            <description>An endpoint has encountered an error. Read the ep_rx_error and ep_tx_error registers to find out which endpoint had an error.</description>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>BUS_RESET</name>
                            <description>Device: bus reset received</description>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>TRANS_COMPLETE</name>
                            <description>Transaction complete.

                                Raised by device if:

                                * An IN or OUT packet is sent with the `LAST_BUFF` bit set in the buffer control register

                                Raised by host if:

                                * A setup packet is sent when no data in or data out transaction follows * An IN packet is received and the `LAST_BUFF` bit is set in the buffer control register * An IN packet is received with zero length * An OUT packet is sent and the `LAST_BUFF` bit is set</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>SETUP_REC</name>
                            <description>Device: Setup packet received</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>CONNECTED</name>
                            <description>Device: connected</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RX_SHORT_PACKET</name>
                            <description>Device or Host has received a short packet. This is when the data received is less than configured in the buffer control register. Device: If using double buffered mode on device the buffer select will not be toggled after writing status back to the buffer control register. This is to prevent any further transactions on that endpoint until the user has reset the buffer control registers. Host: the current transfer will be stopped early.</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>RESUME</name>
                            <description>Host: Device has initiated a remote resume. Device: host has initiated a resume.</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>VBUS_OVER_CURR</name>
                            <description>VBUS over current detected</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SPEED</name>
                            <description>Host: device speed. Disconnected = 00, LS = 01, FS = 10</description>
                            <bitRange>[9:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SUSPENDED</name>
                            <description>Bus in suspended state. Valid for device. Device will go into suspend if neither Keep Alive / SOF frames are enabled.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>LINE_STATE</name>
                            <description>USB bus line state</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <name>LINE_STATE</name>
                                <enumeratedValue>
                                    <name>SE0</name>
                                    <description>SE0</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>J</name>
                                    <description>J</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>K</name>
                                    <description>K</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>SE1</name>
                                    <description>SE1</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>VBUS_DETECTED</name>
                            <description>Device: VBUS Detected</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INT_EP_CTRL</name>
                    <description>interrupt endpoint control register</description>
                    <addressOffset>0x54</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>INT_EP_ACTIVE</name>
                            <description>Host: Enable interrupt endpoint 1 -&gt; 15</description>
                            <bitRange>[15:1]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BUFF_STATUS</name>
                    <description>Buffer status register. A bit set here indicates that a buffer has completed on the endpoint (if the buffer interrupt is enabled). It is possible for 2 buffers to be completed, so clearing the buffer status bit may instantly re set it on the next clock cycle.</description>
                    <addressOffset>0x58</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EP15_OUT</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP15_IN</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP14_OUT</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP14_IN</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP13_OUT</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP13_IN</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP12_OUT</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP12_IN</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP11_OUT</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP11_IN</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP10_OUT</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP10_IN</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP9_OUT</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP9_IN</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP8_OUT</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP8_IN</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP7_OUT</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP7_IN</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP6_OUT</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP6_IN</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP5_OUT</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP5_IN</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP4_OUT</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP4_IN</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP3_OUT</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP3_IN</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP2_OUT</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP2_IN</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP1_OUT</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP1_IN</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP0_OUT</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP0_IN</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BUFF_CPU_SHOULD_HANDLE</name>
                    <description>Which of the double buffers should be handled. Only valid if using an interrupt per buffer (i.e. not per 2 buffers). Not valid for host interrupt endpoint polling because they are only single buffered.</description>
                    <addressOffset>0x5C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EP15_OUT</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP15_IN</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP14_OUT</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP14_IN</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP13_OUT</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP13_IN</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP12_OUT</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP12_IN</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP11_OUT</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP11_IN</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP10_OUT</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP10_IN</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP9_OUT</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP9_IN</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP8_OUT</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP8_IN</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP7_OUT</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP7_IN</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP6_OUT</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP6_IN</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP5_OUT</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP5_IN</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP4_OUT</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP4_IN</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP3_OUT</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP3_IN</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP2_OUT</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP2_IN</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP1_OUT</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP1_IN</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP0_OUT</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP0_IN</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>EP_ABORT</name>
                    <description>Device only: Can be set to ignore the buffer control register for this endpoint in case you would like to revoke a buffer. A NAK will be sent for every access to the endpoint until this bit is cleared. A corresponding bit in `EP_ABORT_DONE` is set when it is safe to modify the buffer control register.</description>
                    <addressOffset>0x60</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EP15_OUT</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP15_IN</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP14_OUT</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP14_IN</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP13_OUT</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP13_IN</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP12_OUT</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP12_IN</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP11_OUT</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP11_IN</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP10_OUT</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP10_IN</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP9_OUT</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP9_IN</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP8_OUT</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP8_IN</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP7_OUT</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP7_IN</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP6_OUT</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP6_IN</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP5_OUT</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP5_IN</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP4_OUT</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP4_IN</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP3_OUT</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP3_IN</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP2_OUT</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP2_IN</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP1_OUT</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP1_IN</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP0_OUT</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP0_IN</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>EP_ABORT_DONE</name>
                    <description>Device only: Used in conjunction with `EP_ABORT`. Set once an endpoint is idle so the programmer knows it is safe to modify the buffer control register.</description>
                    <addressOffset>0x64</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EP15_OUT</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP15_IN</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP14_OUT</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP14_IN</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP13_OUT</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP13_IN</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP12_OUT</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP12_IN</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP11_OUT</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP11_IN</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP10_OUT</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP10_IN</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP9_OUT</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP9_IN</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP8_OUT</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP8_IN</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP7_OUT</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP7_IN</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP6_OUT</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP6_IN</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP5_OUT</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP5_IN</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP4_OUT</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP4_IN</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP3_OUT</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP3_IN</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP2_OUT</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP2_IN</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP1_OUT</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP1_IN</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP0_OUT</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP0_IN</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>EP_STALL_ARM</name>
                    <description>Device: this bit must be set in conjunction with the `STALL` bit in the buffer control register to send a STALL on EP0. The device controller clears these bits when a SETUP packet is received because the USB spec requires that a STALL condition is cleared when a SETUP packet is received.</description>
                    <addressOffset>0x68</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EP0_OUT</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP0_IN</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NAK_POLL</name>
                    <description>Used by the host controller. Sets the wait time in microseconds before trying again if the device replies with a NAK.</description>
                    <addressOffset>0x6C</addressOffset>
                    <resetValue>0x00100010</resetValue>
                    <fields>
                        <field>
                            <name>RETRY_COUNT_HI</name>
                            <description>Bits 9:6 of nak_retry count</description>
                            <bitRange>[31:28]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EPX_STOPPED_ON_NAK</name>
                            <description>EPX polling has stopped because a nak was received</description>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>STOP_EPX_ON_NAK</name>
                            <description>Stop polling epx when a nak is received</description>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DELAY_FS</name>
                            <description>NAK polling interval for a full speed device</description>
                            <bitRange>[25:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RETRY_COUNT_LO</name>
                            <description>Bits 5:0 of nak_retry_count</description>
                            <bitRange>[15:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DELAY_LS</name>
                            <description>NAK polling interval for a low speed device</description>
                            <bitRange>[9:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>EP_STATUS_STALL_NAK</name>
                    <description>Device: bits are set when the `IRQ_ON_NAK` or `IRQ_ON_STALL` bits are set. For EP0 this comes from `SIE_CTRL`. For all other endpoints it comes from the endpoint control register.</description>
                    <addressOffset>0x70</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EP15_OUT</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP15_IN</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP14_OUT</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP14_IN</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP13_OUT</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP13_IN</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP12_OUT</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP12_IN</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP11_OUT</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP11_IN</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP10_OUT</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP10_IN</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP9_OUT</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP9_IN</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP8_OUT</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP8_IN</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP7_OUT</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP7_IN</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP6_OUT</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP6_IN</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP5_OUT</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP5_IN</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP4_OUT</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP4_IN</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP3_OUT</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP3_IN</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP2_OUT</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP2_IN</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP1_OUT</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP1_IN</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP0_OUT</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP0_IN</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>USB_MUXING</name>
                    <description>Where to connect the USB controller. Should be to_phy by default.</description>
                    <addressOffset>0x74</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>SWAP_DPDM</name>
                            <description>Swap the USB PHY DP and DM pins and all related controls and flip receive differential data. Can be used to switch USB DP/DP on the PCB.
                                This is done at a low level so overrides all other controls.</description>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>USBPHY_AS_GPIO</name>
                            <description>Use the usb DP and DM pins as GPIO pins instead of connecting them to the USB controller.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SOFTCON</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TO_DIGITAL_PAD</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TO_EXTPHY</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TO_PHY</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>USB_PWR</name>
                    <description>Overrides for the power signals in the event that the VBUS signals are not hooked up to GPIO. Set the value of the override and then the override enable to switch over to the override value.</description>
                    <addressOffset>0x78</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>OVERCURR_DETECT_EN</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>OVERCURR_DETECT</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VBUS_DETECT_OVERRIDE_EN</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VBUS_DETECT</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VBUS_EN_OVERRIDE_EN</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VBUS_EN</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>USBPHY_DIRECT</name>
                    <description>This register allows for direct control of the USB phy. Use in conjunction with usbphy_direct_override register to enable each override bit.</description>
                    <addressOffset>0x7C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RX_DM_OVERRIDE</name>
                            <description>Override rx_dm value into controller</description>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RX_DP_OVERRIDE</name>
                            <description>Override rx_dp value into controller</description>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RX_DD_OVERRIDE</name>
                            <description>Override rx_dd value into controller</description>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DM_OVV</name>
                            <description>DM over voltage</description>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DP_OVV</name>
                            <description>DP over voltage</description>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DM_OVCN</name>
                            <description>DM overcurrent</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DP_OVCN</name>
                            <description>DP overcurrent</description>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RX_DM</name>
                            <description>DPM pin state</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RX_DP</name>
                            <description>DPP pin state</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RX_DD</name>
                            <description>Differential RX</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TX_DIFFMODE</name>
                            <description>TX_DIFFMODE=0: Single ended mode
                                TX_DIFFMODE=1: Differential drive mode (TX_DM, TX_DM_OE ignored)</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TX_FSSLEW</name>
                            <description>TX_FSSLEW=0: Low speed slew rate
                                TX_FSSLEW=1: Full speed slew rate</description>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TX_PD</name>
                            <description>TX power down override (if override enable is set). 1 = powered down.</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RX_PD</name>
                            <description>RX power down override (if override enable is set). 1 = powered down.</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TX_DM</name>
                            <description>Output data. TX_DIFFMODE=1, Ignored
                                TX_DIFFMODE=0, Drives DPM only. TX_DM_OE=1 to enable drive. DPM=TX_DM</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TX_DP</name>
                            <description>Output data. If TX_DIFFMODE=1, Drives DPP/DPM diff pair. TX_DP_OE=1 to enable drive. DPP=TX_DP, DPM=~TX_DP
                                If TX_DIFFMODE=0, Drives DPP only. TX_DP_OE=1 to enable drive. DPP=TX_DP</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TX_DM_OE</name>
                            <description>Output enable. If TX_DIFFMODE=1, Ignored.
                                If TX_DIFFMODE=0, OE for DPM only. 0 - DPM in Hi-Z state; 1 - DPM driving</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TX_DP_OE</name>
                            <description>Output enable. If TX_DIFFMODE=1, OE for DPP/DPM diff pair. 0 - DPP/DPM in Hi-Z state; 1 - DPP/DPM driving
                                If TX_DIFFMODE=0, OE for DPP only. 0 - DPP in Hi-Z state; 1 - DPP driving</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DM_PULLDN_EN</name>
                            <description>DM pull down enable</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DM_PULLUP_EN</name>
                            <description>DM pull up enable</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DM_PULLUP_HISEL</name>
                            <description>Enable the second DM pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DP_PULLDN_EN</name>
                            <description>DP pull down enable</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DP_PULLUP_EN</name>
                            <description>DP pull up enable</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DP_PULLUP_HISEL</name>
                            <description>Enable the second DP pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>USBPHY_DIRECT_OVERRIDE</name>
                    <description>Override enable for each control in usbphy_direct</description>
                    <addressOffset>0x80</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RX_DM_OVERRIDE_EN</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RX_DP_OVERRIDE_EN</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RX_DD_OVERRIDE_EN</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TX_DIFFMODE_OVERRIDE_EN</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DM_PULLUP_OVERRIDE_EN</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TX_FSSLEW_OVERRIDE_EN</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TX_PD_OVERRIDE_EN</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RX_PD_OVERRIDE_EN</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TX_DM_OVERRIDE_EN</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TX_DP_OVERRIDE_EN</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TX_DM_OE_OVERRIDE_EN</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TX_DP_OE_OVERRIDE_EN</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DM_PULLDN_EN_OVERRIDE_EN</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DP_PULLDN_EN_OVERRIDE_EN</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DP_PULLUP_EN_OVERRIDE_EN</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DM_PULLUP_HISEL_OVERRIDE_EN</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DP_PULLUP_HISEL_OVERRIDE_EN</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>USBPHY_TRIM</name>
                    <description>Used to adjust trim values of USB phy pull down resistors.</description>
                    <addressOffset>0x84</addressOffset>
                    <resetValue>0x00001F1F</resetValue>
                    <fields>
                        <field>
                            <name>DM_PULLDN_TRIM</name>
                            <description>Value to drive to USB PHY
                                DM pulldown resistor trim control
                                Experimental data suggests that the reset value will work, but this register allows adjustment if required</description>
                            <bitRange>[12:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DP_PULLDN_TRIM</name>
                            <description>Value to drive to USB PHY
                                DP pulldown resistor trim control
                                Experimental data suggests that the reset value will work, but this register allows adjustment if required</description>
                            <bitRange>[4:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>LINESTATE_TUNING</name>
                    <description>Used for debug only.</description>
                    <addressOffset>0x88</addressOffset>
                    <resetValue>0x000000F8</resetValue>
                    <fields>
                        <field>
                            <name>SPARE_FIX</name>
                            <bitRange>[11:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DEV_LS_WAKE_FIX</name>
                            <description>Device - exit suspend on any non-idle signalling, not qualified with a 1ms timer</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DEV_RX_ERR_QUIESCE</name>
                            <description>Device - suppress repeated errors until the device FSM is next in the process of decoding an inbound packet.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SIE_RX_CHATTER_SE0_FIX</name>
                            <description>RX - when recovering from line chatter or bitstuff errors, treat SE0 as the end of chatter as well as
                                8 consecutive idle bits.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SIE_RX_BITSTUFF_FIX</name>
                            <description>RX - when a bitstuff error is signalled by rx_dasm, unconditionally terminate RX decode to
                                avoid a hang during certain packet phases.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DEV_BUFF_CONTROL_DOUBLE_READ_FIX</name>
                            <description>Device - the controller FSM performs two reads of the buffer status memory address to
                                avoid sampling metastable data. An enabled buffer is only used if both reads match.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>MULTI_HUB_FIX</name>
                            <description>Host - increase inter-packet and turnaround timeouts to accommodate worst-case hub delays.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>LINESTATE_DELAY</name>
                            <description>Device/Host - add an extra 1-bit debounce of linestate sampling.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RCV_DELAY</name>
                            <description>Device - register the received data to account for hub bit dribble before EOP. Only affects certain hubs.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTR</name>
                    <description>Raw Interrupts</description>
                    <addressOffset>0x8C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EPX_STOPPED_ON_NAK</name>
                            <description>Source: NAK_POLL.EPX_STOPPED_ON_NAK</description>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DEV_SM_WATCHDOG_FIRED</name>
                            <description>Source: DEV_SM_WATCHDOG.FIRED</description>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ENDPOINT_ERROR</name>
                            <description>Source: SIE_STATUS.ENDPOINT_ERROR</description>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RX_SHORT_PACKET</name>
                            <description>Source: SIE_STATUS.RX_SHORT_PACKET</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP_STALL_NAK</name>
                            <description>Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.</description>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ABORT_DONE</name>
                            <description>Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DEV_SOF</name>
                            <description>Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SETUP_REQ</name>
                            <description>Device. Source: SIE_STATUS.SETUP_REC</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DEV_RESUME_FROM_HOST</name>
                            <description>Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DEV_SUSPEND</name>
                            <description>Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED</description>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DEV_CONN_DIS</name>
                            <description>Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BUS_RESET</name>
                            <description>Source: SIE_STATUS.BUS_RESET</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VBUS_DETECT</name>
                            <description>Source: SIE_STATUS.VBUS_DETECTED</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>STALL</name>
                            <description>Source: SIE_STATUS.STALL_REC</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ERROR_CRC</name>
                            <description>Source: SIE_STATUS.CRC_ERROR</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ERROR_BIT_STUFF</name>
                            <description>Source: SIE_STATUS.BIT_STUFF_ERROR</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ERROR_RX_OVERFLOW</name>
                            <description>Source: SIE_STATUS.RX_OVERFLOW</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ERROR_RX_TIMEOUT</name>
                            <description>Source: SIE_STATUS.RX_TIMEOUT</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ERROR_DATA_SEQ</name>
                            <description>Source: SIE_STATUS.DATA_SEQ_ERROR</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BUFF_STATUS</name>
                            <description>Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TRANS_COMPLETE</name>
                            <description>Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HOST_SOF</name>
                            <description>Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HOST_RESUME</name>
                            <description>Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HOST_CONN_DIS</name>
                            <description>Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTE</name>
                    <description>Interrupt Enable</description>
                    <addressOffset>0x90</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EPX_STOPPED_ON_NAK</name>
                            <description>Source: NAK_POLL.EPX_STOPPED_ON_NAK</description>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DEV_SM_WATCHDOG_FIRED</name>
                            <description>Source: DEV_SM_WATCHDOG.FIRED</description>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENDPOINT_ERROR</name>
                            <description>Source: SIE_STATUS.ENDPOINT_ERROR</description>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RX_SHORT_PACKET</name>
                            <description>Source: SIE_STATUS.RX_SHORT_PACKET</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP_STALL_NAK</name>
                            <description>Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.</description>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ABORT_DONE</name>
                            <description>Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DEV_SOF</name>
                            <description>Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SETUP_REQ</name>
                            <description>Device. Source: SIE_STATUS.SETUP_REC</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DEV_RESUME_FROM_HOST</name>
                            <description>Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DEV_SUSPEND</name>
                            <description>Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED</description>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DEV_CONN_DIS</name>
                            <description>Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BUS_RESET</name>
                            <description>Source: SIE_STATUS.BUS_RESET</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VBUS_DETECT</name>
                            <description>Source: SIE_STATUS.VBUS_DETECTED</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>STALL</name>
                            <description>Source: SIE_STATUS.STALL_REC</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ERROR_CRC</name>
                            <description>Source: SIE_STATUS.CRC_ERROR</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ERROR_BIT_STUFF</name>
                            <description>Source: SIE_STATUS.BIT_STUFF_ERROR</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ERROR_RX_OVERFLOW</name>
                            <description>Source: SIE_STATUS.RX_OVERFLOW</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ERROR_RX_TIMEOUT</name>
                            <description>Source: SIE_STATUS.RX_TIMEOUT</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ERROR_DATA_SEQ</name>
                            <description>Source: SIE_STATUS.DATA_SEQ_ERROR</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BUFF_STATUS</name>
                            <description>Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TRANS_COMPLETE</name>
                            <description>Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HOST_SOF</name>
                            <description>Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HOST_RESUME</name>
                            <description>Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HOST_CONN_DIS</name>
                            <description>Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTF</name>
                    <description>Interrupt Force</description>
                    <addressOffset>0x94</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EPX_STOPPED_ON_NAK</name>
                            <description>Source: NAK_POLL.EPX_STOPPED_ON_NAK</description>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DEV_SM_WATCHDOG_FIRED</name>
                            <description>Source: DEV_SM_WATCHDOG.FIRED</description>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENDPOINT_ERROR</name>
                            <description>Source: SIE_STATUS.ENDPOINT_ERROR</description>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RX_SHORT_PACKET</name>
                            <description>Source: SIE_STATUS.RX_SHORT_PACKET</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EP_STALL_NAK</name>
                            <description>Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.</description>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ABORT_DONE</name>
                            <description>Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DEV_SOF</name>
                            <description>Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SETUP_REQ</name>
                            <description>Device. Source: SIE_STATUS.SETUP_REC</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DEV_RESUME_FROM_HOST</name>
                            <description>Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DEV_SUSPEND</name>
                            <description>Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED</description>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DEV_CONN_DIS</name>
                            <description>Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BUS_RESET</name>
                            <description>Source: SIE_STATUS.BUS_RESET</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VBUS_DETECT</name>
                            <description>Source: SIE_STATUS.VBUS_DETECTED</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>STALL</name>
                            <description>Source: SIE_STATUS.STALL_REC</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ERROR_CRC</name>
                            <description>Source: SIE_STATUS.CRC_ERROR</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ERROR_BIT_STUFF</name>
                            <description>Source: SIE_STATUS.BIT_STUFF_ERROR</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ERROR_RX_OVERFLOW</name>
                            <description>Source: SIE_STATUS.RX_OVERFLOW</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ERROR_RX_TIMEOUT</name>
                            <description>Source: SIE_STATUS.RX_TIMEOUT</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ERROR_DATA_SEQ</name>
                            <description>Source: SIE_STATUS.DATA_SEQ_ERROR</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BUFF_STATUS</name>
                            <description>Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TRANS_COMPLETE</name>
                            <description>Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HOST_SOF</name>
                            <description>Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HOST_RESUME</name>
                            <description>Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HOST_CONN_DIS</name>
                            <description>Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTS</name>
                    <description>Interrupt status after masking &amp; forcing</description>
                    <addressOffset>0x98</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EPX_STOPPED_ON_NAK</name>
                            <description>Source: NAK_POLL.EPX_STOPPED_ON_NAK</description>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DEV_SM_WATCHDOG_FIRED</name>
                            <description>Source: DEV_SM_WATCHDOG.FIRED</description>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ENDPOINT_ERROR</name>
                            <description>Source: SIE_STATUS.ENDPOINT_ERROR</description>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RX_SHORT_PACKET</name>
                            <description>Source: SIE_STATUS.RX_SHORT_PACKET</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EP_STALL_NAK</name>
                            <description>Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.</description>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ABORT_DONE</name>
                            <description>Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.</description>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DEV_SOF</name>
                            <description>Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SETUP_REQ</name>
                            <description>Device. Source: SIE_STATUS.SETUP_REC</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DEV_RESUME_FROM_HOST</name>
                            <description>Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DEV_SUSPEND</name>
                            <description>Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED</description>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DEV_CONN_DIS</name>
                            <description>Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BUS_RESET</name>
                            <description>Source: SIE_STATUS.BUS_RESET</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VBUS_DETECT</name>
                            <description>Source: SIE_STATUS.VBUS_DETECTED</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>STALL</name>
                            <description>Source: SIE_STATUS.STALL_REC</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ERROR_CRC</name>
                            <description>Source: SIE_STATUS.CRC_ERROR</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ERROR_BIT_STUFF</name>
                            <description>Source: SIE_STATUS.BIT_STUFF_ERROR</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ERROR_RX_OVERFLOW</name>
                            <description>Source: SIE_STATUS.RX_OVERFLOW</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ERROR_RX_TIMEOUT</name>
                            <description>Source: SIE_STATUS.RX_TIMEOUT</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ERROR_DATA_SEQ</name>
                            <description>Source: SIE_STATUS.DATA_SEQ_ERROR</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BUFF_STATUS</name>
                            <description>Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TRANS_COMPLETE</name>
                            <description>Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HOST_SOF</name>
                            <description>Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HOST_RESUME</name>
                            <description>Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HOST_CONN_DIS</name>
                            <description>Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SOF_TIMESTAMP_RAW</name>
                    <description>Device only. Raw value of free-running PHY clock counter @48MHz. Used to calculate time between SOF events.</description>
                    <addressOffset>0x100</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SOF_TIMESTAMP_RAW</name>
                            <bitRange>[20:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SOF_TIMESTAMP_LAST</name>
                    <description>Device only. Value of free-running PHY clock counter @48MHz when last SOF event occurred.</description>
                    <addressOffset>0x104</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SOF_TIMESTAMP_LAST</name>
                            <bitRange>[20:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SM_STATE</name>
                    <addressOffset>0x108</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RX_DASM</name>
                            <bitRange>[11:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BC_STATE</name>
                            <bitRange>[7:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>STATE</name>
                            <bitRange>[4:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>EP_TX_ERROR</name>
                    <description>TX error count for each endpoint. Write to each field to reset the counter to 0.</description>
                    <addressOffset>0x10C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EP15</name>
                            <bitRange>[31:30]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP14</name>
                            <bitRange>[29:28]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP13</name>
                            <bitRange>[27:26]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP12</name>
                            <bitRange>[25:24]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP11</name>
                            <bitRange>[23:22]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP10</name>
                            <bitRange>[21:20]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP9</name>
                            <bitRange>[19:18]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP8</name>
                            <bitRange>[17:16]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP7</name>
                            <bitRange>[15:14]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP6</name>
                            <bitRange>[13:12]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP5</name>
                            <bitRange>[11:10]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP4</name>
                            <bitRange>[9:8]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP3</name>
                            <bitRange>[7:6]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP2</name>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP1</name>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP0</name>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>EP_RX_ERROR</name>
                    <description>RX error count for each endpoint. Write to each field to reset the counter to 0.</description>
                    <addressOffset>0x110</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EP15_SEQ</name>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP15_TRANSACTION</name>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP14_SEQ</name>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP14_TRANSACTION</name>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP13_SEQ</name>
                            <bitRange>[27:27]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP13_TRANSACTION</name>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP12_SEQ</name>
                            <bitRange>[25:25]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP12_TRANSACTION</name>
                            <bitRange>[24:24]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP11_SEQ</name>
                            <bitRange>[23:23]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP11_TRANSACTION</name>
                            <bitRange>[22:22]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP10_SEQ</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP10_TRANSACTION</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP9_SEQ</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP9_TRANSACTION</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP8_SEQ</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP8_TRANSACTION</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP7_SEQ</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP7_TRANSACTION</name>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP6_SEQ</name>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP6_TRANSACTION</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP5_SEQ</name>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP5_TRANSACTION</name>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP4_SEQ</name>
                            <bitRange>[9:9]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP4_TRANSACTION</name>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP3_SEQ</name>
                            <bitRange>[7:7]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP3_TRANSACTION</name>
                            <bitRange>[6:6]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP2_SEQ</name>
                            <bitRange>[5:5]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP2_TRANSACTION</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP1_SEQ</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP1_TRANSACTION</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP0_SEQ</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>EP0_TRANSACTION</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DEV_SM_WATCHDOG</name>
                    <description>Watchdog that forces the device state machine to idle and raises an interrupt if the device stays in a state that isn't idle for the configured limit. The counter is reset on every state transition.
                        Set limit while enable is low and then set the enable.</description>
                    <addressOffset>0x114</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FIRED</name>
                            <bitRange>[20:20]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>RESET</name>
                            <description>Set to 1 to forcibly reset the device state machine on watchdog expiry</description>
                            <bitRange>[19:19]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENABLE</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>LIMIT</name>
                            <bitRange>[17:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>TRNG</name>
            <description>ARM TrustZone RNG register block</description>
            <baseAddress>0x400F0000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x1EC</size>
                <usage>registers</usage>
            </addressBlock>
            <interrupt>
                <name>TRNG_IRQ</name>
                <value>39</value>
            </interrupt>
            <registers>
                <register>
                    <name>RNG_IMR</name>
                    <description>Interrupt masking.</description>
                    <addressOffset>0x100</addressOffset>
                    <resetValue>0x0000000F</resetValue>
                    <fields>
                        <field>
                            <name>RESERVED</name>
                            <description>RESERVED</description>
                            <bitRange>[31:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VN_ERR_INT_MASK</name>
                            <description>1'b1-mask interrupt, no interrupt will be generated. See RNG_ISR for an explanation on this interrupt.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CRNGT_ERR_INT_MASK</name>
                            <description>1'b1-mask interrupt, no interrupt will be generated. See RNG_ISR for an explanation on this interrupt.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AUTOCORR_ERR_INT_MASK</name>
                            <description>1'b1-mask interrupt, no interrupt will be generated. See RNG_ISR for an explanation on this interrupt.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EHR_VALID_INT_MASK</name>
                            <description>1'b1-mask interrupt, no interrupt will be generated. See RNG_ISR for an explanation on this interrupt.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RNG_ISR</name>
                    <description>RNG status register. If corresponding RNG_IMR bit is unmasked, an interrupt will be generated.</description>
                    <addressOffset>0x104</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RESERVED</name>
                            <description>RESERVED</description>
                            <bitRange>[31:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VN_ERR</name>
                            <description>1'b1 indicates Von Neuman error. Error in von Neuman occurs if 32 consecutive collected bits are identical, ZERO or ONE.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CRNGT_ERR</name>
                            <description>1'b1 indicates CRNGT in the RNG test failed. Failure occurs when two consecutive blocks of 16 collected bits are equal.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>AUTOCORR_ERR</name>
                            <description>1'b1 indicates Autocorrelation test failed four times in a row. When set, RNG cease from functioning until next reset.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EHR_VALID</name>
                            <description>1'b1 indicates that 192 bits have been collected in the RNG, and are ready to be read.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RNG_ICR</name>
                    <description>Interrupt/status bit clear Register.</description>
                    <addressOffset>0x108</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RESERVED</name>
                            <description>RESERVED</description>
                            <bitRange>[31:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VN_ERR</name>
                            <description>Write 1'b1 - clear corresponding bit in RNG_ISR.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CRNGT_ERR</name>
                            <description>Write 1'b1 - clear corresponding bit in RNG_ISR.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AUTOCORR_ERR</name>
                            <description>Cannot be cleared by SW! Only RNG reset clears this bit.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>EHR_VALID</name>
                            <description>Write 1'b1 - clear corresponding bit in RNG_ISR.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRNG_CONFIG</name>
                    <description>Selecting the inverter-chain length.</description>
                    <addressOffset>0x10C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RESERVED</name>
                            <description>RESERVED</description>
                            <bitRange>[31:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RND_SRC_SEL</name>
                            <description>Selects the number of inverters (out of four possible selections) in the ring oscillator (the entropy source).</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRNG_VALID</name>
                    <description>192 bit collection indication.</description>
                    <addressOffset>0x110</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RESERVED</name>
                            <description>RESERVED</description>
                            <bitRange>[31:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EHR_VALID</name>
                            <description>1'b1 indicates that collection of bits in the RNG is completed, and data can be read from EHR_DATA register.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>EHR_DATA0</name>
                    <description>RNG collected bits.</description>
                    <addressOffset>0x114</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EHR_DATA0</name>
                            <description>Bits [31:0] of Entropy Holding Register (EHR) - RNG output register</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>EHR_DATA1</name>
                    <description>RNG collected bits.</description>
                    <addressOffset>0x118</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EHR_DATA1</name>
                            <description>Bits [63:32] of Entropy Holding Register (EHR) - RNG output register</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>EHR_DATA2</name>
                    <description>RNG collected bits.</description>
                    <addressOffset>0x11C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EHR_DATA2</name>
                            <description>Bits [95:64] of Entropy Holding Register (EHR) - RNG output register</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>EHR_DATA3</name>
                    <description>RNG collected bits.</description>
                    <addressOffset>0x120</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EHR_DATA3</name>
                            <description>Bits [127:96] of Entropy Holding Register (EHR) - RNG output register</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>EHR_DATA4</name>
                    <description>RNG collected bits.</description>
                    <addressOffset>0x124</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EHR_DATA4</name>
                            <description>Bits [159:128] of Entropy Holding Register (EHR) - RNG output register</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>EHR_DATA5</name>
                    <description>RNG collected bits.</description>
                    <addressOffset>0x128</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EHR_DATA5</name>
                            <description>Bits [191:160] of Entropy Holding Register (EHR) - RNG output register</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RND_SOURCE_ENABLE</name>
                    <description>Enable signal for the random source.</description>
                    <addressOffset>0x12C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RESERVED</name>
                            <description>RESERVED</description>
                            <bitRange>[31:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RND_SRC_EN</name>
                            <description>* 1'b1 - entropy source is enabled. *1'b0 - entropy source is disabled</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SAMPLE_CNT1</name>
                    <description>Counts clocks between sampling of random bit.</description>
                    <addressOffset>0x130</addressOffset>
                    <resetValue>0x0000FFFF</resetValue>
                    <fields>
                        <field>
                            <name>SAMPLE_CNTR1</name>
                            <description>Sets the number of rng_clk cycles between two consecutive ring oscillator samples. Note! If the Von-Neuman is bypassed, the minimum value for sample counter must not be less then decimal seventeen</description>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>AUTOCORR_STATISTIC</name>
                    <description>Statistic about Autocorrelation test activations.</description>
                    <addressOffset>0x134</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RESERVED</name>
                            <description>RESERVED</description>
                            <bitRange>[31:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>AUTOCORR_FAILS</name>
                            <description>Count each time an autocorrelation test fails. Any write to the register reset the counter. Stop collecting statistic if one of the counters reached the limit.</description>
                            <bitRange>[21:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AUTOCORR_TRYS</name>
                            <description>Count each time an autocorrelation test starts. Any write to the register reset the counter. Stop collecting statistic if one of the counters reached the limit.</description>
                            <bitRange>[13:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRNG_DEBUG_CONTROL</name>
                    <description>Debug register.</description>
                    <addressOffset>0x138</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>AUTO_CORRELATE_BYPASS</name>
                            <description>When set, the autocorrelation test in the TRNG module is bypassed.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TRNG_CRNGT_BYPASS</name>
                            <description>When set, the CRNGT test in the RNG is bypassed.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>VNC_BYPASS</name>
                            <description>When set, the Von-Neuman balancer is bypassed (including the 32 consecutive bits test).</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RESERVED</name>
                            <description>N/A</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRNG_SW_RESET</name>
                    <description>Generate internal SW reset within the RNG block.</description>
                    <addressOffset>0x140</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RESERVED</name>
                            <description>RESERVED</description>
                            <bitRange>[31:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TRNG_SW_RESET</name>
                            <description>Writing 1'b1 to this register causes an internal RNG reset.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RNG_DEBUG_EN_INPUT</name>
                    <description>Enable the RNG debug mode</description>
                    <addressOffset>0x1B4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RESERVED</name>
                            <description>RESERVED</description>
                            <bitRange>[31:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RNG_DEBUG_EN</name>
                            <description>* 1'b1 - debug mode is enabled. *1'b0 - debug mode is disabled</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRNG_BUSY</name>
                    <description>RNG Busy indication.</description>
                    <addressOffset>0x1B8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RESERVED</name>
                            <description>RESERVED</description>
                            <bitRange>[31:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TRNG_BUSY</name>
                            <description>Reflects rng_busy status.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RST_BITS_COUNTER</name>
                    <description>Reset the counter of collected bits in the RNG.</description>
                    <addressOffset>0x1BC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RESERVED</name>
                            <description>RESERVED</description>
                            <bitRange>[31:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RST_BITS_COUNTER</name>
                            <description>Writing any value to this address will reset the bits counter and RNG valid registers. RND_SORCE_ENABLE register must be unset in order for the reset to take place.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RNG_VERSION</name>
                    <description>Displays the version settings of the TRNG.</description>
                    <addressOffset>0x1C0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RESERVED</name>
                            <description>RESERVED</description>
                            <bitRange>[31:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RNG_USE_5_SBOXES</name>
                            <description>* 1'b1 - 5 SBOX AES. *1'b0 - 20 SBOX AES</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RESEEDING_EXISTS</name>
                            <description>* 1'b1 - Exists. *1'b0 - Does not exist</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KAT_EXISTS</name>
                            <description>* 1'b1 - Exists. *1'b0 - Does not exist</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PRNG_EXISTS</name>
                            <description>* 1'b1 - Exists. *1'b0 - Does not exist</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>TRNG_TESTS_BYPASS_EN</name>
                            <description>* 1'b1 - Exists. *1'b0 - Does not exist</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>AUTOCORR_EXISTS</name>
                            <description>* 1'b1 - Exists. *1'b0 - Does not exist</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CRNGT_EXISTS</name>
                            <description>* 1'b1 - Exists. *1'b0 - Does not exist</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>EHR_WIDTH_192</name>
                            <description>* 1'b1 - 192-bit EHR. *1'b0 - 128-bit EHR</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RNG_BIST_CNTR_0</name>
                    <description>Collected BIST results.</description>
                    <addressOffset>0x1E0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RESERVED</name>
                            <description>RESERVED</description>
                            <bitRange>[31:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ROSC_CNTR_VAL</name>
                            <description>Reflects the results of RNG BIST counter.</description>
                            <bitRange>[21:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RNG_BIST_CNTR_1</name>
                    <description>Collected BIST results.</description>
                    <addressOffset>0x1E4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RESERVED</name>
                            <description>RESERVED</description>
                            <bitRange>[31:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ROSC_CNTR_VAL</name>
                            <description>Reflects the results of RNG BIST counter.</description>
                            <bitRange>[21:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RNG_BIST_CNTR_2</name>
                    <description>Collected BIST results.</description>
                    <addressOffset>0x1E8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RESERVED</name>
                            <description>RESERVED</description>
                            <bitRange>[31:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ROSC_CNTR_VAL</name>
                            <description>Reflects the results of RNG BIST counter.</description>
                            <bitRange>[21:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>GLITCH_DETECTOR</name>
            <description>Glitch detector controls</description>
            <baseAddress>0x40158000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x18</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>ARM</name>
                    <description>Forcibly arm the glitch detectors, if they are not already armed by OTP. When armed, any individual detector trigger will cause a restart of the switched core power domain's power-on reset state machine.

                        Glitch detector triggers are recorded accumulatively in TRIG_STATUS. If the system is reset by a glitch detector trigger, this is recorded in POWMAN_CHIP_RESET.

                        This register is Secure read/write only.</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00005BAD</resetValue>
                    <fields>
                        <field>
                            <name>ARM</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>no</name>
                                    <description>Do not force the glitch detectors to be armed</description>
                                    <value>23469</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>yes</name>
                                    <description>Force the glitch detectors to be armed. (Any value other than ARM_NO counts as YES)</description>
                                    <value>0</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DISARM</name>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DISARM</name>
                            <description>Forcibly disarm the glitch detectors, if they are armed by OTP. Ignored if ARM is YES.

                                This register is Secure read/write only.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>no</name>
                                    <description>Do not disarm the glitch detectors. (Any value other than DISARM_YES counts as NO)</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>yes</name>
                                    <description>Disarm the glitch detectors</description>
                                    <value>56495</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SENSITIVITY</name>
                    <description>Adjust the sensitivity of glitch detectors to values other than their OTP-provided defaults.

                        This register is Secure read/write only.</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DEFAULT</name>
                            <bitRange>[31:24]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>yes</name>
                                    <description>Use the default sensitivity configured in OTP for all detectors. (Any value other than DEFAULT_NO counts as YES)</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>no</name>
                                    <description>Do not use the default sensitivity configured in OTP. Instead use the value from this register.</description>
                                    <value>222</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>DET3_INV</name>
                            <description>Must be the inverse of DET3, else the default value is used.</description>
                            <bitRange>[15:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DET2_INV</name>
                            <description>Must be the inverse of DET2, else the default value is used.</description>
                            <bitRange>[13:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DET1_INV</name>
                            <description>Must be the inverse of DET1, else the default value is used.</description>
                            <bitRange>[11:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DET0_INV</name>
                            <description>Must be the inverse of DET0, else the default value is used.</description>
                            <bitRange>[9:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DET3</name>
                            <description>Set sensitivity for detector 3. Higher values are more sensitive.</description>
                            <bitRange>[7:6]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DET2</name>
                            <description>Set sensitivity for detector 2. Higher values are more sensitive.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DET1</name>
                            <description>Set sensitivity for detector 1. Higher values are more sensitive.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DET0</name>
                            <description>Set sensitivity for detector 0. Higher values are more sensitive.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>LOCK</name>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>LOCK</name>
                            <description>Write any nonzero value to disable writes to ARM, DISARM, SENSITIVITY and LOCK. This register is Secure read/write only.</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRIG_STATUS</name>
                    <description>Set when a detector output triggers. Write-1-clear.

                        (May immediately return high if the detector remains in a failed state. Detectors can only be cleared by a full reset of the switched core power domain.)

                        This register is Secure read/write only.</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DET3</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>DET2</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>DET1</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>DET0</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>TRIG_FORCE</name>
                    <description>Simulate the firing of one or more detectors. Writing ones to this register will set the matching bits in STATUS_TRIG.

                        If the glitch detectors are currently armed, writing ones will also immediately reset the switched core power domain, and set the reset reason latches in POWMAN_CHIP_RESET to indicate a glitch detector resets.

                        This register is Secure read/write only.</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>TRIG_FORCE</name>
                            <bitRange>[3:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>OTP</name>
            <description>SNPS OTP control IF (SBPI and RPi wrapper control)</description>
            <baseAddress>0x40120000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x174</size>
                <usage>registers</usage>
            </addressBlock>
            <interrupt>
                <name>OTP_IRQ</name>
                <value>38</value>
            </interrupt>
            <registers>
                <register>
                    <name>SW_LOCK0</name>
                    <description>Software lock register for page 0.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK1</name>
                    <description>Software lock register for page 1.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK2</name>
                    <description>Software lock register for page 2.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK3</name>
                    <description>Software lock register for page 3.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK4</name>
                    <description>Software lock register for page 4.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK5</name>
                    <description>Software lock register for page 5.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x14</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK6</name>
                    <description>Software lock register for page 6.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x18</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK7</name>
                    <description>Software lock register for page 7.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x1C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK8</name>
                    <description>Software lock register for page 8.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x20</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK9</name>
                    <description>Software lock register for page 9.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x24</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK10</name>
                    <description>Software lock register for page 10.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x28</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK11</name>
                    <description>Software lock register for page 11.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x2C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK12</name>
                    <description>Software lock register for page 12.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x30</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK13</name>
                    <description>Software lock register for page 13.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x34</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK14</name>
                    <description>Software lock register for page 14.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x38</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK15</name>
                    <description>Software lock register for page 15.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x3C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK16</name>
                    <description>Software lock register for page 16.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x40</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK17</name>
                    <description>Software lock register for page 17.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x44</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK18</name>
                    <description>Software lock register for page 18.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x48</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK19</name>
                    <description>Software lock register for page 19.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x4C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK20</name>
                    <description>Software lock register for page 20.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x50</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK21</name>
                    <description>Software lock register for page 21.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x54</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK22</name>
                    <description>Software lock register for page 22.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x58</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK23</name>
                    <description>Software lock register for page 23.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x5C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK24</name>
                    <description>Software lock register for page 24.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x60</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK25</name>
                    <description>Software lock register for page 25.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x64</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK26</name>
                    <description>Software lock register for page 26.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x68</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK27</name>
                    <description>Software lock register for page 27.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x6C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK28</name>
                    <description>Software lock register for page 28.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x70</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK29</name>
                    <description>Software lock register for page 29.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x74</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK30</name>
                    <description>Software lock register for page 30.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x78</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK31</name>
                    <description>Software lock register for page 31.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x7C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK32</name>
                    <description>Software lock register for page 32.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x80</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK33</name>
                    <description>Software lock register for page 33.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x84</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK34</name>
                    <description>Software lock register for page 34.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x88</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK35</name>
                    <description>Software lock register for page 35.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x8C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK36</name>
                    <description>Software lock register for page 36.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x90</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK37</name>
                    <description>Software lock register for page 37.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x94</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK38</name>
                    <description>Software lock register for page 38.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x98</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK39</name>
                    <description>Software lock register for page 39.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0x9C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK40</name>
                    <description>Software lock register for page 40.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xA0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK41</name>
                    <description>Software lock register for page 41.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xA4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK42</name>
                    <description>Software lock register for page 42.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xA8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK43</name>
                    <description>Software lock register for page 43.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xAC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK44</name>
                    <description>Software lock register for page 44.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xB0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK45</name>
                    <description>Software lock register for page 45.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xB4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK46</name>
                    <description>Software lock register for page 46.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xB8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK47</name>
                    <description>Software lock register for page 47.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xBC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK48</name>
                    <description>Software lock register for page 48.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xC0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK49</name>
                    <description>Software lock register for page 49.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xC4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK50</name>
                    <description>Software lock register for page 50.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xC8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK51</name>
                    <description>Software lock register for page 51.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xCC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK52</name>
                    <description>Software lock register for page 52.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xD0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK53</name>
                    <description>Software lock register for page 53.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xD4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK54</name>
                    <description>Software lock register for page 54.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xD8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK55</name>
                    <description>Software lock register for page 55.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xDC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK56</name>
                    <description>Software lock register for page 56.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xE0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK57</name>
                    <description>Software lock register for page 57.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xE4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK58</name>
                    <description>Software lock register for page 58.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xE8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK59</name>
                    <description>Software lock register for page 59.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xEC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK60</name>
                    <description>Software lock register for page 60.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xF0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK61</name>
                    <description>Software lock register for page 61.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xF4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK62</name>
                    <description>Software lock register for page 62.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xF8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SW_LOCK63</name>
                    <description>Software lock register for page 63.

                        Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.</description>
                    <addressOffset>0xFC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NSEC</name>
                            <description>Non-secure lock status. Writes are OR'd with the current value.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>SEC</name>
                            <description>Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SBPI_INSTR</name>
                    <description>Dispatch instructions to the SBPI interface, used for programming the OTP fuses.</description>
                    <addressOffset>0x100</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>EXEC</name>
                            <description>Execute instruction</description>
                            <bitRange>[30:30]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>IS_WR</name>
                            <description>Payload type is write</description>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>HAS_PAYLOAD</name>
                            <description>Instruction has payload (data to be written or to be read)</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PAYLOAD_SIZE_M1</name>
                            <description>Instruction payload size in bytes minus 1</description>
                            <bitRange>[27:24]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>TARGET</name>
                            <description>Instruction target, it can be PMC (0x3a) or DAP (0x02)</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CMD</name>
                            <bitRange>[15:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SHORT_WDATA</name>
                            <description>wdata to be used only when payload_size_m1=0</description>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SBPI_WDATA_0</name>
                    <description>SBPI write payload bytes 3..0</description>
                    <addressOffset>0x104</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SBPI_WDATA_0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SBPI_WDATA_1</name>
                    <description>SBPI write payload bytes 7..4</description>
                    <addressOffset>0x108</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SBPI_WDATA_1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SBPI_WDATA_2</name>
                    <description>SBPI write payload bytes 11..8</description>
                    <addressOffset>0x10C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SBPI_WDATA_2</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SBPI_WDATA_3</name>
                    <description>SBPI write payload bytes 15..12</description>
                    <addressOffset>0x110</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SBPI_WDATA_3</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SBPI_RDATA_0</name>
                    <description>Read payload bytes 3..0. Once read, the data in the register will automatically clear to 0.</description>
                    <addressOffset>0x114</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SBPI_RDATA_0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SBPI_RDATA_1</name>
                    <description>Read payload bytes 7..4. Once read, the data in the register will automatically clear to 0.</description>
                    <addressOffset>0x118</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SBPI_RDATA_1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SBPI_RDATA_2</name>
                    <description>Read payload bytes 11..8. Once read, the data in the register will automatically clear to 0.</description>
                    <addressOffset>0x11C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SBPI_RDATA_2</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SBPI_RDATA_3</name>
                    <description>Read payload bytes 15..12. Once read, the data in the register will automatically clear to 0.</description>
                    <addressOffset>0x120</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>SBPI_RDATA_3</name>
                            <bitRange>[31:0]</bitRange>
                            <access>read-only</access>
                            <readAction>modify</readAction>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SBPI_STATUS</name>
                    <addressOffset>0x124</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>MISO</name>
                            <description>SBPI MISO (master in - slave out): response from SBPI</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FLAG</name>
                            <description>SBPI flag</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>INSTR_MISS</name>
                            <description>Last instruction missed (dropped), as the previous has not finished running</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>INSTR_DONE</name>
                            <description>Last instruction done</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>RDATA_VLD</name>
                            <description>Read command has returned data</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>USR</name>
                    <description>Controls for APB data read interface (USER interface)</description>
                    <addressOffset>0x128</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>PD</name>
                            <description>Power-down; 1 disables current reference. Must be 0 to read data from the OTP.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DCTRL</name>
                            <description>1 enables USER interface; 0 disables USER interface (enables SBPI).

                                This bit must be cleared before performing any SBPI access, such as when programming the OTP. The APB data read interface (USER interface) will be inaccessible during this time, and will return a bus error if any read is attempted.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DBG</name>
                    <description>Debug for OTP power-on state machine</description>
                    <addressOffset>0x12C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CUSTOMER_RMA_FLAG</name>
                            <description>The chip is in RMA mode</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PSM_STATE</name>
                            <description>Monitor the PSM FSM's state</description>
                            <bitRange>[7:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ROSC_UP</name>
                            <description>Ring oscillator is up and running</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ROSC_UP_SEEN</name>
                            <description>Ring oscillator was seen up and running</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>BOOT_DONE</name>
                            <description>PSM boot done status flag</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PSM_DONE</name>
                            <description>PSM done status flag</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BIST</name>
                    <description>During BIST, count address locations that have at least one leaky bit</description>
                    <addressOffset>0x134</addressOffset>
                    <resetValue>0x0FFF0000</resetValue>
                    <fields>
                        <field>
                            <name>CNT_FAIL</name>
                            <description>Flag if the count of address locations with at least one leaky bit exceeds cnt_max</description>
                            <bitRange>[30:30]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CNT_CLR</name>
                            <description>Clear counter before use</description>
                            <bitRange>[29:29]</bitRange>
                            <access>write-only</access>
                        </field>
                        <field>
                            <name>CNT_ENA</name>
                            <description>Enable the counter before the BIST function is initiated</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CNT_MAX</name>
                            <description>The cnt_fail flag will be set if the number of leaky locations exceeds this number</description>
                            <bitRange>[27:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>CNT</name>
                            <description>Number of locations that have at least one leaky bit. Note: This count is true only if the BIST was initiated without the fix option.</description>
                            <bitRange>[12:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRT_KEY_W0</name>
                    <description>Word 0 (bits 31..0) of the key. Write only, read returns 0x0</description>
                    <addressOffset>0x138</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CRT_KEY_W0</name>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRT_KEY_W1</name>
                    <description>Word 1 (bits 63..32) of the key. Write only, read returns 0x0</description>
                    <addressOffset>0x13C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CRT_KEY_W1</name>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRT_KEY_W2</name>
                    <description>Word 2 (bits 95..64) of the key. Write only, read returns 0x0</description>
                    <addressOffset>0x140</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CRT_KEY_W2</name>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRT_KEY_W3</name>
                    <description>Word 3 (bits 127..96) of the key. Write only, read returns 0x0</description>
                    <addressOffset>0x144</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CRT_KEY_W3</name>
                            <bitRange>[31:0]</bitRange>
                            <access>write-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRITICAL</name>
                    <description>Quickly check values of critical flags read during boot up</description>
                    <addressOffset>0x148</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RISCV_DISABLE</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ARM_DISABLE</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GLITCH_DETECTOR_SENS</name>
                            <bitRange>[6:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GLITCH_DETECTOR_ENABLE</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DEFAULT_ARCHSEL</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DEBUG_DISABLE</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SECURE_DEBUG_DISABLE</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SECURE_BOOT_ENABLE</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY_VALID</name>
                    <description>Which keys were valid (enrolled) at boot time</description>
                    <addressOffset>0x14C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>KEY_VALID</name>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DEBUGEN</name>
                    <description>Enable a debug feature that has been disabled. Debug features are disabled if one of the relevant critical boot flags is set in OTP (DEBUG_DISABLE or SECURE_DEBUG_DISABLE), OR if a debug key is marked valid in OTP, and the matching key value has not been supplied over SWD.

                        Specifically:

                        - The DEBUG_DISABLE flag disables all debug features. This can be fully overridden by setting all bits of this register.

                        - The SECURE_DEBUG_DISABLE flag disables secure processor debug. This can be fully overridden by setting the PROC0_SECURE and PROC1_SECURE bits of this register.

                        - If a single debug key has been registered, and no matching key value has been supplied over SWD, then all debug features are disabled. This can be fully overridden by setting all bits of this register.

                        - If both debug keys have been registered, and the Non-secure key's value (key 6) has been supplied over SWD, secure processor debug is disabled. This can be fully overridden by setting the PROC0_SECURE and PROC1_SECURE bits of this register.

                        - If both debug keys have been registered, and the Secure key's value (key 5) has been supplied over SWD, then no debug features are disabled by the key mechanism. However, note that in this case debug features may still be disabled by the critical boot flags.</description>
                    <addressOffset>0x150</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>MISC</name>
                            <description>Enable other debug components. Specifically, the CTI, and the APB-AP used to access the RISC-V Debug Module.

                                These components are disabled by default if either of the debug disable critical flags is set, or if at least one debug key has been enrolled and the least secure of these enrolled key values has not been provided over SWD.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PROC1_SECURE</name>
                            <description>Permit core 1's Mem-AP to generate Secure accesses, assuming it is enabled at all. Also enable secure debug of core 1 (SPIDEN and SPNIDEN).

                                Secure debug of core 1 is disabled by default if the secure debug disable critical flag is set, or if at least one debug key has been enrolled and the most secure of these enrolled key values not yet provided over SWD.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PROC1</name>
                            <description>Enable core 1's Mem-AP if it is currently disabled.

                                The Mem-AP is disabled by default if either of the debug disable critical flags is set, or if at least one debug key has been enrolled and the least secure of these enrolled key values has not been provided over SWD.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PROC0_SECURE</name>
                            <description>Permit core 0's Mem-AP to generate Secure accesses, assuming it is enabled at all. Also enable secure debug of core 0 (SPIDEN and SPNIDEN).

                                Secure debug of core 0 is disabled by default if the secure debug disable critical flag is set, or if at least one debug key has been enrolled and the most secure of these enrolled key values not yet provided over SWD.

                                Note also that core Mem-APs are unconditionally disabled when a core is switched to RISC-V mode (by setting the ARCHSEL bit and performing a warm reset of the core).</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PROC0</name>
                            <description>Enable core 0's Mem-AP if it is currently disabled.

                                The Mem-AP is disabled by default if either of the debug disable critical flags is set, or if at least one debug key has been enrolled and the least secure of these enrolled key values has not been provided over SWD.

                                Note also that core Mem-APs are unconditionally disabled when a core is switched to RISC-V mode (by setting the ARCHSEL bit and performing a warm reset of the core).</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DEBUGEN_LOCK</name>
                    <description>Write 1s to lock corresponding bits in DEBUGEN. This register is reset by the processor cold reset.</description>
                    <addressOffset>0x154</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>MISC</name>
                            <description>Write 1 to lock the MISC bit of DEBUGEN. Can't be cleared once set.</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PROC1_SECURE</name>
                            <description>Write 1 to lock the PROC1_SECURE bit of DEBUGEN. Can't be cleared once set.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PROC1</name>
                            <description>Write 1 to lock the PROC1 bit of DEBUGEN. Can't be cleared once set.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PROC0_SECURE</name>
                            <description>Write 1 to lock the PROC0_SECURE bit of DEBUGEN. Can't be cleared once set.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PROC0</name>
                            <description>Write 1 to lock the PROC0 bit of DEBUGEN. Can't be cleared once set.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ARCHSEL</name>
                    <description>Architecture select (Arm/RISC-V). The default and allowable values of this register are constrained by the critical boot flags.

                        This register is reset by the earliest reset in the switched core power domain (before a processor cold reset).

                        Cores sample their architecture select signal on a warm reset. The source of the warm reset could be the system power-up state machine, the watchdog timer, Arm SYSRESETREQ or from RISC-V hartresetreq.

                        Note that when an Arm core is deselected, its cold reset domain is also held in reset, since in particular the SYSRESETREQ bit becomes inaccessible once the core is deselected. Note also the RISC-V cores do not have a cold reset domain, since their corresponding controls are located in the Debug Module.</description>
                    <addressOffset>0x158</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CORE1</name>
                            <description>Select architecture for core 1.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>arm</name>
                                    <description>Switch core 1 to Arm (Cortex-M33)</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>riscv</name>
                                    <description>Switch core 1 to RISC-V (Hazard3)</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>Select architecture for core 0.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>arm</name>
                                    <description>Switch core 0 to Arm (Cortex-M33)</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>riscv</name>
                                    <description>Switch core 0 to RISC-V (Hazard3)</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ARCHSEL_STATUS</name>
                    <description>Get the current architecture select state of each core. Cores sample the current value of the ARCHSEL register when their warm reset is released, at which point the corresponding bit in this register will also update.</description>
                    <addressOffset>0x15C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CORE1</name>
                            <description>Current architecture for core 0. Updated on processor warm reset.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>arm</name>
                                    <description>Core 1 is currently Arm (Cortex-M33)</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>riscv</name>
                                    <description>Core 1 is currently RISC-V (Hazard3)</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>CORE0</name>
                            <description>Current architecture for core 0. Updated on processor warm reset.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>arm</name>
                                    <description>Core 0 is currently Arm (Cortex-M33)</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>riscv</name>
                                    <description>Core 0 is currently RISC-V (Hazard3)</description>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTDIS</name>
                    <description>Tell the bootrom to ignore scratch register boot vectors (both power manager and watchdog) on the next power up.

                        If an early boot stage has soft-locked some OTP pages in order to protect their contents from later stages, there is a risk that Secure code running at a later stage can unlock the pages by performing a watchdog reset that resets the OTP.

                        This register can be used to ensure that the bootloader runs as normal on the next power up, preventing Secure code at a later stage from accessing OTP in its unlocked state.

                        Should be used in conjunction with the power manager BOOTDIS register.</description>
                    <addressOffset>0x160</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>NEXT</name>
                            <description>This flag always ORs writes into its current contents. It can be set but not cleared by software.

                                The BOOTDIS_NEXT bit is OR'd into the BOOTDIS_NOW bit when the core is powered down. Simultaneously, the BOOTDIS_NEXT bit is cleared. Setting this bit means that the boot scratch registers will be ignored following the next core power down.

                                This flag should be set by an early boot stage that has soft-locked OTP pages, to prevent later stages from unlocking it via watchdog reset.</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>NOW</name>
                            <description>When the core is powered down, the current value of BOOTDIS_NEXT is OR'd into BOOTDIS_NOW, and BOOTDIS_NEXT is cleared.

                                The bootrom checks this flag before reading the boot scratch registers. If it is set, the bootrom clears it, and ignores the BOOT registers. This prevents Secure software from diverting the boot path before a bootloader has had the chance to soft lock OTP pages containing sensitive data.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTR</name>
                    <description>Raw Interrupts</description>
                    <addressOffset>0x164</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>APB_RD_NSEC_FAIL</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>APB_RD_SEC_FAIL</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>APB_DCTRL_FAIL</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>SBPI_WR_FAIL</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                            <modifiedWriteValues>oneToClear</modifiedWriteValues>
                        </field>
                        <field>
                            <name>SBPI_FLAG_N</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTE</name>
                    <description>Interrupt Enable</description>
                    <addressOffset>0x168</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>APB_RD_NSEC_FAIL</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>APB_RD_SEC_FAIL</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>APB_DCTRL_FAIL</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SBPI_WR_FAIL</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SBPI_FLAG_N</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTF</name>
                    <description>Interrupt Force</description>
                    <addressOffset>0x16C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>APB_RD_NSEC_FAIL</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>APB_RD_SEC_FAIL</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>APB_DCTRL_FAIL</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SBPI_WR_FAIL</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>SBPI_FLAG_N</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INTS</name>
                    <description>Interrupt status after masking &amp; forcing</description>
                    <addressOffset>0x170</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>APB_RD_NSEC_FAIL</name>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>APB_RD_SEC_FAIL</name>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>APB_DCTRL_FAIL</name>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SBPI_WR_FAIL</name>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SBPI_FLAG_N</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>OTP_DATA</name>
            <description>Predefined OTP data layout for RP2350</description>
            <baseAddress>0x40130000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x1EF0</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>CHIPID0</name>
                    <description>Bits 15:0 of public device ID. (ECC)

                        The CHIPID0..3 rows contain a 64-bit random identifier for this chip, which can be read from the USB bootloader PICOBOOT interface or from the get_sys_info ROM API.

                        The number of random bits makes the occurrence of twins exceedingly unlikely: for example, a fleet of a hundred million devices has a 99.97% probability of no twinned IDs. This is estimated to be lower than the occurrence of process errors in the assignment of sequential random IDs, and for practical purposes CHIPID may be treated as unique.</description>
                    <addressOffset>0x0</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CHIPID0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CHIPID1</name>
                    <description>Bits 31:16 of public device ID (ECC)</description>
                    <addressOffset>0x2</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CHIPID1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CHIPID2</name>
                    <description>Bits 47:32 of public device ID (ECC)</description>
                    <addressOffset>0x4</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CHIPID2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CHIPID3</name>
                    <description>Bits 63:48 of public device ID (ECC)</description>
                    <addressOffset>0x6</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CHIPID3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RANDID0</name>
                    <description>Bits 15:0 of private per-device random number (ECC)

                        The RANDID0..7 rows form a 128-bit random number generated during device test.

                        This ID is not exposed through the USB PICOBOOT GET_INFO command or the ROM `get_sys_info()` API. However note that the USB PICOBOOT OTP access point can read the entirety of page 0, so this value is not meaningfully private unless the USB PICOBOOT interface is disabled via the DISABLE_BOOTSEL_USB_PICOBOOT_IFC flag in BOOT_FLAGS0.</description>
                    <addressOffset>0x8</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>RANDID0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RANDID1</name>
                    <description>Bits 31:16 of private per-device random number (ECC)</description>
                    <addressOffset>0xA</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>RANDID1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RANDID2</name>
                    <description>Bits 47:32 of private per-device random number (ECC)</description>
                    <addressOffset>0xC</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>RANDID2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RANDID3</name>
                    <description>Bits 63:48 of private per-device random number (ECC)</description>
                    <addressOffset>0xE</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>RANDID3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RANDID4</name>
                    <description>Bits 79:64 of private per-device random number (ECC)</description>
                    <addressOffset>0x10</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>RANDID4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RANDID5</name>
                    <description>Bits 95:80 of private per-device random number (ECC)</description>
                    <addressOffset>0x12</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>RANDID5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RANDID6</name>
                    <description>Bits 111:96 of private per-device random number (ECC)</description>
                    <addressOffset>0x14</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>RANDID6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RANDID7</name>
                    <description>Bits 127:112 of private per-device random number (ECC)</description>
                    <addressOffset>0x16</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>RANDID7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ROSC_CALIB</name>
                    <description>Ring oscillator frequency in kHz, measured during manufacturing (ECC)

                        This is measured at 1.1 V, at room temperature, with the ROSC configuration registers in their reset state.</description>
                    <addressOffset>0x20</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>ROSC_CALIB</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>LPOSC_CALIB</name>
                    <description>Low-power oscillator frequency in Hz, measured during manufacturing (ECC)

                        This is measured at 1.1V, at room temperature, with the LPOSC trim register in its reset state.</description>
                    <addressOffset>0x22</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>LPOSC_CALIB</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NUM_GPIOS</name>
                    <description>The number of main user GPIOs (bank 0). Should read 48 in the QFN80 package, and 30 in the QFN60 package. (ECC)</description>
                    <addressOffset>0x30</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>NUM_GPIOS</name>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INFO_CRC0</name>
                    <description>Lower 16 bits of CRC32 of OTP addresses 0x00 through 0x6b (polynomial 0x4c11db7, input reflected, output reflected, seed all-ones, final XOR all-ones) (ECC)</description>
                    <addressOffset>0x6C</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>INFO_CRC0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INFO_CRC1</name>
                    <description>Upper 16 bits of CRC32 of OTP addresses 0x00 through 0x6b (ECC)</description>
                    <addressOffset>0x6E</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>INFO_CRC1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FLASH_DEVINFO</name>
                    <description>Stores information about external flash device(s). (ECC)

                        Assumed to be valid if BOOT_FLAGS0_FLASH_DEVINFO_ENABLE is set.</description>
                    <addressOffset>0xA8</addressOffset>
                    <size>0x10</size>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CS1_SIZE</name>
                            <description>The size of the flash/PSRAM device on chip select 1 (addressable at 0x11000000 through 0x11ffffff).

                                A value of zero is decoded as a size of zero (no device). Nonzero values are decoded as 4kiB &lt;&lt; CS1_SIZE. For example, four megabytes is encoded with a CS1_SIZE value of 10, and 16 megabytes is encoded with a CS1_SIZE value of 12.

                                When BOOT_FLAGS0_FLASH_DEVINFO_ENABLE is not set, a default of zero is used.</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NONE</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8K</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>16K</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>32K</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>64k</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>128K</name>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>256K</name>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>512K</name>
                                    <value>7</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>1M</name>
                                    <value>8</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>2M</name>
                                    <value>9</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4M</name>
                                    <value>10</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8M</name>
                                    <value>11</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>16M</name>
                                    <value>12</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>CS0_SIZE</name>
                            <description>The size of the flash/PSRAM device on chip select 0 (addressable at 0x10000000 through 0x10ffffff).

                                A value of zero is decoded as a size of zero (no device). Nonzero values are decoded as 4kiB &lt;&lt; CS0_SIZE. For example, four megabytes is encoded with a CS0_SIZE value of 10, and 16 megabytes is encoded with a CS0_SIZE value of 12.

                                When BOOT_FLAGS0_FLASH_DEVINFO_ENABLE is not set, a default of 12 (16 MiB) is used.</description>
                            <bitRange>[11:8]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NONE</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8K</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>16K</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>32K</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>64k</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>128K</name>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>256K</name>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>512K</name>
                                    <value>7</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>1M</name>
                                    <value>8</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>2M</name>
                                    <value>9</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4M</name>
                                    <value>10</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8M</name>
                                    <value>11</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>16M</name>
                                    <value>12</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>D8H_ERASE_SUPPORTED</name>
                            <description>If true, all attached devices are assumed to support (or ignore, in the case of PSRAM) a block erase command with a command prefix of D8h, an erase size of 64 kiB, and a 24-bit address. Almost all 25-series flash devices support this command.

                                If set, the bootrom will use the D8h erase command where it is able, to accelerate bulk erase operations. This makes flash programming faster.

                                When BOOT_FLAGS0_FLASH_DEVINFO_ENABLE is not set, this field defaults to false.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CS1_GPIO</name>
                            <description>Indicate a GPIO number to be used for the secondary flash chip select (CS1), which selects the external QSPI device mapped at system addresses 0x11000000 through 0x11ffffff. There is no such configuration for CS0, as the primary chip select has a dedicated pin.

                                On RP2350 the permissible GPIO numbers are 0, 8, 19 and 47.

                                Ignored if CS1_size is zero. If CS1_SIZE is nonzero, the bootrom will automatically configure this GPIO as a second chip select upon entering the flash boot path, or entering any other path that may use the QSPI flash interface, such as BOOTSEL mode (nsboot).</description>
                            <bitRange>[5:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FLASH_PARTITION_SLOT_SIZE</name>
                    <description>Gap between partition table slot 0 and slot 1 at the start of flash (the default size is 4096 bytes) (ECC) Enabled by the OVERRIDE_FLASH_PARTITION_SLOT_SIZE bit in BOOT_FLAGS, the size is 4096 * (value + 1)</description>
                    <addressOffset>0xAA</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>FLASH_PARTITION_SLOT_SIZE</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTSEL_LED_CFG</name>
                    <description>Pin configuration for LED status, used by USB bootloader. (ECC)
                        Must be valid if BOOT_FLAGS0_ENABLE_BOOTSEL_LED is set.</description>
                    <addressOffset>0xAC</addressOffset>
                    <size>0x10</size>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ACTIVELOW</name>
                            <description>LED is active-low. (Default: active-high.)</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PIN</name>
                            <description>GPIO index to use for bootloader activity LED.</description>
                            <bitRange>[5:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTSEL_PLL_CFG</name>
                    <description>Optional PLL configuration for BOOTSEL mode. (ECC)

                        This should be configured to produce an exact 48 MHz based on the crystal oscillator frequency. User mode software may also use this value to calculate the expected crystal frequency based on an assumed 48 MHz PLL output.

                        If no configuration is given, the crystal is assumed to be 12 MHz.

                        The PLL frequency can be calculated as:

                        PLL out = (XOSC frequency / (REFDIV+1)) x FBDIV / (POSTDIV1 x POSTDIV2)

                        Conversely the crystal frequency can be calculated as:

                        XOSC frequency = 48 MHz x (REFDIV+1) x (POSTDIV1 x POSTDIV2) / FBDIV

                        (Note the  +1 on REFDIV is because the value stored in this OTP location is the actual divisor value minus one.)

                        Used if and only if ENABLE_BOOTSEL_NON_DEFAULT_PLL_XOSC_CFG is set in BOOT_FLAGS0. That bit should be set only after this row and BOOTSEL_XOSC_CFG are both correctly programmed.</description>
                    <addressOffset>0xAE</addressOffset>
                    <size>0x10</size>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>REFDIV</name>
                            <description>PLL reference divisor, minus one.

                                Programming a value of 0 means a reference divisor of 1. Programming a value of 1 means a reference divisor of 2 (for exceptionally fast XIN inputs)</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>POSTDIV2</name>
                            <description>PLL post-divide 2 divisor, in the range 1..7 inclusive.</description>
                            <bitRange>[14:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>POSTDIV1</name>
                            <description>PLL post-divide 1 divisor, in the range 1..7 inclusive.</description>
                            <bitRange>[11:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FBDIV</name>
                            <description>PLL feedback divisor, in the range 16..320 inclusive.</description>
                            <bitRange>[8:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTSEL_XOSC_CFG</name>
                    <description>Non-default crystal oscillator configuration for the USB bootloader. (ECC)

                        These values may also be used by user code configuring the crystal oscillator.

                        Used if and only if ENABLE_BOOTSEL_NON_DEFAULT_PLL_XOSC_CFG is set in BOOT_FLAGS0. That bit should be set only after this row and BOOTSEL_PLL_CFG are both correctly programmed.</description>
                    <addressOffset>0xB0</addressOffset>
                    <size>0x10</size>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RANGE</name>
                            <description>Value of the XOSC_CTRL_FREQ_RANGE register.</description>
                            <bitRange>[15:14]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>1_15MHZ</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>10_30MHZ</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>25_60MHZ</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>40_100MHZ</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>STARTUP</name>
                            <description>Value of the XOSC_STARTUP register</description>
                            <bitRange>[13:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>USB_WHITE_LABEL_ADDR</name>
                    <description>Row index of the USB_WHITE_LABEL structure within OTP (ECC)

                        The table has 16 rows, each of which are also ECC and marked valid by the corresponding valid bit in USB_BOOT_FLAGS (ECC).

                        The entries are either _VALUEs where the 16 bit value is used as is, or _STRDEFs which acts as a pointers to a string value.

                        The value stored in a _STRDEF is two separate bytes: The low seven bits of the first (LSB) byte indicates the number of characters in the string, and the top bit of the first (LSB) byte if set to indicate that each character in the string is two bytes (Unicode) versus one byte if unset. The second (MSB) byte represents the location of the string data, and is encoded as the number of rows from this USB_WHITE_LABEL_ADDR; i.e. the row of the start of the string is USB_WHITE_LABEL_ADDR value + msb_byte.

                        In each case, the corresponding valid bit enables replacing the default value for the corresponding item provided by the boot rom.

                        Note that Unicode _STRDEFs are only supported for USB_DEVICE_PRODUCT_STRDEF, USB_DEVICE_SERIAL_NUMBER_STRDEF and USB_DEVICE_MANUFACTURER_STRDEF. Unicode values will be ignored if specified for other fields, and non-unicode values for these three items will be converted to Unicode characters by setting the upper 8 bits to zero.

                        Note that if the USB_WHITE_LABEL structure or the corresponding strings are not readable by BOOTSEL mode based on OTP permissions, or if alignment requirements are not met, then the corresponding default values are used.

                        The index values indicate where each field is located (row USB_WHITE_LABEL_ADDR value + index):</description>
                    <addressOffset>0xB8</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>USB_WHITE_LABEL_ADDR</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INDEX_USB_DEVICE_VID_VALUE</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_USB_DEVICE_PID_VALUE</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_USB_DEVICE_BCD_DEVICE_VALUE</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_USB_DEVICE_LANG_ID_VALUE</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_USB_DEVICE_MANUFACTURER_STRDEF</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_USB_DEVICE_PRODUCT_STRDEF</name>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_USB_DEVICE_SERIAL_NUMBER_STRDEF</name>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_USB_CONFIG_ATTRIBUTES_MAX_POWER_VALUES</name>
                                    <value>7</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_VOLUME_LABEL_STRDEF</name>
                                    <value>8</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_SCSI_INQUIRY_VENDOR_STRDEF</name>
                                    <value>9</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_SCSI_INQUIRY_PRODUCT_STRDEF</name>
                                    <value>10</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_SCSI_INQUIRY_VERSION_STRDEF</name>
                                    <value>11</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_INDEX_HTM_REDIRECT_URL_STRDEF</name>
                                    <value>12</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_INDEX_HTM_REDIRECT_NAME_STRDEF</name>
                                    <value>13</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_INFO_UF2_TXT_MODEL_STRDEF</name>
                                    <value>14</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_INFO_UF2_TXT_BOARD_ID_STRDEF</name>
                                    <value>15</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>OTPBOOT_SRC</name>
                    <description>OTP start row for the OTP boot image. (ECC)

                        If OTP boot is enabled, the bootrom will load from this location into SRAM and then directly enter the loaded image. Note that the image must be signed if SECURE_BOOT_ENABLE is set. The image itself is assumed to be ECC-protected.

                        This must be an even number. Equivalently, the OTP boot image must start at a word-aligned location in the ECC read data address window.</description>
                    <addressOffset>0xBC</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>OTPBOOT_SRC</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>OTPBOOT_LEN</name>
                    <description>Length in rows of the OTP boot image. (ECC)

                        OTPBOOT_LEN must be even. The total image size must be a multiple of 4 bytes (32 bits).</description>
                    <addressOffset>0xBE</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>OTPBOOT_LEN</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>OTPBOOT_DST0</name>
                    <description>Bits 15:0 of the OTP boot image load destination (and entry point). (ECC)

                        This must be a location in main SRAM (main SRAM is addresses 0x20000000 through 0x20082000) and must be word-aligned.</description>
                    <addressOffset>0xC0</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>OTPBOOT_DST0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>OTPBOOT_DST1</name>
                    <description>Bits 31:16 of the OTP boot image load destination (and entry point). (ECC)

                        This must be a location in main SRAM (main SRAM is addresses 0x20000000 through 0x20082000) and must be word-aligned.</description>
                    <addressOffset>0xC2</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>OTPBOOT_DST1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_0</name>
                    <description>Bits 15:0 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x100</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_1</name>
                    <description>Bits 31:16 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x102</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_2</name>
                    <description>Bits 47:32 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x104</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_3</name>
                    <description>Bits 63:48 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x106</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_4</name>
                    <description>Bits 79:64 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x108</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_5</name>
                    <description>Bits 95:80 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x10A</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_6</name>
                    <description>Bits 111:96 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x10C</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_7</name>
                    <description>Bits 127:112 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x10E</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_8</name>
                    <description>Bits 143:128 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x110</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_8</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_9</name>
                    <description>Bits 159:144 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x112</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_9</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_10</name>
                    <description>Bits 175:160 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x114</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_10</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_11</name>
                    <description>Bits 191:176 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x116</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_11</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_12</name>
                    <description>Bits 207:192 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x118</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_12</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_13</name>
                    <description>Bits 223:208 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x11A</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_13</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_14</name>
                    <description>Bits 239:224 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x11C</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_14</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_15</name>
                    <description>Bits 255:240 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x11E</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_15</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_0</name>
                    <description>Bits 15:0 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x120</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_1</name>
                    <description>Bits 31:16 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x122</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_2</name>
                    <description>Bits 47:32 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x124</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_3</name>
                    <description>Bits 63:48 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x126</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_4</name>
                    <description>Bits 79:64 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x128</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_5</name>
                    <description>Bits 95:80 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x12A</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_6</name>
                    <description>Bits 111:96 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x12C</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_7</name>
                    <description>Bits 127:112 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x12E</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_8</name>
                    <description>Bits 143:128 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x130</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_8</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_9</name>
                    <description>Bits 159:144 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x132</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_9</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_10</name>
                    <description>Bits 175:160 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x134</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_10</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_11</name>
                    <description>Bits 191:176 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x136</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_11</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_12</name>
                    <description>Bits 207:192 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x138</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_12</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_13</name>
                    <description>Bits 223:208 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x13A</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_13</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_14</name>
                    <description>Bits 239:224 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x13C</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_14</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_15</name>
                    <description>Bits 255:240 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x13E</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_15</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_0</name>
                    <description>Bits 15:0 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x140</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_1</name>
                    <description>Bits 31:16 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x142</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_2</name>
                    <description>Bits 47:32 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x144</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_3</name>
                    <description>Bits 63:48 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x146</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_4</name>
                    <description>Bits 79:64 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x148</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_5</name>
                    <description>Bits 95:80 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x14A</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_6</name>
                    <description>Bits 111:96 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x14C</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_7</name>
                    <description>Bits 127:112 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x14E</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_8</name>
                    <description>Bits 143:128 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x150</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_8</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_9</name>
                    <description>Bits 159:144 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x152</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_9</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_10</name>
                    <description>Bits 175:160 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x154</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_10</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_11</name>
                    <description>Bits 191:176 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x156</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_11</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_12</name>
                    <description>Bits 207:192 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x158</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_12</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_13</name>
                    <description>Bits 223:208 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x15A</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_13</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_14</name>
                    <description>Bits 239:224 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x15C</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_14</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_15</name>
                    <description>Bits 255:240 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x15E</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_15</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_0</name>
                    <description>Bits 15:0 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x160</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_1</name>
                    <description>Bits 31:16 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x162</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_2</name>
                    <description>Bits 47:32 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x164</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_3</name>
                    <description>Bits 63:48 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x166</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_4</name>
                    <description>Bits 79:64 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x168</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_5</name>
                    <description>Bits 95:80 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x16A</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_6</name>
                    <description>Bits 111:96 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x16C</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_7</name>
                    <description>Bits 127:112 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x16E</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_8</name>
                    <description>Bits 143:128 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x170</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_8</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_9</name>
                    <description>Bits 159:144 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x172</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_9</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_10</name>
                    <description>Bits 175:160 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x174</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_10</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_11</name>
                    <description>Bits 191:176 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x176</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_11</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_12</name>
                    <description>Bits 207:192 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x178</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_12</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_13</name>
                    <description>Bits 223:208 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x17A</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_13</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_14</name>
                    <description>Bits 239:224 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x17C</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_14</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_15</name>
                    <description>Bits 255:240 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x17E</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_15</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY1_0</name>
                    <description>Bits 15:0 of OTP access key 1 (ECC)</description>
                    <addressOffset>0x1E90</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY1_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY1_1</name>
                    <description>Bits 31:16 of OTP access key 1 (ECC)</description>
                    <addressOffset>0x1E92</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY1_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY1_2</name>
                    <description>Bits 47:32 of OTP access key 1 (ECC)</description>
                    <addressOffset>0x1E94</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY1_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY1_3</name>
                    <description>Bits 63:48 of OTP access key 1 (ECC)</description>
                    <addressOffset>0x1E96</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY1_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY1_4</name>
                    <description>Bits 79:64 of OTP access key 1 (ECC)</description>
                    <addressOffset>0x1E98</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY1_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY1_5</name>
                    <description>Bits 95:80 of OTP access key 1 (ECC)</description>
                    <addressOffset>0x1E9A</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY1_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY1_6</name>
                    <description>Bits 111:96 of OTP access key 1 (ECC)</description>
                    <addressOffset>0x1E9C</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY1_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY1_7</name>
                    <description>Bits 127:112 of OTP access key 1 (ECC)</description>
                    <addressOffset>0x1E9E</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY1_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY2_0</name>
                    <description>Bits 15:0 of OTP access key 2 (ECC)</description>
                    <addressOffset>0x1EA0</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY2_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY2_1</name>
                    <description>Bits 31:16 of OTP access key 2 (ECC)</description>
                    <addressOffset>0x1EA2</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY2_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY2_2</name>
                    <description>Bits 47:32 of OTP access key 2 (ECC)</description>
                    <addressOffset>0x1EA4</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY2_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY2_3</name>
                    <description>Bits 63:48 of OTP access key 2 (ECC)</description>
                    <addressOffset>0x1EA6</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY2_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY2_4</name>
                    <description>Bits 79:64 of OTP access key 2 (ECC)</description>
                    <addressOffset>0x1EA8</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY2_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY2_5</name>
                    <description>Bits 95:80 of OTP access key 2 (ECC)</description>
                    <addressOffset>0x1EAA</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY2_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY2_6</name>
                    <description>Bits 111:96 of OTP access key 2 (ECC)</description>
                    <addressOffset>0x1EAC</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY2_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY2_7</name>
                    <description>Bits 127:112 of OTP access key 2 (ECC)</description>
                    <addressOffset>0x1EAE</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY2_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY3_0</name>
                    <description>Bits 15:0 of OTP access key 3 (ECC)</description>
                    <addressOffset>0x1EB0</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY3_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY3_1</name>
                    <description>Bits 31:16 of OTP access key 3 (ECC)</description>
                    <addressOffset>0x1EB2</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY3_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY3_2</name>
                    <description>Bits 47:32 of OTP access key 3 (ECC)</description>
                    <addressOffset>0x1EB4</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY3_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY3_3</name>
                    <description>Bits 63:48 of OTP access key 3 (ECC)</description>
                    <addressOffset>0x1EB6</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY3_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY3_4</name>
                    <description>Bits 79:64 of OTP access key 3 (ECC)</description>
                    <addressOffset>0x1EB8</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY3_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY3_5</name>
                    <description>Bits 95:80 of OTP access key 3 (ECC)</description>
                    <addressOffset>0x1EBA</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY3_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY3_6</name>
                    <description>Bits 111:96 of OTP access key 3 (ECC)</description>
                    <addressOffset>0x1EBC</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY3_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY3_7</name>
                    <description>Bits 127:112 of OTP access key 3 (ECC)</description>
                    <addressOffset>0x1EBE</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY3_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY4_0</name>
                    <description>Bits 15:0 of OTP access key 4 (ECC)</description>
                    <addressOffset>0x1EC0</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY4_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY4_1</name>
                    <description>Bits 31:16 of OTP access key 4 (ECC)</description>
                    <addressOffset>0x1EC2</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY4_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY4_2</name>
                    <description>Bits 47:32 of OTP access key 4 (ECC)</description>
                    <addressOffset>0x1EC4</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY4_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY4_3</name>
                    <description>Bits 63:48 of OTP access key 4 (ECC)</description>
                    <addressOffset>0x1EC6</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY4_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY4_4</name>
                    <description>Bits 79:64 of OTP access key 4 (ECC)</description>
                    <addressOffset>0x1EC8</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY4_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY4_5</name>
                    <description>Bits 95:80 of OTP access key 4 (ECC)</description>
                    <addressOffset>0x1ECA</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY4_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY4_6</name>
                    <description>Bits 111:96 of OTP access key 4 (ECC)</description>
                    <addressOffset>0x1ECC</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY4_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY4_7</name>
                    <description>Bits 127:112 of OTP access key 4 (ECC)</description>
                    <addressOffset>0x1ECE</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY4_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY5_0</name>
                    <description>Bits 15:0 of OTP access key 5 (ECC)</description>
                    <addressOffset>0x1ED0</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY5_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY5_1</name>
                    <description>Bits 31:16 of OTP access key 5 (ECC)</description>
                    <addressOffset>0x1ED2</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY5_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY5_2</name>
                    <description>Bits 47:32 of OTP access key 5 (ECC)</description>
                    <addressOffset>0x1ED4</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY5_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY5_3</name>
                    <description>Bits 63:48 of OTP access key 5 (ECC)</description>
                    <addressOffset>0x1ED6</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY5_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY5_4</name>
                    <description>Bits 79:64 of OTP access key 5 (ECC)</description>
                    <addressOffset>0x1ED8</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY5_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY5_5</name>
                    <description>Bits 95:80 of OTP access key 5 (ECC)</description>
                    <addressOffset>0x1EDA</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY5_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY5_6</name>
                    <description>Bits 111:96 of OTP access key 5 (ECC)</description>
                    <addressOffset>0x1EDC</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY5_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY5_7</name>
                    <description>Bits 127:112 of OTP access key 5 (ECC)</description>
                    <addressOffset>0x1EDE</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY5_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY6_0</name>
                    <description>Bits 15:0 of OTP access key 6 (ECC)</description>
                    <addressOffset>0x1EE0</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY6_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY6_1</name>
                    <description>Bits 31:16 of OTP access key 6 (ECC)</description>
                    <addressOffset>0x1EE2</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY6_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY6_2</name>
                    <description>Bits 47:32 of OTP access key 6 (ECC)</description>
                    <addressOffset>0x1EE4</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY6_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY6_3</name>
                    <description>Bits 63:48 of OTP access key 6 (ECC)</description>
                    <addressOffset>0x1EE6</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY6_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY6_4</name>
                    <description>Bits 79:64 of OTP access key 6 (ECC)</description>
                    <addressOffset>0x1EE8</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY6_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY6_5</name>
                    <description>Bits 95:80 of OTP access key 6 (ECC)</description>
                    <addressOffset>0x1EEA</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY6_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY6_6</name>
                    <description>Bits 111:96 of OTP access key 6 (ECC)</description>
                    <addressOffset>0x1EEC</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY6_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY6_7</name>
                    <description>Bits 127:112 of OTP access key 6 (ECC)</description>
                    <addressOffset>0x1EEE</addressOffset>
                    <size>0x10</size>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY6_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>OTP_DATA_RAW</name>
            <description>Predefined OTP data layout for RP2350</description>
            <baseAddress>0x40134000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x4000</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>CHIPID0</name>
                    <description>Bits 15:0 of public device ID. (ECC)

                        The CHIPID0..3 rows contain a 64-bit random identifier for this chip, which can be read from the USB bootloader PICOBOOT interface or from the get_sys_info ROM API.

                        The number of random bits makes the occurrence of twins exceedingly unlikely: for example, a fleet of a hundred million devices has a 99.97% probability of no twinned IDs. This is estimated to be lower than the occurrence of process errors in the assignment of sequential random IDs, and for practical purposes CHIPID may be treated as unique.</description>
                    <addressOffset>0x0</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CHIPID0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CHIPID1</name>
                    <description>Bits 31:16 of public device ID (ECC)</description>
                    <addressOffset>0x4</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CHIPID1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CHIPID2</name>
                    <description>Bits 47:32 of public device ID (ECC)</description>
                    <addressOffset>0x8</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CHIPID2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CHIPID3</name>
                    <description>Bits 63:48 of public device ID (ECC)</description>
                    <addressOffset>0xC</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CHIPID3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RANDID0</name>
                    <description>Bits 15:0 of private per-device random number (ECC)

                        The RANDID0..7 rows form a 128-bit random number generated during device test.

                        This ID is not exposed through the USB PICOBOOT GET_INFO command or the ROM `get_sys_info()` API. However note that the USB PICOBOOT OTP access point can read the entirety of page 0, so this value is not meaningfully private unless the USB PICOBOOT interface is disabled via the DISABLE_BOOTSEL_USB_PICOBOOT_IFC flag in BOOT_FLAGS0.</description>
                    <addressOffset>0x10</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>RANDID0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RANDID1</name>
                    <description>Bits 31:16 of private per-device random number (ECC)</description>
                    <addressOffset>0x14</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>RANDID1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RANDID2</name>
                    <description>Bits 47:32 of private per-device random number (ECC)</description>
                    <addressOffset>0x18</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>RANDID2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RANDID3</name>
                    <description>Bits 63:48 of private per-device random number (ECC)</description>
                    <addressOffset>0x1C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>RANDID3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RANDID4</name>
                    <description>Bits 79:64 of private per-device random number (ECC)</description>
                    <addressOffset>0x20</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>RANDID4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RANDID5</name>
                    <description>Bits 95:80 of private per-device random number (ECC)</description>
                    <addressOffset>0x24</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>RANDID5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RANDID6</name>
                    <description>Bits 111:96 of private per-device random number (ECC)</description>
                    <addressOffset>0x28</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>RANDID6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>RANDID7</name>
                    <description>Bits 127:112 of private per-device random number (ECC)</description>
                    <addressOffset>0x2C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>RANDID7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>ROSC_CALIB</name>
                    <description>Ring oscillator frequency in kHz, measured during manufacturing (ECC)

                        This is measured at 1.1 V, at room temperature, with the ROSC configuration registers in their reset state.</description>
                    <addressOffset>0x40</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>ROSC_CALIB</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>LPOSC_CALIB</name>
                    <description>Low-power oscillator frequency in Hz, measured during manufacturing (ECC)

                        This is measured at 1.1V, at room temperature, with the LPOSC trim register in its reset state.</description>
                    <addressOffset>0x44</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>LPOSC_CALIB</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>NUM_GPIOS</name>
                    <description>The number of main user GPIOs (bank 0). Should read 48 in the QFN80 package, and 30 in the QFN60 package. (ECC)</description>
                    <addressOffset>0x60</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>NUM_GPIOS</name>
                            <bitRange>[7:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INFO_CRC0</name>
                    <description>Lower 16 bits of CRC32 of OTP addresses 0x00 through 0x6b (polynomial 0x4c11db7, input reflected, output reflected, seed all-ones, final XOR all-ones) (ECC)</description>
                    <addressOffset>0xD8</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>INFO_CRC0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>INFO_CRC1</name>
                    <description>Upper 16 bits of CRC32 of OTP addresses 0x00 through 0x6b (ECC)</description>
                    <addressOffset>0xDC</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>INFO_CRC1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRIT0</name>
                    <description>Page 0 critical boot flags (RBIT-8)</description>
                    <addressOffset>0xE0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RISCV_DISABLE</name>
                            <description>Permanently disable RISC-V processors (Hazard3)</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ARM_DISABLE</name>
                            <description>Permanently disable ARM processors (Cortex-M33)</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRIT0_R1</name>
                    <description>Redundant copy of CRIT0</description>
                    <addressOffset>0xE4</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CRIT0_R1</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRIT0_R2</name>
                    <description>Redundant copy of CRIT0</description>
                    <addressOffset>0xE8</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CRIT0_R2</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRIT0_R3</name>
                    <description>Redundant copy of CRIT0</description>
                    <addressOffset>0xEC</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CRIT0_R3</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRIT0_R4</name>
                    <description>Redundant copy of CRIT0</description>
                    <addressOffset>0xF0</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CRIT0_R4</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRIT0_R5</name>
                    <description>Redundant copy of CRIT0</description>
                    <addressOffset>0xF4</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CRIT0_R5</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRIT0_R6</name>
                    <description>Redundant copy of CRIT0</description>
                    <addressOffset>0xF8</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CRIT0_R6</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRIT0_R7</name>
                    <description>Redundant copy of CRIT0</description>
                    <addressOffset>0xFC</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CRIT0_R7</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRIT1</name>
                    <description>Page 1 critical boot flags (RBIT-8)</description>
                    <addressOffset>0x100</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>GLITCH_DETECTOR_SENS</name>
                            <description>Increase the sensitivity of the glitch detectors from their default.</description>
                            <bitRange>[6:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>GLITCH_DETECTOR_ENABLE</name>
                            <description>Arm the glitch detectors to reset the system if an abnormal clock/power event is observed.</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>BOOT_ARCH</name>
                            <description>Set the default boot architecture, 0=ARM 1=RISC-V. Ignored if ARM_DISABLE, RISCV_DISABLE or SECURE_BOOT_ENABLE is set.</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DEBUG_DISABLE</name>
                            <description>Disable all debug access</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SECURE_DEBUG_DISABLE</name>
                            <description>Disable Secure debug access</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SECURE_BOOT_ENABLE</name>
                            <description>Enable boot signature enforcement, and permanently disable the RISC-V cores.</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRIT1_R1</name>
                    <description>Redundant copy of CRIT1</description>
                    <addressOffset>0x104</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CRIT1_R1</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRIT1_R2</name>
                    <description>Redundant copy of CRIT1</description>
                    <addressOffset>0x108</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CRIT1_R2</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRIT1_R3</name>
                    <description>Redundant copy of CRIT1</description>
                    <addressOffset>0x10C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CRIT1_R3</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRIT1_R4</name>
                    <description>Redundant copy of CRIT1</description>
                    <addressOffset>0x110</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CRIT1_R4</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRIT1_R5</name>
                    <description>Redundant copy of CRIT1</description>
                    <addressOffset>0x114</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CRIT1_R5</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRIT1_R6</name>
                    <description>Redundant copy of CRIT1</description>
                    <addressOffset>0x118</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CRIT1_R6</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>CRIT1_R7</name>
                    <description>Redundant copy of CRIT1</description>
                    <addressOffset>0x11C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>CRIT1_R7</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOT_FLAGS0</name>
                    <description>Disable/Enable boot paths/features in the RP2350 mask ROM. Disables always supersede enables. Enables are provided where there are other configurations in OTP that must be valid. (RBIT-3)</description>
                    <addressOffset>0x120</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DISABLE_SRAM_WINDOW_BOOT</name>
                            <bitRange>[21:21]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DISABLE_XIP_ACCESS_ON_SRAM_ENTRY</name>
                            <description>Disable all access to XIP after entering an SRAM binary.

                                Note that this will cause bootrom APIs that access XIP to fail, including APIs that interact with the partition table.</description>
                            <bitRange>[20:20]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DISABLE_BOOTSEL_UART_BOOT</name>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DISABLE_BOOTSEL_USB_PICOBOOT_IFC</name>
                            <bitRange>[18:18]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DISABLE_BOOTSEL_USB_MSD_IFC</name>
                            <bitRange>[17:17]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DISABLE_WATCHDOG_SCRATCH</name>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DISABLE_POWER_SCRATCH</name>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ENABLE_OTP_BOOT</name>
                            <description>Enable OTP boot. A number of OTP rows specified by OTPBOOT_LEN will be loaded, starting from OTPBOOT_SRC, into the SRAM location specified by OTPBOOT_DST1 and OTPBOOT_DST0.

                                The loaded program image is stored with ECC, 16 bits per row, and must contain a valid IMAGE_DEF. Do not set this bit without first programming an image into OTP and configuring OTPBOOT_LEN, OTPBOOT_SRC, OTPBOOT_DST0 and OTPBOOT_DST1.

                                Note that OTPBOOT_LEN and OTPBOOT_SRC must be even numbers of OTP rows. Equivalently, the image must be a multiple of 32 bits in size, and must start at a 32-bit-aligned address in the ECC read data address window.</description>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DISABLE_OTP_BOOT</name>
                            <description>Takes precedence over ENABLE_OTP_BOOT.</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DISABLE_FLASH_BOOT</name>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ROLLBACK_REQUIRED</name>
                            <description>Require binaries to have a rollback version. Set automatically the first time a binary with a rollback version is booted.</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>HASHED_PARTITION_TABLE</name>
                            <description>Require a partition table to be hashed (if not signed)</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SECURE_PARTITION_TABLE</name>
                            <description>Require a partition table to be signed</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DISABLE_AUTO_SWITCH_ARCH</name>
                            <description>Disable auto-switch of CPU architecture on boot when the (only) binary to be booted is for the other Arm/RISC-V architecture and both architectures are enabled</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>SINGLE_FLASH_BINARY</name>
                            <description>Restrict flash boot path to use of a single binary at the start of flash</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>OVERRIDE_FLASH_PARTITION_SLOT_SIZE</name>
                            <description>Override the limit for default flash metadata scanning.

                                The value is specified in FLASH_PARTITION_SLOT_SIZE. Make sure FLASH_PARTITION_SLOT_SIZE is valid before setting this bit</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FLASH_DEVINFO_ENABLE</name>
                            <description>Mark FLASH_DEVINFO as containing valid, ECC'd data which describes external flash devices.</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FAST_SIGCHECK_ROSC_DIV</name>
                            <description>Enable quartering of ROSC divisor during signature check, to reduce secure boot time</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FLASH_IO_VOLTAGE_1V8</name>
                            <description>If 1, configure the QSPI pads for 1.8 V operation when accessing flash for the first time from the bootrom, using the VOLTAGE_SELECT register for the QSPI pads bank. This slightly improves the input timing of the pads at low voltages, but does not affect their output characteristics.

                                If 0, leave VOLTAGE_SELECT in its reset state (suitable for operation at and above 2.5 V)</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ENABLE_BOOTSEL_NON_DEFAULT_PLL_XOSC_CFG</name>
                            <description>Enable loading of the non-default XOSC and PLL configuration before entering BOOTSEL mode.

                                Ensure that BOOTSEL_XOSC_CFG and BOOTSEL_PLL_CFG are correctly programmed before setting this bit.

                                If this bit is set, user software may use the contents of BOOTSEL_PLL_CFG to calculated the expected XOSC frequency based on the fixed USB boot frequency of 48 MHz.</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ENABLE_BOOTSEL_LED</name>
                            <description>Enable bootloader activity LED. If set, bootsel_led_cfg is assumed to be valid</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DISABLE_BOOTSEL_EXEC2</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOT_FLAGS0_R1</name>
                    <description>Redundant copy of BOOT_FLAGS0</description>
                    <addressOffset>0x124</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOT_FLAGS0_R1</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOT_FLAGS0_R2</name>
                    <description>Redundant copy of BOOT_FLAGS0</description>
                    <addressOffset>0x128</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOT_FLAGS0_R2</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOT_FLAGS1</name>
                    <description>Disable/Enable boot paths/features in the RP2350 mask ROM. Disables always supersede enables. Enables are provided where there are other configurations in OTP that must be valid. (RBIT-3)</description>
                    <addressOffset>0x12C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DOUBLE_TAP</name>
                            <description>Enable entering BOOTSEL mode via double-tap of the RUN/RSTn pin. Adds a significant delay to boot time, as configured by DOUBLE_TAP_DELAY.

                                This functions by waiting at startup (i.e. following a reset) to see if a second reset is applied soon afterward. The second reset is detected by the bootrom with help of the POWMAN_CHIP_RESET_DOUBLE_TAP flag, which is not reset by the external reset pin, and the bootrom enters BOOTSEL mode (NSBOOT) to await further instruction over USB or UART.</description>
                            <bitRange>[19:19]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>DOUBLE_TAP_DELAY</name>
                            <description>Adjust how long to wait for a second reset when double tap BOOTSEL mode is enabled via DOUBLE_TAP. The minimum is 50 milliseconds, and each unit of this field adds an additional 50 milliseconds.

                                For example, settings this field to its maximum value of 7 will cause the chip to wait for 400 milliseconds at boot to check for a second reset which requests entry to BOOTSEL mode.

                                200 milliseconds (DOUBLE_TAP_DELAY=3) is a good intermediate value.</description>
                            <bitRange>[18:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_INVALID</name>
                            <description>Mark a boot key as invalid, or prevent it from ever becoming valid. The bootrom will ignore any boot key marked as invalid during secure boot signature checks.

                                Each bit in this field corresponds to one of the four 256-bit boot key hashes that may be stored in page 2 of the OTP.

                                When provisioning boot keys, it's recommended to mark any boot key slots you don't intend to use as KEY_INVALID, so that spurious keys can not be installed at a later time.</description>
                            <bitRange>[11:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_VALID</name>
                            <description>Mark each of the possible boot keys as valid. The bootrom will check signatures against all valid boot keys, and ignore invalid boot keys.

                                Each bit in this field corresponds to one of the four 256-bit boot key hashes that may be stored in page 2 of the OTP.

                                A KEY_VALID bit is ignored if the corresponding KEY_INVALID bit is set. Boot keys are considered valid only when KEY_VALID is set and KEY_INVALID is clear.

                                Do not mark a boot key as KEY_VALID if it does not contain a valid SHA-256 hash of your secp256k1 public key. Verify keys after programming, before setting the KEY_VALID bits -- a boot key with uncorrectable ECC faults will render your device unbootable if secure boot is enabled.

                                Do not enable secure boot without first installing a valid key. This will render your device unbootable.</description>
                            <bitRange>[3:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOT_FLAGS1_R1</name>
                    <description>Redundant copy of BOOT_FLAGS1</description>
                    <addressOffset>0x130</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOT_FLAGS1_R1</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOT_FLAGS1_R2</name>
                    <description>Redundant copy of BOOT_FLAGS1</description>
                    <addressOffset>0x134</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOT_FLAGS1_R2</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DEFAULT_BOOT_VERSION0</name>
                    <description>Default boot version thermometer counter, bits 23:0 (RBIT-3)</description>
                    <addressOffset>0x138</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>DEFAULT_BOOT_VERSION0</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DEFAULT_BOOT_VERSION0_R1</name>
                    <description>Redundant copy of DEFAULT_BOOT_VERSION0</description>
                    <addressOffset>0x13C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>DEFAULT_BOOT_VERSION0_R1</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DEFAULT_BOOT_VERSION0_R2</name>
                    <description>Redundant copy of DEFAULT_BOOT_VERSION0</description>
                    <addressOffset>0x140</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>DEFAULT_BOOT_VERSION0_R2</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DEFAULT_BOOT_VERSION1</name>
                    <description>Default boot version thermometer counter, bits 47:24 (RBIT-3)</description>
                    <addressOffset>0x144</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>DEFAULT_BOOT_VERSION1</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DEFAULT_BOOT_VERSION1_R1</name>
                    <description>Redundant copy of DEFAULT_BOOT_VERSION1</description>
                    <addressOffset>0x148</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>DEFAULT_BOOT_VERSION1_R1</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>DEFAULT_BOOT_VERSION1_R2</name>
                    <description>Redundant copy of DEFAULT_BOOT_VERSION1</description>
                    <addressOffset>0x14C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>DEFAULT_BOOT_VERSION1_R2</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FLASH_DEVINFO</name>
                    <description>Stores information about external flash device(s). (ECC)

                        Assumed to be valid if BOOT_FLAGS0_FLASH_DEVINFO_ENABLE is set.</description>
                    <addressOffset>0x150</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>CS1_SIZE</name>
                            <description>The size of the flash/PSRAM device on chip select 1 (addressable at 0x11000000 through 0x11ffffff).

                                A value of zero is decoded as a size of zero (no device). Nonzero values are decoded as 4kiB &lt;&lt; CS1_SIZE. For example, four megabytes is encoded with a CS1_SIZE value of 10, and 16 megabytes is encoded with a CS1_SIZE value of 12.

                                When BOOT_FLAGS0_FLASH_DEVINFO_ENABLE is not set, a default of zero is used.</description>
                            <bitRange>[15:12]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NONE</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8K</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>16K</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>32K</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>64k</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>128K</name>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>256K</name>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>512K</name>
                                    <value>7</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>1M</name>
                                    <value>8</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>2M</name>
                                    <value>9</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4M</name>
                                    <value>10</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8M</name>
                                    <value>11</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>16M</name>
                                    <value>12</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>CS0_SIZE</name>
                            <description>The size of the flash/PSRAM device on chip select 0 (addressable at 0x10000000 through 0x10ffffff).

                                A value of zero is decoded as a size of zero (no device). Nonzero values are decoded as 4kiB &lt;&lt; CS0_SIZE. For example, four megabytes is encoded with a CS0_SIZE value of 10, and 16 megabytes is encoded with a CS0_SIZE value of 12.

                                When BOOT_FLAGS0_FLASH_DEVINFO_ENABLE is not set, a default of 12 (16 MiB) is used.</description>
                            <bitRange>[11:8]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>NONE</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8K</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>16K</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>32K</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>64k</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>128K</name>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>256K</name>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>512K</name>
                                    <value>7</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>1M</name>
                                    <value>8</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>2M</name>
                                    <value>9</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>4M</name>
                                    <value>10</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>8M</name>
                                    <value>11</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>16M</name>
                                    <value>12</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>D8H_ERASE_SUPPORTED</name>
                            <description>If true, all attached devices are assumed to support (or ignore, in the case of PSRAM) a block erase command with a command prefix of D8h, an erase size of 64 kiB, and a 24-bit address. Almost all 25-series flash devices support this command.

                                If set, the bootrom will use the D8h erase command where it is able, to accelerate bulk erase operations. This makes flash programming faster.

                                When BOOT_FLAGS0_FLASH_DEVINFO_ENABLE is not set, this field defaults to false.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>CS1_GPIO</name>
                            <description>Indicate a GPIO number to be used for the secondary flash chip select (CS1), which selects the external QSPI device mapped at system addresses 0x11000000 through 0x11ffffff. There is no such configuration for CS0, as the primary chip select has a dedicated pin.

                                On RP2350 the permissible GPIO numbers are 0, 8, 19 and 47.

                                Ignored if CS1_size is zero. If CS1_SIZE is nonzero, the bootrom will automatically configure this GPIO as a second chip select upon entering the flash boot path, or entering any other path that may use the QSPI flash interface, such as BOOTSEL mode (nsboot).</description>
                            <bitRange>[5:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>FLASH_PARTITION_SLOT_SIZE</name>
                    <description>Gap between partition table slot 0 and slot 1 at the start of flash (the default size is 4096 bytes) (ECC) Enabled by the OVERRIDE_FLASH_PARTITION_SLOT_SIZE bit in BOOT_FLAGS, the size is 4096 * (value + 1)</description>
                    <addressOffset>0x154</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>FLASH_PARTITION_SLOT_SIZE</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTSEL_LED_CFG</name>
                    <description>Pin configuration for LED status, used by USB bootloader. (ECC)
                        Must be valid if BOOT_FLAGS0_ENABLE_BOOTSEL_LED is set.</description>
                    <addressOffset>0x158</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ACTIVELOW</name>
                            <description>LED is active-low. (Default: active-high.)</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>PIN</name>
                            <description>GPIO index to use for bootloader activity LED.</description>
                            <bitRange>[5:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTSEL_PLL_CFG</name>
                    <description>Optional PLL configuration for BOOTSEL mode. (ECC)

                        This should be configured to produce an exact 48 MHz based on the crystal oscillator frequency. User mode software may also use this value to calculate the expected crystal frequency based on an assumed 48 MHz PLL output.

                        If no configuration is given, the crystal is assumed to be 12 MHz.

                        The PLL frequency can be calculated as:

                        PLL out = (XOSC frequency / (REFDIV+1)) x FBDIV / (POSTDIV1 x POSTDIV2)

                        Conversely the crystal frequency can be calculated as:

                        XOSC frequency = 48 MHz x (REFDIV+1) x (POSTDIV1 x POSTDIV2) / FBDIV

                        (Note the  +1 on REFDIV is because the value stored in this OTP location is the actual divisor value minus one.)

                        Used if and only if ENABLE_BOOTSEL_NON_DEFAULT_PLL_XOSC_CFG is set in BOOT_FLAGS0. That bit should be set only after this row and BOOTSEL_XOSC_CFG are both correctly programmed.</description>
                    <addressOffset>0x15C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>REFDIV</name>
                            <description>PLL reference divisor, minus one.

                                Programming a value of 0 means a reference divisor of 1. Programming a value of 1 means a reference divisor of 2 (for exceptionally fast XIN inputs)</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>POSTDIV2</name>
                            <description>PLL post-divide 2 divisor, in the range 1..7 inclusive.</description>
                            <bitRange>[14:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>POSTDIV1</name>
                            <description>PLL post-divide 1 divisor, in the range 1..7 inclusive.</description>
                            <bitRange>[11:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FBDIV</name>
                            <description>PLL feedback divisor, in the range 16..320 inclusive.</description>
                            <bitRange>[8:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTSEL_XOSC_CFG</name>
                    <description>Non-default crystal oscillator configuration for the USB bootloader. (ECC)

                        These values may also be used by user code configuring the crystal oscillator.

                        Used if and only if ENABLE_BOOTSEL_NON_DEFAULT_PLL_XOSC_CFG is set in BOOT_FLAGS0. That bit should be set only after this row and BOOTSEL_PLL_CFG are both correctly programmed.</description>
                    <addressOffset>0x160</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>RANGE</name>
                            <description>Value of the XOSC_CTRL_FREQ_RANGE register.</description>
                            <bitRange>[15:14]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>1_15MHZ</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>10_30MHZ</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>25_60MHZ</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>40_100MHZ</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>STARTUP</name>
                            <description>Value of the XOSC_STARTUP register</description>
                            <bitRange>[13:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>USB_BOOT_FLAGS</name>
                    <description>USB boot specific feature flags (RBIT-3)</description>
                    <addressOffset>0x164</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>DP_DM_SWAP</name>
                            <description>Swap DM/DP during USB boot, to support board layouts with mirrored USB routing (deliberate or accidental).</description>
                            <bitRange>[23:23]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WHITE_LABEL_ADDR_VALID</name>
                            <description>valid flag for INFO_UF2_TXT_BOARD_ID_STRDEF entry of the USB_WHITE_LABEL struct (index 15)</description>
                            <bitRange>[22:22]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WL_INFO_UF2_TXT_BOARD_ID_STRDEF_VALID</name>
                            <description>valid flag for the USB_WHITE_LABEL_ADDR field</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WL_INFO_UF2_TXT_MODEL_STRDEF_VALID</name>
                            <description>valid flag for INFO_UF2_TXT_MODEL_STRDEF entry of the USB_WHITE_LABEL struct (index 14)</description>
                            <bitRange>[14:14]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WL_INDEX_HTM_REDIRECT_NAME_STRDEF_VALID</name>
                            <description>valid flag for INDEX_HTM_REDIRECT_NAME_STRDEF entry of the USB_WHITE_LABEL struct (index 13)</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WL_INDEX_HTM_REDIRECT_URL_STRDEF_VALID</name>
                            <description>valid flag for INDEX_HTM_REDIRECT_URL_STRDEF entry of the USB_WHITE_LABEL struct (index 12)</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WL_SCSI_INQUIRY_VERSION_STRDEF_VALID</name>
                            <description>valid flag for SCSI_INQUIRY_VERSION_STRDEF entry of the USB_WHITE_LABEL struct (index 11)</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WL_SCSI_INQUIRY_PRODUCT_STRDEF_VALID</name>
                            <description>valid flag for SCSI_INQUIRY_PRODUCT_STRDEF entry of the USB_WHITE_LABEL struct (index 10)</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WL_SCSI_INQUIRY_VENDOR_STRDEF_VALID</name>
                            <description>valid flag for SCSI_INQUIRY_VENDOR_STRDEF entry of the USB_WHITE_LABEL struct (index 9)</description>
                            <bitRange>[9:9]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WL_VOLUME_LABEL_STRDEF_VALID</name>
                            <description>valid flag for VOLUME_LABEL_STRDEF entry of the USB_WHITE_LABEL struct (index 8)</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WL_USB_CONFIG_ATTRIBUTES_MAX_POWER_VALUES_VALID</name>
                            <description>valid flag for USB_CONFIG_ATTRIBUTES_MAX_POWER_VALUES entry of the USB_WHITE_LABEL struct (index 7)</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WL_USB_DEVICE_SERIAL_NUMBER_STRDEF_VALID</name>
                            <description>valid flag for USB_DEVICE_SERIAL_NUMBER_STRDEF entry of the USB_WHITE_LABEL struct (index 6)</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WL_USB_DEVICE_PRODUCT_STRDEF_VALID</name>
                            <description>valid flag for USB_DEVICE_PRODUCT_STRDEF entry of the USB_WHITE_LABEL struct (index 5)</description>
                            <bitRange>[5:5]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WL_USB_DEVICE_MANUFACTURER_STRDEF_VALID</name>
                            <description>valid flag for USB_DEVICE_MANUFACTURER_STRDEF entry of the USB_WHITE_LABEL struct (index 4)</description>
                            <bitRange>[4:4]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WL_USB_DEVICE_LANG_ID_VALUE_VALID</name>
                            <description>valid flag for USB_DEVICE_LANG_ID_VALUE entry of the USB_WHITE_LABEL struct (index 3)</description>
                            <bitRange>[3:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WL_USB_DEVICE_SERIAL_NUMBER_VALUE_VALID</name>
                            <description>valid flag for USB_DEVICE_BCD_DEVICEVALUE entry of the USB_WHITE_LABEL struct (index 2)</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WL_USB_DEVICE_PID_VALUE_VALID</name>
                            <description>valid flag for USB_DEVICE_PID_VALUE entry of the USB_WHITE_LABEL struct (index 1)</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>WL_USB_DEVICE_VID_VALUE_VALID</name>
                            <description>valid flag for USB_DEVICE_VID_VALUE entry of the USB_WHITE_LABEL struct (index 0)</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>USB_BOOT_FLAGS_R1</name>
                    <description>Redundant copy of USB_BOOT_FLAGS</description>
                    <addressOffset>0x168</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>USB_BOOT_FLAGS_R1</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>USB_BOOT_FLAGS_R2</name>
                    <description>Redundant copy of USB_BOOT_FLAGS</description>
                    <addressOffset>0x16C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>USB_BOOT_FLAGS_R2</name>
                            <bitRange>[23:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>USB_WHITE_LABEL_ADDR</name>
                    <description>Row index of the USB_WHITE_LABEL structure within OTP (ECC)

                        The table has 16 rows, each of which are also ECC and marked valid by the corresponding valid bit in USB_BOOT_FLAGS (ECC).

                        The entries are either _VALUEs where the 16 bit value is used as is, or _STRDEFs which acts as a pointers to a string value.

                        The value stored in a _STRDEF is two separate bytes: The low seven bits of the first (LSB) byte indicates the number of characters in the string, and the top bit of the first (LSB) byte if set to indicate that each character in the string is two bytes (Unicode) versus one byte if unset. The second (MSB) byte represents the location of the string data, and is encoded as the number of rows from this USB_WHITE_LABEL_ADDR; i.e. the row of the start of the string is USB_WHITE_LABEL_ADDR value + msb_byte.

                        In each case, the corresponding valid bit enables replacing the default value for the corresponding item provided by the boot rom.

                        Note that Unicode _STRDEFs are only supported for USB_DEVICE_PRODUCT_STRDEF, USB_DEVICE_SERIAL_NUMBER_STRDEF and USB_DEVICE_MANUFACTURER_STRDEF. Unicode values will be ignored if specified for other fields, and non-unicode values for these three items will be converted to Unicode characters by setting the upper 8 bits to zero.

                        Note that if the USB_WHITE_LABEL structure or the corresponding strings are not readable by BOOTSEL mode based on OTP permissions, or if alignment requirements are not met, then the corresponding default values are used.

                        The index values indicate where each field is located (row USB_WHITE_LABEL_ADDR value + index):</description>
                    <addressOffset>0x170</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>USB_WHITE_LABEL_ADDR</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>INDEX_USB_DEVICE_VID_VALUE</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_USB_DEVICE_PID_VALUE</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_USB_DEVICE_BCD_DEVICE_VALUE</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_USB_DEVICE_LANG_ID_VALUE</name>
                                    <value>3</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_USB_DEVICE_MANUFACTURER_STRDEF</name>
                                    <value>4</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_USB_DEVICE_PRODUCT_STRDEF</name>
                                    <value>5</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_USB_DEVICE_SERIAL_NUMBER_STRDEF</name>
                                    <value>6</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_USB_CONFIG_ATTRIBUTES_MAX_POWER_VALUES</name>
                                    <value>7</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_VOLUME_LABEL_STRDEF</name>
                                    <value>8</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_SCSI_INQUIRY_VENDOR_STRDEF</name>
                                    <value>9</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_SCSI_INQUIRY_PRODUCT_STRDEF</name>
                                    <value>10</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_SCSI_INQUIRY_VERSION_STRDEF</name>
                                    <value>11</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_INDEX_HTM_REDIRECT_URL_STRDEF</name>
                                    <value>12</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_INDEX_HTM_REDIRECT_NAME_STRDEF</name>
                                    <value>13</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_INFO_UF2_TXT_MODEL_STRDEF</name>
                                    <value>14</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>INDEX_INFO_UF2_TXT_BOARD_ID_STRDEF</name>
                                    <value>15</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>OTPBOOT_SRC</name>
                    <description>OTP start row for the OTP boot image. (ECC)

                        If OTP boot is enabled, the bootrom will load from this location into SRAM and then directly enter the loaded image. Note that the image must be signed if SECURE_BOOT_ENABLE is set. The image itself is assumed to be ECC-protected.

                        This must be an even number. Equivalently, the OTP boot image must start at a word-aligned location in the ECC read data address window.</description>
                    <addressOffset>0x178</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>OTPBOOT_SRC</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>OTPBOOT_LEN</name>
                    <description>Length in rows of the OTP boot image. (ECC)

                        OTPBOOT_LEN must be even. The total image size must be a multiple of 4 bytes (32 bits).</description>
                    <addressOffset>0x17C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>OTPBOOT_LEN</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>OTPBOOT_DST0</name>
                    <description>Bits 15:0 of the OTP boot image load destination (and entry point). (ECC)

                        This must be a location in main SRAM (main SRAM is addresses 0x20000000 through 0x20082000) and must be word-aligned.</description>
                    <addressOffset>0x180</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>OTPBOOT_DST0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>OTPBOOT_DST1</name>
                    <description>Bits 31:16 of the OTP boot image load destination (and entry point). (ECC)

                        This must be a location in main SRAM (main SRAM is addresses 0x20000000 through 0x20082000) and must be word-aligned.</description>
                    <addressOffset>0x184</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>OTPBOOT_DST1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_0</name>
                    <description>Bits 15:0 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x200</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_1</name>
                    <description>Bits 31:16 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x204</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_2</name>
                    <description>Bits 47:32 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x208</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_3</name>
                    <description>Bits 63:48 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x20C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_4</name>
                    <description>Bits 79:64 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x210</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_5</name>
                    <description>Bits 95:80 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x214</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_6</name>
                    <description>Bits 111:96 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x218</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_7</name>
                    <description>Bits 127:112 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x21C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_8</name>
                    <description>Bits 143:128 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x220</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_8</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_9</name>
                    <description>Bits 159:144 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x224</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_9</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_10</name>
                    <description>Bits 175:160 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x228</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_10</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_11</name>
                    <description>Bits 191:176 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x22C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_11</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_12</name>
                    <description>Bits 207:192 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x230</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_12</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_13</name>
                    <description>Bits 223:208 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x234</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_13</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_14</name>
                    <description>Bits 239:224 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x238</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_14</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY0_15</name>
                    <description>Bits 255:240 of SHA-256 hash of boot key 0 (ECC)</description>
                    <addressOffset>0x23C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY0_15</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_0</name>
                    <description>Bits 15:0 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x240</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_1</name>
                    <description>Bits 31:16 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x244</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_2</name>
                    <description>Bits 47:32 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x248</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_3</name>
                    <description>Bits 63:48 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x24C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_4</name>
                    <description>Bits 79:64 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x250</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_5</name>
                    <description>Bits 95:80 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x254</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_6</name>
                    <description>Bits 111:96 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x258</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_7</name>
                    <description>Bits 127:112 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x25C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_8</name>
                    <description>Bits 143:128 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x260</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_8</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_9</name>
                    <description>Bits 159:144 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x264</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_9</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_10</name>
                    <description>Bits 175:160 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x268</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_10</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_11</name>
                    <description>Bits 191:176 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x26C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_11</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_12</name>
                    <description>Bits 207:192 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x270</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_12</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_13</name>
                    <description>Bits 223:208 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x274</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_13</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_14</name>
                    <description>Bits 239:224 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x278</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_14</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY1_15</name>
                    <description>Bits 255:240 of SHA-256 hash of boot key 1 (ECC)</description>
                    <addressOffset>0x27C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY1_15</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_0</name>
                    <description>Bits 15:0 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x280</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_1</name>
                    <description>Bits 31:16 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x284</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_2</name>
                    <description>Bits 47:32 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x288</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_3</name>
                    <description>Bits 63:48 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x28C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_4</name>
                    <description>Bits 79:64 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x290</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_5</name>
                    <description>Bits 95:80 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x294</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_6</name>
                    <description>Bits 111:96 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x298</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_7</name>
                    <description>Bits 127:112 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x29C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_8</name>
                    <description>Bits 143:128 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x2A0</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_8</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_9</name>
                    <description>Bits 159:144 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x2A4</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_9</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_10</name>
                    <description>Bits 175:160 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x2A8</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_10</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_11</name>
                    <description>Bits 191:176 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x2AC</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_11</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_12</name>
                    <description>Bits 207:192 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x2B0</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_12</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_13</name>
                    <description>Bits 223:208 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x2B4</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_13</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_14</name>
                    <description>Bits 239:224 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x2B8</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_14</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY2_15</name>
                    <description>Bits 255:240 of SHA-256 hash of boot key 2 (ECC)</description>
                    <addressOffset>0x2BC</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY2_15</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_0</name>
                    <description>Bits 15:0 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x2C0</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_1</name>
                    <description>Bits 31:16 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x2C4</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_2</name>
                    <description>Bits 47:32 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x2C8</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_3</name>
                    <description>Bits 63:48 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x2CC</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_4</name>
                    <description>Bits 79:64 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x2D0</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_5</name>
                    <description>Bits 95:80 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x2D4</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_6</name>
                    <description>Bits 111:96 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x2D8</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_7</name>
                    <description>Bits 127:112 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x2DC</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_8</name>
                    <description>Bits 143:128 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x2E0</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_8</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_9</name>
                    <description>Bits 159:144 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x2E4</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_9</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_10</name>
                    <description>Bits 175:160 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x2E8</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_10</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_11</name>
                    <description>Bits 191:176 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x2EC</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_11</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_12</name>
                    <description>Bits 207:192 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x2F0</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_12</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_13</name>
                    <description>Bits 223:208 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x2F4</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_13</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_14</name>
                    <description>Bits 239:224 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x2F8</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_14</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>BOOTKEY3_15</name>
                    <description>Bits 255:240 of SHA-256 hash of boot key 3 (ECC)</description>
                    <addressOffset>0x2FC</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>BOOTKEY3_15</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY1_0</name>
                    <description>Bits 15:0 of OTP access key 1 (ECC)</description>
                    <addressOffset>0x3D20</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY1_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY1_1</name>
                    <description>Bits 31:16 of OTP access key 1 (ECC)</description>
                    <addressOffset>0x3D24</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY1_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY1_2</name>
                    <description>Bits 47:32 of OTP access key 1 (ECC)</description>
                    <addressOffset>0x3D28</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY1_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY1_3</name>
                    <description>Bits 63:48 of OTP access key 1 (ECC)</description>
                    <addressOffset>0x3D2C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY1_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY1_4</name>
                    <description>Bits 79:64 of OTP access key 1 (ECC)</description>
                    <addressOffset>0x3D30</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY1_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY1_5</name>
                    <description>Bits 95:80 of OTP access key 1 (ECC)</description>
                    <addressOffset>0x3D34</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY1_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY1_6</name>
                    <description>Bits 111:96 of OTP access key 1 (ECC)</description>
                    <addressOffset>0x3D38</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY1_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY1_7</name>
                    <description>Bits 127:112 of OTP access key 1 (ECC)</description>
                    <addressOffset>0x3D3C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY1_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY2_0</name>
                    <description>Bits 15:0 of OTP access key 2 (ECC)</description>
                    <addressOffset>0x3D40</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY2_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY2_1</name>
                    <description>Bits 31:16 of OTP access key 2 (ECC)</description>
                    <addressOffset>0x3D44</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY2_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY2_2</name>
                    <description>Bits 47:32 of OTP access key 2 (ECC)</description>
                    <addressOffset>0x3D48</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY2_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY2_3</name>
                    <description>Bits 63:48 of OTP access key 2 (ECC)</description>
                    <addressOffset>0x3D4C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY2_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY2_4</name>
                    <description>Bits 79:64 of OTP access key 2 (ECC)</description>
                    <addressOffset>0x3D50</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY2_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY2_5</name>
                    <description>Bits 95:80 of OTP access key 2 (ECC)</description>
                    <addressOffset>0x3D54</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY2_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY2_6</name>
                    <description>Bits 111:96 of OTP access key 2 (ECC)</description>
                    <addressOffset>0x3D58</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY2_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY2_7</name>
                    <description>Bits 127:112 of OTP access key 2 (ECC)</description>
                    <addressOffset>0x3D5C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY2_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY3_0</name>
                    <description>Bits 15:0 of OTP access key 3 (ECC)</description>
                    <addressOffset>0x3D60</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY3_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY3_1</name>
                    <description>Bits 31:16 of OTP access key 3 (ECC)</description>
                    <addressOffset>0x3D64</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY3_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY3_2</name>
                    <description>Bits 47:32 of OTP access key 3 (ECC)</description>
                    <addressOffset>0x3D68</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY3_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY3_3</name>
                    <description>Bits 63:48 of OTP access key 3 (ECC)</description>
                    <addressOffset>0x3D6C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY3_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY3_4</name>
                    <description>Bits 79:64 of OTP access key 3 (ECC)</description>
                    <addressOffset>0x3D70</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY3_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY3_5</name>
                    <description>Bits 95:80 of OTP access key 3 (ECC)</description>
                    <addressOffset>0x3D74</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY3_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY3_6</name>
                    <description>Bits 111:96 of OTP access key 3 (ECC)</description>
                    <addressOffset>0x3D78</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY3_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY3_7</name>
                    <description>Bits 127:112 of OTP access key 3 (ECC)</description>
                    <addressOffset>0x3D7C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY3_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY4_0</name>
                    <description>Bits 15:0 of OTP access key 4 (ECC)</description>
                    <addressOffset>0x3D80</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY4_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY4_1</name>
                    <description>Bits 31:16 of OTP access key 4 (ECC)</description>
                    <addressOffset>0x3D84</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY4_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY4_2</name>
                    <description>Bits 47:32 of OTP access key 4 (ECC)</description>
                    <addressOffset>0x3D88</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY4_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY4_3</name>
                    <description>Bits 63:48 of OTP access key 4 (ECC)</description>
                    <addressOffset>0x3D8C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY4_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY4_4</name>
                    <description>Bits 79:64 of OTP access key 4 (ECC)</description>
                    <addressOffset>0x3D90</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY4_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY4_5</name>
                    <description>Bits 95:80 of OTP access key 4 (ECC)</description>
                    <addressOffset>0x3D94</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY4_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY4_6</name>
                    <description>Bits 111:96 of OTP access key 4 (ECC)</description>
                    <addressOffset>0x3D98</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY4_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY4_7</name>
                    <description>Bits 127:112 of OTP access key 4 (ECC)</description>
                    <addressOffset>0x3D9C</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY4_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY5_0</name>
                    <description>Bits 15:0 of OTP access key 5 (ECC)</description>
                    <addressOffset>0x3DA0</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY5_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY5_1</name>
                    <description>Bits 31:16 of OTP access key 5 (ECC)</description>
                    <addressOffset>0x3DA4</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY5_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY5_2</name>
                    <description>Bits 47:32 of OTP access key 5 (ECC)</description>
                    <addressOffset>0x3DA8</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY5_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY5_3</name>
                    <description>Bits 63:48 of OTP access key 5 (ECC)</description>
                    <addressOffset>0x3DAC</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY5_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY5_4</name>
                    <description>Bits 79:64 of OTP access key 5 (ECC)</description>
                    <addressOffset>0x3DB0</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY5_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY5_5</name>
                    <description>Bits 95:80 of OTP access key 5 (ECC)</description>
                    <addressOffset>0x3DB4</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY5_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY5_6</name>
                    <description>Bits 111:96 of OTP access key 5 (ECC)</description>
                    <addressOffset>0x3DB8</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY5_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY5_7</name>
                    <description>Bits 127:112 of OTP access key 5 (ECC)</description>
                    <addressOffset>0x3DBC</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY5_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY6_0</name>
                    <description>Bits 15:0 of OTP access key 6 (ECC)</description>
                    <addressOffset>0x3DC0</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY6_0</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY6_1</name>
                    <description>Bits 31:16 of OTP access key 6 (ECC)</description>
                    <addressOffset>0x3DC4</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY6_1</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY6_2</name>
                    <description>Bits 47:32 of OTP access key 6 (ECC)</description>
                    <addressOffset>0x3DC8</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY6_2</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY6_3</name>
                    <description>Bits 63:48 of OTP access key 6 (ECC)</description>
                    <addressOffset>0x3DCC</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY6_3</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY6_4</name>
                    <description>Bits 79:64 of OTP access key 6 (ECC)</description>
                    <addressOffset>0x3DD0</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY6_4</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY6_5</name>
                    <description>Bits 95:80 of OTP access key 6 (ECC)</description>
                    <addressOffset>0x3DD4</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY6_5</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY6_6</name>
                    <description>Bits 111:96 of OTP access key 6 (ECC)</description>
                    <addressOffset>0x3DD8</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY6_6</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY6_7</name>
                    <description>Bits 127:112 of OTP access key 6 (ECC)</description>
                    <addressOffset>0x3DDC</addressOffset>
                    <resetMask>0x00000000</resetMask>
                    <fields>
                        <field>
                            <name>KEY6_7</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY1_VALID</name>
                    <description>Valid flag for key 1. Once the valid flag is set, the key can no longer be read or written, and becomes a valid fixed key for protecting OTP pages.</description>
                    <addressOffset>0x3DE4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>VALID_R2</name>
                            <description>Redundant copy of VALID, with 3-way majority vote</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VALID_R1</name>
                            <description>Redundant copy of VALID, with 3-way majority vote</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VALID</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY2_VALID</name>
                    <description>Valid flag for key 2. Once the valid flag is set, the key can no longer be read or written, and becomes a valid fixed key for protecting OTP pages.</description>
                    <addressOffset>0x3DE8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>VALID_R2</name>
                            <description>Redundant copy of VALID, with 3-way majority vote</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VALID_R1</name>
                            <description>Redundant copy of VALID, with 3-way majority vote</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VALID</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY3_VALID</name>
                    <description>Valid flag for key 3. Once the valid flag is set, the key can no longer be read or written, and becomes a valid fixed key for protecting OTP pages.</description>
                    <addressOffset>0x3DEC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>VALID_R2</name>
                            <description>Redundant copy of VALID, with 3-way majority vote</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VALID_R1</name>
                            <description>Redundant copy of VALID, with 3-way majority vote</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VALID</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY4_VALID</name>
                    <description>Valid flag for key 4. Once the valid flag is set, the key can no longer be read or written, and becomes a valid fixed key for protecting OTP pages.</description>
                    <addressOffset>0x3DF0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>VALID_R2</name>
                            <description>Redundant copy of VALID, with 3-way majority vote</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VALID_R1</name>
                            <description>Redundant copy of VALID, with 3-way majority vote</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VALID</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY5_VALID</name>
                    <description>Valid flag for key 5. Once the valid flag is set, the key can no longer be read or written, and becomes a valid fixed key for protecting OTP pages.</description>
                    <addressOffset>0x3DF4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>VALID_R2</name>
                            <description>Redundant copy of VALID, with 3-way majority vote</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VALID_R1</name>
                            <description>Redundant copy of VALID, with 3-way majority vote</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VALID</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>KEY6_VALID</name>
                    <description>Valid flag for key 6. Once the valid flag is set, the key can no longer be read or written, and becomes a valid fixed key for protecting OTP pages.</description>
                    <addressOffset>0x3DF8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>VALID_R2</name>
                            <description>Redundant copy of VALID, with 3-way majority vote</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VALID_R1</name>
                            <description>Redundant copy of VALID, with 3-way majority vote</description>
                            <bitRange>[8:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>VALID</name>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE0_LOCK0</name>
                    <description>Lock configuration LSBs for page 0 (rows 0x0 through 0x3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E00</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE0_LOCK1</name>
                    <description>Lock configuration MSBs for page 0 (rows 0x0 through 0x3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E04</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE1_LOCK0</name>
                    <description>Lock configuration LSBs for page 1 (rows 0x40 through 0x7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E08</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE1_LOCK1</name>
                    <description>Lock configuration MSBs for page 1 (rows 0x40 through 0x7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E0C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE2_LOCK0</name>
                    <description>Lock configuration LSBs for page 2 (rows 0x80 through 0xbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE2_LOCK1</name>
                    <description>Lock configuration MSBs for page 2 (rows 0x80 through 0xbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E14</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE3_LOCK0</name>
                    <description>Lock configuration LSBs for page 3 (rows 0xc0 through 0xff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E18</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE3_LOCK1</name>
                    <description>Lock configuration MSBs for page 3 (rows 0xc0 through 0xff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E1C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE4_LOCK0</name>
                    <description>Lock configuration LSBs for page 4 (rows 0x100 through 0x13f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E20</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE4_LOCK1</name>
                    <description>Lock configuration MSBs for page 4 (rows 0x100 through 0x13f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E24</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE5_LOCK0</name>
                    <description>Lock configuration LSBs for page 5 (rows 0x140 through 0x17f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E28</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE5_LOCK1</name>
                    <description>Lock configuration MSBs for page 5 (rows 0x140 through 0x17f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E2C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE6_LOCK0</name>
                    <description>Lock configuration LSBs for page 6 (rows 0x180 through 0x1bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E30</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE6_LOCK1</name>
                    <description>Lock configuration MSBs for page 6 (rows 0x180 through 0x1bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E34</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE7_LOCK0</name>
                    <description>Lock configuration LSBs for page 7 (rows 0x1c0 through 0x1ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E38</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE7_LOCK1</name>
                    <description>Lock configuration MSBs for page 7 (rows 0x1c0 through 0x1ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E3C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE8_LOCK0</name>
                    <description>Lock configuration LSBs for page 8 (rows 0x200 through 0x23f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E40</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE8_LOCK1</name>
                    <description>Lock configuration MSBs for page 8 (rows 0x200 through 0x23f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E44</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE9_LOCK0</name>
                    <description>Lock configuration LSBs for page 9 (rows 0x240 through 0x27f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E48</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE9_LOCK1</name>
                    <description>Lock configuration MSBs for page 9 (rows 0x240 through 0x27f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E4C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE10_LOCK0</name>
                    <description>Lock configuration LSBs for page 10 (rows 0x280 through 0x2bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E50</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE10_LOCK1</name>
                    <description>Lock configuration MSBs for page 10 (rows 0x280 through 0x2bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E54</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE11_LOCK0</name>
                    <description>Lock configuration LSBs for page 11 (rows 0x2c0 through 0x2ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E58</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE11_LOCK1</name>
                    <description>Lock configuration MSBs for page 11 (rows 0x2c0 through 0x2ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E5C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE12_LOCK0</name>
                    <description>Lock configuration LSBs for page 12 (rows 0x300 through 0x33f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E60</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE12_LOCK1</name>
                    <description>Lock configuration MSBs for page 12 (rows 0x300 through 0x33f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E64</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE13_LOCK0</name>
                    <description>Lock configuration LSBs for page 13 (rows 0x340 through 0x37f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E68</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE13_LOCK1</name>
                    <description>Lock configuration MSBs for page 13 (rows 0x340 through 0x37f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E6C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE14_LOCK0</name>
                    <description>Lock configuration LSBs for page 14 (rows 0x380 through 0x3bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E70</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE14_LOCK1</name>
                    <description>Lock configuration MSBs for page 14 (rows 0x380 through 0x3bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E74</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE15_LOCK0</name>
                    <description>Lock configuration LSBs for page 15 (rows 0x3c0 through 0x3ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E78</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE15_LOCK1</name>
                    <description>Lock configuration MSBs for page 15 (rows 0x3c0 through 0x3ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E7C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE16_LOCK0</name>
                    <description>Lock configuration LSBs for page 16 (rows 0x400 through 0x43f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E80</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE16_LOCK1</name>
                    <description>Lock configuration MSBs for page 16 (rows 0x400 through 0x43f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E84</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE17_LOCK0</name>
                    <description>Lock configuration LSBs for page 17 (rows 0x440 through 0x47f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E88</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE17_LOCK1</name>
                    <description>Lock configuration MSBs for page 17 (rows 0x440 through 0x47f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E8C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE18_LOCK0</name>
                    <description>Lock configuration LSBs for page 18 (rows 0x480 through 0x4bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E90</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE18_LOCK1</name>
                    <description>Lock configuration MSBs for page 18 (rows 0x480 through 0x4bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E94</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE19_LOCK0</name>
                    <description>Lock configuration LSBs for page 19 (rows 0x4c0 through 0x4ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E98</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE19_LOCK1</name>
                    <description>Lock configuration MSBs for page 19 (rows 0x4c0 through 0x4ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3E9C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE20_LOCK0</name>
                    <description>Lock configuration LSBs for page 20 (rows 0x500 through 0x53f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EA0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE20_LOCK1</name>
                    <description>Lock configuration MSBs for page 20 (rows 0x500 through 0x53f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EA4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE21_LOCK0</name>
                    <description>Lock configuration LSBs for page 21 (rows 0x540 through 0x57f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EA8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE21_LOCK1</name>
                    <description>Lock configuration MSBs for page 21 (rows 0x540 through 0x57f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EAC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE22_LOCK0</name>
                    <description>Lock configuration LSBs for page 22 (rows 0x580 through 0x5bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EB0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE22_LOCK1</name>
                    <description>Lock configuration MSBs for page 22 (rows 0x580 through 0x5bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EB4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE23_LOCK0</name>
                    <description>Lock configuration LSBs for page 23 (rows 0x5c0 through 0x5ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EB8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE23_LOCK1</name>
                    <description>Lock configuration MSBs for page 23 (rows 0x5c0 through 0x5ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EBC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE24_LOCK0</name>
                    <description>Lock configuration LSBs for page 24 (rows 0x600 through 0x63f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EC0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE24_LOCK1</name>
                    <description>Lock configuration MSBs for page 24 (rows 0x600 through 0x63f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EC4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE25_LOCK0</name>
                    <description>Lock configuration LSBs for page 25 (rows 0x640 through 0x67f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EC8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE25_LOCK1</name>
                    <description>Lock configuration MSBs for page 25 (rows 0x640 through 0x67f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3ECC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE26_LOCK0</name>
                    <description>Lock configuration LSBs for page 26 (rows 0x680 through 0x6bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3ED0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE26_LOCK1</name>
                    <description>Lock configuration MSBs for page 26 (rows 0x680 through 0x6bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3ED4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE27_LOCK0</name>
                    <description>Lock configuration LSBs for page 27 (rows 0x6c0 through 0x6ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3ED8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE27_LOCK1</name>
                    <description>Lock configuration MSBs for page 27 (rows 0x6c0 through 0x6ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EDC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE28_LOCK0</name>
                    <description>Lock configuration LSBs for page 28 (rows 0x700 through 0x73f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EE0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE28_LOCK1</name>
                    <description>Lock configuration MSBs for page 28 (rows 0x700 through 0x73f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EE4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE29_LOCK0</name>
                    <description>Lock configuration LSBs for page 29 (rows 0x740 through 0x77f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EE8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE29_LOCK1</name>
                    <description>Lock configuration MSBs for page 29 (rows 0x740 through 0x77f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EEC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE30_LOCK0</name>
                    <description>Lock configuration LSBs for page 30 (rows 0x780 through 0x7bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EF0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE30_LOCK1</name>
                    <description>Lock configuration MSBs for page 30 (rows 0x780 through 0x7bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EF4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE31_LOCK0</name>
                    <description>Lock configuration LSBs for page 31 (rows 0x7c0 through 0x7ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EF8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE31_LOCK1</name>
                    <description>Lock configuration MSBs for page 31 (rows 0x7c0 through 0x7ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3EFC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE32_LOCK0</name>
                    <description>Lock configuration LSBs for page 32 (rows 0x800 through 0x83f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F00</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE32_LOCK1</name>
                    <description>Lock configuration MSBs for page 32 (rows 0x800 through 0x83f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F04</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE33_LOCK0</name>
                    <description>Lock configuration LSBs for page 33 (rows 0x840 through 0x87f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F08</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE33_LOCK1</name>
                    <description>Lock configuration MSBs for page 33 (rows 0x840 through 0x87f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F0C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE34_LOCK0</name>
                    <description>Lock configuration LSBs for page 34 (rows 0x880 through 0x8bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F10</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE34_LOCK1</name>
                    <description>Lock configuration MSBs for page 34 (rows 0x880 through 0x8bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F14</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE35_LOCK0</name>
                    <description>Lock configuration LSBs for page 35 (rows 0x8c0 through 0x8ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F18</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE35_LOCK1</name>
                    <description>Lock configuration MSBs for page 35 (rows 0x8c0 through 0x8ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F1C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE36_LOCK0</name>
                    <description>Lock configuration LSBs for page 36 (rows 0x900 through 0x93f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F20</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE36_LOCK1</name>
                    <description>Lock configuration MSBs for page 36 (rows 0x900 through 0x93f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F24</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE37_LOCK0</name>
                    <description>Lock configuration LSBs for page 37 (rows 0x940 through 0x97f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F28</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE37_LOCK1</name>
                    <description>Lock configuration MSBs for page 37 (rows 0x940 through 0x97f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F2C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE38_LOCK0</name>
                    <description>Lock configuration LSBs for page 38 (rows 0x980 through 0x9bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F30</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE38_LOCK1</name>
                    <description>Lock configuration MSBs for page 38 (rows 0x980 through 0x9bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F34</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE39_LOCK0</name>
                    <description>Lock configuration LSBs for page 39 (rows 0x9c0 through 0x9ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F38</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE39_LOCK1</name>
                    <description>Lock configuration MSBs for page 39 (rows 0x9c0 through 0x9ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F3C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE40_LOCK0</name>
                    <description>Lock configuration LSBs for page 40 (rows 0xa00 through 0xa3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F40</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE40_LOCK1</name>
                    <description>Lock configuration MSBs for page 40 (rows 0xa00 through 0xa3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F44</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE41_LOCK0</name>
                    <description>Lock configuration LSBs for page 41 (rows 0xa40 through 0xa7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F48</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE41_LOCK1</name>
                    <description>Lock configuration MSBs for page 41 (rows 0xa40 through 0xa7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F4C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE42_LOCK0</name>
                    <description>Lock configuration LSBs for page 42 (rows 0xa80 through 0xabf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F50</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE42_LOCK1</name>
                    <description>Lock configuration MSBs for page 42 (rows 0xa80 through 0xabf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F54</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE43_LOCK0</name>
                    <description>Lock configuration LSBs for page 43 (rows 0xac0 through 0xaff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F58</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE43_LOCK1</name>
                    <description>Lock configuration MSBs for page 43 (rows 0xac0 through 0xaff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F5C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE44_LOCK0</name>
                    <description>Lock configuration LSBs for page 44 (rows 0xb00 through 0xb3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F60</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE44_LOCK1</name>
                    <description>Lock configuration MSBs for page 44 (rows 0xb00 through 0xb3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F64</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE45_LOCK0</name>
                    <description>Lock configuration LSBs for page 45 (rows 0xb40 through 0xb7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F68</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE45_LOCK1</name>
                    <description>Lock configuration MSBs for page 45 (rows 0xb40 through 0xb7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F6C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE46_LOCK0</name>
                    <description>Lock configuration LSBs for page 46 (rows 0xb80 through 0xbbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F70</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE46_LOCK1</name>
                    <description>Lock configuration MSBs for page 46 (rows 0xb80 through 0xbbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F74</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE47_LOCK0</name>
                    <description>Lock configuration LSBs for page 47 (rows 0xbc0 through 0xbff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F78</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE47_LOCK1</name>
                    <description>Lock configuration MSBs for page 47 (rows 0xbc0 through 0xbff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F7C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE48_LOCK0</name>
                    <description>Lock configuration LSBs for page 48 (rows 0xc00 through 0xc3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F80</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE48_LOCK1</name>
                    <description>Lock configuration MSBs for page 48 (rows 0xc00 through 0xc3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F84</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE49_LOCK0</name>
                    <description>Lock configuration LSBs for page 49 (rows 0xc40 through 0xc7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F88</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE49_LOCK1</name>
                    <description>Lock configuration MSBs for page 49 (rows 0xc40 through 0xc7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F8C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE50_LOCK0</name>
                    <description>Lock configuration LSBs for page 50 (rows 0xc80 through 0xcbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F90</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE50_LOCK1</name>
                    <description>Lock configuration MSBs for page 50 (rows 0xc80 through 0xcbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F94</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE51_LOCK0</name>
                    <description>Lock configuration LSBs for page 51 (rows 0xcc0 through 0xcff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F98</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE51_LOCK1</name>
                    <description>Lock configuration MSBs for page 51 (rows 0xcc0 through 0xcff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3F9C</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE52_LOCK0</name>
                    <description>Lock configuration LSBs for page 52 (rows 0xd00 through 0xd3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FA0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE52_LOCK1</name>
                    <description>Lock configuration MSBs for page 52 (rows 0xd00 through 0xd3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FA4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE53_LOCK0</name>
                    <description>Lock configuration LSBs for page 53 (rows 0xd40 through 0xd7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FA8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE53_LOCK1</name>
                    <description>Lock configuration MSBs for page 53 (rows 0xd40 through 0xd7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FAC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE54_LOCK0</name>
                    <description>Lock configuration LSBs for page 54 (rows 0xd80 through 0xdbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FB0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE54_LOCK1</name>
                    <description>Lock configuration MSBs for page 54 (rows 0xd80 through 0xdbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FB4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE55_LOCK0</name>
                    <description>Lock configuration LSBs for page 55 (rows 0xdc0 through 0xdff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FB8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE55_LOCK1</name>
                    <description>Lock configuration MSBs for page 55 (rows 0xdc0 through 0xdff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FBC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE56_LOCK0</name>
                    <description>Lock configuration LSBs for page 56 (rows 0xe00 through 0xe3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FC0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE56_LOCK1</name>
                    <description>Lock configuration MSBs for page 56 (rows 0xe00 through 0xe3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FC4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE57_LOCK0</name>
                    <description>Lock configuration LSBs for page 57 (rows 0xe40 through 0xe7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FC8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE57_LOCK1</name>
                    <description>Lock configuration MSBs for page 57 (rows 0xe40 through 0xe7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FCC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE58_LOCK0</name>
                    <description>Lock configuration LSBs for page 58 (rows 0xe80 through 0xebf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FD0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE58_LOCK1</name>
                    <description>Lock configuration MSBs for page 58 (rows 0xe80 through 0xebf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FD4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE59_LOCK0</name>
                    <description>Lock configuration LSBs for page 59 (rows 0xec0 through 0xeff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FD8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE59_LOCK1</name>
                    <description>Lock configuration MSBs for page 59 (rows 0xec0 through 0xeff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FDC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE60_LOCK0</name>
                    <description>Lock configuration LSBs for page 60 (rows 0xf00 through 0xf3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FE0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE60_LOCK1</name>
                    <description>Lock configuration MSBs for page 60 (rows 0xf00 through 0xf3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FE4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE61_LOCK0</name>
                    <description>Lock configuration LSBs for page 61 (rows 0xf40 through 0xf7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FE8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE61_LOCK1</name>
                    <description>Lock configuration MSBs for page 61 (rows 0xf40 through 0xf7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FEC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE62_LOCK0</name>
                    <description>Lock configuration LSBs for page 62 (rows 0xf80 through 0xfbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FF0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE62_LOCK1</name>
                    <description>Lock configuration MSBs for page 62 (rows 0xf80 through 0xfbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FF4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE63_LOCK0</name>
                    <description>Lock configuration LSBs for page 63 (rows 0xfc0 through 0xfff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FF8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>RMA</name>
                            <description>Decommission for RMA of a suspected faulty device. This re-enables the factory test JTAG interface, and makes pages 3 through 61 of the OTP permanently inaccessible.</description>
                            <bitRange>[7:7]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>NO_KEY_STATE</name>
                            <description>State when at least one key is registered for this page and no matching key has been entered.</description>
                            <bitRange>[6:6]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <value>1</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>KEY_R</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.</description>
                            <bitRange>[5:3]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>KEY_W</name>
                            <description>Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.</description>
                            <bitRange>[2:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>PAGE63_LOCK1</name>
                    <description>Lock configuration MSBs for page 63 (rows 0xfc0 through 0xfff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.

                        This OTP location is always readable, and is write-protected by its own permissions.</description>
                    <addressOffset>0x3FFC</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>R2</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[23:16]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>R1</name>
                            <description>Redundant copy of bits 7:0</description>
                            <bitRange>[15:8]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>LOCK_BL</name>
                            <description>Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.</description>
                            <bitRange>[5:4]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Bootloader permits user reads and writes to this page</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Bootloader permits user reads of this page</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Bootloader does not permit user access to this page</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_NS</name>
                            <description>Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.

                                Note that READ_WRITE and READ_ONLY are equivalent in hardware, as the SBPI programming interface is not accessible to Non-secure software. However, Secure software may check these bits to apply write permissions to a Non-secure OTP programming API.</description>
                            <bitRange>[3:2]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page can be read by Non-secure software, and Secure software may permit Non-secure writes.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Non-secure software</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Non-secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>LOCK_S</name>
                            <description>Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.</description>
                            <bitRange>[1:0]</bitRange>
                            <access>read-only</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>read_write</name>
                                    <description>Page is fully accessible by Secure software.</description>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>read_only</name>
                                    <description>Page can be read by Secure software, but can not be written.</description>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>reserved</name>
                                    <description>Do not use. Behaves the same as INACCESSIBLE.</description>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>inaccessible</name>
                                    <description>Page can not be accessed by Secure software.</description>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>TBMAN</name>
            <description>For managing simulation testbenches</description>
            <baseAddress>0x40160000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x4</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>PLATFORM</name>
                    <description>Indicates the type of platform in use</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000001</resetValue>
                    <fields>
                        <field>
                            <name>HDLSIM</name>
                            <description>Indicates the platform is a simulation</description>
                            <bitRange>[2:2]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>FPGA</name>
                            <description>Indicates the platform is an FPGA</description>
                            <bitRange>[1:1]</bitRange>
                            <access>read-only</access>
                        </field>
                        <field>
                            <name>ASIC</name>
                            <description>Indicates the platform is an ASIC</description>
                            <bitRange>[0:0]</bitRange>
                            <access>read-only</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
        <peripheral>
            <name>USB_DPRAM</name>
            <description>DPRAM layout for USB device.</description>
            <baseAddress>0x50100000</baseAddress>
            <addressBlock>
                <offset>0x0</offset>
                <size>0x100</size>
                <usage>registers</usage>
            </addressBlock>
            <registers>
                <register>
                    <name>SETUP_PACKET_LOW</name>
                    <description>Bytes 0-3 of the SETUP packet from the host.</description>
                    <addressOffset>0x0</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>WVALUE</name>
                            <bitRange>[31:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BREQUEST</name>
                            <bitRange>[15:8]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BMREQUESTTYPE</name>
                            <bitRange>[7:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <name>SETUP_PACKET_HIGH</name>
                    <description>Bytes 4-7 of the setup packet from the host.</description>
                    <addressOffset>0x4</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>WLENGTH</name>
                            <bitRange>[31:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>WINDEX</name>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>30</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-29</dimIndex>
                    <name>EP_CONTROL%s</name>
                    <description>TODO</description>
                    <addressOffset>0x8</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>ENABLE</name>
                            <description>Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.</description>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DOUBLE_BUFFERED</name>
                            <description>This endpoint is double buffered.</description>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INTERRUPT_PER_BUFF</name>
                            <description>Trigger an interrupt each time a buffer is done.</description>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INTERRUPT_PER_DOUBLE_BUFF</name>
                            <description>Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.</description>
                            <bitRange>[28:28]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>ENDPOINT_TYPE</name>
                            <bitRange>[27:26]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>Control</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Isochronous</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Bulk</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>Interrupt</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>INTERRUPT_ON_STALL</name>
                            <description>Trigger an interrupt if a STALL is sent. Intended for debug only.</description>
                            <bitRange>[17:17]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>INTERRUPT_ON_NAK</name>
                            <description>Trigger an interrupt if a NAK is sent. Intended for debug only.</description>
                            <bitRange>[16:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>BUFFER_ADDRESS</name>
                            <description>64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.</description>
                            <bitRange>[15:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
                <register>
                    <dim>32</dim>
                    <dimIncrement>0x4</dimIncrement>
                    <dimIndex>0-31</dimIndex>
                    <name>EP_BUFFER_CONTROL%s</name>
                    <description>TODO</description>
                    <addressOffset>0x80</addressOffset>
                    <resetValue>0x00000000</resetValue>
                    <fields>
                        <field>
                            <name>FULL_1</name>
                            <description>Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.</description>
                            <bitRange>[31:31]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>LAST_1</name>
                            <description>Buffer 1 is the last buffer of the transfer.</description>
                            <bitRange>[30:30]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PID_1</name>
                            <description>The data pid of buffer 1.</description>
                            <bitRange>[29:29]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>DOUBLE_BUFFER_ISO_OFFSET</name>
                            <description>The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
                                For a non Isochronous endpoint the offset is always 64 bytes.</description>
                            <bitRange>[28:27]</bitRange>
                            <access>read-write</access>
                            <enumeratedValues>
                                <enumeratedValue>
                                    <name>128</name>
                                    <value>0</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>256</name>
                                    <value>1</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>512</name>
                                    <value>2</value>
                                </enumeratedValue>
                                <enumeratedValue>
                                    <name>1024</name>
                                    <value>3</value>
                                </enumeratedValue>
                            </enumeratedValues>
                        </field>
                        <field>
                            <name>AVAILABLE_1</name>
                            <description>Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.</description>
                            <bitRange>[26:26]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>LENGTH_1</name>
                            <description>The length of the data in buffer 1.</description>
                            <bitRange>[25:16]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>FULL_0</name>
                            <description>Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.</description>
                            <bitRange>[15:15]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>LAST_0</name>
                            <description>Buffer 0 is the last buffer of the transfer.</description>
                            <bitRange>[14:14]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>PID_0</name>
                            <description>The data pid of buffer 0.</description>
                            <bitRange>[13:13]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>RESET</name>
                            <description>Reset the buffer selector to buffer 0.</description>
                            <bitRange>[12:12]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>STALL</name>
                            <description>Reply with a stall (valid for both buffers).</description>
                            <bitRange>[11:11]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>AVAILABLE_0</name>
                            <description>Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.</description>
                            <bitRange>[10:10]</bitRange>
                            <access>read-write</access>
                        </field>
                        <field>
                            <name>LENGTH_0</name>
                            <description>The length of the data in buffer 1.</description>
                            <bitRange>[9:0]</bitRange>
                            <access>read-write</access>
                        </field>
                    </fields>
                </register>
            </registers>
        </peripheral>
    </peripherals>
</device>