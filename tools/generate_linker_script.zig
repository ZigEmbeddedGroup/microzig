const std = @import("std");
const microzig = @import("build-internals");
const Mode = microzig.LinkerScriptOptions.Mode;
const MemoryRegion = microzig.MemoryRegion;

pub const Args = struct {
    cpu_name: []const u8,
    cpu_arch: std.Target.Cpu.Arch,
    chip_name: []const u8,
    memory_regions: []const MemoryRegion,
    mode: Mode,
};

pub fn main() !void {
    var gpa: std.heap.DebugAllocator(.{}) = .init;
    defer _ = gpa.deinit();

    var arena = std.heap.ArenaAllocator.init(gpa.allocator());
    defer arena.deinit();

    const allocator = arena.allocator();
    const args = try std.process.argsAlloc(allocator);

    std.debug.assert(args.len >= 3);

    const json_args = args[1];
    const user_ld_files = args[2 .. args.len - 1];
    const output_path = args[args.len - 1];

    const parsed_args = try std.json.parseFromSliceLeaky(Args, allocator, json_args, .{});

    const file = try std.fs.cwd().createFile(output_path, .{});
    defer file.close();

    const writer = file.writer();
    try writer.print(
        \\/*
        \\ * This file was auto-generated by microzig
        \\ *
        \\ * Target CPU:  {[cpu]s}
        \\ * Target Chip: {[chip]s}
        \\ */
        \\
        \\
    , .{
        .cpu = parsed_args.cpu_name,
        .chip = parsed_args.chip_name,
    });

    if (parsed_args.mode != .none) {
        try writer.writeAll("MEMORY\n{\n");
        {
            var counters = [4]usize{ 0, 0, 0, 0 };
            for (parsed_args.memory_regions) |region| {
                // flash (rx!w) : ORIGIN = 0x00000000, LENGTH = 512k

                switch (region.kind) {
                    .flash => {
                        try writer.print("  flash{d}    (rx!w)", .{counters[0]});
                        counters[0] += 1;
                    },

                    .ram => {
                        try writer.print("  ram{d}      (rw!x)", .{counters[1]});
                        counters[1] += 1;
                    },

                    .io => {
                        try writer.print("  io{d}       (rw!x)", .{counters[2]});
                        counters[2] += 1;
                    },

                    .reserved => {
                        try writer.print("  reserved{d} (rw!x)", .{counters[3]});
                        counters[3] += 1;
                    },

                    .custom => |custom| {
                        try writer.print("  {s} (", .{custom.name});
                        if (custom.readable) try writer.writeAll("r");
                        if (custom.writeable) try writer.writeAll("w");
                        if (custom.executable) try writer.writeAll("x");

                        if (!custom.readable or !custom.writeable or !custom.executable) {
                            try writer.writeAll("!");
                            if (!custom.readable) try writer.writeAll("r");
                            if (!custom.writeable) try writer.writeAll("w");
                            if (!custom.executable) try writer.writeAll("x");
                        }
                        try writer.writeAll(")");
                    },
                }
                try writer.print(" : ORIGIN = 0x{X:0>8}, LENGTH = 0x{X:0>8}\n", .{ region.offset, region.length });
            }
        }

        try writer.writeAll("}\n");
    }

    if (parsed_args.mode == .include_sections) {
        try writer.writeAll("\n/* auto-generated sections */\n");
        try generate_sections(writer, parsed_args.cpu_arch, parsed_args.mode.include_sections.rodata_in_flash);
    }

    for (user_ld_files) |file_path| {
        const ld_file = try std.fs.cwd().openFile(file_path, .{});
        const ld_file_data = try ld_file.readToEndAlloc(allocator, 1_000_000);

        try writer.print("\n/* file: {s} */\n", .{file_path});
        try writer.writeAll(ld_file_data);
    }
}

pub fn generate_sections(writer: anytype, cpu_arch: std.Target.Cpu.Arch, rodata_in_flash: bool) !void {
    try writer.writeAll(
        \\SECTIONS
        \\{
        \\  .flash_start :
        \\  {
        \\    KEEP(*(microzig_flash_start))
        \\  }
        \\
        \\  .text :
        \\  {
        \\    *(.text*)
        \\
    );

    if (rodata_in_flash) {
        try writer.writeAll(
            \\    *(.rodata*)
            \\
        );
    }

    try writer.writeAll(
        \\  } > flash0
        \\
        \\
    );

    switch (cpu_arch) {
        .arm, .thumb => try writer.writeAll(
            \\  .ARM.extab : {
            \\    *(.ARM.extab* .gnu.linkonce.armextab.*)
            \\  } > flash0
            \\
            \\  .ARM.exidx : {
            \\    *(.ARM.exidx* .gnu.linkonce.armexidx.*)
            \\  } > flash0
            \\
            \\
        ),
        else => {},
    }

    try writer.writeAll(
        \\  .data :
        \\  {
        \\    microzig_data_start = .;
        \\    KEEP(*(microzig_time_critical))
        \\    *(.sdata*)
        \\    *(.data*)
        \\
    );

    if (!rodata_in_flash) {
        try writer.writeAll(
            \\    *(.rodata*)
            \\
        );
    }

    try writer.writeAll(
        \\    microzig_data_end = .;
        \\  } > ram0 AT> flash0
        \\
        \\  .bss (NOLOAD) :
        \\  {
        \\    microzig_bss_start = .;
        \\    *(.bss*)
        \\    *(.sbss*)
        \\    microzig_bss_end = .;
        \\  } > ram0
        \\
        \\  .flash_end :
        \\  {
        \\    microzig_flash_end = .;
        \\  } > flash0
        \\
        \\  microzig_data_load_start = LOADADDR(.data);
        \\
    );

    switch (cpu_arch) {
        .riscv32, .riscv64 => try writer.writeAll(
            \\  PROVIDE(__global_pointer$ = microzig_data_start + 0x800);
            \\
        ),
        else => {},
    }

    try writer.writeAll("}\n");
}
