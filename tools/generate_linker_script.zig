const std = @import("std");
const microzig = @import("build-internals");
const Mode = microzig.LinkerScript.GenerateOptions.Mode;
const MemoryRegion = microzig.MemoryRegion;

pub const Args = struct {
    cpu_name: []const u8,
    cpu_arch: std.Target.Cpu.Arch,
    chip_name: []const u8,
    memory_regions: []const MemoryRegion,
    mode: Mode,
};

pub fn main() !void {
    var debug_allocator: std.heap.DebugAllocator(.{}) = .init;
    defer _ = debug_allocator.deinit();

    var arena = std.heap.ArenaAllocator.init(debug_allocator.allocator());
    defer arena.deinit();

    const allocator = arena.allocator();
    const args = try std.process.argsAlloc(allocator);
    if (args.len < 3) {
        return error.UsageError;
    }

    const json_args = args[1];
    const user_ld_files = args[2 .. args.len - 1];
    const output_path = args[args.len - 1];

    const parsed_args = try std.json.parseFromSliceLeaky(Args, allocator, json_args, .{});

    const file = try std.fs.cwd().createFile(output_path, .{});
    defer file.close();

    const writer = file.writer();
    try writer.print(
        \\/*
        \\ * This file was auto-generated by microzig
        \\ *
        \\ * Target CPU:  {[cpu]s}
        \\ * Target Chip: {[chip]s}
        \\ */
        \\
        \\
    , .{
        .cpu = parsed_args.cpu_name,
        .chip = parsed_args.chip_name,
    });

    // name all unnamed regions
    const region_names: [][]const u8 = try allocator.alloc([]const u8, parsed_args.memory_regions.len);
    {
        var counters: [5]usize = @splat(0);
        for (region_names, parsed_args.memory_regions) |*region_name, region| {
            if (region.name) |name| {
                region_name.* = try allocator.dupe(u8, name);
            } else {
                region_name.* = try std.fmt.allocPrint(allocator, "{s}{}", .{
                    @tagName(region.tag),
                    counters[@intFromEnum(region.tag)],
                });
            }
            counters[@intFromEnum(region.tag)] += 1;
        }
    }

    if (parsed_args.mode != .none) {
        try writer.writeAll("MEMORY\n{\n");

        for (parsed_args.memory_regions, region_names) |region, region_name| {
            // flash (rx!w) : ORIGIN = 0x00000000, LENGTH = 512k

            try writer.print("  {s} (", .{region_name});

            if (region.access.read) try writer.writeAll("r");
            if (region.access.write) try writer.writeAll("w");
            if (region.access.execute) try writer.writeAll("x");

            if (!region.access.read or !region.access.write or !region.access.execute) {
                try writer.writeAll("!");
                if (!region.access.read) try writer.writeAll("r");
                if (!region.access.write) try writer.writeAll("w");
                if (!region.access.execute) try writer.writeAll("x");
            }
            try writer.writeAll(")");

            try writer.print(" : ORIGIN = 0x{X:0>8}, LENGTH = 0x{X:0>8}\n", .{ region.offset, region.length });
        }

        try writer.writeAll("}\n");
    }

    if (parsed_args.mode == .memory_regions_and_sections) {
        const flash_region_name = for (region_names, parsed_args.memory_regions) |region_name, region| {
            if (region.tag == .flash) {
                break region_name;
            }
        } else return error.NoFlashRegion;

        const ram_region_name, const ram_region = for (region_names, parsed_args.memory_regions) |region_name, region| {
            if (region.tag == .ram) {
                break .{ region_name, region };
            }
        } else return error.NoRamRegion;

        const options = parsed_args.mode.memory_regions_and_sections;

        const Location = enum {
            omit,
            flash,
            ram,
        };

        const rodata_location: Location = switch (options.rodata_location) {
            .flash => .flash,
            .ram => .ram,
            .omit => .omit,
        };

        const time_critical_location: Location = switch (options.time_critical_location) {
            .auto => if (ram_region.access.execute) .ram else .flash,
            .flash => .flash,
            .ram => if (ram_region.access.execute)
                .ram
            else
                return error.InvalidTimeCriticalLocation,
            .omit => .omit,
        };

        try writer.print(
            \\
            \\/* auto-generated sections */
            \\SECTIONS
            \\{{
            \\  .flash_start :
            \\  {{
            \\    KEEP(*(microzig_flash_start))
            \\  }} > {s}
            \\
            \\  .text :
            \\  {{
            \\    *(.text*)
            \\
        , .{flash_region_name});

        if (time_critical_location == .flash) {
            try writer.writeAll(
                \\    KEEP(*(microzig_time_critical))
                \\
            );
        }

        if (rodata_location == .flash) {
            try writer.writeAll(
                \\    *(.srodata*)
                \\    *(.rodata*)
                \\
            );
        }

        try writer.print(
            \\  }} > {s}
            \\
            \\
        , .{flash_region_name});

        switch (parsed_args.cpu_arch) {
            .arm, .thumb => try writer.print(
                \\  .ARM.extab : {{
                \\    *(.ARM.extab* .gnu.linkonce.armextab.*)
                \\  }} > {[flash]s}
                \\
                \\  .ARM.exidx : {{
                \\    *(.ARM.exidx* .gnu.linkonce.armexidx.*)
                \\  }} > {[flash]s}
                \\
                \\
            , .{ .flash = flash_region_name }),
            else => {},
        }

        try writer.writeAll(
            \\  .data :
            \\  {
            \\    microzig_data_start = .;
            \\    *(.sdata*)
            \\    *(.data*)
            \\
        );

        if (rodata_location == .ram) {
            try writer.writeAll(
                \\    *(.srodata*)
                \\    *(.rodata*)
                \\
            );
        }

        if (time_critical_location == .ram) {
            try writer.writeAll(
                \\    KEEP(*(microzig_time_critical))
                \\
            );
        }

        try writer.print(
            \\    microzig_data_end = .;
            \\  }} > {[ram]s} AT> {[flash]s}
            \\
            \\  .bss (NOLOAD) :
            \\  {{
            \\    microzig_bss_start = .;
            \\    *(.sbss*)
            \\    *(.bss*)
            \\    microzig_bss_end = .;
            \\  }} > {[ram]s}
            \\
            \\  .flash_end :
            \\  {{
            \\    microzig_flash_end = .;
            \\  }} > {[flash]s}
            \\
            \\  microzig_data_load_start = LOADADDR(.data);
            \\
        , .{
            .flash = flash_region_name,
            .ram = ram_region_name,
        });

        switch (parsed_args.cpu_arch) {
            .riscv32, .riscv64 => try writer.writeAll(
                \\  PROVIDE(__global_pointer$ = microzig_data_start + 0x800);
                \\
            ),
            else => {},
        }

        try writer.writeAll("}\n");
    }

    for (user_ld_files) |file_path| {
        const ld_file = try std.fs.cwd().openFile(file_path, .{});
        const ld_file_data = try ld_file.readToEndAlloc(allocator, 1_000_000);

        try writer.print("\n/* file: {s} */\n", .{file_path});
        try writer.writeAll(ld_file_data);
    }
}
