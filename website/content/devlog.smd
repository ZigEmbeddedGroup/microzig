---
.title = "Devlog",
.date = @date("2021-07-06T00:00:00"),
.author = "ZEG contributors",
.layout = "devlog.shtml",
.alternatives = [{
  .name = "rss",
  .layout = "devlog.xml",
  .output = "devlog/rss.xml",
}],
.draft = false,
---

## [About]($section.id('about'))

This is a non-exhaustive, curated list of changes meant to help users quickly
see what has improved since they last checked.

You can [subscribe to this page via RSS]($link.alternative('rss')).

## Changes

## [Printer]($section.id('2025-07-07'))

[]($image.asset('printer-01.png'))

Printer is a tool to process logging output from your code and print it in a
readable and pretty format. As of now it only annotates addresses from stack
traces with source code locations, but it can be extended later to also print
defmt (when this kind of logger will be added to microzig). You can also use it
as a library to write build system tools (checkout the rp2xxx_flasher example).

## [Segger RTT Support]($section.id('2025-06-26'))

Segger makes a popular open source utility for sending and receiving data
to/from an MCU via a JLink probe called
[Real Time Trace](https://kb.segger.com/RTT). Support for this protocol
was ported to pure Zig, and is available to be used by Arm Cortex-M
targets. This enables both logging and sending data from/to the MCU via
Segger's [RTT Viewer](https://kb.segger.com/J-Link_RTT_Viewer) utility.

## [Regz Wizard]($section.id('2025-06-22'))

[]($image.asset('regz-wizard-01.png'))

Regz is the program responsible for generating code to access MMIO within
MicroZig. We've started building a GUI for it called Regz Wizard. It's built on
top of [DVUI](https://github.com/david-vanderson/dvui), and right now it
displays the generated code for an ATDF or SVD file.

In the future it will aid in patching files. Keeping track of changes to an
original register schema is important for when that schema is updated, and
reproducing changes on similar hardware. [Some projects
exist](https://github.com/embassy-rs/stm32-data) just to provide consistent
data structure between MCUs. This consistency makes it easier to write HALs
that are portable across multiple MCUs.

## [Initial micro:bit support]($section.id('2025-06-19'))

Add support for the micro:bit 5x5 led display.

[]($image.asset('microbit-display.jpeg'))

## [Linker Script Generation]($section.id('2025-06-18'))

Every firmware needs a linker script that places stuff where it belongs in
memory. When porting microzig to a new target you must face the challenge of
dealing with a linker script. But fear not as microzig has your back (in most
cases). Let's checkout the `linker_script` field in `Target`.

```zig
linker_script: LinkerScript = .{},
```

```zig
pub const LinkerScript = struct {
    /// Will anything be auto-generated for this linker script?
    generate: GenerateOptions = .{ .memory_regions_and_sections = .{} },
    /// Linker script path. Will be appended after what is auto-generated if it's not null.
    file: ?LazyPath = null,

    pub const GenerateOptions = union(enum) {
        /// Only generates a comment with target info.
        none,
        /// Only generates memory regions.
        memory_regions,
        /// Generates memory regions and default sections based on the provided options.
        memory_regions_and_sections: struct {
            /// Where should rodata go?
            rodata_location: enum {
                /// Place rodata in the first region tagged as flash.
                flash,
                /// Place rodata in the first region tagged as ram.
                ram,
            } = .flash,
        },
    };
};
```

For an example let's look at the target definition of rp2040. In this case we
need a linker script that should also place the bootrom at the beginning of
flash. Fortunately, we can still mostly auto-generate one and just patch it up
a bit.

```zig
// port/raspberrypi/rp2xxx/build.zig

const chip_rp2040: microzig.Target = .{
    // ...
    .chip = .{
        // ...
        .memory_regions = &.{
            .{ .tag = .flash, .offset = 0x10000000, .length = 2048 * 1024, .access = .rx },
            .{ .tag = .ram, .offset = 0x20000000, .length = 256 * 1024, .access = .rwx },
        },
    },
    .linker_script = .{
        // The `generate` field defaults to `.memory_regions_and_sections`.

        // This will be appended at the end of the auto-generated linker
        // script.
        .file = b.path("ld/rp2040/sections.ld"),
    },
};
```

```
/* port/raspberrypi/rp2xxx/ld/rp2040/sections.ld */

SECTIONS
{
  .boot2 : {
    __boot2_start__ = .;
    KEEP (*(.boot2))
    __boot2_end__ = .;
  } > flash0

  ASSERT(__boot2_end__ - __boot2_start__ == 256,
    "ERROR: Pico second stage bootloader must be 256 bytes in size")
}
INSERT BEFORE .flash_start;
```

This is the generated linker script:

```
/*
 * Target CPU:  cortex_m0plus
 * Target Chip: RP2040
 */

/*
 * This section was auto-generated by microzig.
 */
MEMORY
{
  flash0 (rx!w) : ORIGIN = 0x10000000, LENGTH = 0x00200000
  ram0 (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00040000
}
SECTIONS
{
  .flash_start :
  {
    KEEP(*(microzig_flash_start))
  } > flash0

  .text :
  {
    *(.text*)
    *(.srodata*)
    *(.rodata*)
  } > flash0

  .ARM.extab : {
    *(.ARM.extab* .gnu.linkonce.armextab.*)
  } > flash0

  .ARM.exidx : {
    *(.ARM.exidx* .gnu.linkonce.armexidx.*)
  } > flash0

  .data :
  {
    microzig_data_start = .;
    *(.sdata*)
    *(.data*)
    KEEP(*(.ram_text))
    microzig_data_end = .;
  } > ram0 AT> flash0

  .bss (NOLOAD) :
  {
    microzig_bss_start = .;
    *(.sbss*)
    *(.bss*)
    microzig_bss_end = .;
  } > ram0

  .flash_end :
  {
    microzig_flash_end = .;
  } > flash0

  microzig_data_load_start = LOADADDR(.data);
}
/*
 * End of auto-generated section.
 */
SECTIONS
{
  .boot2 : {
    __boot2_start__ = .;
    KEEP (*(.boot2))
    __boot2_end__ = .;
  } > flash0

  ASSERT(__boot2_end__ - __boot2_start__ == 256,
    "ERROR: Pico second stage bootloader must be 256 bytes in size")
}
INSERT BEFORE .flash_start;
```

### FYI
- If the ram memory region used by the linker script generator is executable, a
  `.ram_text` section will be included for code that should be placed in ram.
  This applies to the rp2040 target where the section tagged as ram is
  executable.
