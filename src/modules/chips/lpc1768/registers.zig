// this file is generated by regz
//
// device: LPC176x5x
// cpu: CM3

pub const VectorTable = extern struct {
    initial_stack_pointer: u32,
    Reset: InterruptVector = unhandled,
    NMI: InterruptVector = unhandled,
    HardFault: InterruptVector = unhandled,
    MemManage: InterruptVector = unhandled,
    BusFault: InterruptVector = unhandled,
    UsageFault: InterruptVector = unhandled,
    reserved0: [4]u32 = undefined,
    SVCall: InterruptVector = unhandled,
    reserved1: [2]u32 = undefined,
    PendSV: InterruptVector = unhandled,
    SysTick: InterruptVector = unhandled,
    WDT: InterruptVector = unhandled,
    TIMER0: InterruptVector = unhandled,
    TIMER1: InterruptVector = unhandled,
    TIMER2: InterruptVector = unhandled,
    TIMER3: InterruptVector = unhandled,
    UART0: InterruptVector = unhandled,
    UART1: InterruptVector = unhandled,
    UART2: InterruptVector = unhandled,
    UART3: InterruptVector = unhandled,
    PWM1: InterruptVector = unhandled,
    I2C0: InterruptVector = unhandled,
    I2C1: InterruptVector = unhandled,
    I2C2: InterruptVector = unhandled,
    SPI: InterruptVector = unhandled,
    SSP0: InterruptVector = unhandled,
    SSP1: InterruptVector = unhandled,
    PLL0: InterruptVector = unhandled,
    RTC: InterruptVector = unhandled,
    EINT0: InterruptVector = unhandled,
    EINT1: InterruptVector = unhandled,
    EINT2: InterruptVector = unhandled,
    EINT3: InterruptVector = unhandled,
    ADC: InterruptVector = unhandled,
    BOD: InterruptVector = unhandled,
    USB: InterruptVector = unhandled,
    CAN: InterruptVector = unhandled,
    DMA: InterruptVector = unhandled,
    I2S: InterruptVector = unhandled,
    ENET: InterruptVector = unhandled,
    RIT: InterruptVector = unhandled,
    MCPWM: InterruptVector = unhandled,
    QEI: InterruptVector = unhandled,
    PLL1: InterruptVector = unhandled,
    USBActivity: InterruptVector = unhandled,
    CANActivity: InterruptVector = unhandled,
};

pub const registers = struct {
    /// Watchdog Timer (WDT)
    pub const WDT = struct {
        pub const base_address = 0x40000000;

        /// address: 0x40000000
        /// Watchdog mode register. This register determines the basic mode and status of
        /// the Watchdog Timer.
        pub const MOD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog enable bit. This bit is Set Only.
            WDEN: u1,
            /// Watchdog reset enable bit. This bit is Set Only. See Table 652.
            WDRESET: u1,
            /// Watchdog time-out flag. Set when the watchdog timer times out, cleared by
            /// software.
            WDTOF: u1,
            /// Watchdog interrupt flag. Cleared by software.
            WDINT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u28,
        }), base_address + 0x0);

        /// address: 0x40000004
        /// Watchdog timer constant register. The value in this register determines the
        /// time-out value.
        pub const TC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog time-out interval.
            Count: u32,
        }), base_address + 0x4);

        /// address: 0x40000008
        /// Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register
        /// reloads the Watchdog timer with the value contained in WDTC.
        pub const FEED = @intToPtr(*volatile Mmio(32, packed struct {
            /// Feed value should be 0xAA followed by 0x55.
            Feed: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x4000000c
        /// Watchdog timer value register. This register reads out the current value of the
        /// Watchdog timer.
        pub const TV = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter timer value.
            Count: u32,
        }), base_address + 0xc);

        /// address: 0x40000010
        /// Watchdog clock select register.
        pub const CLKSEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Selects source of WDT clock
            CLKSEL: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            /// If this bit is set to one writing to this register does not affect bit 0. The
            /// clock source can only be changed by first clearing this bit, then writing the
            /// new value of bit 0.
            LOCK: u1,
        }), base_address + 0x10);
    };
    /// Timer0/1/2/3
    pub const TIMER0 = struct {
        pub const base_address = 0x40004000;

        /// address: 0x40004000
        /// Interrupt Register. The IR can be written to clear interrupts. The IR can be
        /// read to identify which of eight possible interrupt sources are pending.
        pub const IR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt flag for match channel 0.
            MR0INT: u1,
            /// Interrupt flag for match channel 1.
            MR1INT: u1,
            /// Interrupt flag for match channel 2.
            MR2INT: u1,
            /// Interrupt flag for match channel 3.
            MR3INT: u1,
            /// Interrupt flag for capture channel 0 event.
            CR0INT: u1,
            /// Interrupt flag for capture channel 1 event.
            CR1INT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u26,
        }), base_address + 0x0);

        /// address: 0x40004004
        /// Timer Control Register. The TCR is used to control the Timer Counter functions.
        /// The Timer Counter can be disabled or reset through the TCR.
        pub const TCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// When one, the Timer Counter and Prescale Counter are enabled for counting. When
            /// zero, the counters are disabled.
            CEN: u1,
            /// When one, the Timer Counter and the Prescale Counter are synchronously reset on
            /// the next positive edge of PCLK. The counters remain reset until TCR[1] is
            /// returned to zero.
            CRST: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u30,
        }), base_address + 0x4);

        /// address: 0x40004008
        /// Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is
        /// controlled through the TCR.
        pub const TC = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4000400c
        /// Prescale Register. When the Prescale Counter (PC) is equal to this value, the
        /// next clock increments the TC and clears the PC.
        pub const PR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescale counter maximum value.
            PM: u32,
        }), base_address + 0xc);

        /// address: 0x40004010
        /// Prescale Counter. The 32 bit PC is a counter which is incremented to the value
        /// stored in PR. When the value in PR is reached, the TC is incremented and the PC
        /// is cleared. The PC is observable and controllable through the bus interface.
        pub const PC = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40004014
        /// Match Control Register. The MCR is used to control if an interrupt is generated
        /// and if the TC is reset when a Match occurs.
        pub const MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt on MR0
            MR0I: u1,
            /// Reset on MR0
            MR0R: u1,
            /// Stop on MR0
            MR0S: u1,
            /// Interrupt on MR1
            MR1I: u1,
            /// Reset on MR1
            MR1R: u1,
            /// Stop on MR1
            MR1S: u1,
            /// Interrupt on MR2
            MR2I: u1,
            /// Reset on MR2
            MR2R: u1,
            /// Stop on MR2.
            MR2S: u1,
            /// Interrupt on MR3
            MR3I: u1,
            /// Reset on MR3
            MR3R: u1,
            /// Stop on MR3
            MR3S: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u20,
        }), base_address + 0x14);

        /// address: 0x40004018
        /// Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both
        /// the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
        pub const MR = @intToPtr(*volatile [4]Mmio(32, packed struct {
            /// Timer counter match value.
            MATCH: u32,
        }), base_address + 0x18);

        /// address: 0x40004028
        /// Capture Control Register. The CCR controls which edges of the capture inputs are
        /// used to load the Capture Registers and whether or not an interrupt is generated
        /// when a capture takes place.
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture on CAPn.0 rising edge
            CAP0RE: u1,
            /// Capture on CAPn.0 falling edge
            CAP0FE: u1,
            /// Interrupt on CAPn.0 event
            CAP0I: u1,
            /// Capture on CAPn.1 rising edge
            CAP1RE: u1,
            /// Capture on CAPn.1 falling edge
            CAP1FE: u1,
            /// Interrupt on CAPn.1 event
            CAP1I: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u26,
        }), base_address + 0x28);

        /// address: 0x4000402c
        /// Capture Register 0. CR0 is loaded with the value of TC when there is an event on
        /// the CAPn.0 input.
        pub const CR = @intToPtr(*volatile [2]Mmio(32, packed struct {
            /// Timer counter capture value.
            CAP: u32,
        }), base_address + 0x2c);

        /// address: 0x4000403c
        /// External Match Register. The EMR controls the external match pins.
        pub const EMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// External Match 0. When a match occurs between the TC and MR0, this bit can
            /// either toggle, go low, go high, or do nothing, depending on bits 5:4 of this
            /// register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner
            /// (0 = low, 1 = high).
            EM0: u1,
            /// External Match 1. When a match occurs between the TC and MR1, this bit can
            /// either toggle, go low, go high, or do nothing, depending on bits 7:6 of this
            /// register. This bit can be driven onto a MATn.1 pin, in a positive-logic manner
            /// (0 = low, 1 = high).
            EM1: u1,
            /// External Match 2. When a match occurs between the TC and MR2, this bit can
            /// either toggle, go low, go high, or do nothing, depending on bits 9:8 of this
            /// register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner
            /// (0 = low, 1 = high).
            EM2: u1,
            /// External Match 3. When a match occurs between the TC and MR3, this bit can
            /// either toggle, go low, go high, or do nothing, depending on bits 11:10 of this
            /// register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner
            /// (0 = low, 1 = high).
            EM3: u1,
            /// External Match Control 0. Determines the functionality of External Match 0.
            EMC0: u2,
            /// External Match Control 1. Determines the functionality of External Match 1.
            EMC1: u2,
            /// External Match Control 2. Determines the functionality of External Match 2.
            EMC2: u2,
            /// External Match Control 3. Determines the functionality of External Match 3.
            EMC3: u2,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u20,
        }), base_address + 0x3c);

        /// address: 0x40004070
        /// Count Control Register. The CTCR selects between Timer and Counter mode, and in
        /// Counter mode selects the signal and edge(s) for counting.
        pub const CTCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter/Timer Mode This field selects which rising PCLK edges can increment
            /// Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC).
            /// Timer Mode: the TC is incremented when the Prescale Counter matches the Prescale
            /// Register.
            CTMODE: u2,
            /// Count Input Select When bits 1:0 in this register are not 00, these bits select
            /// which CAP pin is sampled for clocking. Note: If Counter mode is selected for a
            /// particular CAPn input in the TnCTCR, the 3 bits for that input in the Capture
            /// Control Register (TnCCR) must be programmed as 000. However, capture and/or
            /// interrupt can be selected for the other 3 CAPn inputs in the same timer.
            CINSEL: u2,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u28,
        }), base_address + 0x70);
    };
    pub const TIMER1 = struct {
        pub const base_address = 0x40008000;

        /// address: 0x40008000
        /// Interrupt Register. The IR can be written to clear interrupts. The IR can be
        /// read to identify which of eight possible interrupt sources are pending.
        pub const IR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt flag for match channel 0.
            MR0INT: u1,
            /// Interrupt flag for match channel 1.
            MR1INT: u1,
            /// Interrupt flag for match channel 2.
            MR2INT: u1,
            /// Interrupt flag for match channel 3.
            MR3INT: u1,
            /// Interrupt flag for capture channel 0 event.
            CR0INT: u1,
            /// Interrupt flag for capture channel 1 event.
            CR1INT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u26,
        }), base_address + 0x0);

        /// address: 0x40008004
        /// Timer Control Register. The TCR is used to control the Timer Counter functions.
        /// The Timer Counter can be disabled or reset through the TCR.
        pub const TCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// When one, the Timer Counter and Prescale Counter are enabled for counting. When
            /// zero, the counters are disabled.
            CEN: u1,
            /// When one, the Timer Counter and the Prescale Counter are synchronously reset on
            /// the next positive edge of PCLK. The counters remain reset until TCR[1] is
            /// returned to zero.
            CRST: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u30,
        }), base_address + 0x4);

        /// address: 0x40008008
        /// Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is
        /// controlled through the TCR.
        pub const TC = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4000800c
        /// Prescale Register. When the Prescale Counter (PC) is equal to this value, the
        /// next clock increments the TC and clears the PC.
        pub const PR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescale counter maximum value.
            PM: u32,
        }), base_address + 0xc);

        /// address: 0x40008010
        /// Prescale Counter. The 32 bit PC is a counter which is incremented to the value
        /// stored in PR. When the value in PR is reached, the TC is incremented and the PC
        /// is cleared. The PC is observable and controllable through the bus interface.
        pub const PC = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40008014
        /// Match Control Register. The MCR is used to control if an interrupt is generated
        /// and if the TC is reset when a Match occurs.
        pub const MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt on MR0
            MR0I: u1,
            /// Reset on MR0
            MR0R: u1,
            /// Stop on MR0
            MR0S: u1,
            /// Interrupt on MR1
            MR1I: u1,
            /// Reset on MR1
            MR1R: u1,
            /// Stop on MR1
            MR1S: u1,
            /// Interrupt on MR2
            MR2I: u1,
            /// Reset on MR2
            MR2R: u1,
            /// Stop on MR2.
            MR2S: u1,
            /// Interrupt on MR3
            MR3I: u1,
            /// Reset on MR3
            MR3R: u1,
            /// Stop on MR3
            MR3S: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u20,
        }), base_address + 0x14);

        /// address: 0x40008018
        /// Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both
        /// the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
        pub const MR = @intToPtr(*volatile [4]Mmio(32, packed struct {
            /// Timer counter match value.
            MATCH: u32,
        }), base_address + 0x18);

        /// address: 0x40008028
        /// Capture Control Register. The CCR controls which edges of the capture inputs are
        /// used to load the Capture Registers and whether or not an interrupt is generated
        /// when a capture takes place.
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture on CAPn.0 rising edge
            CAP0RE: u1,
            /// Capture on CAPn.0 falling edge
            CAP0FE: u1,
            /// Interrupt on CAPn.0 event
            CAP0I: u1,
            /// Capture on CAPn.1 rising edge
            CAP1RE: u1,
            /// Capture on CAPn.1 falling edge
            CAP1FE: u1,
            /// Interrupt on CAPn.1 event
            CAP1I: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u26,
        }), base_address + 0x28);

        /// address: 0x4000802c
        /// Capture Register 0. CR0 is loaded with the value of TC when there is an event on
        /// the CAPn.0 input.
        pub const CR = @intToPtr(*volatile [2]Mmio(32, packed struct {
            /// Timer counter capture value.
            CAP: u32,
        }), base_address + 0x2c);

        /// address: 0x4000803c
        /// External Match Register. The EMR controls the external match pins.
        pub const EMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// External Match 0. When a match occurs between the TC and MR0, this bit can
            /// either toggle, go low, go high, or do nothing, depending on bits 5:4 of this
            /// register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner
            /// (0 = low, 1 = high).
            EM0: u1,
            /// External Match 1. When a match occurs between the TC and MR1, this bit can
            /// either toggle, go low, go high, or do nothing, depending on bits 7:6 of this
            /// register. This bit can be driven onto a MATn.1 pin, in a positive-logic manner
            /// (0 = low, 1 = high).
            EM1: u1,
            /// External Match 2. When a match occurs between the TC and MR2, this bit can
            /// either toggle, go low, go high, or do nothing, depending on bits 9:8 of this
            /// register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner
            /// (0 = low, 1 = high).
            EM2: u1,
            /// External Match 3. When a match occurs between the TC and MR3, this bit can
            /// either toggle, go low, go high, or do nothing, depending on bits 11:10 of this
            /// register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner
            /// (0 = low, 1 = high).
            EM3: u1,
            /// External Match Control 0. Determines the functionality of External Match 0.
            EMC0: u2,
            /// External Match Control 1. Determines the functionality of External Match 1.
            EMC1: u2,
            /// External Match Control 2. Determines the functionality of External Match 2.
            EMC2: u2,
            /// External Match Control 3. Determines the functionality of External Match 3.
            EMC3: u2,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u20,
        }), base_address + 0x3c);

        /// address: 0x40008070
        /// Count Control Register. The CTCR selects between Timer and Counter mode, and in
        /// Counter mode selects the signal and edge(s) for counting.
        pub const CTCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter/Timer Mode This field selects which rising PCLK edges can increment
            /// Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC).
            /// Timer Mode: the TC is incremented when the Prescale Counter matches the Prescale
            /// Register.
            CTMODE: u2,
            /// Count Input Select When bits 1:0 in this register are not 00, these bits select
            /// which CAP pin is sampled for clocking. Note: If Counter mode is selected for a
            /// particular CAPn input in the TnCTCR, the 3 bits for that input in the Capture
            /// Control Register (TnCCR) must be programmed as 000. However, capture and/or
            /// interrupt can be selected for the other 3 CAPn inputs in the same timer.
            CINSEL: u2,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u28,
        }), base_address + 0x70);
    };
    /// UART0/2/3
    pub const UART0 = struct {
        pub const base_address = 0x4000c000;

        /// address: 0x4000c000
        /// Receiver Buffer Register. Contains the next received character to be read (DLAB
        /// =0).
        pub const RBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The UARTn Receiver Buffer Register contains the oldest received byte in the
            /// UARTn Rx FIFO.
            RBR: u8,
            /// Reserved, the value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x0);

        /// address: 0x4000c000
        /// Transmit Holding Regiter. The next character to be transmitted is written here
        /// (DLAB =0).
        pub const THR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing to the UARTn Transmit Holding Register causes the data to be stored in
            /// the UARTn transmit FIFO. The byte will be sent when it reaches the bottom of the
            /// FIFO and the transmitter is available.
            THR: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED0: u8,
            RESERVED1: u16,
        }), base_address + 0x0);

        /// address: 0x4000c000
        /// Divisor Latch LSB. Least significant byte of the baud rate divisor value. The
        /// full divisor is used to generate a baud rate from the fractional rate divider
        /// (DLAB =1).
        pub const DLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The UARTn Divisor Latch LSB Register, along with the UnDLM register, determines
            /// the baud rate of the UARTn.
            DLLSB: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED0: u8,
            RESERVED1: u16,
        }), base_address + 0x0);

        /// address: 0x4000c004
        /// Divisor Latch MSB. Most significant byte of the baud rate divisor value. The
        /// full divisor is used to generate a baud rate from the fractional rate divider
        /// (DLAB =1).
        pub const DLM = @intToPtr(*volatile Mmio(32, packed struct {
            /// The UARTn Divisor Latch MSB Register, along with the U0DLL register, determines
            /// the baud rate of the UARTn.
            DLMSB: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED0: u8,
            RESERVED1: u16,
        }), base_address + 0x4);

        /// address: 0x4000c004
        /// Interrupt Enable Register. Contains individual interrupt enable bits for the 7
        /// potential UART interrupts (DLAB =0).
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// RBR Interrupt Enable. Enables the Receive Data Available interrupt for UARTn. It
            /// also controls the Character Receive Time-out interrupt.
            RBRIE: u1,
            /// THRE Interrupt Enable. Enables the THRE interrupt for UARTn. The status of this
            /// can be read from UnLSR[5].
            THREIE: u1,
            /// RX Line Status Interrupt Enable. Enables the UARTn RX line status interrupts.
            /// The status of this interrupt can be read from UnLSR[4:1].
            RXIE: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u5,
            /// Enables the end of auto-baud interrupt.
            ABEOINTEN: u1,
            /// Enables the auto-baud time-out interrupt.
            ABTOINTEN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u22,
        }), base_address + 0x4);

        /// address: 0x4000c008
        /// Interrupt ID Register. Identifies which interrupt(s) are pending.
        pub const IIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt status. Note that UnIIR[0] is active low. The pending interrupt can be
            /// determined by evaluating UnIIR[3:1].
            INTSTATUS: u1,
            /// Interrupt identification. UnIER[3:1] identifies an interrupt corresponding to
            /// the UARTn Rx or TX FIFO. All other combinations of UnIER[3:1] not listed below
            /// are reserved (000,100,101,111).
            INTID: u3,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u2,
            /// Copies of UnFCR[0].
            FIFOENABLE: u2,
            /// End of auto-baud interrupt. True if auto-baud has finished successfully and
            /// interrupt is enabled.
            ABEOINT: u1,
            /// Auto-baud time-out interrupt. True if auto-baud has timed out and interrupt is
            /// enabled.
            ABTOINT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u22,
        }), base_address + 0x8);

        /// address: 0x4000c008
        /// FIFO Control Register. Controls UART FIFO usage and modes.
        pub const FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO Enable.
            FIFOEN: u1,
            /// RX FIFO Reset.
            RXFIFORES: u1,
            /// TX FIFO Reset.
            TXFIFORES: u1,
            /// DMA Mode Select. When the FIFO enable (bit 0 of this register) is set, this bit
            /// selects the DMA mode. See Section 18.6.6.1.
            DMAMODE: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u2,
            /// RX Trigger Level. These two bits determine how many receiver UARTn FIFO
            /// characters must be written before an interrupt or DMA request is activated.
            RXTRIGLVL: u2,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED0: u8,
            RESERVED1: u16,
        }), base_address + 0x8);

        /// address: 0x4000c00c
        /// Line Control Register. Contains controls for frame formatting and break
        /// generation.
        pub const LCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Word Length Select.
            WLS: u2,
            /// Stop Bit Select
            SBS: u1,
            /// Parity Enable.
            PE: u1,
            /// Parity Select
            PS: u2,
            /// Break Control
            BC: u1,
            /// Divisor Latch Access Bit
            DLAB: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xc);

        /// address: 0x4000c014
        /// Line Status Register. Contains flags for transmit and receive status, including
        /// line errors.
        pub const LSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver Data Ready. UnLSR[0] is set when the UnRBR holds an unread character
            /// and is cleared when the UARTn RBR FIFO is empty.
            RDR: u1,
            /// Overrun Error. The overrun error condition is set as soon as it occurs. An UnLSR
            /// read clears UnLSR[1]. UnLSR[1] is set when UARTn RSR has a new character
            /// assembled and the UARTn RBR FIFO is full. In this case, the UARTn RBR FIFO will
            /// not be overwritten and the character in the UARTn RSR will be lost.
            OE: u1,
            /// Parity Error. When the parity bit of a received character is in the wrong state,
            /// a parity error occurs. An UnLSR read clears UnLSR[2]. Time of parity error
            /// detection is dependent on UnFCR[0]. Note: A parity error is associated with the
            /// character at the top of the UARTn RBR FIFO.
            PE: u1,
            /// Framing Error. When the stop bit of a received character is a logic 0, a framing
            /// error occurs. An UnLSR read clears UnLSR[3]. The time of the framing error
            /// detection is dependent on UnFCR[0]. Upon detection of a framing error, the Rx
            /// will attempt to resynchronize to the data and assume that the bad stop bit is
            /// actually an early start bit. However, it cannot be assumed that the next
            /// received byte will be correct even if there is no Framing Error. Note: A framing
            /// error is associated with the character at the top of the UARTn RBR FIFO.
            FE: u1,
            /// Break Interrupt. When RXDn is held in the spacing state (all zeroes) for one
            /// full character transmission (start, data, parity, stop), a break interrupt
            /// occurs. Once the break condition has been detected, the receiver goes idle until
            /// RXDn goes to marking state (all ones). An UnLSR read clears this status bit. The
            /// time of break detection is dependent on UnFCR[0]. Note: The break interrupt is
            /// associated with the character at the top of the UARTn RBR FIFO.
            BI: u1,
            /// Transmitter Holding Register Empty. THRE is set immediately upon detection of an
            /// empty UARTn THR and is cleared on a UnTHR write.
            THRE: u1,
            /// Transmitter Empty. TEMT is set when both UnTHR and UnTSR are empty; TEMT is
            /// cleared when either the UnTSR or the UnTHR contain valid data.
            TEMT: u1,
            /// Error in RX FIFO . UnLSR[7] is set when a character with a Rx error such as
            /// framing error, parity error or break interrupt, is loaded into the UnRBR. This
            /// bit is cleared when the UnLSR register is read and there are no subsequent
            /// errors in the UARTn FIFO.
            RXFE: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED0: u8,
            RESERVED1: u16,
        }), base_address + 0x14);

        /// address: 0x4000c01c
        /// Scratch Pad Register. 8-bit temporary storage for software.
        pub const SCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// A readable, writable byte.
            PAD: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED0: u8,
            RESERVED1: u16,
        }), base_address + 0x1c);

        /// address: 0x4000c020
        /// Auto-baud Control Register. Contains controls for the auto-baud feature.
        pub const ACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start bit. This bit is automatically cleared after auto-baud completion.
            START: u1,
            /// Auto-baud mode select bit.
            MODE: u1,
            /// Restart bit.
            AUTORESTART: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u5,
            /// End of auto-baud interrupt clear bit (write-only accessible). Writing a 1 will
            /// clear the corresponding interrupt in the UnIIR. Writing a 0 has no impact.
            ABEOINTCLR: u1,
            /// Auto-baud time-out interrupt clear bit (write-only accessible). Writing a 1 will
            /// clear the corresponding interrupt in the UnIIR. Writing a 0 has no impact.
            ABTOINTCLR: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u22,
        }), base_address + 0x20);

        /// address: 0x4000c028
        /// Fractional Divider Register. Generates a clock input for the baud rate divider.
        pub const FDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Baud-rate generation pre-scaler divisor value. If this field is 0, fractional
            /// baud-rate generator will not impact the UARTn baudrate.
            DIVADDVAL: u4,
            /// Baud-rate pre-scaler multiplier value. This field must be greater or equal 1 for
            /// UARTn to operate properly, regardless of whether the fractional baud-rate
            /// generator is used or not.
            MULVAL: u4,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED0: u8,
            RESERVED1: u16,
        }), base_address + 0x28);

        /// address: 0x4000c030
        /// Transmit Enable Register. Turns off UART transmitter for use with software flow
        /// control.
        pub const TER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u7,
            /// When this bit is 1, as it is after a Reset, data written to the THR is output on
            /// the TXD pin as soon as any preceding data has been sent. If this bit is cleared
            /// to 0 while a character is being sent, the transmission of that character is
            /// completed, but no further characters are sent until this bit is set again. In
            /// other words, a 0 in this bit blocks the transfer of characters from the THR or
            /// TX FIFO into the transmit shift register. Software implementing
            /// software-handshaking can clear this bit when it receives an XOFF character
            /// (DC3). Software can set this bit again when it receives an XON (DC1) character.
            TXEN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED0: u8,
            RESERVED1: u16,
        }), base_address + 0x30);

        /// address: 0x4000c04c
        /// RS-485/EIA-485 Control. Contains controls to configure various aspects of
        /// RS-485/EIA-485 modes.
        pub const RS485CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// NMM enable.
            NMMEN: u1,
            /// Receiver enable.
            RXDIS: u1,
            /// AAD enable.
            AADEN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u1,
            /// Direction control enable.
            DCTRL: u1,
            /// Direction control pin polarity. This bit reverses the polarity of the direction
            /// control signal on the Un_OE pin.
            OINV: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u26,
        }), base_address + 0x4c);

        /// address: 0x4000c050
        /// RS-485/EIA-485 address match. Contains the address match value for
        /// RS-485/EIA-485 mode.
        pub const RS485ADRMATCH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Contains the address match value.
            ADRMATCH: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x50);

        /// address: 0x4000c054
        /// RS-485/EIA-485 direction control delay.
        pub const RS485DLY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Contains the direction control (UnOE) delay value. This register works in
            /// conjunction with an 8-bit counter.
            DLY: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED0: u8,
            RESERVED1: u16,
        }), base_address + 0x54);
    };
    /// UART1
    pub const UART1 = struct {
        pub const base_address = 0x40010000;

        /// address: 0x40010000
        /// DLAB =0 Receiver Buffer Register. Contains the next received character to be
        /// read.
        pub const RBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The UART1 Receiver Buffer Register contains the oldest received byte in the
            /// UART1 RX FIFO.
            RBR: u8,
            /// Reserved, the value read from a reserved bit is not defined.
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40010000
        /// DLAB =0. Transmit Holding Register. The next character to be transmitted is
        /// written here.
        pub const THR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing to the UART1 Transmit Holding Register causes the data to be stored in
            /// the UART1 transmit FIFO. The byte will be sent when it reaches the bottom of the
            /// FIFO and the transmitter is available.
            THR: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40010000
        /// DLAB =1. Divisor Latch LSB. Least significant byte of the baud rate divisor
        /// value. The full divisor is used to generate a baud rate from the fractional rate
        /// divider.
        pub const DLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The UART1 Divisor Latch LSB Register, along with the U1DLM register, determines
            /// the baud rate of the UART1.
            DLLSB: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40010004
        /// DLAB =1. Divisor Latch MSB. Most significant byte of the baud rate divisor
        /// value. The full divisor is used to generate a baud rate from the fractional rate
        /// divider.
        pub const DLM = @intToPtr(*volatile Mmio(32, packed struct {
            /// The UART1 Divisor Latch MSB Register, along with the U1DLL register, determines
            /// the baud rate of the UART1.
            DLMSB: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40010004
        /// DLAB =0. Interrupt Enable Register. Contains individual interrupt enable bits
        /// for the 7 potential UART1 interrupts.
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// RBR Interrupt Enable. Enables the Receive Data Available interrupt for UART1. It
            /// also controls the Character Receive Time-out interrupt.
            RBRIE: u1,
            /// THRE Interrupt Enable. Enables the THRE interrupt for UART1. The status of this
            /// interrupt can be read from LSR[5].
            THREIE: u1,
            /// RX Line Interrupt Enable. Enables the UART1 RX line status interrupts. The
            /// status of this interrupt can be read from LSR[4:1].
            RXIE: u1,
            /// Modem Status Interrupt Enable. Enables the modem interrupt. The status of this
            /// interrupt can be read from MSR[3:0].
            MSIE: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u3,
            /// CTS Interrupt Enable. If auto-cts mode is enabled this bit enables/disables the
            /// modem status interrupt generation on a CTS1 signal transition. If auto-cts mode
            /// is disabled a CTS1 transition will generate an interrupt if Modem Status
            /// Interrupt Enable (IER[3]) is set. In normal operation a CTS1 signal transition
            /// will generate a Modem Status Interrupt unless the interrupt has been disabled by
            /// clearing the IER[3] bit in the IER register. In auto-cts mode a transition on
            /// the CTS1 bit will trigger an interrupt only if both the IER[3] and IER[7] bits
            /// are set.
            CTSIE: u1,
            /// Enables the end of auto-baud interrupt.
            ABEOIE: u1,
            /// Enables the auto-baud time-out interrupt.
            ABTOIE: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u22,
        }), base_address + 0x4);

        /// address: 0x40010008
        /// Interrupt ID Register. Identifies which interrupt(s) are pending.
        pub const IIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt status. Note that IIR[0] is active low. The pending interrupt can be
            /// determined by evaluating IIR[3:1].
            INTSTATUS: u1,
            /// Interrupt identification. IER[3:1] identifies an interrupt corresponding to the
            /// UART1 Rx or TX FIFO. All other combinations of IER[3:1] not listed below are
            /// reserved (100,101,111).
            INTID: u3,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u2,
            /// Copies of FCR[0].
            FIFOENABLE: u2,
            /// End of auto-baud interrupt. True if auto-baud has finished successfully and
            /// interrupt is enabled.
            ABEOINT: u1,
            /// Auto-baud time-out interrupt. True if auto-baud has timed out and interrupt is
            /// enabled.
            ABTOINT: u1,
            /// Reserved, the value read from a reserved bit is not defined.
            RESERVED: u22,
        }), base_address + 0x8);

        /// address: 0x40010008
        /// FIFO Control Register. Controls UART1 FIFO usage and modes.
        pub const FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO enable.
            FIFOEN: u1,
            /// RX FIFO Reset.
            RXFIFORES: u1,
            /// TX FIFO Reset.
            TXFIFORES: u1,
            /// DMA Mode Select. When the FIFO enable bit (bit 0 of this register) is set, this
            /// bit selects the DMA mode. See Section 36.6.6.1.
            DMAMODE: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u2,
            /// RX Trigger Level. These two bits determine how many receiver UART1 FIFO
            /// characters must be written before an interrupt is activated.
            RXTRIGLVL: u2,
            /// Reserved, user software should not write ones to reserved bits.
            RESERVED: u24,
        }), base_address + 0x8);

        /// address: 0x4001000c
        /// Line Control Register. Contains controls for frame formatting and break
        /// generation.
        pub const LCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Word Length Select.
            WLS: u2,
            /// Stop Bit Select.
            SBS: u1,
            /// Parity Enable.
            PE: u1,
            /// Parity Select.
            PS: u2,
            /// Break Control.
            BC: u1,
            /// Divisor Latch Access Bit (DLAB)
            DLAB: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xc);

        /// address: 0x40010010
        /// Modem Control Register. Contains controls for flow control handshaking and
        /// loopback mode.
        pub const MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DTR Control. Source for modem output pin, DTR. This bit reads as 0 when modem
            /// loopback mode is active.
            DTRCTRL: u1,
            /// RTS Control. Source for modem output pin RTS. This bit reads as 0 when modem
            /// loopback mode is active.
            RTSCTRL: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u2,
            /// Loopback Mode Select. The modem loopback mode provides a mechanism to perform
            /// diagnostic loopback testing. Serial data from the transmitter is connected
            /// internally to serial input of the receiver. Input pin, RXD1, has no effect on
            /// loopback and output pin, TXD1 is held in marking state. The 4 modem inputs (CTS,
            /// DSR, RI and DCD) are disconnected externally. Externally, the modem outputs
            /// (RTS, DTR) are set inactive. Internally, the 4 modem outputs are connected to
            /// the 4 modem inputs. As a result of these connections, the upper 4 bits of the
            /// MSR will be driven by the lower 4 bits of the MCR rather than the 4 modem inputs
            /// in normal mode. This permits modem status interrupts to be generated in loopback
            /// mode by writing the lower 4 bits of MCR.
            LMS: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u1,
            /// RTS enable.
            RTSEN: u1,
            /// CTS enable.
            CTSEN: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x10);

        /// address: 0x40010014
        /// Line Status Register. Contains flags for transmit and receive status, including
        /// line errors.
        pub const LSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver Data Ready. LSR[0] is set when the RBR holds an unread character and is
            /// cleared when the UART1 RBR FIFO is empty.
            RDR: u1,
            /// Overrun Error. The overrun error condition is set as soon as it occurs. An LSR
            /// read clears LSR[1]. LSR[1] is set when UART1 RSR has a new character assembled
            /// and the UART1 RBR FIFO is full. In this case, the UART1 RBR FIFO will not be
            /// overwritten and the character in the UART1 RSR will be lost.
            OE: u1,
            /// Parity Error. When the parity bit of a received character is in the wrong state,
            /// a parity error occurs. An LSR read clears LSR[2]. Time of parity error detection
            /// is dependent on FCR[0]. Note: A parity error is associated with the character at
            /// the top of the UART1 RBR FIFO.
            PE: u1,
            /// Framing Error. When the stop bit of a received character is a logic 0, a framing
            /// error occurs. An LSR read clears LSR[3]. The time of the framing error detection
            /// is dependent on FCR0. Upon detection of a framing error, the RX will attempt to
            /// resynchronize to the data and assume that the bad stop bit is actually an early
            /// start bit. However, it cannot be assumed that the next received byte will be
            /// correct even if there is no Framing Error. Note: A framing error is associated
            /// with the character at the top of the UART1 RBR FIFO.
            FE: u1,
            /// Break Interrupt. When RXD1 is held in the spacing state (all zeroes) for one
            /// full character transmission (start, data, parity, stop), a break interrupt
            /// occurs. Once the break condition has been detected, the receiver goes idle until
            /// RXD1 goes to marking state (all ones). An LSR read clears this status bit. The
            /// time of break detection is dependent on FCR[0]. Note: The break interrupt is
            /// associated with the character at the top of the UART1 RBR FIFO.
            BI: u1,
            /// Transmitter Holding Register Empty. THRE is set immediately upon detection of an
            /// empty UART1 THR and is cleared on a THR write.
            THRE: u1,
            /// Transmitter Empty. TEMT is set when both THR and TSR are empty; TEMT is cleared
            /// when either the TSR or the THR contain valid data.
            TEMT: u1,
            /// Error in RX FIFO. LSR[7] is set when a character with a RX error such as framing
            /// error, parity error or break interrupt, is loaded into the RBR. This bit is
            /// cleared when the LSR register is read and there are no subsequent errors in the
            /// UART1 FIFO.
            RXFE: u1,
            /// Reserved, the value read from a reserved bit is not defined.
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x40010018
        /// Modem Status Register. Contains handshake signal status flags.
        pub const MSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Delta CTS. Set upon state change of input CTS. Cleared on an MSR read.
            DCTS: u1,
            /// Delta DSR. Set upon state change of input DSR. Cleared on an MSR read.
            DDSR: u1,
            /// Trailing Edge RI. Set upon low to high transition of input RI. Cleared on an MSR
            /// read.
            TERI: u1,
            /// Delta DCD. Set upon state change of input DCD. Cleared on an MSR read.
            DDCD: u1,
            /// Clear To Send State. Complement of input signal CTS. This bit is connected to
            /// MCR[1] in modem loopback mode.
            CTS: u1,
            /// Data Set Ready State. Complement of input signal DSR. This bit is connected to
            /// MCR[0] in modem loopback mode.
            DSR: u1,
            /// Ring Indicator State. Complement of input RI. This bit is connected to MCR[2] in
            /// modem loopback mode.
            RI: u1,
            /// Data Carrier Detect State. Complement of input DCD. This bit is connected to
            /// MCR[3] in modem loopback mode.
            DCD: u1,
            /// Reserved, the value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x18);

        /// address: 0x4001001c
        /// Scratch Pad Register. 8-bit temporary storage for software.
        pub const SCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// A readable, writable byte.
            Pad: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x1c);

        /// address: 0x40010020
        /// Auto-baud Control Register. Contains controls for the auto-baud feature.
        pub const ACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto-baud start bit. This bit is automatically cleared after auto-baud
            /// completion.
            START: u1,
            /// Auto-baud mode select bit.
            MODE: u1,
            /// Auto-baud restart bit.
            AUTORESTART: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u5,
            /// End of auto-baud interrupt clear bit (write-only).
            ABEOINTCLR: u1,
            /// Auto-baud time-out interrupt clear bit (write-only).
            ABTOINTCLR: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u22,
        }), base_address + 0x20);

        /// address: 0x40010028
        /// Fractional Divider Register. Generates a clock input for the baud rate divider.
        pub const FDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Baud rate generation pre-scaler divisor value. If this field is 0, fractional
            /// baud rate generator will not impact the UART1 baud rate.
            DIVADDVAL: u4,
            /// Baud rate pre-scaler multiplier value. This field must be greater or equal 1 for
            /// UART1 to operate properly, regardless of whether the fractional baud rate
            /// generator is used or not.
            MULVAL: u4,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x28);

        /// address: 0x40010030
        /// Transmit Enable Register. Turns off UART transmitter for use with software flow
        /// control.
        pub const TER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u7,
            /// When this bit is 1, as it is after a Reset, data written to the THR is output on
            /// the TXD pin as soon as any preceding data has been sent. If this bit cleared to
            /// 0 while a character is being sent, the transmission of that character is
            /// completed, but no further characters are sent until this bit is set again. In
            /// other words, a 0 in this bit blocks the transfer of characters from the THR or
            /// TX FIFO into the transmit shift register. Software can clear this bit when it
            /// detects that the a hardware-handshaking TX-permit signal (CTS) has gone false,
            /// or with software handshaking, when it receives an XOFF character (DC3). Software
            /// can set this bit again when it detects that the TX-permit signal has gone true,
            /// or when it receives an XON (DC1) character.
            TXEN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x30);

        /// address: 0x4001004c
        /// RS-485/EIA-485 Control. Contains controls to configure various aspects of
        /// RS-485/EIA-485 modes.
        pub const RS485CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// RS-485/EIA-485 Normal Multidrop Mode (NMM) mode select.
            NMMEN: u1,
            /// Receive enable.
            RXDIS: u1,
            /// Auto Address Detect (AAD) enable.
            AADEN: u1,
            /// Direction control.
            SEL: u1,
            /// Direction control enable.
            DCTRL: u1,
            /// Polarity. This bit reverses the polarity of the direction control signal on the
            /// RTS (or DTR) pin.
            OINV: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u26,
        }), base_address + 0x4c);

        /// address: 0x40010050
        /// RS-485/EIA-485 address match. Contains the address match value for
        /// RS-485/EIA-485 mode.
        pub const RS485ADRMATCH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Contains the address match value.
            ADRMATCH: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x50);

        /// address: 0x40010054
        /// RS-485/EIA-485 direction control delay.
        pub const RS485DLY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Contains the direction control (RTS or DTR) delay value. This register works in
            /// conjunction with an 8-bit counter.
            DLY: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x54);
    };
    /// Pulse Width Modulators (PWM1)
    pub const PWM1 = struct {
        pub const base_address = 0x40018000;

        /// address: 0x40018000
        /// Interrupt Register. The IR can be written to clear interrupts, or read to
        /// identify which PWM interrupt sources are pending.
        pub const IR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt flag for PWM match channel 0.
            PWMMR0INT: u1,
            /// Interrupt flag for PWM match channel 1.
            PWMMR1INT: u1,
            /// Interrupt flag for PWM match channel 2.
            PWMMR2INT: u1,
            /// Interrupt flag for PWM match channel 3.
            PWMMR3INT: u1,
            /// Interrupt flag for capture input 0
            PWMCAP0INT: u1,
            /// Interrupt flag for capture input 1 (available in PWM1IR only; this bit is
            /// reserved in PWM0IR).
            PWMCAP1INT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u2,
            /// Interrupt flag for PWM match channel 4.
            PWMMR4INT: u1,
            /// Interrupt flag for PWM match channel 5.
            PWMMR5INT: u1,
            /// Interrupt flag for PWM match channel 6.
            PWMMR6INT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u21,
        }), base_address + 0x0);

        /// address: 0x40018004
        /// Timer Control Register. The TCR is used to control the Timer Counter functions.
        pub const TCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter Enable
            CE: u1,
            /// Counter Reset
            CR: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u1,
            /// PWM Enable
            PWMEN: u1,
            /// Master Disable (PWM0 only). The two PWMs may be synchronized using the Master
            /// Disable control bit. The Master disable bit of the Master PWM (PWM0 module)
            /// controls a secondary enable input to both PWMs, as shown in Figure 141. This bit
            /// has no function in the Slave PWM (PWM1).
            MDIS: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u27,
        }), base_address + 0x4);

        /// address: 0x40018008
        /// Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is
        /// controlled through the TCR.
        pub const TC = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4001800c
        /// Prescale Register. Determines how often the PWM counter is incremented.
        pub const PR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescale counter maximum value.
            PM: u32,
        }), base_address + 0xc);

        /// address: 0x40018010
        /// Prescale Counter. Prescaler for the main PWM counter.
        pub const PC = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40018014
        /// Match Control Register. The MCR is used to control whether an interrupt is
        /// generated and if the PWM counter is reset when a Match occurs.
        pub const MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt PWM0
            PWMMR0I: u1,
            /// Reset PWM0
            PWMMR0R: u1,
            /// Stop PWM0
            PWMMR0S: u1,
            /// Interrupt PWM1
            PWMMR1I: u1,
            /// Reset PWM1
            PWMMR1R: u1,
            /// Stop PWM1
            PWMMR1S: u1,
            /// Interrupt PWM0
            PWMMR2I: u1,
            /// Reset PWM0
            PWMMR2R: u1,
            /// Stop PWM0
            PWMMR2S: u1,
            /// Interrupt PWM3
            PWMMR3I: u1,
            /// Reset PWM3
            PWMMR3R: u1,
            /// Stop PWM0
            PWMMR3S: u1,
            /// Interrupt PWM4
            PWMMR4I: u1,
            /// Reset PWM4
            PWMMR4R: u1,
            /// Stop PWM4
            PWMMR4S: u1,
            /// Interrupt PWM5
            PWMMR5I: u1,
            /// Reset PWM5
            PWMMR5R: u1,
            /// Stop PWM5
            PWMMR5S: u1,
            /// Interrupt PWM6
            PWMMR6I: u1,
            /// Reset PWM6
            PWMMR6R: u1,
            /// Stop PWM6
            PWMMR6S: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u11,
        }), base_address + 0x14);

        /// address: 0x40018018
        /// Match Register. Match registers
        /// are continuously compared to the PWM counter in order to control PWM
        /// output edges.
        pub const MR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer counter match value.
            MATCH: u32,
        }), base_address + 0x18);

        /// address: 0x4001801c
        /// Match Register. Match registers
        /// are continuously compared to the PWM counter in order to control PWM
        /// output edges.
        pub const MR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer counter match value.
            MATCH: u32,
        }), base_address + 0x1c);

        /// address: 0x40018020
        /// Match Register. Match registers
        /// are continuously compared to the PWM counter in order to control PWM
        /// output edges.
        pub const MR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer counter match value.
            MATCH: u32,
        }), base_address + 0x20);

        /// address: 0x40018024
        /// Match Register. Match registers
        /// are continuously compared to the PWM counter in order to control PWM
        /// output edges.
        pub const MR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer counter match value.
            MATCH: u32,
        }), base_address + 0x24);

        /// address: 0x40018028
        /// Capture Control Register. The CCR controls which edges of the capture inputs are
        /// used to load the Capture Registers and whether or not an interrupt is generated
        /// for a capture event.
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture on PWMn_CAP0 rising edge
            CAP0_R: u1,
            /// Capture on PWMn_CAP0 falling edge
            CAP0_F: u1,
            /// Interrupt on PWMn_CAP0 event
            CAP0_I: u1,
            /// Capture on PWMn_CAP1 rising edge. Reserved for PWM0.
            CAP1_R: u1,
            /// Capture on PWMn_CAP1 falling edge. Reserved for PWM0.
            CAP1_F: u1,
            /// Interrupt on PWMn_CAP1 event. Reserved for PWM0.
            CAP1_I: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u26,
        }), base_address + 0x28);

        /// address: 0x4001802c
        /// PWM Control Register. Enables PWM outputs and selects either single edge or
        /// double edge controlled PWM outputs.
        pub const CR = @intToPtr(*volatile [2]Mmio(32, packed struct {
            /// Reserved.
            RESERVED: u2,
            /// PWM[2] output single/double edge mode control.
            PWMSEL2: u1,
            /// PWM[3] output edge control.
            PWMSEL3: u1,
            /// PWM[4] output edge control.
            PWMSEL4: u1,
            /// PWM[5] output edge control.
            PWMSEL5: u1,
            /// PWM[6] output edge control.
            PWMSEL6: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u2,
            /// PWM[1] output enable control.
            PWMENA1: u1,
            /// PWM[2] output enable control.
            PWMENA2: u1,
            /// PWM[3] output enable control.
            PWMENA3: u1,
            /// PWM[4] output enable control.
            PWMENA4: u1,
            /// PWM[5] output enable control.
            PWMENA5: u1,
            /// PWM[6] output enable control. See PWMENA1 for details.
            PWMENA6: u1,
            /// Unused, always zero.
            RESERVED: u17,
        }), base_address + 0x2c);

        /// address: 0x40018040
        /// Match Register. Match registers
        /// are continuously compared to the PWM counter in order to control PWM
        /// output edges.
        pub const MR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer counter match value.
            MATCH: u32,
        }), base_address + 0x40);

        /// address: 0x40018044
        /// Match Register. Match registers
        /// are continuously compared to the PWM counter in order to control PWM
        /// output edges.
        pub const MR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer counter match value.
            MATCH: u32,
        }), base_address + 0x44);

        /// address: 0x40018048
        /// Match Register. Match registers
        /// are continuously compared to the PWM counter in order to control PWM
        /// output edges.
        pub const MR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer counter match value.
            MATCH: u32,
        }), base_address + 0x48);

        /// address: 0x4001804c
        /// PWM Control Register. Enables PWM outputs and selects either single edge or
        /// double edge controlled PWM outputs.
        pub const PCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved.
            RESERVED: u2,
            /// PWM[2] output single/double edge mode control.
            PWMSEL2: u1,
            /// PWM[3] output edge control.
            PWMSEL3: u1,
            /// PWM[4] output edge control.
            PWMSEL4: u1,
            /// PWM[5] output edge control.
            PWMSEL5: u1,
            /// PWM[6] output edge control.
            PWMSEL6: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u2,
            /// PWM[1] output enable control.
            PWMENA1: u1,
            /// PWM[2] output enable control.
            PWMENA2: u1,
            /// PWM[3] output enable control.
            PWMENA3: u1,
            /// PWM[4] output enable control.
            PWMENA4: u1,
            /// PWM[5] output enable control.
            PWMENA5: u1,
            /// PWM[6] output enable control. See PWMENA1 for details.
            PWMENA6: u1,
            /// Unused, always zero.
            RESERVED: u17,
        }), base_address + 0x4c);

        /// address: 0x40018050
        /// Load Enable Register. Enables use of updated PWM match values.
        pub const LER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable PWM Match 0 Latch. PWM MR0 register update control. Writing a one to this
            /// bit allows the last value written to the PWM Match Register 0 to be become
            /// effective when the timer is next reset by a PWM Match event. See Section 27.6.7.
            MAT0LATCHEN: u1,
            /// Enable PWM Match 1 Latch. PWM MR1 register update control. See bit 0 for
            /// details.
            MAT1LATCHEN: u1,
            /// Enable PWM Match 2 Latch. PWM MR2 register update control. See bit 0 for
            /// details.
            MAT2LATCHEN: u1,
            /// Enable PWM Match 3 Latch. PWM MR3 register update control. See bit 0 for
            /// details.
            MAT3LATCHEN: u1,
            /// Enable PWM Match 4 Latch. PWM MR4 register update control. See bit 0 for
            /// details.
            MAT4LATCHEN: u1,
            /// Enable PWM Match 5 Latch. PWM MR5 register update control. See bit 0 for
            /// details.
            MAT5LATCHEN: u1,
            /// Enable PWM Match 6 Latch. PWM MR6 register update control. See bit 0 for
            /// details.
            MAT6LATCHEN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u25,
        }), base_address + 0x50);

        /// address: 0x40018070
        /// Count Control Register. The CTCR selects between Timer and Counter mode, and in
        /// Counter mode selects the signal and edge(s) for counting.
        pub const CTCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter/ Timer Mode
            MOD: u2,
            /// Count Input Select. When bits 1:0 are not 00, these bits select which PWM_CAP
            /// pin carries the signal used to increment the TC. Other combinations are
            /// reserved.
            CIS: u2,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u28,
        }), base_address + 0x70);
    };
    /// I2C bus interface
    pub const I2C0 = struct {
        pub const base_address = 0x4001c000;

        /// address: 0x4001c000
        /// I2C Control Set Register. When a one is written to a bit of this register, the
        /// corresponding bit in the I2C control register is set. Writing a zero has no
        /// effect on the corresponding bit in the I2C control register.
        pub const CONSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. User software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u2,
            /// Assert acknowledge flag.
            AA: u1,
            /// I2C interrupt flag.
            SI: u1,
            /// STOP flag.
            STO: u1,
            /// START flag.
            STA: u1,
            /// I2C interface enable.
            I2EN: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u25,
        }), base_address + 0x0);

        /// address: 0x4001c004
        /// I2C Status Register. During I2C operation, this register provides detailed
        /// status codes that allow software to determine the next action needed.
        pub const STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits are unused and are always 0.
            RESERVED: u3,
            /// These bits give the actual status information about the I 2C interface.
            Status: u5,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x4);

        /// address: 0x4001c008
        /// I2C Data Register. During master or slave transmit mode, data to be transmitted
        /// is written to this register. During master or slave receive mode, data that has
        /// been received may be read from this register.
        pub const DAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register holds data values that have been received or are to be
            /// transmitted.
            Data: u8,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x8);

        /// address: 0x4001c00c
        /// I2C Slave Address Register 0. Contains the 7-bit slave address for operation of
        /// the I2C interface in slave mode, and is not used in master mode. The least
        /// significant bit determines whether a slave responds to the General Call address.
        pub const ADR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// General Call enable bit.
            GC: u1,
            /// The I2C device address for slave mode.
            Address: u7,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0xc);

        /// address: 0x4001c010
        /// SCH Duty Cycle Register High Half Word. Determines the high time of the I2C
        /// clock.
        pub const SCLH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Count for SCL HIGH time period selection.
            SCLH: u16,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u16,
        }), base_address + 0x10);

        /// address: 0x4001c014
        /// SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock.
        /// SCLL and SCLH together determine the clock frequency generated by an I2C master
        /// and certain times used in slave mode.
        pub const SCLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Count for SCL low time period selection.
            SCLL: u16,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u16,
        }), base_address + 0x14);

        /// address: 0x4001c018
        /// I2C Control Clear Register. When a one is written to a bit of this register, the
        /// corresponding bit in the I2C control register is cleared. Writing a zero has no
        /// effect on the corresponding bit in the I2C control register.
        pub const CONCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. User software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u2,
            /// Assert acknowledge Clear bit.
            AAC: u1,
            /// I2C interrupt Clear bit.
            SIC: u1,
            /// Reserved. User software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u1,
            /// START flag Clear bit.
            STAC: u1,
            /// I2C interface Disable bit.
            I2ENC: u1,
            /// Reserved. User software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x18);

        /// address: 0x4001c01c
        /// Monitor mode control register.
        pub const MMCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Monitor mode enable.
            MM_ENA: u1,
            /// SCL output enable.
            ENA_SCL: u1,
            /// Select interrupt register match.
            MATCH_ALL: u1,
            /// Reserved. The value read from reserved bits is not defined.
            RESERVED: u29,
        }), base_address + 0x1c);

        /// address: 0x4001c020
        /// I2C Slave Address Register. Contains the 7-bit slave address for operation of
        /// the I2C interface in slave mode, and is not used in master mode. The least
        /// significant bit determines whether a slave responds to the General Call address.
        pub const ADR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// General Call enable bit.
            GC: u1,
            /// The I2C device address for slave mode.
            Address: u7,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x20);

        /// address: 0x4001c024
        /// I2C Slave Address Register. Contains the 7-bit slave address for operation of
        /// the I2C interface in slave mode, and is not used in master mode. The least
        /// significant bit determines whether a slave responds to the General Call address.
        pub const ADR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// General Call enable bit.
            GC: u1,
            /// The I2C device address for slave mode.
            Address: u7,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x24);

        /// address: 0x4001c028
        /// I2C Slave Address Register. Contains the 7-bit slave address for operation of
        /// the I2C interface in slave mode, and is not used in master mode. The least
        /// significant bit determines whether a slave responds to the General Call address.
        pub const ADR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// General Call enable bit.
            GC: u1,
            /// The I2C device address for slave mode.
            Address: u7,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x28);

        /// address: 0x4001c02c
        /// Data buffer register. The contents of the 8 MSBs of the DAT shift register will
        /// be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of
        /// data plus ACK or NACK) has been received on the bus.
        pub const DATA_BUFFER = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register holds contents of the 8 MSBs of the DAT shift register.
            Data: u8,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x2c);

        /// address: 0x4001c030
        /// I2C Slave address mask register
        pub const MASK = @intToPtr(*volatile [4]Mmio(32, packed struct {
            /// Reserved. User software should not write ones to reserved bits. This bit reads
            /// always back as 0.
            RESERVED: u1,
            /// Mask bits.
            MASK: u7,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x30);
    };
    /// SPI
    pub const SPI = struct {
        pub const base_address = 0x40020000;

        /// address: 0x40020000
        /// SPI Control Register. This register controls the operation of the SPI.
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u2,
            /// The SPI controller sends and receives 8 bits of data per transfer.
            BITENABLE: u1,
            /// Clock phase control determines the relationship between the data and the clock
            /// on SPI transfers, and controls when a slave transfer is defined as starting and
            /// ending.
            CPHA: u1,
            /// Clock polarity control.
            CPOL: u1,
            /// Master mode select.
            MSTR: u1,
            /// LSB First controls which direction each byte is shifted when transferred.
            LSBF: u1,
            /// Serial peripheral interrupt enable.
            SPIE: u1,
            /// When bit 2 of this register is 1, this field controls the number of bits per
            /// transfer:
            BITS: u4,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u20,
        }), base_address + 0x0);

        /// address: 0x40020004
        /// SPI Status Register. This register shows the status of the SPI.
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u3,
            /// Slave abort. When 1, this bit indicates that a slave abort has occurred. This
            /// bit is cleared by reading this register.
            ABRT: u1,
            /// Mode fault. when 1, this bit indicates that a Mode fault error has occurred.
            /// This bit is cleared by reading this register, then writing the SPI0 control
            /// register.
            MODF: u1,
            /// Read overrun. When 1, this bit indicates that a read overrun has occurred. This
            /// bit is cleared by reading this register.
            ROVR: u1,
            /// Write collision. When 1, this bit indicates that a write collision has occurred.
            /// This bit is cleared by reading this register, then accessing the SPI Data
            /// Register.
            WCOL: u1,
            /// SPI transfer complete flag. When 1, this bit indicates when a SPI data transfer
            /// is complete. When a master, this bit is set at the end of the last cycle of the
            /// transfer. When a slave, this bit is set on the last data sampling edge of the
            /// SCK. This bit is cleared by first reading this register, then accessing the SPI
            /// Data Register. Note: this is not the SPI interrupt flag. This flag is found in
            /// the SPINT register.
            SPIF: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x4);

        /// address: 0x40020008
        /// SPI Data Register. This bi-directional register provides the transmit and
        /// receive data for the SPI. Transmit data is provided to the SPI0 by writing to
        /// this register. Data received by the SPI0 can be read from this register.
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SPI Bi-directional data port.
            DATALOW: u8,
            /// If bit 2 of the SPCR is 1 and bits 11:8 are other than 1000, some or all of
            /// these bits contain the additional transmit and receive bits. When less than 16
            /// bits are selected, the more significant among these bits read as zeroes.
            DATAHIGH: u8,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u16,
        }), base_address + 0x8);

        /// address: 0x4002000c
        /// SPI Clock Counter Register. This register controls the frequency of a master's
        /// SCK0.
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SPI0 Clock counter setting.
            COUNTER: u8,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0xc);

        /// address: 0x4002001c
        /// SPI Interrupt Flag. This register contains the interrupt flag for the SPI
        /// interface.
        pub const INT = @intToPtr(*volatile Mmio(32, packed struct {
            /// SPI interrupt flag. Set by the SPI interface to generate an interrupt. Cleared
            /// by writing a 1 to this bit. Note: this bit will be set once when SPIE = 1 and at
            /// least one of SPIF and WCOL bits is 1. However, only when the SPI Interrupt bit
            /// is set and SPI0 Interrupt is enabled in the NVIC, SPI based interrupt can be
            /// processed by interrupt handling software.
            SPIF: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u7,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x1c);
    };
    /// Real Time Clock (RTC)
    pub const RTC = struct {
        pub const base_address = 0x40024000;

        /// address: 0x40024000
        /// Interrupt Location Register
        pub const ILR = @intToPtr(*volatile Mmio(32, packed struct {
            /// When one, the Counter Increment Interrupt block generated an interrupt. Writing
            /// a one to this bit location clears the counter increment interrupt.
            RTCCIF: u1,
            /// When one, the alarm registers generated an interrupt. Writing a one to this bit
            /// location clears the alarm interrupt.
            RTCALF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u11,
        }), base_address + 0x0);

        /// address: 0x40024008
        /// Clock Control Register
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock Enable.
            CLKEN: u1,
            /// CTC Reset.
            CTCRST: u1,
            /// Internal test mode controls. These bits must be 0 for normal RTC operation.
            RESERVED: u2,
            /// Calibration counter enable.
            CCALEN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u27,
        }), base_address + 0x8);

        /// address: 0x4002400c
        /// Counter Increment Interrupt Register
        pub const CIIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// When 1, an increment of the Second value generates an interrupt.
            IMSEC: u1,
            /// When 1, an increment of the Minute value generates an interrupt.
            IMMIN: u1,
            /// When 1, an increment of the Hour value generates an interrupt.
            IMHOUR: u1,
            /// When 1, an increment of the Day of Month value generates an interrupt.
            IMDOM: u1,
            /// When 1, an increment of the Day of Week value generates an interrupt.
            IMDOW: u1,
            /// When 1, an increment of the Day of Year value generates an interrupt.
            IMDOY: u1,
            /// When 1, an increment of the Month value generates an interrupt.
            IMMON: u1,
            /// When 1, an increment of the Year value generates an interrupt.
            IMYEAR: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0xc);

        /// address: 0x40024010
        /// Alarm Mask Register
        pub const AMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// When 1, the Second value is not compared for the alarm.
            AMRSEC: u1,
            /// When 1, the Minutes value is not compared for the alarm.
            AMRMIN: u1,
            /// When 1, the Hour value is not compared for the alarm.
            AMRHOUR: u1,
            /// When 1, the Day of Month value is not compared for the alarm.
            AMRDOM: u1,
            /// When 1, the Day of Week value is not compared for the alarm.
            AMRDOW: u1,
            /// When 1, the Day of Year value is not compared for the alarm.
            AMRDOY: u1,
            /// When 1, the Month value is not compared for the alarm.
            AMRMON: u1,
            /// When 1, the Year value is not compared for the alarm.
            AMRYEAR: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x10);

        /// address: 0x40024014
        /// Consolidated Time Register 0
        pub const CTIME0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Seconds value in the range of 0 to 59
            SECONDS: u6,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u2,
            /// Minutes value in the range of 0 to 59
            MINUTES: u6,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u2,
            /// Hours value in the range of 0 to 23
            HOURS: u5,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u3,
            /// Day of week value in the range of 0 to 6
            DOW: u3,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u5,
        }), base_address + 0x14);

        /// address: 0x40024018
        /// Consolidated Time Register 1
        pub const CTIME1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Day of month value in the range of 1 to 28, 29, 30, or 31 (depending on the
            /// month and whether it is a leap year).
            DOM: u5,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u3,
            /// Month value in the range of 1 to 12.
            MONTH: u4,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u4,
            /// Year value in the range of 0 to 4095.
            YEAR: u12,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u4,
        }), base_address + 0x18);

        /// address: 0x4002401c
        /// Consolidated Time Register 2
        pub const CTIME2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Day of year value in the range of 1 to 365 (366 for leap years).
            DOY: u12,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u20,
        }), base_address + 0x1c);

        /// address: 0x40024020
        /// Seconds Counter
        pub const SEC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Seconds value in the range of 0 to 59
            SECONDS: u6,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u26,
        }), base_address + 0x20);

        /// address: 0x40024024
        /// Minutes Register
        pub const MIN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Minutes value in the range of 0 to 59
            MINUTES: u6,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u26,
        }), base_address + 0x24);

        /// address: 0x40024028
        /// Hours Register
        pub const HRS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Hours value in the range of 0 to 23
            HOURS: u5,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u27,
        }), base_address + 0x28);

        /// address: 0x4002402c
        /// Day of Month Register
        pub const DOM = @intToPtr(*volatile Mmio(32, packed struct {
            /// Day of month value in the range of 1 to 28, 29, 30, or 31 (depending on the
            /// month and whether it is a leap year).
            DOM: u5,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u27,
        }), base_address + 0x2c);

        /// address: 0x40024030
        /// Day of Week Register
        pub const DOW = @intToPtr(*volatile Mmio(32, packed struct {
            /// Day of week value in the range of 0 to 6.
            DOW: u3,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u29,
        }), base_address + 0x30);

        /// address: 0x40024034
        /// Day of Year Register
        pub const DOY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Day of year value in the range of 1 to 365 (366 for leap years).
            DOY: u9,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u23,
        }), base_address + 0x34);

        /// address: 0x40024038
        /// Months Register
        pub const MONTH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Month value in the range of 1 to 12.
            MONTH: u4,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u28,
        }), base_address + 0x38);

        /// address: 0x4002403c
        /// Years Register
        pub const YEAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Year value in the range of 0 to 4095.
            YEAR: u12,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u20,
        }), base_address + 0x3c);

        /// address: 0x40024040
        /// Calibration Value Register
        pub const CALIBRATION = @intToPtr(*volatile Mmio(32, packed struct {
            /// If enabled, the calibration counter counts up to this value. The maximum value
            /// is 131, 072 corresponding to about 36.4 hours. Calibration is disabled if CALVAL
            /// = 0.
            CALVAL: u17,
            /// Calibration direction
            CALDIR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x40);

        /// address: 0x40024044
        /// General Purpose Register 0
        pub const GPREG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// General purpose storage.
            GP: u32,
        }), base_address + 0x44);

        /// address: 0x40024048
        /// General Purpose Register 0
        pub const GPREG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// General purpose storage.
            GP: u32,
        }), base_address + 0x48);

        /// address: 0x4002404c
        /// General Purpose Register 0
        pub const GPREG2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// General purpose storage.
            GP: u32,
        }), base_address + 0x4c);

        /// address: 0x40024050
        /// General Purpose Register 0
        pub const GPREG3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// General purpose storage.
            GP: u32,
        }), base_address + 0x50);

        /// address: 0x40024054
        /// General Purpose Register 0
        pub const GPREG4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// General purpose storage.
            GP: u32,
        }), base_address + 0x54);

        /// address: 0x4002405c
        /// RTC Auxiliary control register
        pub const RTC_AUX = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u4,
            /// RTC Oscillator Fail detect flag. Read: this bit is set if the RTC oscillator
            /// stops, and when RTC power is first turned on. An interrupt will occur when this
            /// bit is set, the RTC_OSCFEN bit in RTC_AUXEN is a 1, and the RTC interrupt is
            /// enabled in the NVIC. Write: writing a 1 to this bit clears the flag.
            RTC_OSCF: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u1,
            /// When 0: the RTC_ALARM pin reflects the RTC alarm status. When 1: the RTC_ALARM
            /// pin indicates Deep Power-down mode.
            RTC_PDOUT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u25,
        }), base_address + 0x5c);

        /// address: 0x40024058
        /// RTC Auxiliary Enable register
        pub const RTC_AUXEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u4,
            /// Oscillator Fail Detect interrupt enable. When 0: the RTC Oscillator Fail detect
            /// interrupt is disabled. When 1: the RTC Oscillator Fail detect interrupt is
            /// enabled. See Section 30.6.2.5.
            RTC_OSCFEN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u27,
        }), base_address + 0x58);

        /// address: 0x40024060
        /// Alarm value for Seconds
        pub const ASEC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Seconds value in the range of 0 to 59
            SECONDS: u6,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u26,
        }), base_address + 0x60);

        /// address: 0x40024064
        /// Alarm value for Minutes
        pub const AMIN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Minutes value in the range of 0 to 59
            MINUTES: u6,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u26,
        }), base_address + 0x64);

        /// address: 0x40024068
        /// Alarm value for Hours
        pub const AHRS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Hours value in the range of 0 to 23
            HOURS: u5,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u27,
        }), base_address + 0x68);

        /// address: 0x4002406c
        /// Alarm value for Day of Month
        pub const ADOM = @intToPtr(*volatile Mmio(32, packed struct {
            /// Day of month value in the range of 1 to 28, 29, 30, or 31 (depending on the
            /// month and whether it is a leap year).
            DOM: u5,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u27,
        }), base_address + 0x6c);

        /// address: 0x40024070
        /// Alarm value for Day of Week
        pub const ADOW = @intToPtr(*volatile Mmio(32, packed struct {
            /// Day of week value in the range of 0 to 6.
            DOW: u3,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u29,
        }), base_address + 0x70);

        /// address: 0x40024074
        /// Alarm value for Day of Year
        pub const ADOY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Day of year value in the range of 1 to 365 (366 for leap years).
            DOY: u9,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u23,
        }), base_address + 0x74);

        /// address: 0x40024078
        /// Alarm value for Months
        pub const AMON = @intToPtr(*volatile Mmio(32, packed struct {
            /// Month value in the range of 1 to 12.
            MONTH: u4,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u28,
        }), base_address + 0x78);

        /// address: 0x4002407c
        /// Alarm value for Year
        pub const AYRS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Year value in the range of 0 to 4095.
            YEAR: u12,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u20,
        }), base_address + 0x7c);
    };
    /// GPIO
    pub const GPIOINT = struct {
        pub const base_address = 0x40028080;

        /// address: 0x40028080
        /// GPIO overall Interrupt Status.
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 0 GPIO interrupt pending.
            P0INT: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u1,
            /// Port 2 GPIO interrupt pending.
            P2INT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x0);

        /// address: 0x40028084
        /// GPIO Interrupt Status for Rising edge for Port 0.
        pub const STATR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Status of Rising Edge Interrupt for P0[0]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_0REI: u1,
            /// Status of Rising Edge Interrupt for P0[1]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_1REI: u1,
            /// Status of Rising Edge Interrupt for P0[2]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_2REI: u1,
            /// Status of Rising Edge Interrupt for P0[3]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_3REI: u1,
            /// Status of Rising Edge Interrupt for P0[4]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_4REI: u1,
            /// Status of Rising Edge Interrupt for P0[5]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_5REI: u1,
            /// Status of Rising Edge Interrupt for P0[6]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_6REI: u1,
            /// Status of Rising Edge Interrupt for P0[7]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_7REI: u1,
            /// Status of Rising Edge Interrupt for P0[8]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_8REI: u1,
            /// Status of Rising Edge Interrupt for P0[9]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_9REI: u1,
            /// Status of Rising Edge Interrupt for P0[10]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_10REI: u1,
            /// Status of Rising Edge Interrupt for P0[11]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_11REI: u1,
            /// Status of Rising Edge Interrupt for P0[12]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_12REI: u1,
            /// Status of Rising Edge Interrupt for P0[13]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_13REI: u1,
            /// Status of Rising Edge Interrupt for P0[14]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_14REI: u1,
            /// Status of Rising Edge Interrupt for P0[15]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_15REI: u1,
            /// Status of Rising Edge Interrupt for P0[16]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_16REI: u1,
            /// Status of Rising Edge Interrupt for P0[17]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_17REI: u1,
            /// Status of Rising Edge Interrupt for P0[18]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_18REI: u1,
            /// Status of Rising Edge Interrupt for P0[19]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_19REI: u1,
            /// Status of Rising Edge Interrupt for P0[20]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_20REI: u1,
            /// Status of Rising Edge Interrupt for P0[21]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_21REI: u1,
            /// Status of Rising Edge Interrupt for P0[22]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_22REI: u1,
            /// Status of Rising Edge Interrupt for P0[23]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_23REI: u1,
            /// Status of Rising Edge Interrupt for P0[24]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_24REI: u1,
            /// Status of Rising Edge Interrupt for P0[25]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_25REI: u1,
            /// Status of Rising Edge Interrupt for P0[26]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_26REI: u1,
            /// Status of Rising Edge Interrupt for P0[27]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_27REI: u1,
            /// Status of Rising Edge Interrupt for P0[28]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_28REI: u1,
            /// Status of Rising Edge Interrupt for P0[29]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_29REI: u1,
            /// Status of Rising Edge Interrupt for P0[30]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P0_30REI: u1,
            /// Reserved.
            RESERVED: u1,
        }), base_address + 0x4);

        /// address: 0x40028088
        /// GPIO Interrupt Status for Falling edge for Port 0.
        pub const STATF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Status of Falling Edge Interrupt for P0[0]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_0FEI: u1,
            /// Status of Falling Edge Interrupt for P0[1]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_1FEI: u1,
            /// Status of Falling Edge Interrupt for P0[2]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_2FEI: u1,
            /// Status of Falling Edge Interrupt for P0[3]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_3FEI: u1,
            /// Status of Falling Edge Interrupt for P0[4]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_4FEI: u1,
            /// Status of Falling Edge Interrupt for P0[5]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_5FEI: u1,
            /// Status of Falling Edge Interrupt for P0[6]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_6FEI: u1,
            /// Status of Falling Edge Interrupt for P0[7]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_7FEI: u1,
            /// Status of Falling Edge Interrupt for P0[8]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_8FEI: u1,
            /// Status of Falling Edge Interrupt for P0[9]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_9FEI: u1,
            /// Status of Falling Edge Interrupt for P0[10]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_10FEI: u1,
            /// Status of Falling Edge Interrupt for P0[11]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_11FEI: u1,
            /// Status of Falling Edge Interrupt for P0[12]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_12FEI: u1,
            /// Status of Falling Edge Interrupt for P0[13]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_13FEI: u1,
            /// Status of Falling Edge Interrupt for P0[14]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_14FEI: u1,
            /// Status of Falling Edge Interrupt for P0[15]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_15FEI: u1,
            /// Status of Falling Edge Interrupt for P0[16]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_16FEI: u1,
            /// Status of Falling Edge Interrupt for P0[17]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_17FEI: u1,
            /// Status of Falling Edge Interrupt for P0[18]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_18FEI: u1,
            /// Status of Falling Edge Interrupt for P0[19]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_19FEI: u1,
            /// Status of Falling Edge Interrupt for P0[20]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_20FEI: u1,
            /// Status of Falling Edge Interrupt for P0[21]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_21FEI: u1,
            /// Status of Falling Edge Interrupt for P0[22]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_22FEI: u1,
            /// Status of Falling Edge Interrupt for P0[23]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_23FEI: u1,
            /// Status of Falling Edge Interrupt for P0[24]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_24FEI: u1,
            /// Status of Falling Edge Interrupt for P0[25]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_25FEI: u1,
            /// Status of Falling Edge Interrupt for P0[26]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_26FEI: u1,
            /// Status of Falling Edge Interrupt for P0[27]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_27FEI: u1,
            /// Status of Falling Edge Interrupt for P0[28]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_28FEI: u1,
            /// Status of Falling Edge Interrupt for P0[29]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_29FEI: u1,
            /// Status of Falling Edge Interrupt for P0[30]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P0_30FEI: u1,
            /// Reserved.
            RESERVED: u1,
        }), base_address + 0x8);

        /// address: 0x4002808c
        /// GPIO Interrupt Clear.
        pub const CLR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear GPIO port Interrupts for P0[0]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_0CI: u1,
            /// Clear GPIO port Interrupts for P0[1]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_1CI: u1,
            /// Clear GPIO port Interrupts for P0[2]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_2CI: u1,
            /// Clear GPIO port Interrupts for P0[3]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_3CI: u1,
            /// Clear GPIO port Interrupts for P0[4]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_4CI: u1,
            /// Clear GPIO port Interrupts for P0[5]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_5CI: u1,
            /// Clear GPIO port Interrupts for P0[6]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_6CI: u1,
            /// Clear GPIO port Interrupts for P0[7]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_7CI: u1,
            /// Clear GPIO port Interrupts for P0[8]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_8CI: u1,
            /// Clear GPIO port Interrupts for P0[9]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_9CI: u1,
            /// Clear GPIO port Interrupts for P0[10]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_10CI: u1,
            /// Clear GPIO port Interrupts for P0[11]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_11CI: u1,
            /// Clear GPIO port Interrupts for P0[12]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_12CI: u1,
            /// Clear GPIO port Interrupts for P0[13]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_13CI: u1,
            /// Clear GPIO port Interrupts for P0[14]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_14CI: u1,
            /// Clear GPIO port Interrupts for P0[15]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_15CI: u1,
            /// Clear GPIO port Interrupts for P0[16]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_16CI: u1,
            /// Clear GPIO port Interrupts for P0[17]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_17CI: u1,
            /// Clear GPIO port Interrupts for P0[18]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_18CI: u1,
            /// Clear GPIO port Interrupts for P0[19]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_19CI: u1,
            /// Clear GPIO port Interrupts for P0[20]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_20CI: u1,
            /// Clear GPIO port Interrupts for P0[21]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_21CI: u1,
            /// Clear GPIO port Interrupts for P0[22]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_22CI: u1,
            /// Clear GPIO port Interrupts for P0[23]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_23CI: u1,
            /// Clear GPIO port Interrupts for P0[24]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_24CI: u1,
            /// Clear GPIO port Interrupts for P0[25]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_25CI: u1,
            /// Clear GPIO port Interrupts for P0[26]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_26CI: u1,
            /// Clear GPIO port Interrupts for P0[27]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_27CI: u1,
            /// Clear GPIO port Interrupts for P0[28]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_28CI: u1,
            /// Clear GPIO port Interrupts for P0[29]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_29CI: u1,
            /// Clear GPIO port Interrupts for P0[30]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P0_30CI: u1,
            /// Reserved.
            RESERVED: u1,
        }), base_address + 0xc);

        /// address: 0x40028090
        /// GPIO Interrupt Enable for Rising edge for Port 0.
        pub const ENR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable rising edge interrupt for P0[0]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_0ER: u1,
            /// Enable rising edge interrupt for P0[1]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_1ER: u1,
            /// Enable rising edge interrupt for P0[2]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_2ER: u1,
            /// Enable rising edge interrupt for P0[3]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_3ER: u1,
            /// Enable rising edge interrupt for P0[4]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_4ER: u1,
            /// Enable rising edge interrupt for P0[5]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_5ER: u1,
            /// Enable rising edge interrupt for P0[6]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_6ER: u1,
            /// Enable rising edge interrupt for P0[7]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_7ER: u1,
            /// Enable rising edge interrupt for P0[8]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_8ER: u1,
            /// Enable rising edge interrupt for P0[9]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_9ER: u1,
            /// Enable rising edge interrupt for P0[10]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_10ER: u1,
            /// Enable rising edge interrupt for P0[11]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_11ER: u1,
            /// Enable rising edge interrupt for P0[12]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_12ER: u1,
            /// Enable rising edge interrupt for P0[13]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_13ER: u1,
            /// Enable rising edge interrupt for P0[14]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_14ER: u1,
            /// Enable rising edge interrupt for P0[15]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_15ER: u1,
            /// Enable rising edge interrupt for P0[16]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_16ER: u1,
            /// Enable rising edge interrupt for P0[17]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_17ER: u1,
            /// Enable rising edge interrupt for P0[18]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_18ER: u1,
            /// Enable rising edge interrupt for P0[19]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_19ER: u1,
            /// Enable rising edge interrupt for P0[20]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_20ER: u1,
            /// Enable rising edge interrupt for P0[21]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_21ER: u1,
            /// Enable rising edge interrupt for P0[22]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_22ER: u1,
            /// Enable rising edge interrupt for P0[23]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_23ER: u1,
            /// Enable rising edge interrupt for P0[24]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_24ER: u1,
            /// Enable rising edge interrupt for P0[25]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_25ER: u1,
            /// Enable rising edge interrupt for P0[26]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_26ER: u1,
            /// Enable rising edge interrupt for P0[27]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_27ER: u1,
            /// Enable rising edge interrupt for P0[28]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_28ER: u1,
            /// Enable rising edge interrupt for P0[29]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_29ER: u1,
            /// Enable rising edge interrupt for P0[30]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P0_30ER: u1,
            /// Reserved.
            RESERVED: u1,
        }), base_address + 0x10);

        /// address: 0x40028094
        /// GPIO Interrupt Enable for Falling edge for Port 0.
        pub const ENF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable falling edge interrupt for P0[0]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P0_0EF: u1,
            /// Enable falling edge interrupt for P0[1]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P0_1EF: u1,
            /// Enable falling edge interrupt for P0[2]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P0_2EF: u1,
            /// Enable falling edge interrupt for P0[3]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P0_3EF: u1,
            /// Enable falling edge interrupt for P0[4]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P0_4EF: u1,
            /// Enable falling edge interrupt for P0[5]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P0_5EF: u1,
            /// Enable falling edge interrupt for P0[6]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P0_6EF: u1,
            /// Enable falling edge interrupt for P0[7]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P0_7EF: u1,
            /// Enable falling edge interrupt for P0[8]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P0_8EF: u1,
            /// Enable falling edge interrupt for P0[9]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P0_9EF: u1,
            /// Enable falling edge interrupt for P0[10]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_10EF: u1,
            /// Enable falling edge interrupt for P0[11]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_11EF: u1,
            /// Enable falling edge interrupt for P0[12]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_12EF: u1,
            /// Enable falling edge interrupt for P0[13]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_13EF: u1,
            /// Enable falling edge interrupt for P0[14]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_14EF: u1,
            /// Enable falling edge interrupt for P0[15]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_15EF: u1,
            /// Enable falling edge interrupt for P0[16]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_16EF: u1,
            /// Enable falling edge interrupt for P0[17]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_17EF: u1,
            /// Enable falling edge interrupt for P0[18]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_18EF: u1,
            /// Enable falling edge interrupt for P0[19]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_19EF: u1,
            /// Enable falling edge interrupt for P0[20]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_20EF: u1,
            /// Enable falling edge interrupt for P0[21]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_21EF: u1,
            /// Enable falling edge interrupt for P0[22]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_22EF: u1,
            /// Enable falling edge interrupt for P0[23]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_23EF: u1,
            /// Enable falling edge interrupt for P0[24]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_24EF: u1,
            /// Enable falling edge interrupt for P0[25]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_25EF: u1,
            /// Enable falling edge interrupt for P0[26]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_26EF: u1,
            /// Enable falling edge interrupt for P0[27]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_27EF: u1,
            /// Enable falling edge interrupt for P0[28]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_28EF: u1,
            /// Enable falling edge interrupt for P0[29]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_29EF: u1,
            /// Enable falling edge interrupt for P0[30]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P0_30EF: u1,
            /// Reserved.
            RESERVED: u1,
        }), base_address + 0x14);

        /// address: 0x400280a4
        /// GPIO Interrupt Status for Rising edge for Port 0.
        pub const STATR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Status of Rising Edge Interrupt for P2[0]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P2_0REI: u1,
            /// Status of Rising Edge Interrupt for P2[1]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P2_1REI: u1,
            /// Status of Rising Edge Interrupt for P2[2]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P2_2REI: u1,
            /// Status of Rising Edge Interrupt for P2[3]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P2_3REI: u1,
            /// Status of Rising Edge Interrupt for P2[4]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P2_4REI: u1,
            /// Status of Rising Edge Interrupt for P2[5]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P2_5REI: u1,
            /// Status of Rising Edge Interrupt for P2[6]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P2_6REI: u1,
            /// Status of Rising Edge Interrupt for P2[7]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P2_7REI: u1,
            /// Status of Rising Edge Interrupt for P2[8]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P2_8REI: u1,
            /// Status of Rising Edge Interrupt for P2[9]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P2_9REI: u1,
            /// Status of Rising Edge Interrupt for P2[10]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P2_10REI: u1,
            /// Status of Rising Edge Interrupt for P2[11]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P2_11REI: u1,
            /// Status of Rising Edge Interrupt for P2[12]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P2_12REI: u1,
            /// Status of Rising Edge Interrupt for P2[13]. 0 = No rising edge detected. 1 =
            /// Rising edge interrupt generated.
            P2_13REI: u1,
            /// Reserved.
            RESERVED: u18,
        }), base_address + 0x24);

        /// address: 0x400280a8
        /// GPIO Interrupt Status for Falling edge for Port 0.
        pub const STATF2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Status of Falling Edge Interrupt for P2[0]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P2_0FEI: u1,
            /// Status of Falling Edge Interrupt for P2[1]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P2_1FEI: u1,
            /// Status of Falling Edge Interrupt for P2[2]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P2_2FEI: u1,
            /// Status of Falling Edge Interrupt for P2[3]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P2_3FEI: u1,
            /// Status of Falling Edge Interrupt for P2[4]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P2_4FEI: u1,
            /// Status of Falling Edge Interrupt for P2[5]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P2_5FEI: u1,
            /// Status of Falling Edge Interrupt for P2[6]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P2_6FEI: u1,
            /// Status of Falling Edge Interrupt for P2[7]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P2_7FEI: u1,
            /// Status of Falling Edge Interrupt for P2[8]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P2_8FEI: u1,
            /// Status of Falling Edge Interrupt for P2[9]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P2_9FEI: u1,
            /// Status of Falling Edge Interrupt for P2[10]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P2_10FEI: u1,
            /// Status of Falling Edge Interrupt for P2[11]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P2_11FEI: u1,
            /// Status of Falling Edge Interrupt for P2[12]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P2_12FEI: u1,
            /// Status of Falling Edge Interrupt for P2[13]. 0 = No falling edge detected. 1 =
            /// Falling edge interrupt generated.
            P2_13FEI: u1,
            /// Reserved.
            RESERVED: u18,
        }), base_address + 0x28);

        /// address: 0x400280ac
        /// GPIO Interrupt Clear.
        pub const CLR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear GPIO port Interrupts for P2[0]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P2_0CI: u1,
            /// Clear GPIO port Interrupts for P2[1]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P2_1CI: u1,
            /// Clear GPIO port Interrupts for P2[2]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P2_2CI: u1,
            /// Clear GPIO port Interrupts for P2[3]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P2_3CI: u1,
            /// Clear GPIO port Interrupts for P2[4]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P2_4CI: u1,
            /// Clear GPIO port Interrupts for P2[5]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P2_5CI: u1,
            /// Clear GPIO port Interrupts for P2[6]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P2_6CI: u1,
            /// Clear GPIO port Interrupts for P2[7]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P2_7CI: u1,
            /// Clear GPIO port Interrupts for P2[8]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P2_8CI: u1,
            /// Clear GPIO port Interrupts for P2[9]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P2_9CI: u1,
            /// Clear GPIO port Interrupts for P2[10]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P2_10CI: u1,
            /// Clear GPIO port Interrupts for P2[11]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P2_11CI: u1,
            /// Clear GPIO port Interrupts for P2[12]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P2_12CI: u1,
            /// Clear GPIO port Interrupts for P2[13]. 0 = No effect. 1 = Clear corresponding
            /// bits in IOnINTSTATR and IOnSTATF.
            P2_13CI: u1,
            /// Reserved.
            RESERVED: u18,
        }), base_address + 0x2c);

        /// address: 0x400280b0
        /// GPIO Interrupt Enable for Rising edge for Port 0.
        pub const ENR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable rising edge interrupt for P2[0]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P2_0ER: u1,
            /// Enable rising edge interrupt for P2[1]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P2_1ER: u1,
            /// Enable rising edge interrupt for P2[2]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P2_2ER: u1,
            /// Enable rising edge interrupt for P2[3]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P2_3ER: u1,
            /// Enable rising edge interrupt for P2[4]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P2_4ER: u1,
            /// Enable rising edge interrupt for P2[5]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P2_5ER: u1,
            /// Enable rising edge interrupt for P2[6]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P2_6ER: u1,
            /// Enable rising edge interrupt for P2[7]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P2_7ER: u1,
            /// Enable rising edge interrupt for P2[8]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P2_8ER: u1,
            /// Enable rising edge interrupt for P2[9]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P2_9ER: u1,
            /// Enable rising edge interrupt for P2[10]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P2_10ER: u1,
            /// Enable rising edge interrupt for P2[11]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P2_11ER: u1,
            /// Enable rising edge interrupt for P2[12]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P2_12ER: u1,
            /// Enable rising edge interrupt for P2[13]. 0 = Disable rising edge interrupt. 1 =
            /// Enable rising edge interrupt.
            P2_13ER: u1,
            /// Reserved.
            RESERVED: u18,
        }), base_address + 0x30);

        /// address: 0x400280b4
        /// GPIO Interrupt Enable for Falling edge for Port 0.
        pub const ENF2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable falling edge interrupt for P2[0]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P2_0EF: u1,
            /// Enable falling edge interrupt for P2[1]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P2_1EF: u1,
            /// Enable falling edge interrupt for P2[2]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P2_2EF: u1,
            /// Enable falling edge interrupt for P2[3]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P2_3EF: u1,
            /// Enable falling edge interrupt for P2[4]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P2_4EF: u1,
            /// Enable falling edge interrupt for P2[5]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P2_5EF: u1,
            /// Enable falling edge interrupt for P2[6]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P2_6EF: u1,
            /// Enable falling edge interrupt for P2[7]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P2_7EF: u1,
            /// Enable falling edge interrupt for P2[8]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P2_8EF: u1,
            /// Enable falling edge interrupt for P2[9]. 0 = Disable falling edge interrupt. 1 =
            /// Enable falling edge interrupt.
            P2_9EF: u1,
            /// Enable falling edge interrupt for P2[10]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P2_10EF: u1,
            /// Enable falling edge interrupt for P2[11]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P2_11EF: u1,
            /// Enable falling edge interrupt for P2[12]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P2_12EF: u1,
            /// Enable falling edge interrupt for P2[13]. 0 = Disable falling edge interrupt. 1
            /// = Enable falling edge interrupt.
            P2_13EF: u1,
            /// Reserved.
            RESERVED: u18,
        }), base_address + 0x34);
    };
    /// Pin connect block
    pub const PINCONNECT = struct {
        pub const base_address = 0x4002c000;

        /// address: 0x4002c000
        /// Pin function select register 0.
        pub const PINSEL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pin function select P0.0.
            P0_0: u2,
            /// Pin function select P0.1.
            P0_1: u2,
            /// Pin function select P0.2.
            P0_2: u2,
            /// Pin function select P0.3.
            P0_3: u2,
            /// Pin function select P0.4.
            P0_4: u2,
            /// Pin function select P0.5.
            P0_5: u2,
            /// Pin function select P0.6.
            P0_6: u2,
            /// Pin function select P0.7.
            P0_7: u2,
            /// Pin function select P0.8.
            P0_8: u2,
            /// Pin function select P0.9.
            P0_9: u2,
            /// Pin function select P0.10.
            P0_10: u2,
            /// Pin function select P0.11.
            P0_11: u2,
            /// Reserved.
            RESERVED: u6,
            /// Pin function select P0.15.
            P0_15: u2,
        }), base_address + 0x0);

        /// address: 0x4002c004
        /// Pin function select register 1.
        pub const PINSEL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pin function select P0.16.
            P0_16: u2,
            /// Pin function select P0.17.
            P0_17: u2,
            /// Pin function select P0.18.
            P0_18: u2,
            /// Pin function select P019.
            P0_19: u2,
            /// Pin function select P0.20.
            P0_20: u2,
            /// Pin function select P0.21.
            P0_21: u2,
            /// Pin function select P022
            P0_22: u2,
            /// Pin function select P023.
            P0_23: u2,
            /// Pin function select P0.24.
            P0_24: u2,
            /// Pin function select P0.25.
            P0_25: u2,
            /// Pin function select P0.26.
            P0_26: u2,
            /// Pin function select P0.27.
            P0_27: u2,
            /// Pin function select P0.28.
            P0_28: u2,
            /// Pin function select P0.29
            P0_29: u2,
            /// Pin function select P0.30.
            P0_30: u2,
            /// Reserved
            RESERVED: u2,
        }), base_address + 0x4);

        /// address: 0x4002c008
        /// Pin function select register 2.
        pub const PINSEL2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pin function select P1.0.
            P1_0: u2,
            /// Pin function select P1.1.
            P1_1: u2,
            /// Reserved.
            RESERVED: u4,
            /// Pin function select P1.4.
            P1_4: u2,
            /// Reserved.
            RESERVED: u6,
            /// Pin function select P1.8.
            P1_8: u2,
            /// Pin function select P1.9.
            P1_9: u2,
            /// Pin function select P1.10.
            P1_10: u2,
            /// Pin function select P1.14.
            P1_14: u2,
            /// Reserved.
            RESERVED: u6,
            /// Pin function select P1.15.
            P1_15: u2,
        }), base_address + 0x8);

        /// address: 0x4002c00c
        /// Pin function select register 3.
        pub const PINSEL3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pin function select P1.16.
            P1_16: u2,
            /// Pin function select P1.17.
            P1_17: u2,
            /// Pin function select P1.18.
            P1_18: u2,
            /// Pin function select P1.19.
            P1_19: u2,
            /// Pin function select P1.20.
            P1_20: u2,
            /// Pin function select P1.21.
            P1_21: u2,
            /// Pin function select P1.22
            P1_22: u2,
            /// Pin function select P1.23.
            P1_23: u2,
            /// Pin function select P1.24.
            P1_24: u2,
            /// Pin function select P1.25.
            P1_25: u2,
            /// Pin function select P1.26.
            P1_26: u2,
            /// Pin function select P1.27.
            P1_27: u2,
            /// Pin function select P1.28.
            P1_28: u2,
            /// Pin function select P1.29
            P1_29: u2,
            /// Pin function select P1.30.
            P1_30: u2,
            /// Pin function select P1.31.
            P1_31: u2,
        }), base_address + 0xc);

        /// address: 0x4002c010
        /// Pin function select register 4
        pub const PINSEL4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pin function select P2.0.
            P2_0: u2,
            /// Pin function select P2.1.
            P2_1: u2,
            /// Pin function select P2.2.
            P2_2: u2,
            /// Pin function select P2.3.
            P2_3: u2,
            /// Pin function select P2.4.
            P2_4: u2,
            /// Pin function select P2.5.
            P2_5: u2,
            /// Pin function select P2.6.
            P2_6: u2,
            /// Pin function select P2.7.
            P2_7: u2,
            /// Pin function select P2.8.
            P2_8: u2,
            /// Pin function select P2.9.
            P2_9: u2,
            /// Pin function select P2.10.
            P2_10: u2,
            /// Pin function select P2.11.
            P2_11: u2,
            /// Pin function select P2.12.
            P2_12: u2,
            /// Pin function select P2.13.
            P2_13: u2,
            /// Reserved.
            RESERVED: u4,
        }), base_address + 0x10);

        /// address: 0x4002c01c
        /// Pin function select register 7
        pub const PINSEL7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved.
            RESERVED: u18,
            /// Pin function select P3.25.
            P3_25: u2,
            /// Pin function select P3.26.
            P3_26: u2,
            /// Reserved.
            RESERVED: u10,
        }), base_address + 0x1c);

        /// address: 0x4002c024
        /// Pin function select register 9
        pub const PINSEL9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved.
            RESERVED: u24,
            /// Pin function select P4.28.
            P4_28: u2,
            /// Pin function select P4.29.
            P4_29: u2,
            /// Reserved.
            RESERVED: u4,
        }), base_address + 0x24);

        /// address: 0x4002c028
        /// Pin function select register 10
        pub const PINSEL10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Software should not write 1 to these bits.
            RESERVED: u3,
            /// TPIU interface pins control.
            TPIUCTRL: u1,
            /// Reserved. Software should not write 1 to these bits.
            RESERVED: u28,
        }), base_address + 0x28);

        /// address: 0x4002c040
        /// Pin mode select register 0
        pub const PINMODE0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 0 pin 0 on-chip pull-up/down resistor control.
            P0_00MODE: u2,
            /// Port 0 pin 1 control.
            P0_01MODE: u2,
            /// Port 0 pin 2 control.
            P0_02MODE: u2,
            /// Port 0 pin 3 control.
            P0_03MODE: u2,
            /// Port 0 pin 4 control.
            P0_04MODE: u2,
            /// Port 0 pin 5 control.
            P0_05MODE: u2,
            /// Port 0 pin 6 control.
            P0_06MODE: u2,
            /// Port 0 pin 7 control.
            P0_07MODE: u2,
            /// Port 0 pin 8 control.
            P0_08MODE: u2,
            /// Port 0 pin 9 control.
            P0_09MODE: u2,
            /// Port 0 pin 10 control.
            P0_10MODE: u2,
            /// Port 0 pin 11 control.
            P0_11MODE: u2,
            /// Reserved.
            RESERVED: u6,
            /// Port 0 pin 15 control.
            P0_15MODE: u2,
        }), base_address + 0x40);

        /// address: 0x4002c044
        /// Pin mode select register 1
        pub const PINMODE1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 1 pin 16 control.
            P0_16MODE: u2,
            /// Port 1 pin 17 control.
            P0_17MODE: u2,
            /// Port 1 pin 18 control.
            P0_18MODE: u2,
            /// Port 1 pin 19 control.
            P0_19MODE: u2,
            /// Port 1 pin 20 control.
            P0_20MODE: u2,
            /// Port 1 pin 21 control.
            P0_21MODE: u2,
            /// Port 1 pin 22 control.
            P0_22MODE: u2,
            /// Port 1 pin 23 control.
            P0_23MODE: u2,
            /// Port 1 pin 24 control.
            P0_24MODE: u2,
            /// Port 1 pin 25 control.
            P0_25MODE: u2,
            /// Port 1 pin 26 control.
            P0_26MODE: u2,
            /// Reserved.
            RESERVED: u8,
            /// Reserved.
            RESERVED: u2,
        }), base_address + 0x44);

        /// address: 0x4002c048
        /// Pin mode select register 2
        pub const PINMODE2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 1 pin 0 control.
            P1_00MODE: u2,
            /// Port 1 pin 1 control.
            P1_01MODE: u2,
            /// Reserved.
            RESERVED: u4,
            /// Port 1 pin 4 control.
            P1_04MODE: u2,
            /// Reserved.
            RESERVED: u6,
            /// Port 1 pin 8 control.
            P1_08MODE: u2,
            /// Port 1 pin 9 control.
            P1_09MODE: u2,
            /// Port 1 pin 10 control.
            P1_10MODE: u2,
            /// Reserved.
            RESERVED: u6,
            /// Port 1 pin 14 control.
            P1_14MODE: u2,
            /// Port 1 pin 15 control.
            P1_15MODE: u2,
        }), base_address + 0x48);

        /// address: 0x4002c04c
        /// Pin mode select register 3.
        pub const PINMODE3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 1 pin 16 control.
            P1_16MODE: u2,
            /// Port 1 pin 17 control.
            P1_17MODE: u2,
            /// Port 1 pin 18 control.
            P1_18MODE: u2,
            /// Port 1 pin 19 control.
            P1_19MODE: u2,
            /// Port 1 pin 20 control.
            P1_20MODE: u2,
            /// Port 1 pin 21 control.
            P1_21MODE: u2,
            /// Port 1 pin 22 control.
            P1_22MODE: u2,
            /// Port 1 pin 23 control.
            P1_23MODE: u2,
            /// Port 1 pin 24 control.
            P1_24MODE: u2,
            /// Port 1 pin 25 control.
            P1_25MODE: u2,
            /// Port 1 pin 26 control.
            P1_26MODE: u2,
            /// Port 1 pin 27 control.
            P1_27MODE: u2,
            /// Port 1 pin 28 control.
            P1_28MODE: u2,
            /// Port 1 pin 29 control.
            P1_29MODE: u2,
            /// Port 1 pin 30 control.
            P1_30MODE: u2,
            /// Port 1 pin 31 control.
            P1_31MODE: u2,
        }), base_address + 0x4c);

        /// address: 0x4002c050
        /// Pin mode select register 4
        pub const PINMODE4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 2 pin 0 control.
            P2_00MODE: u2,
            /// Port 2 pin 1 control.
            P2_01MODE: u2,
            /// Port 2 pin 2 control.
            P2_02MODE: u2,
            /// Port 2 pin 3 control.
            P2_03MODE: u2,
            /// Port 2 pin 4 control.
            P2_04MODE: u2,
            /// Port 2 pin 5 control.
            P2_05MODE: u2,
            /// Port 2 pin 6 control.
            P2_06MODE: u2,
            /// Port 2 pin 7 control.
            P2_07MODE: u2,
            /// Port 2 pin 8 control.
            P2_08MODE: u2,
            /// Port 2 pin 9 control.
            P2_09MODE: u2,
            /// Port 2 pin 10 control.
            P2_10MODE: u2,
            /// Port 2 pin 11 control.
            P2_11MODE: u2,
            /// Port 2 pin 12 control.
            P2_12MODE: u2,
            /// Port 2 pin 13 control.
            P2_13MODE: u2,
            /// Reserved.
            RESERVED: u4,
        }), base_address + 0x50);

        /// address: 0x4002c05c
        /// Pin mode select register 7
        pub const PINMODE7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved
            RESERVED: u18,
            /// Port 3 pin 25 control.
            P3_25MODE: u2,
            /// Port 3 pin 26 control.
            P3_26MODE: u2,
            /// Reserved.
            RESERVED: u10,
        }), base_address + 0x5c);

        /// address: 0x4002c064
        /// Pin mode select register 9
        pub const PINMODE9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved.
            RESERVED: u24,
            /// Port 4 pin 28 control.
            P4_28MODE: u2,
            /// Port 4 pin 29 control.
            P4_29MODE: u2,
            /// Reserved.
            RESERVED: u4,
        }), base_address + 0x64);

        /// address: 0x4002c068
        /// Open drain mode control register 0
        pub const PINMODE_OD0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 0 pin 0 open drain mode control. Pins may potentially be used for I2C-buses
            /// using standard port pins. If so, they should be configured for open drain mode
            /// via the related bits in PINMODE_OD0.
            P0_00OD: u1,
            /// Port 0 pin 1 open drain mode control. Pins may potentially be used for I2C-buses
            /// using standard port pins. If so, they should be configured for open drain mode
            /// via the related bits in PINMODE_OD0.
            P0_01OD: u1,
            /// Port 0 pin 2 open drain mode control
            P0_02OD: u1,
            /// Port 0 pin 3 open drain mode control
            P0_03OD: u1,
            /// Port 0 pin 4 open drain mode control
            P0_04OD: u1,
            /// Port 0 pin 5 open drain mode control
            P0_05OD: u1,
            /// Port 0 pin 6 open drain mode control
            P0_06OD: u1,
            /// Port 0 pin 7 open drain mode control
            P0_07OD: u1,
            /// Port 0 pin 8 open drain mode control
            P0_08OD: u1,
            /// Port 0 pin 9 open drain mode control
            P0_09OD: u1,
            /// Port 0 pin 10 open drain mode control. Pins may potentially be used for
            /// I2C-buses using standard port pins. If so, they should be configured for open
            /// drain mode via the related bits in PINMODE_OD0.
            P0_10OD: u1,
            /// Port 0 pin 11 open drain mode control. Pins may potentially be used for
            /// I2C-buses using standard port pins. If so, they should be configured for open
            /// drain mode via the related bits in PINMODE_OD0.
            P0_11OD: u1,
            /// Reserved.
            RESERVED: u3,
            /// Port 0 pin 15 open drain mode control
            P0_15OD: u1,
            /// Port 0 pin 16 open drain mode control
            P0_16OD: u1,
            /// Port 0 pin 17 open drain mode control
            P0_17OD: u1,
            /// Port 0 pin 18 open drain mode control
            P0_18OD: u1,
            /// Port 0 pin 19 open drain mode control. Pins may potentially be used for
            /// I2C-buses using standard port pins. If so, they should be configured for open
            /// drain mode via the related bits in PINMODE_OD0.
            P0_19OD: u1,
            /// Port 0 pin 20open drain mode control. Pins may potentially be used for I2C-buses
            /// using standard port pins. If so, they should be configured for open drain mode
            /// via the related bits in PINMODE_OD0.
            P0_20OD: u1,
            /// Port 0 pin 21 open drain mode control
            P0_21OD: u1,
            /// Port 0 pin 22 open drain mode control
            P0_22OD: u1,
            /// Port 0 pin 23 open drain mode control
            P0_23OD: u1,
            /// Port 0 pin 24open drain mode control
            P0_24OD: u1,
            /// Port 0 pin 25 open drain mode control
            P0_25OD: u1,
            /// Port 0 pin 26 open drain mode control
            P0_26OD: u1,
            /// Reserved.
            RESERVED: u2,
            /// Port 0 pin 29 open drain mode control
            P0_29OD: u1,
            /// Port 0 pin 30 open drain mode control
            P0_30OD: u1,
            /// Reserved.
            RESERVED: u1,
        }), base_address + 0x68);

        /// address: 0x4002c06c
        /// Open drain mode control register 1
        pub const PINMODE_OD1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 1 pin 0 open drain mode control.
            P1_00OD: u1,
            /// Port 1 pin 1 open drain mode control, see P1.00OD
            P1_01OD: u1,
            /// Reserved.
            RESERVED: u2,
            /// Port 1 pin 4 open drain mode control, see P1.00OD
            P1_04OD: u1,
            /// Reserved.
            RESERVED: u3,
            /// Port 1 pin 8 open drain mode control, see P1.00OD
            P1_08OD: u1,
            /// Port 1 pin 9 open drain mode control, see P1.00OD
            P1_09OD: u1,
            /// Port 1 pin 10 open drain mode control, see P1.00OD
            P1_10OD: u1,
            /// Reserved.
            RESERVED: u3,
            /// Port 1 pin 14 open drain mode control, see P1.00OD
            P1_14OD: u1,
            /// Port 1 pin 15 open drain mode control, see P1.00OD
            P1_15OD: u1,
            /// Port 1 pin 16 open drain mode control, see P1.00OD
            P1_16OD: u1,
            /// Port 1 pin 17 open drain mode control, see P1.00OD
            P1_17OD: u1,
            /// Port 1 pin 18 open drain mode control, see P1.00OD
            P1_18OD: u1,
            /// Port 1 pin 19 open drain mode control, see P1.00OD
            P1_19OD: u1,
            /// Port 1 pin 20open drain mode control, see P1.00OD
            P1_20OD: u1,
            /// Port 1 pin 21 open drain mode control, see P1.00OD
            P1_21OD: u1,
            /// Port 1 pin 22 open drain mode control, see P1.00OD
            P1_22OD: u1,
            /// Port 1 pin 23 open drain mode control, see P1.00OD
            P1_23OD: u1,
            /// Port 1 pin 24open drain mode control, see P1.00OD
            P1_24OD: u1,
            /// Port 1 pin 25 open drain mode control, see P1.00OD
            P1_25OD: u1,
            /// Port 1 pin 26 open drain mode control, see P1.00OD
            P1_26OD: u1,
            /// Port 1 pin 27 open drain mode control, see P1.00OD
            P1_27OD: u1,
            /// Port 1 pin 28 open drain mode control, see P1.00OD
            P1_28OD: u1,
            /// Port 1 pin 29 open drain mode control, see P1.00OD
            P1_29OD: u1,
            /// Port 1 pin 30 open drain mode control, see P1.00OD
            P1_30OD: u1,
            /// Port 1 pin 31 open drain mode control.
            P1_31OD: u1,
        }), base_address + 0x6c);

        /// address: 0x4002c070
        /// Open drain mode control register 2
        pub const PINMODE_OD2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 2 pin 0 open drain mode control.
            P2_00OD: u1,
            /// Port 2 pin 1 open drain mode control, see P2.00OD
            P2_01OD: u1,
            /// Port 2 pin 2 open drain mode control, see P2.00OD
            P2_02OD: u1,
            /// Port 2 pin 3 open drain mode control, see P2.00OD
            P2_03OD: u1,
            /// Port 2 pin 4 open drain mode control, see P2.00OD
            P2_04OD: u1,
            /// Port 2 pin 5 open drain mode control, see P2.00OD
            P2_05OD: u1,
            /// Port 2 pin 6 open drain mode control, see P2.00OD
            P2_06OD: u1,
            /// Port 2 pin 7 open drain mode control, see P2.00OD
            P2_07OD: u1,
            /// Port 2 pin 8 open drain mode control, see P2.00OD
            P2_08OD: u1,
            /// Port 2 pin 9 open drain mode control, see P2.00OD
            P2_09OD: u1,
            /// Port 2 pin 10 open drain mode control, see P2.00OD
            P2_10OD: u1,
            /// Port 2 pin 11 open drain mode control, see P2.00OD
            P2_11OD: u1,
            /// Port 2 pin 12 open drain mode control, see P2.00OD
            P2_12OD: u1,
            /// Port 2 pin 13 open drain mode control, see P2.00OD
            P2_13OD: u1,
            /// Reserved.
            RESERVED: u18,
        }), base_address + 0x70);

        /// address: 0x4002c074
        /// Open drain mode control register 3
        pub const PINMODE_OD3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved.
            RESERVED: u25,
            /// Port 3 pin 25 open drain mode control.
            P3_25OD: u1,
            /// Port 3 pin 26 open drain mode control, see P3.25OD
            P3_26OD: u1,
            /// Reserved.
            RESERVED: u5,
        }), base_address + 0x74);

        /// address: 0x4002c078
        /// Open drain mode control register 4
        pub const PINMODE_OD4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved.
            RESERVED: u28,
            /// Port 4 pin 28 open drain mode control.
            P4_28OD: u1,
            /// Port 4 pin 29 open drain mode control, see P4.28OD
            P4_29OD: u1,
            /// Reserved.
            RESERVED: u2,
        }), base_address + 0x78);

        /// address: 0x4002c07c
        /// I2C Pin Configuration register
        pub const I2CPADCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Drive mode control for the SDA0 pin, P0.27.
            SDADRV0: u1,
            /// I 2C filter mode control for the SDA0 pin, P0.27.
            SDAI2C0: u1,
            /// Drive mode control for the SCL0 pin, P0.28.
            SCLDRV0: u1,
            /// I 2C filter mode control for the SCL0 pin, P0.28.
            SCLI2C0: u1,
            /// Reserved.
            RESERVED: u28,
        }), base_address + 0x7c);
    };
    /// SSP1 controller
    pub const SSP1 = struct {
        pub const base_address = 0x40030000;

        /// address: 0x40030000
        /// Control Register 0. Selects the serial clock rate, bus type, and data size.
        pub const CR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Size Select. This field controls the number of bits transferred in each
            /// frame. Values 0000-0010 are not supported and should not be used.
            DSS: u4,
            /// Frame Format.
            FRF: u2,
            /// Clock Out Polarity. This bit is only used in SPI mode.
            CPOL: u1,
            /// Clock Out Phase. This bit is only used in SPI mode.
            CPHA: u1,
            /// Serial Clock Rate. The number of prescaler-output clocks per bit on the bus,
            /// minus one. Given that CPSDVSR is the prescale divider, and the APB clock PCLK
            /// clocks the prescaler, the bit frequency is PCLK / (CPSDVSR X [SCR+1]).
            SCR: u8,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u16,
        }), base_address + 0x0);

        /// address: 0x40030004
        /// Control Register 1. Selects master/slave and other modes.
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Loop Back Mode.
            LBM: u1,
            /// SSP Enable.
            SSE: u1,
            /// Master/Slave Mode.This bit can only be written when the SSE bit is 0.
            MS: u1,
            /// Slave Output Disable. This bit is relevant only in slave mode (MS = 1). If it is
            /// 1, this blocks this SSP controller from driving the transmit data line (MISO).
            SOD: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u28,
        }), base_address + 0x4);

        /// address: 0x40030008
        /// Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO.
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write: software can write data to be sent in a future frame to this register
            /// whenever the TNF bit in the Status register is 1, indicating that the Tx FIFO is
            /// not full. If the Tx FIFO was previously empty and the SSP controller is not busy
            /// on the bus, transmission of the data will begin immediately. Otherwise the data
            /// written to this register will be sent as soon as all previous data has been sent
            /// (and received). If the data length is less than 16 bits, software must
            /// right-justify the data written to this register. Read: software can read data
            /// from this register whenever the RNE bit in the Status register is 1, indicating
            /// that the Rx FIFO is not empty. When software reads this register, the SSP
            /// controller returns data from the least recent frame in the Rx FIFO. If the data
            /// length is less than 16 bits, the data is right-justified in this field with
            /// higher order bits filled with 0s.
            DATA: u16,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u16,
        }), base_address + 0x8);

        /// address: 0x4003000c
        /// Status Register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit FIFO Empty. This bit is 1 is the Transmit FIFO is empty, 0 if not.
            TFE: u1,
            /// Transmit FIFO Not Full. This bit is 0 if the Tx FIFO is full, 1 if not.
            TNF: u1,
            /// Receive FIFO Not Empty. This bit is 0 if the Receive FIFO is empty, 1 if not.
            RNE: u1,
            /// Receive FIFO Full. This bit is 1 if the Receive FIFO is full, 0 if not.
            RFF: u1,
            /// Busy. This bit is 0 if the SSPn controller is idle, or 1 if it is currently
            /// sending/receiving a frame and/or the Tx FIFO is not empty.
            BSY: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u27,
        }), base_address + 0xc);

        /// address: 0x40030010
        /// Clock Prescale Register
        pub const CPSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// This even value between 2 and 254, by which PCLK is divided to yield the
            /// prescaler output clock. Bit 0 always reads as 0.
            CPSDVSR: u8,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x10);

        /// address: 0x40030014
        /// Interrupt Mask Set and Clear Register
        pub const IMSC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software should set this bit to enable interrupt when a Receive Overrun occurs,
            /// that is, when the Rx FIFO is full and another frame is completely received. The
            /// ARM spec implies that the preceding frame data is overwritten by the new frame
            /// data when this occurs.
            RORIM: u1,
            /// Software should set this bit to enable interrupt when a Receive Time-out
            /// condition occurs. A Receive Time-out occurs when the Rx FIFO is not empty, and
            /// no has not been read for a time-out period. The time-out period is the same for
            /// master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK /
            /// (CPSDVSR X [SCR+1]).
            RTIM: u1,
            /// Software should set this bit to enable interrupt when the Rx FIFO is at least
            /// half full.
            RXIM: u1,
            /// Software should set this bit to enable interrupt when the Tx FIFO is at least
            /// half empty.
            TXIM: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u28,
        }), base_address + 0x14);

        /// address: 0x40030018
        /// Raw Interrupt Status Register
        pub const RIS = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit is 1 if another frame was completely received while the RxFIFO was
            /// full. The ARM spec implies that the preceding frame data is overwritten by the
            /// new frame data when this occurs.
            RORRIS: u1,
            /// This bit is 1 if the Rx FIFO is not empty, and has not been read for a time-out
            /// period. The time-out period is the same for master and slave modes and is
            /// determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X [SCR+1]).
            RTRIS: u1,
            /// This bit is 1 if the Rx FIFO is at least half full.
            RXRIS: u1,
            /// This bit is 1 if the Tx FIFO is at least half empty.
            TXRIS: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u28,
        }), base_address + 0x18);

        /// address: 0x4003001c
        /// Masked Interrupt Status Register
        pub const MIS = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit is 1 if another frame was completely received while the RxFIFO was
            /// full, and this interrupt is enabled.
            RORMIS: u1,
            /// This bit is 1 if the Rx FIFO is not empty, has not been read for a time-out
            /// period, and this interrupt is enabled. The time-out period is the same for
            /// master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK /
            /// (CPSDVSR X [SCR+1]).
            RTMIS: u1,
            /// This bit is 1 if the Rx FIFO is at least half full, and this interrupt is
            /// enabled.
            RXMIS: u1,
            /// This bit is 1 if the Tx FIFO is at least half empty, and this interrupt is
            /// enabled.
            TXMIS: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u28,
        }), base_address + 0x1c);

        /// address: 0x40030020
        /// SSPICR Interrupt Clear Register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a 1 to this bit clears the frame was received when RxFIFO was full
            /// interrupt.
            RORIC: u1,
            /// Writing a 1 to this bit clears the Rx FIFO was not empty and has not been read
            /// for a time-out period interrupt. The time-out period is the same for master and
            /// slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR /
            /// [SCR+1]).
            RTIC: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u30,
        }), base_address + 0x20);

        /// address: 0x40030024
        /// SSP0 DMA control register
        pub const DMACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive DMA Enable. When this bit is set to one 1, DMA for the receive FIFO is
            /// enabled, otherwise receive DMA is disabled.
            RXDMAE: u1,
            /// Transmit DMA Enable. When this bit is set to one 1, DMA for the transmit FIFO is
            /// enabled, otherwise transmit DMA is disabled
            TXDMAE: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u30,
        }), base_address + 0x24);
    };
    /// Analog-to-Digital Converter (ADC)
    pub const ADC = struct {
        pub const base_address = 0x40034000;

        /// address: 0x40034000
        /// A/D Control Register. The ADCR register must be written to select the operating
        /// mode before A/D conversion can occur.
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Selects which of the AD0[7:0] pins is (are) to be sampled and converted. For
            /// AD0, bit 0 selects Pin AD0[0], and bit 7 selects pin AD0[7]. In
            /// software-controlled mode, only one of these bits should be 1. In hardware scan
            /// mode, any value containing 1 to 8 ones is allowed. All zeroes is equivalent to
            /// 0x01.
            SEL: u8,
            /// The APB clock (PCLK) is divided by (this value plus one) to produce the clock
            /// for the A/D converter, which should be less than or equal to 12.4 MHz.
            /// Typically, software should program the smallest value in this field that yields
            /// a clock of 12.4 MHz or slightly less, but in certain cases (such as a
            /// high-impedance analog source) a slower clock may be desirable.
            CLKDIV: u8,
            /// Burst mode
            BURST: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u4,
            /// Power down mode
            PDN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u2,
            /// When the BURST bit is 0, these bits control whether and when an A/D conversion
            /// is started:
            START: u3,
            /// This bit is significant only when the START field contains 010-111. In these
            /// cases:
            EDGE: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u4,
        }), base_address + 0x0);

        /// address: 0x40034004
        /// A/D Global Data Register. This register contains the ADC's DONE bit and the
        /// result of the most recent A/D conversion.
        pub const GDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u4,
            /// When DONE is 1, this field contains a binary fraction representing the voltage
            /// on the AD0[n] pin selected by the SEL field, as it falls within the range of
            /// VREFP to VSS. Zero in the field indicates that the voltage on the input pin was
            /// less than, equal to, or close to that on VSS, while 0xFFF indicates that the
            /// voltage on the input was close to, equal to, or greater than that on VREFP.
            RESULT: u12,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u8,
            /// These bits contain the channel from which the RESULT bits were converted (e.g.
            /// 000 identifies channel 0, 001 channel 1...).
            CHN: u3,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u3,
            /// This bit is 1 in burst mode if the results of one or more conversions was (were)
            /// lost and overwritten before the conversion that produced the result in the
            /// RESULT bits. This bit is cleared by reading this register.
            OVERRUN: u1,
            /// This bit is set to 1 when an A/D conversion completes. It is cleared when this
            /// register is read and when the ADCR is written. If the ADCR is written while a
            /// conversion is still in progress, this bit is set and a new conversion is
            /// started.
            DONE: u1,
        }), base_address + 0x4);

        /// address: 0x4003400c
        /// A/D Interrupt Enable Register. This register contains enable bits that allow the
        /// DONE flag of each A/D channel to be included or excluded from contributing to
        /// the generation of an A/D interrupt.
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt enable
            ADINTEN0: u1,
            /// Interrupt enable
            ADINTEN1: u1,
            /// Interrupt enable
            ADINTEN2: u1,
            /// Interrupt enable
            ADINTEN3: u1,
            /// Interrupt enable
            ADINTEN4: u1,
            /// Interrupt enable
            ADINTEN5: u1,
            /// Interrupt enable
            ADINTEN6: u1,
            /// Interrupt enable
            ADINTEN7: u1,
            /// Interrupt enable
            ADGINTEN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u23,
        }), base_address + 0xc);

        /// address: 0x40034010
        /// A/D Channel 0 Data Register. This register contains the result of the most
        /// recent conversion completed on channel 0.
        pub const DR = @intToPtr(*volatile [8]Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u4,
            /// When DONE is 1, this field contains a binary fraction representing the voltage
            /// on the AD0[n] pin, as it falls within the range of VREFP to V SS. Zero in the
            /// field indicates that the voltage on the input pin was less than, equal to, or
            /// close to that on VSS, while 0xFFF indicates that the voltage on the input was
            /// close to, equal to, or greater than that on VREFP.
            RESULT: u12,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u14,
            /// This bit is 1 in burst mode if the results of one or more conversions was (were)
            /// lost and overwritten before the conversion that produced the result in the
            /// RESULT bits.This bit is cleared by reading this register.
            OVERRUN: u1,
            /// This bit is set to 1 when an A/D conversion completes. It is cleared when this
            /// register is read.
            DONE: u1,
        }), base_address + 0x10);

        /// address: 0x40034030
        /// A/D Status Register. This register contains DONE and OVERRUN flags for all of
        /// the A/D channels, as well as the A/D interrupt/DMA flag.
        pub const STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit mirrors the DONE status flag from the result register for A/D channel
            /// 0.
            DONE0: u1,
            /// This bit mirrors the DONE status flag from the result register for A/D channel
            /// 1.
            DONE1: u1,
            /// This bit mirrors the DONE status flag from the result register for A/D channel
            /// 2.
            DONE2: u1,
            /// This bit mirrors the DONE status flag from the result register for A/D channel
            /// 3.
            DONE3: u1,
            /// This bit mirrors the DONE status flag from the result register for A/D channel
            /// 4.
            DONE4: u1,
            /// This bit mirrors the DONE status flag from the result register for A/D channel
            /// 5.
            DONE5: u1,
            /// This bit mirrors the DONE status flag from the result register for A/D channel
            /// 6.
            DONE6: u1,
            /// This bit mirrors the DONE status flag from the result register for A/D channel
            /// 7.
            DONE7: u1,
            /// This bit mirrors the OVERRRUN status flag from the result register for A/D
            /// channel 0.
            OVERRUN0: u1,
            /// This bit mirrors the OVERRRUN status flag from the result register for A/D
            /// channel 1.
            OVERRUN1: u1,
            /// This bit mirrors the OVERRRUN status flag from the result register for A/D
            /// channel 2.
            OVERRUN2: u1,
            /// This bit mirrors the OVERRRUN status flag from the result register for A/D
            /// channel 3.
            OVERRUN3: u1,
            /// This bit mirrors the OVERRRUN status flag from the result register for A/D
            /// channel 4.
            OVERRUN4: u1,
            /// This bit mirrors the OVERRRUN status flag from the result register for A/D
            /// channel 5.
            OVERRUN5: u1,
            /// This bit mirrors the OVERRRUN status flag from the result register for A/D
            /// channel 6.
            OVERRUN6: u1,
            /// This bit mirrors the OVERRRUN status flag from the result register for A/D
            /// channel 7.
            OVERRUN7: u1,
            /// This bit is the A/D interrupt flag. It is one when any of the individual A/D
            /// channel Done flags is asserted and enabled to contribute to the A/D interrupt
            /// via the ADINTEN register.
            ADINT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u15,
        }), base_address + 0x30);

        /// address: 0x40034034
        /// ADC trim register.
        pub const TRM = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u4,
            /// Offset trim bits for ADC operation. Initialized by the boot code. Can be
            /// overwritten by the user.
            ADCOFFS: u4,
            /// written-to by boot code. Can not be overwritten by the user. These bits are
            /// locked after boot code write.
            TRIM: u4,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u20,
        }), base_address + 0x34);
    };
    /// CAN acceptance filter RAM
    pub const CANAFRAM = struct {
        pub const base_address = 0x40038000;

        /// address: 0x40038000
        /// CAN AF ram access register
        pub const MASK = @intToPtr(*volatile [512]u32, base_address + 0x0);
    };
    /// CAN controller acceptance filter
    pub const CANAF = struct {
        pub const base_address = 0x4003c000;

        /// address: 0x4003c000
        /// Acceptance Filter Register
        pub const AFMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// if AccBP is 0, the Acceptance Filter is not operational. All Rx messages on all
            /// CAN buses are ignored.
            ACCOFF: u1,
            /// All Rx messages are accepted on enabled CAN controllers. Software must set this
            /// bit before modifying the contents of any of the registers described below, and
            /// before modifying the contents of Lookup Table RAM in any way other than setting
            /// or clearing Disable bits in Standard Identifier entries. When both this bit and
            /// AccOff are 0, the Acceptance filter operates to screen received CAN Identifiers.
            ACCBP: u1,
            /// FullCAN mode
            EFCAN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u29,
        }), base_address + 0x0);

        /// address: 0x4003c004
        /// Standard Frame Individual Start Address Register
        pub const SFF_SA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u2,
            /// The start address of the table of individual Standard Identifiers in AF Lookup
            /// RAM. If the table is empty, write the same value in this register and the
            /// SFF_GRP_sa register described below. For compatibility with possible future
            /// devices, write zeroes in bits 31:11 and 1:0 of this register. If the eFCAN bit
            /// in the AFMR is 1, this value also indicates the size of the table of Standard
            /// IDs which the Acceptance Filter will search and (if found) automatically store
            /// received messages in Acceptance Filter RAM.
            SFF_SA: u9,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u21,
        }), base_address + 0x4);

        /// address: 0x4003c008
        /// Standard Frame Group Start Address Register
        pub const SFF_GRP_SA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u2,
            /// The start address of the table of grouped Standard Identifiers in AF Lookup RAM.
            /// If the table is empty, write the same value in this register and the EFF_sa
            /// register described below. The largest value that should be written to this
            /// register is 0x800, when only the Standard Individual table is used, and the last
            /// word (address 0x7FC) in AF Lookup Table RAM is used. For compatibility with
            /// possible future devices, please write zeroes in bits 31:12 and 1:0 of this
            /// register.
            SFF_GRP_SA: u10,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u20,
        }), base_address + 0x8);

        /// address: 0x4003c00c
        /// Extended Frame Start Address Register
        pub const EFF_SA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u2,
            /// The start address of the table of individual Extended Identifiers in AF Lookup
            /// RAM. If the table is empty, write the same value in this register and the
            /// EFF_GRP_sa register described below. The largest value that should be written to
            /// this register is 0x800, when both Extended Tables are empty and the last word
            /// (address 0x7FC) in AF Lookup Table RAM is used. For compatibility with possible
            /// future devices, please write zeroes in bits 31:11 and 1:0 of this register.
            EFF_SA: u9,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u21,
        }), base_address + 0xc);

        /// address: 0x4003c010
        /// Extended Frame Group Start Address Register
        pub const EFF_GRP_SA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u2,
            /// The start address of the table of grouped Extended Identifiers in AF Lookup RAM.
            /// If the table is empty, write the same value in this register and the ENDofTable
            /// register described below. The largest value that should be written to this
            /// register is 0x800, when this table is empty and the last word (address 0x7FC) in
            /// AF Lookup Table RAM is used. For compatibility with possible future devices,
            /// please write zeroes in bits 31:12 and 1:0 of this register.
            EFF_GRP_SA: u10,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u20,
        }), base_address + 0x10);

        /// address: 0x4003c014
        /// End of AF Tables register
        pub const ENDOFTABLE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u2,
            /// The address above the last active address in the last active AF table. For
            /// compatibility with possible future devices, please write zeroes in bits 31:12
            /// and 1:0 of this register. If the eFCAN bit in the AFMR is 0, the largest value
            /// that should be written to this register is 0x800, which allows the last word
            /// (address 0x7FC) in AF Lookup Table RAM to be used. If the eFCAN bit in the AFMR
            /// is 1, this value marks the start of the area of Acceptance Filter RAM, into
            /// which the Acceptance Filter will automatically receive messages for selected IDs
            /// on selected CAN buses. In this case, the maximum value that should be written to
            /// this register is 0x800 minus 6 times the value in SFF_sa. This allows 12 bytes
            /// of message storage between this address and the end of Acceptance Filter RAM,
            /// for each Standard ID that is specified between the start of Acceptance Filter
            /// RAM, and the next active AF table.
            ENDOFTABLE: u10,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u20,
        }), base_address + 0x14);

        /// address: 0x4003c018
        /// LUT Error Address register
        pub const LUTERRAD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u2,
            /// It the LUT Error bit (below) is 1, this read-only field contains the address in
            /// AF Lookup Table RAM, at which the Acceptance Filter encountered an error in the
            /// content of the tables.
            LUTERRAD: u9,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u21,
        }), base_address + 0x18);

        /// address: 0x4003c01c
        /// LUT Error Register
        pub const LUTERR = @intToPtr(*volatile Mmio(32, packed struct {
            /// This read-only bit is set to 1 if the Acceptance Filter encounters an error in
            /// the content of the tables in AF RAM. It is cleared when software reads the
            /// LUTerrAd register. This condition is ORed with the other CAN interrupts from the
            /// CAN controllers, to produce the request that is connected to the NVIC.
            LUTERR: u1,
            /// Reserved, the value read from a reserved bit is not defined.
            RESERVED: u31,
        }), base_address + 0x1c);

        /// address: 0x4003c020
        /// FullCAN interrupt enable register
        pub const FCANIE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Global FullCAN Interrupt Enable. When 1, this interrupt is enabled.
            FCANIE: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u31,
        }), base_address + 0x20);

        /// address: 0x4003c024
        /// FullCAN interrupt and capture register0
        pub const FCANIC0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// FullCan Interrupt Pending 0 = FullCan Interrupt Pending bit 0. 1 = FullCan
            /// Interrupt Pending bit 1. ... 31 = FullCan Interrupt Pending bit 31.
            INTPND: u32,
        }), base_address + 0x24);

        /// address: 0x4003c028
        /// FullCAN interrupt and capture register1
        pub const FCANIC1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// FullCan Interrupt Pending bit 32. 0 = FullCan Interrupt Pending bit 32. 1 =
            /// FullCan Interrupt Pending bit 33. ... 31 = FullCan Interrupt Pending bit 63.
            IntPnd32: u32,
        }), base_address + 0x28);
    };
    /// Central CAN controller
    pub const CCAN = struct {
        pub const base_address = 0x40040000;

        /// address: 0x40040000
        /// CAN Central Transmit Status Register
        pub const TXSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// When 1, the CAN controller 1 is sending a message (same as TS in the CAN1GSR).
            TS1: u1,
            /// When 1, the CAN controller 2 is sending a message (same as TS in the CAN2GSR)
            TS2: u1,
            /// Reserved, the value read from a reserved bit is not defined.
            RESERVED: u6,
            /// When 1, all 3 Tx Buffers of the CAN1 controller are available to the CPU (same
            /// as TBS in CAN1GSR).
            TBS1: u1,
            /// When 1, all 3 Tx Buffers of the CAN2 controller are available to the CPU (same
            /// as TBS in CAN2GSR).
            TBS2: u1,
            /// Reserved, the value read from a reserved bit is not defined.
            RESERVED: u6,
            /// When 1, all requested transmissions have been completed successfully by the CAN1
            /// controller (same as TCS in CAN1GSR).
            TCS1: u1,
            /// When 1, all requested transmissions have been completed successfully by the CAN2
            /// controller (same as TCS in CAN2GSR).
            TCS2: u1,
            /// Reserved, the value read from a reserved bit is not defined.
            RESERVED: u14,
        }), base_address + 0x0);

        /// address: 0x40040004
        /// CAN Central Receive Status Register
        pub const RXSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// When 1, CAN1 is receiving a message (same as RS in CAN1GSR).
            RS1: u1,
            /// When 1, CAN2 is receiving a message (same as RS in CAN2GSR).
            RS2: u1,
            /// Reserved, the value read from a reserved bit is not defined.
            RESERVED: u6,
            /// When 1, a received message is available in the CAN1 controller (same as RBS in
            /// CAN1GSR).
            RB1: u1,
            /// When 1, a received message is available in the CAN2 controller (same as RBS in
            /// CAN2GSR).
            RB2: u1,
            /// Reserved, the value read from a reserved bit is not defined.
            RESERVED: u6,
            /// When 1, a message was lost because the preceding message to CAN1 controller was
            /// not read out quickly enough (same as DOS in CAN1GSR).
            DOS1: u1,
            /// When 1, a message was lost because the preceding message to CAN2 controller was
            /// not read out quickly enough (same as DOS in CAN2GSR).
            DOS2: u1,
            /// Reserved, the value read from a reserved bit is not defined.
            RESERVED: u14,
        }), base_address + 0x4);

        /// address: 0x40040008
        /// CAN Central Miscellaneous Register
        pub const MSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// When 1, one or both of the CAN1 Tx and Rx Error Counters has reached the limit
            /// set in the CAN1EWL register (same as ES in CAN1GSR)
            E1: u1,
            /// When 1, one or both of the CAN2 Tx and Rx Error Counters has reached the limit
            /// set in the CAN2EWL register (same as ES in CAN2GSR)
            E2: u1,
            /// Reserved, the value read from a reserved bit is not defined.
            RESERVED: u6,
            /// When 1, the CAN1 controller is currently involved in bus activities (same as BS
            /// in CAN1GSR).
            BS1: u1,
            /// When 1, the CAN2 controller is currently involved in bus activities (same as BS
            /// in CAN2GSR).
            BS2: u1,
            /// Reserved, the value read from a reserved bit is not defined.
            RESERVED: u22,
        }), base_address + 0x8);
    };
    /// CAN1 controller
    pub const CAN1 = struct {
        pub const base_address = 0x40044000;

        /// address: 0x40044000
        /// Controls the operating mode of the CAN Controller.
        pub const MOD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reset Mode.
            RM: u1,
            /// Listen Only Mode.
            LOM: u1,
            /// Self Test Mode.
            STM: u1,
            /// Transmit Priority Mode.
            TPM: u1,
            /// Sleep Mode.
            SM: u1,
            /// Receive Polarity Mode.
            RPM: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u1,
            /// Test Mode.
            TM: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x0);

        /// address: 0x40044004
        /// Command bits that affect the state of the CAN Controller
        pub const CMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmission Request.
            TR: u1,
            /// Abort Transmission.
            AT: u1,
            /// Release Receive Buffer.
            RRB: u1,
            /// Clear Data Overrun.
            CDO: u1,
            /// Self Reception Request.
            SRR: u1,
            /// Select Tx Buffer 1.
            STB1: u1,
            /// Select Tx Buffer 2.
            STB2: u1,
            /// Select Tx Buffer 3.
            STB3: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x4);

        /// address: 0x40044008
        /// Global Controller Status and Error Counters. The error counters can only be
        /// written when RM in CANMOD is 1.
        pub const GSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive Buffer Status. After reading all messages and releasing their memory
            /// space with the command 'Release Receive Buffer,' this bit is cleared.
            RBS: u1,
            /// Data Overrun Status. If there is not enough space to store the message within
            /// the Receive Buffer, that message is dropped and the Data Overrun condition is
            /// signalled to the CPU in the moment this message becomes valid. If this message
            /// is not completed successfully (e.g. because of an error), no overrun condition
            /// is signalled.
            DOS: u1,
            /// Transmit Buffer Status.
            TBS: u1,
            /// Transmit Complete Status. The Transmission Complete Status bit is set '0'
            /// (incomplete) whenever the Transmission Request bit or the Self Reception Request
            /// bit is set '1' at least for one of the three Transmit Buffers. The Transmission
            /// Complete Status bit will remain '0' until all messages are transmitted
            /// successfully.
            TCS: u1,
            /// Receive Status. If both the Receive Status and the Transmit Status bits are '0'
            /// (idle), the CAN-Bus is idle. If both bits are set, the controller is waiting to
            /// become idle again. After hardware reset 11 consecutive recessive bits have to be
            /// detected until idle status is reached. After Bus-off this will take 128 times of
            /// 11 consecutive recessive bits.
            RS: u1,
            /// Transmit Status. If both the Receive Status and the Transmit Status bits are '0'
            /// (idle), the CAN-Bus is idle. If both bits are set, the controller is waiting to
            /// become idle again. After hardware reset 11 consecutive recessive bits have to be
            /// detected until idle status is reached. After Bus-off this will take 128 times of
            /// 11 consecutive recessive bits.
            TS: u1,
            /// Error Status. Errors detected during reception or transmission will effect the
            /// error counters according to the CAN specification. The Error Status bit is set
            /// when at least one of the error counters has reached or exceeded the Error
            /// Warning Limit. An Error Warning Interrupt is generated, if enabled. The default
            /// value of the Error Warning Limit after hardware reset is 96 decimal, see also
            /// Section 21.7.7 CAN Error Warning Limit register (CAN1EWL - 0x4004 4018, CAN2EWL
            /// - 0x4004 8018).
            ES: u1,
            /// Bus Status. Mode bit '1' (present) and an Error Warning Interrupt is generated,
            /// if enabled. Afterwards the Transmit Error Counter is set to '127', and the
            /// Receive Error Counter is cleared. It will stay in this mode until the CPU clears
            /// the Reset Mode bit. Once this is completed the CAN Controller will wait the
            /// minimum protocol-defined time (128 occurrences of the Bus-Free signal) counting
            /// down the Transmit Error Counter. After that, the Bus Status bit is cleared
            /// (Bus-On), the Error Status bit is set '0' (ok), the Error Counters are reset,
            /// and an Error Warning Interrupt is generated, if enabled. Reading the TX Error
            /// Counter during this time gives information about the status of the Bus-Off
            /// recovery.
            BS: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u8,
            /// The current value of the Rx Error Counter (an 8-bit value).
            RXERR: u8,
            /// The current value of the Tx Error Counter (an 8-bit value).
            TXERR: u8,
        }), base_address + 0x8);

        /// address: 0x4004400c
        /// Interrupt status, Arbitration Lost Capture, Error Code Capture
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive Interrupt. This bit is set whenever the RBS bit in CANxSR and the RIE
            /// bit in CANxIER are both 1, indicating that a new message was received and stored
            /// in the Receive Buffer. The Receive Interrupt Bit is not cleared upon a read
            /// access to the Interrupt Register. Giving the Command Release Receive Buffer will
            /// clear RI temporarily. If there is another message available within the Receive
            /// Buffer after the release command, RI is set again. Otherwise RI remains cleared.
            RI: u1,
            /// Transmit Interrupt 1. This bit is set when the TBS1 bit in CANxSR goes from 0 to
            /// 1 (whenever a message out of TXB1 was successfully transmitted or aborted),
            /// indicating that Transmit buffer 1 is available, and the TIE1 bit in CANxIER is
            /// 1.
            TI1: u1,
            /// Error Warning Interrupt. This bit is set on every change (set or clear) of
            /// either the Error Status or Bus Status bit in CANxSR and the EIE bit bit is set
            /// within the Interrupt Enable Register at the time of the change.
            EI: u1,
            /// Data Overrun Interrupt. This bit is set when the DOS bit in CANxSR goes from 0
            /// to 1 and the DOIE bit in CANxIER is 1.
            DOI: u1,
            /// Wake-Up Interrupt. This bit is set if the CAN controller is sleeping and bus
            /// activity is detected and the WUIE bit in CANxIER is 1. A Wake-Up Interrupt is
            /// also generated if the CPU tries to set the Sleep bit while the CAN controller is
            /// involved in bus activities or a CAN Interrupt is pending. The WUI flag can also
            /// get asserted when the according enable bit WUIE is not set. In this case a
            /// Wake-Up Interrupt does not get asserted.
            WUI: u1,
            /// Error Passive Interrupt. This bit is set if the EPIE bit in CANxIER is 1, and
            /// the CAN controller switches between Error Passive and Error Active mode in
            /// either direction. This is the case when the CAN Controller has reached the Error
            /// Passive Status (at least one error counter exceeds the CAN protocol defined
            /// level of 127) or if the CAN Controller is in Error Passive Status and enters the
            /// Error Active Status again.
            EPI: u1,
            /// Arbitration Lost Interrupt. This bit is set if the ALIE bit in CANxIER is 1, and
            /// the CAN controller loses arbitration while attempting to transmit. In this case
            /// the CAN node becomes a receiver.
            ALI: u1,
            /// Bus Error Interrupt -- this bit is set if the BEIE bit in CANxIER is 1, and the
            /// CAN controller detects an error on the bus.
            BEI: u1,
            /// ID Ready Interrupt -- this bit is set if the IDIE bit in CANxIER is 1, and a CAN
            /// Identifier has been received (a message was successfully transmitted or
            /// aborted). This bit is set whenever a message was successfully transmitted or
            /// aborted and the IDIE bit is set in the IER register.
            IDI: u1,
            /// Transmit Interrupt 2. This bit is set when the TBS2 bit in CANxSR goes from 0 to
            /// 1 (whenever a message out of TXB2 was successfully transmitted or aborted),
            /// indicating that Transmit buffer 2 is available, and the TIE2 bit in CANxIER is
            /// 1.
            TI2: u1,
            /// Transmit Interrupt 3. This bit is set when the TBS3 bit in CANxSR goes from 0 to
            /// 1 (whenever a message out of TXB3 was successfully transmitted or aborted),
            /// indicating that Transmit buffer 3 is available, and the TIE3 bit in CANxIER is
            /// 1.
            TI3: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u5,
            /// Error Code Capture: when the CAN controller detects a bus error, the location of
            /// the error within the frame is captured in this field. The value reflects an
            /// internal state variable, and as a result is not very linear: 00011 = Start of
            /// Frame 00010 = ID28 ... ID21 00110 = ID20 ... ID18 00100 = SRTR Bit 00101 = IDE
            /// bit 00111 = ID17 ... 13 01111 = ID12 ... ID5 01110 = ID4 ... ID0 01100 = RTR Bit
            /// 01101 = Reserved Bit 1 01001 = Reserved Bit 0 01011 = Data Length Code 01010 =
            /// Data Field 01000 = CRC Sequence 11000 = CRC Delimiter 11001 = Acknowledge Slot
            /// 11011 = Acknowledge Delimiter 11010 = End of Frame 10010 = Intermission Whenever
            /// a bus error occurs, the corresponding bus error interrupt is forced, if enabled.
            /// At the same time, the current position of the Bit Stream Processor is captured
            /// into the Error Code Capture Register. The content within this register is fixed
            /// until the user software has read out its content once. From now on, the capture
            /// mechanism is activated again, i.e. reading the CANxICR enables another Bus Error
            /// Interrupt.
            ERRBIT4_0: u5,
            /// When the CAN controller detects a bus error, the direction of the current bit is
            /// captured in this bit.
            ERRDIR: u1,
            /// When the CAN controller detects a bus error, the type of error is captured in
            /// this field:
            ERRC1_0: u2,
            /// Each time arbitration is lost while trying to send on the CAN, the bit number
            /// within the frame is captured into this field. After the content of ALCBIT is
            /// read, the ALI bit is cleared and a new Arbitration Lost interrupt can occur. 00
            /// = arbitration lost in the first bit (MS) of identifier ... 11 = arbitration lost
            /// in SRTS bit (RTR bit for standard frame messages) 12 = arbitration lost in IDE
            /// bit 13 = arbitration lost in 12th bit of identifier (extended frame only) ... 30
            /// = arbitration lost in last bit of identifier (extended frame only) 31 =
            /// arbitration lost in RTR bit (extended frame only) On arbitration lost, the
            /// corresponding arbitration lost interrupt is forced, if enabled. At that time,
            /// the current bit position of the Bit Stream Processor is captured into the
            /// Arbitration Lost Capture Register. The content within this register is fixed
            /// until the user application has read out its contents once. From now on, the
            /// capture mechanism is activated again.
            ALCBIT: u8,
        }), base_address + 0xc);

        /// address: 0x40044010
        /// Interrupt Enable
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver Interrupt Enable. When the Receive Buffer Status is 'full', the CAN
            /// Controller requests the respective interrupt.
            RIE: u1,
            /// Transmit Interrupt Enable for Buffer1. When a message has been successfully
            /// transmitted out of TXB1 or Transmit Buffer 1 is accessible again (e.g. after an
            /// Abort Transmission command), the CAN Controller requests the respective
            /// interrupt.
            TIE1: u1,
            /// Error Warning Interrupt Enable. If the Error or Bus Status change (see Status
            /// Register), the CAN Controller requests the respective interrupt.
            EIE: u1,
            /// Data Overrun Interrupt Enable. If the Data Overrun Status bit is set (see Status
            /// Register), the CAN Controller requests the respective interrupt.
            DOIE: u1,
            /// Wake-Up Interrupt Enable. If the sleeping CAN controller wakes up, the
            /// respective interrupt is requested.
            WUIE: u1,
            /// Error Passive Interrupt Enable. If the error status of the CAN Controller
            /// changes from error active to error passive or vice versa, the respective
            /// interrupt is requested.
            EPIE: u1,
            /// Arbitration Lost Interrupt Enable. If the CAN Controller has lost arbitration,
            /// the respective interrupt is requested.
            ALIE: u1,
            /// Bus Error Interrupt Enable. If a bus error has been detected, the CAN Controller
            /// requests the respective interrupt.
            BEIE: u1,
            /// ID Ready Interrupt Enable. When a CAN identifier has been received, the CAN
            /// Controller requests the respective interrupt.
            IDIE: u1,
            /// Transmit Interrupt Enable for Buffer2. When a message has been successfully
            /// transmitted out of TXB2 or Transmit Buffer 2 is accessible again (e.g. after an
            /// Abort Transmission command), the CAN Controller requests the respective
            /// interrupt.
            TIE2: u1,
            /// Transmit Interrupt Enable for Buffer3. When a message has been successfully
            /// transmitted out of TXB3 or Transmit Buffer 3 is accessible again (e.g. after an
            /// Abort Transmission command), the CAN Controller requests the respective
            /// interrupt.
            TIE3: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u21,
        }), base_address + 0x10);

        /// address: 0x40044014
        /// Bus Timing. Can only be written when RM in CANMOD is 1.
        pub const BTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Baud Rate Prescaler. The APB clock is divided by (this value plus one) to
            /// produce the CAN clock.
            BRP: u10,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u4,
            /// The Synchronization Jump Width is (this value plus one) CAN clocks.
            SJW: u2,
            /// The delay from the nominal Sync point to the sample point is (this value plus
            /// one) CAN clocks.
            TESG1: u4,
            /// The delay from the sample point to the next nominal sync point is (this value
            /// plus one) CAN clocks. The nominal CAN bit time is (this value plus the value in
            /// TSEG1 plus 3) CAN clocks.
            TESG2: u3,
            /// Sampling
            SAM: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u8,
        }), base_address + 0x14);

        /// address: 0x40044018
        /// Error Warning Limit. Can only be written when RM in CANMOD is 1.
        pub const EWL = @intToPtr(*volatile Mmio(32, packed struct {
            /// During CAN operation, this value is compared to both the Tx and Rx Error
            /// Counters. If either of these counter matches this value, the Error Status (ES)
            /// bit in CANSR is set.
            EWL: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x18);

        /// address: 0x4004401c
        /// Status Register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive Buffer Status. This bit is identical to the RBS bit in the CANxGSR.
            RBS_1: u1,
            /// Data Overrun Status. This bit is identical to the DOS bit in the CANxGSR.
            DOS_1: u1,
            /// Transmit Buffer Status 1.
            TBS1_1: u1,
            /// Transmission Complete Status.
            TCS1_1: u1,
            /// Receive Status. This bit is identical to the RS bit in the GSR.
            RS_1: u1,
            /// Transmit Status 1.
            TS1_1: u1,
            /// Error Status. This bit is identical to the ES bit in the CANxGSR.
            ES_1: u1,
            /// Bus Status. This bit is identical to the BS bit in the CANxGSR.
            BS_1: u1,
            /// Receive Buffer Status. This bit is identical to the RBS bit in the CANxGSR.
            RBS_2: u1,
            /// Data Overrun Status. This bit is identical to the DOS bit in the CANxGSR.
            DOS_2: u1,
            /// Transmit Buffer Status 2.
            TBS2_2: u1,
            /// Transmission Complete Status.
            TCS2_2: u1,
            /// Receive Status. This bit is identical to the RS bit in the GSR.
            RS_2: u1,
            /// Transmit Status 2.
            TS2_2: u1,
            /// Error Status. This bit is identical to the ES bit in the CANxGSR.
            ES_2: u1,
            /// Bus Status. This bit is identical to the BS bit in the CANxGSR.
            BS_2: u1,
            /// Receive Buffer Status. This bit is identical to the RBS bit in the CANxGSR.
            RBS_3: u1,
            /// Data Overrun Status. This bit is identical to the DOS bit in the CANxGSR.
            DOS_3: u1,
            /// Transmit Buffer Status 3.
            TBS3_3: u1,
            /// Transmission Complete Status.
            TCS3_3: u1,
            /// Receive Status. This bit is identical to the RS bit in the GSR.
            RS_3: u1,
            /// Transmit Status 3.
            TS3_3: u1,
            /// Error Status. This bit is identical to the ES bit in the CANxGSR.
            ES_3: u1,
            /// Bus Status. This bit is identical to the BS bit in the CANxGSR.
            BS_3: u1,
            /// Reserved, the value read from a reserved bit is not defined.
            RESERVED: u8,
        }), base_address + 0x1c);

        /// address: 0x40044020
        /// Receive frame status. Can only be written when RM in CANMOD is 1.
        pub const RFS = @intToPtr(*volatile Mmio(32, packed struct {
            /// ID Index. If the BP bit (below) is 0, this value is the zero-based number of the
            /// Lookup Table RAM entry at which the Acceptance Filter matched the received
            /// Identifier. Disabled entries in the Standard tables are included in this
            /// numbering, but will not be matched. See Section 21.17 Examples of acceptance
            /// filter tables and ID index values on page 587 for examples of ID Index values.
            IDINDEX: u10,
            /// If this bit is 1, the current message was received in AF Bypass mode, and the ID
            /// Index field (above) is meaningless.
            BP: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u5,
            /// The field contains the Data Length Code (DLC) field of the current received
            /// message. When RTR = 0, this is related to the number of data bytes available in
            /// the CANRDA and CANRDB registers as follows: 0000-0111 = 0 to 7 bytes1000-1111 =
            /// 8 bytes With RTR = 1, this value indicates the number of data bytes requested to
            /// be sent back, with the same encoding.
            DLC: u4,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u10,
            /// This bit contains the Remote Transmission Request bit of the current received
            /// message. 0 indicates a Data Frame, in which (if DLC is non-zero) data can be
            /// read from the CANRDA and possibly the CANRDB registers. 1 indicates a Remote
            /// frame, in which case the DLC value identifies the number of data bytes requested
            /// to be sent using the same Identifier.
            RTR: u1,
            /// A 0 in this bit indicates that the current received message included an 11-bit
            /// Identifier, while a 1 indicates a 29-bit Identifier. This affects the contents
            /// of the CANid register described below.
            FF: u1,
        }), base_address + 0x20);

        /// address: 0x40044024
        /// Received Identifier. Can only be written when RM in CANMOD is 1.
        pub const RID = @intToPtr(*volatile Mmio(32, packed struct {
            /// The 11-bit Identifier field of the current received message. In CAN 2.0A, these
            /// bits are called ID10-0, while in CAN 2.0B they're called ID29-18.
            ID: u11,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u21,
        }), base_address + 0x24);

        /// address: 0x40044028
        /// Received data bytes 1-4. Can only be written when RM in CANMOD is 1.
        pub const RDA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data 1. If the DLC field in CANRFS >= 0001, this contains the first Data byte of
            /// the current received message.
            DATA1: u8,
            /// Data 2. If the DLC field in CANRFS >= 0010, this contains the first Data byte of
            /// the current received message.
            DATA2: u8,
            /// Data 3. If the DLC field in CANRFS >= 0011, this contains the first Data byte of
            /// the current received message.
            DATA3: u8,
            /// Data 4. If the DLC field in CANRFS >= 0100, this contains the first Data byte of
            /// the current received message.
            DATA4: u8,
        }), base_address + 0x28);

        /// address: 0x4004402c
        /// Received data bytes 5-8. Can only be written when RM in CANMOD is 1.
        pub const RDB = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data 5. If the DLC field in CANRFS >= 0101, this contains the first Data byte of
            /// the current received message.
            DATA5: u8,
            /// Data 6. If the DLC field in CANRFS >= 0110, this contains the first Data byte of
            /// the current received message.
            DATA6: u8,
            /// Data 7. If the DLC field in CANRFS >= 0111, this contains the first Data byte of
            /// the current received message.
            DATA7: u8,
            /// Data 8. If the DLC field in CANRFS >= 1000, this contains the first Data byte of
            /// the current received message.
            DATA8: u8,
        }), base_address + 0x2c);

        /// address: 0x40044030
        /// Transmit
        /// frame info (Tx Buffer )
        pub const TFI1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// If the TPM (Transmit Priority Mode) bit in the CANxMOD register is set to 1,
            /// enabled Tx Buffers contend for the right to send their messages based on this
            /// field. The buffer with the lowest TX Priority value wins the prioritization and
            /// is sent first.
            PRIO: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u8,
            /// Data Length Code. This value is sent in the DLC field of the next transmit
            /// message. In addition, if RTR = 0, this value controls the number of Data bytes
            /// sent in the next transmit message, from the CANxTDA and CANxTDB registers:
            /// 0000-0111 = 0-7 bytes 1xxx = 8 bytes
            DLC: u4,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u10,
            /// This value is sent in the RTR bit of the next transmit message. If this bit is
            /// 0, the number of data bytes called out by the DLC field are sent from the
            /// CANxTDA and CANxTDB registers. If this bit is 1, a Remote Frame is sent,
            /// containing a request for that number of bytes.
            RTR: u1,
            /// If this bit is 0, the next transmit message will be sent with an 11-bit
            /// Identifier (standard frame format), while if it's 1, the message will be sent
            /// with a 29-bit Identifier (extended frame format).
            FF: u1,
        }), base_address + 0x30);

        /// address: 0x40044040
        /// Transmit
        /// frame info (Tx Buffer )
        pub const TFI2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// If the TPM (Transmit Priority Mode) bit in the CANxMOD register is set to 1,
            /// enabled Tx Buffers contend for the right to send their messages based on this
            /// field. The buffer with the lowest TX Priority value wins the prioritization and
            /// is sent first.
            PRIO: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u8,
            /// Data Length Code. This value is sent in the DLC field of the next transmit
            /// message. In addition, if RTR = 0, this value controls the number of Data bytes
            /// sent in the next transmit message, from the CANxTDA and CANxTDB registers:
            /// 0000-0111 = 0-7 bytes 1xxx = 8 bytes
            DLC: u4,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u10,
            /// This value is sent in the RTR bit of the next transmit message. If this bit is
            /// 0, the number of data bytes called out by the DLC field are sent from the
            /// CANxTDA and CANxTDB registers. If this bit is 1, a Remote Frame is sent,
            /// containing a request for that number of bytes.
            RTR: u1,
            /// If this bit is 0, the next transmit message will be sent with an 11-bit
            /// Identifier (standard frame format), while if it's 1, the message will be sent
            /// with a 29-bit Identifier (extended frame format).
            FF: u1,
        }), base_address + 0x40);

        /// address: 0x40044050
        /// Transmit
        /// frame info (Tx Buffer )
        pub const TFI3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// If the TPM (Transmit Priority Mode) bit in the CANxMOD register is set to 1,
            /// enabled Tx Buffers contend for the right to send their messages based on this
            /// field. The buffer with the lowest TX Priority value wins the prioritization and
            /// is sent first.
            PRIO: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u8,
            /// Data Length Code. This value is sent in the DLC field of the next transmit
            /// message. In addition, if RTR = 0, this value controls the number of Data bytes
            /// sent in the next transmit message, from the CANxTDA and CANxTDB registers:
            /// 0000-0111 = 0-7 bytes 1xxx = 8 bytes
            DLC: u4,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u10,
            /// This value is sent in the RTR bit of the next transmit message. If this bit is
            /// 0, the number of data bytes called out by the DLC field are sent from the
            /// CANxTDA and CANxTDB registers. If this bit is 1, a Remote Frame is sent,
            /// containing a request for that number of bytes.
            RTR: u1,
            /// If this bit is 0, the next transmit message will be sent with an 11-bit
            /// Identifier (standard frame format), while if it's 1, the message will be sent
            /// with a 29-bit Identifier (extended frame format).
            FF: u1,
        }), base_address + 0x50);

        /// address: 0x40044034
        /// Transmit
        /// Identifier (Tx Buffer)
        pub const TID1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The 11-bit Identifier to be sent in the next transmit message.
            ID: u11,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u21,
        }), base_address + 0x34);

        /// address: 0x40044044
        /// Transmit
        /// Identifier (Tx Buffer)
        pub const TID2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The 11-bit Identifier to be sent in the next transmit message.
            ID: u11,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u21,
        }), base_address + 0x44);

        /// address: 0x40044054
        /// Transmit
        /// Identifier (Tx Buffer)
        pub const TID3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The 11-bit Identifier to be sent in the next transmit message.
            ID: u11,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u21,
        }), base_address + 0x54);

        /// address: 0x40044038
        /// Transmit
        /// data bytes 1-4 (Tx Buffer)
        pub const TDA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data 1. If RTR = 0 and DLC >= 0001 in the corresponding CANxTFI, this byte is
            /// sent as the first Data byte of the next transmit message.
            DATA1: u8,
            /// Data 2. If RTR = 0 and DLC >= 0010 in the corresponding CANxTFI, this byte is
            /// sent as the 2nd Data byte of the next transmit message.
            DATA2: u8,
            /// Data 3. If RTR = 0 and DLC >= 0011 in the corresponding CANxTFI, this byte is
            /// sent as the 3rd Data byte of the next transmit message.
            DATA3: u8,
            /// Data 4. If RTR = 0 and DLC >= 0100 in the corresponding CANxTFI, this byte is
            /// sent as the 4th Data byte of the next transmit message.
            DATA4: u8,
        }), base_address + 0x38);

        /// address: 0x40044048
        /// Transmit
        /// data bytes 1-4 (Tx Buffer)
        pub const TDA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data 1. If RTR = 0 and DLC >= 0001 in the corresponding CANxTFI, this byte is
            /// sent as the first Data byte of the next transmit message.
            DATA1: u8,
            /// Data 2. If RTR = 0 and DLC >= 0010 in the corresponding CANxTFI, this byte is
            /// sent as the 2nd Data byte of the next transmit message.
            DATA2: u8,
            /// Data 3. If RTR = 0 and DLC >= 0011 in the corresponding CANxTFI, this byte is
            /// sent as the 3rd Data byte of the next transmit message.
            DATA3: u8,
            /// Data 4. If RTR = 0 and DLC >= 0100 in the corresponding CANxTFI, this byte is
            /// sent as the 4th Data byte of the next transmit message.
            DATA4: u8,
        }), base_address + 0x48);

        /// address: 0x40044058
        /// Transmit
        /// data bytes 1-4 (Tx Buffer)
        pub const TDA3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data 1. If RTR = 0 and DLC >= 0001 in the corresponding CANxTFI, this byte is
            /// sent as the first Data byte of the next transmit message.
            DATA1: u8,
            /// Data 2. If RTR = 0 and DLC >= 0010 in the corresponding CANxTFI, this byte is
            /// sent as the 2nd Data byte of the next transmit message.
            DATA2: u8,
            /// Data 3. If RTR = 0 and DLC >= 0011 in the corresponding CANxTFI, this byte is
            /// sent as the 3rd Data byte of the next transmit message.
            DATA3: u8,
            /// Data 4. If RTR = 0 and DLC >= 0100 in the corresponding CANxTFI, this byte is
            /// sent as the 4th Data byte of the next transmit message.
            DATA4: u8,
        }), base_address + 0x58);

        /// address: 0x4004403c
        /// Transmit
        /// data bytes 5-8 (Tx Buffer )
        pub const TDB1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data 5. If RTR = 0 and DLC >= 0101 in the corresponding CANTFI, this byte is
            /// sent as the 5th Data byte of the next transmit message.
            DATA5: u8,
            /// Data 6. If RTR = 0 and DLC >= 0110 in the corresponding CANTFI, this byte is
            /// sent as the 6th Data byte of the next transmit message.
            DATA6: u8,
            /// Data 7. If RTR = 0 and DLC >= 0111 in the corresponding CANTFI, this byte is
            /// sent as the 7th Data byte of the next transmit message.
            DATA7: u8,
            /// Data 8. If RTR = 0 and DLC >= 1000 in the corresponding CANTFI, this byte is
            /// sent as the 8th Data byte of the next transmit message.
            DATA8: u8,
        }), base_address + 0x3c);

        /// address: 0x4004404c
        /// Transmit
        /// data bytes 5-8 (Tx Buffer )
        pub const TDB2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data 5. If RTR = 0 and DLC >= 0101 in the corresponding CANTFI, this byte is
            /// sent as the 5th Data byte of the next transmit message.
            DATA5: u8,
            /// Data 6. If RTR = 0 and DLC >= 0110 in the corresponding CANTFI, this byte is
            /// sent as the 6th Data byte of the next transmit message.
            DATA6: u8,
            /// Data 7. If RTR = 0 and DLC >= 0111 in the corresponding CANTFI, this byte is
            /// sent as the 7th Data byte of the next transmit message.
            DATA7: u8,
            /// Data 8. If RTR = 0 and DLC >= 1000 in the corresponding CANTFI, this byte is
            /// sent as the 8th Data byte of the next transmit message.
            DATA8: u8,
        }), base_address + 0x4c);

        /// address: 0x4004405c
        /// Transmit
        /// data bytes 5-8 (Tx Buffer )
        pub const TDB3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data 5. If RTR = 0 and DLC >= 0101 in the corresponding CANTFI, this byte is
            /// sent as the 5th Data byte of the next transmit message.
            DATA5: u8,
            /// Data 6. If RTR = 0 and DLC >= 0110 in the corresponding CANTFI, this byte is
            /// sent as the 6th Data byte of the next transmit message.
            DATA6: u8,
            /// Data 7. If RTR = 0 and DLC >= 0111 in the corresponding CANTFI, this byte is
            /// sent as the 7th Data byte of the next transmit message.
            DATA7: u8,
            /// Data 8. If RTR = 0 and DLC >= 1000 in the corresponding CANTFI, this byte is
            /// sent as the 8th Data byte of the next transmit message.
            DATA8: u8,
        }), base_address + 0x5c);
    };
    pub const CAN2 = struct {
        pub const base_address = 0x40048000;

        /// address: 0x40048000
        /// Controls the operating mode of the CAN Controller.
        pub const MOD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reset Mode.
            RM: u1,
            /// Listen Only Mode.
            LOM: u1,
            /// Self Test Mode.
            STM: u1,
            /// Transmit Priority Mode.
            TPM: u1,
            /// Sleep Mode.
            SM: u1,
            /// Receive Polarity Mode.
            RPM: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u1,
            /// Test Mode.
            TM: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x0);

        /// address: 0x40048004
        /// Command bits that affect the state of the CAN Controller
        pub const CMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmission Request.
            TR: u1,
            /// Abort Transmission.
            AT: u1,
            /// Release Receive Buffer.
            RRB: u1,
            /// Clear Data Overrun.
            CDO: u1,
            /// Self Reception Request.
            SRR: u1,
            /// Select Tx Buffer 1.
            STB1: u1,
            /// Select Tx Buffer 2.
            STB2: u1,
            /// Select Tx Buffer 3.
            STB3: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x4);

        /// address: 0x40048008
        /// Global Controller Status and Error Counters. The error counters can only be
        /// written when RM in CANMOD is 1.
        pub const GSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive Buffer Status. After reading all messages and releasing their memory
            /// space with the command 'Release Receive Buffer,' this bit is cleared.
            RBS: u1,
            /// Data Overrun Status. If there is not enough space to store the message within
            /// the Receive Buffer, that message is dropped and the Data Overrun condition is
            /// signalled to the CPU in the moment this message becomes valid. If this message
            /// is not completed successfully (e.g. because of an error), no overrun condition
            /// is signalled.
            DOS: u1,
            /// Transmit Buffer Status.
            TBS: u1,
            /// Transmit Complete Status. The Transmission Complete Status bit is set '0'
            /// (incomplete) whenever the Transmission Request bit or the Self Reception Request
            /// bit is set '1' at least for one of the three Transmit Buffers. The Transmission
            /// Complete Status bit will remain '0' until all messages are transmitted
            /// successfully.
            TCS: u1,
            /// Receive Status. If both the Receive Status and the Transmit Status bits are '0'
            /// (idle), the CAN-Bus is idle. If both bits are set, the controller is waiting to
            /// become idle again. After hardware reset 11 consecutive recessive bits have to be
            /// detected until idle status is reached. After Bus-off this will take 128 times of
            /// 11 consecutive recessive bits.
            RS: u1,
            /// Transmit Status. If both the Receive Status and the Transmit Status bits are '0'
            /// (idle), the CAN-Bus is idle. If both bits are set, the controller is waiting to
            /// become idle again. After hardware reset 11 consecutive recessive bits have to be
            /// detected until idle status is reached. After Bus-off this will take 128 times of
            /// 11 consecutive recessive bits.
            TS: u1,
            /// Error Status. Errors detected during reception or transmission will effect the
            /// error counters according to the CAN specification. The Error Status bit is set
            /// when at least one of the error counters has reached or exceeded the Error
            /// Warning Limit. An Error Warning Interrupt is generated, if enabled. The default
            /// value of the Error Warning Limit after hardware reset is 96 decimal, see also
            /// Section 21.7.7 CAN Error Warning Limit register (CAN1EWL - 0x4004 4018, CAN2EWL
            /// - 0x4004 8018).
            ES: u1,
            /// Bus Status. Mode bit '1' (present) and an Error Warning Interrupt is generated,
            /// if enabled. Afterwards the Transmit Error Counter is set to '127', and the
            /// Receive Error Counter is cleared. It will stay in this mode until the CPU clears
            /// the Reset Mode bit. Once this is completed the CAN Controller will wait the
            /// minimum protocol-defined time (128 occurrences of the Bus-Free signal) counting
            /// down the Transmit Error Counter. After that, the Bus Status bit is cleared
            /// (Bus-On), the Error Status bit is set '0' (ok), the Error Counters are reset,
            /// and an Error Warning Interrupt is generated, if enabled. Reading the TX Error
            /// Counter during this time gives information about the status of the Bus-Off
            /// recovery.
            BS: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u8,
            /// The current value of the Rx Error Counter (an 8-bit value).
            RXERR: u8,
            /// The current value of the Tx Error Counter (an 8-bit value).
            TXERR: u8,
        }), base_address + 0x8);

        /// address: 0x4004800c
        /// Interrupt status, Arbitration Lost Capture, Error Code Capture
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive Interrupt. This bit is set whenever the RBS bit in CANxSR and the RIE
            /// bit in CANxIER are both 1, indicating that a new message was received and stored
            /// in the Receive Buffer. The Receive Interrupt Bit is not cleared upon a read
            /// access to the Interrupt Register. Giving the Command Release Receive Buffer will
            /// clear RI temporarily. If there is another message available within the Receive
            /// Buffer after the release command, RI is set again. Otherwise RI remains cleared.
            RI: u1,
            /// Transmit Interrupt 1. This bit is set when the TBS1 bit in CANxSR goes from 0 to
            /// 1 (whenever a message out of TXB1 was successfully transmitted or aborted),
            /// indicating that Transmit buffer 1 is available, and the TIE1 bit in CANxIER is
            /// 1.
            TI1: u1,
            /// Error Warning Interrupt. This bit is set on every change (set or clear) of
            /// either the Error Status or Bus Status bit in CANxSR and the EIE bit bit is set
            /// within the Interrupt Enable Register at the time of the change.
            EI: u1,
            /// Data Overrun Interrupt. This bit is set when the DOS bit in CANxSR goes from 0
            /// to 1 and the DOIE bit in CANxIER is 1.
            DOI: u1,
            /// Wake-Up Interrupt. This bit is set if the CAN controller is sleeping and bus
            /// activity is detected and the WUIE bit in CANxIER is 1. A Wake-Up Interrupt is
            /// also generated if the CPU tries to set the Sleep bit while the CAN controller is
            /// involved in bus activities or a CAN Interrupt is pending. The WUI flag can also
            /// get asserted when the according enable bit WUIE is not set. In this case a
            /// Wake-Up Interrupt does not get asserted.
            WUI: u1,
            /// Error Passive Interrupt. This bit is set if the EPIE bit in CANxIER is 1, and
            /// the CAN controller switches between Error Passive and Error Active mode in
            /// either direction. This is the case when the CAN Controller has reached the Error
            /// Passive Status (at least one error counter exceeds the CAN protocol defined
            /// level of 127) or if the CAN Controller is in Error Passive Status and enters the
            /// Error Active Status again.
            EPI: u1,
            /// Arbitration Lost Interrupt. This bit is set if the ALIE bit in CANxIER is 1, and
            /// the CAN controller loses arbitration while attempting to transmit. In this case
            /// the CAN node becomes a receiver.
            ALI: u1,
            /// Bus Error Interrupt -- this bit is set if the BEIE bit in CANxIER is 1, and the
            /// CAN controller detects an error on the bus.
            BEI: u1,
            /// ID Ready Interrupt -- this bit is set if the IDIE bit in CANxIER is 1, and a CAN
            /// Identifier has been received (a message was successfully transmitted or
            /// aborted). This bit is set whenever a message was successfully transmitted or
            /// aborted and the IDIE bit is set in the IER register.
            IDI: u1,
            /// Transmit Interrupt 2. This bit is set when the TBS2 bit in CANxSR goes from 0 to
            /// 1 (whenever a message out of TXB2 was successfully transmitted or aborted),
            /// indicating that Transmit buffer 2 is available, and the TIE2 bit in CANxIER is
            /// 1.
            TI2: u1,
            /// Transmit Interrupt 3. This bit is set when the TBS3 bit in CANxSR goes from 0 to
            /// 1 (whenever a message out of TXB3 was successfully transmitted or aborted),
            /// indicating that Transmit buffer 3 is available, and the TIE3 bit in CANxIER is
            /// 1.
            TI3: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u5,
            /// Error Code Capture: when the CAN controller detects a bus error, the location of
            /// the error within the frame is captured in this field. The value reflects an
            /// internal state variable, and as a result is not very linear: 00011 = Start of
            /// Frame 00010 = ID28 ... ID21 00110 = ID20 ... ID18 00100 = SRTR Bit 00101 = IDE
            /// bit 00111 = ID17 ... 13 01111 = ID12 ... ID5 01110 = ID4 ... ID0 01100 = RTR Bit
            /// 01101 = Reserved Bit 1 01001 = Reserved Bit 0 01011 = Data Length Code 01010 =
            /// Data Field 01000 = CRC Sequence 11000 = CRC Delimiter 11001 = Acknowledge Slot
            /// 11011 = Acknowledge Delimiter 11010 = End of Frame 10010 = Intermission Whenever
            /// a bus error occurs, the corresponding bus error interrupt is forced, if enabled.
            /// At the same time, the current position of the Bit Stream Processor is captured
            /// into the Error Code Capture Register. The content within this register is fixed
            /// until the user software has read out its content once. From now on, the capture
            /// mechanism is activated again, i.e. reading the CANxICR enables another Bus Error
            /// Interrupt.
            ERRBIT4_0: u5,
            /// When the CAN controller detects a bus error, the direction of the current bit is
            /// captured in this bit.
            ERRDIR: u1,
            /// When the CAN controller detects a bus error, the type of error is captured in
            /// this field:
            ERRC1_0: u2,
            /// Each time arbitration is lost while trying to send on the CAN, the bit number
            /// within the frame is captured into this field. After the content of ALCBIT is
            /// read, the ALI bit is cleared and a new Arbitration Lost interrupt can occur. 00
            /// = arbitration lost in the first bit (MS) of identifier ... 11 = arbitration lost
            /// in SRTS bit (RTR bit for standard frame messages) 12 = arbitration lost in IDE
            /// bit 13 = arbitration lost in 12th bit of identifier (extended frame only) ... 30
            /// = arbitration lost in last bit of identifier (extended frame only) 31 =
            /// arbitration lost in RTR bit (extended frame only) On arbitration lost, the
            /// corresponding arbitration lost interrupt is forced, if enabled. At that time,
            /// the current bit position of the Bit Stream Processor is captured into the
            /// Arbitration Lost Capture Register. The content within this register is fixed
            /// until the user application has read out its contents once. From now on, the
            /// capture mechanism is activated again.
            ALCBIT: u8,
        }), base_address + 0xc);

        /// address: 0x40048010
        /// Interrupt Enable
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver Interrupt Enable. When the Receive Buffer Status is 'full', the CAN
            /// Controller requests the respective interrupt.
            RIE: u1,
            /// Transmit Interrupt Enable for Buffer1. When a message has been successfully
            /// transmitted out of TXB1 or Transmit Buffer 1 is accessible again (e.g. after an
            /// Abort Transmission command), the CAN Controller requests the respective
            /// interrupt.
            TIE1: u1,
            /// Error Warning Interrupt Enable. If the Error or Bus Status change (see Status
            /// Register), the CAN Controller requests the respective interrupt.
            EIE: u1,
            /// Data Overrun Interrupt Enable. If the Data Overrun Status bit is set (see Status
            /// Register), the CAN Controller requests the respective interrupt.
            DOIE: u1,
            /// Wake-Up Interrupt Enable. If the sleeping CAN controller wakes up, the
            /// respective interrupt is requested.
            WUIE: u1,
            /// Error Passive Interrupt Enable. If the error status of the CAN Controller
            /// changes from error active to error passive or vice versa, the respective
            /// interrupt is requested.
            EPIE: u1,
            /// Arbitration Lost Interrupt Enable. If the CAN Controller has lost arbitration,
            /// the respective interrupt is requested.
            ALIE: u1,
            /// Bus Error Interrupt Enable. If a bus error has been detected, the CAN Controller
            /// requests the respective interrupt.
            BEIE: u1,
            /// ID Ready Interrupt Enable. When a CAN identifier has been received, the CAN
            /// Controller requests the respective interrupt.
            IDIE: u1,
            /// Transmit Interrupt Enable for Buffer2. When a message has been successfully
            /// transmitted out of TXB2 or Transmit Buffer 2 is accessible again (e.g. after an
            /// Abort Transmission command), the CAN Controller requests the respective
            /// interrupt.
            TIE2: u1,
            /// Transmit Interrupt Enable for Buffer3. When a message has been successfully
            /// transmitted out of TXB3 or Transmit Buffer 3 is accessible again (e.g. after an
            /// Abort Transmission command), the CAN Controller requests the respective
            /// interrupt.
            TIE3: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u21,
        }), base_address + 0x10);

        /// address: 0x40048014
        /// Bus Timing. Can only be written when RM in CANMOD is 1.
        pub const BTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Baud Rate Prescaler. The APB clock is divided by (this value plus one) to
            /// produce the CAN clock.
            BRP: u10,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u4,
            /// The Synchronization Jump Width is (this value plus one) CAN clocks.
            SJW: u2,
            /// The delay from the nominal Sync point to the sample point is (this value plus
            /// one) CAN clocks.
            TESG1: u4,
            /// The delay from the sample point to the next nominal sync point is (this value
            /// plus one) CAN clocks. The nominal CAN bit time is (this value plus the value in
            /// TSEG1 plus 3) CAN clocks.
            TESG2: u3,
            /// Sampling
            SAM: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u8,
        }), base_address + 0x14);

        /// address: 0x40048018
        /// Error Warning Limit. Can only be written when RM in CANMOD is 1.
        pub const EWL = @intToPtr(*volatile Mmio(32, packed struct {
            /// During CAN operation, this value is compared to both the Tx and Rx Error
            /// Counters. If either of these counter matches this value, the Error Status (ES)
            /// bit in CANSR is set.
            EWL: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x18);

        /// address: 0x4004801c
        /// Status Register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive Buffer Status. This bit is identical to the RBS bit in the CANxGSR.
            RBS_1: u1,
            /// Data Overrun Status. This bit is identical to the DOS bit in the CANxGSR.
            DOS_1: u1,
            /// Transmit Buffer Status 1.
            TBS1_1: u1,
            /// Transmission Complete Status.
            TCS1_1: u1,
            /// Receive Status. This bit is identical to the RS bit in the GSR.
            RS_1: u1,
            /// Transmit Status 1.
            TS1_1: u1,
            /// Error Status. This bit is identical to the ES bit in the CANxGSR.
            ES_1: u1,
            /// Bus Status. This bit is identical to the BS bit in the CANxGSR.
            BS_1: u1,
            /// Receive Buffer Status. This bit is identical to the RBS bit in the CANxGSR.
            RBS_2: u1,
            /// Data Overrun Status. This bit is identical to the DOS bit in the CANxGSR.
            DOS_2: u1,
            /// Transmit Buffer Status 2.
            TBS2_2: u1,
            /// Transmission Complete Status.
            TCS2_2: u1,
            /// Receive Status. This bit is identical to the RS bit in the GSR.
            RS_2: u1,
            /// Transmit Status 2.
            TS2_2: u1,
            /// Error Status. This bit is identical to the ES bit in the CANxGSR.
            ES_2: u1,
            /// Bus Status. This bit is identical to the BS bit in the CANxGSR.
            BS_2: u1,
            /// Receive Buffer Status. This bit is identical to the RBS bit in the CANxGSR.
            RBS_3: u1,
            /// Data Overrun Status. This bit is identical to the DOS bit in the CANxGSR.
            DOS_3: u1,
            /// Transmit Buffer Status 3.
            TBS3_3: u1,
            /// Transmission Complete Status.
            TCS3_3: u1,
            /// Receive Status. This bit is identical to the RS bit in the GSR.
            RS_3: u1,
            /// Transmit Status 3.
            TS3_3: u1,
            /// Error Status. This bit is identical to the ES bit in the CANxGSR.
            ES_3: u1,
            /// Bus Status. This bit is identical to the BS bit in the CANxGSR.
            BS_3: u1,
            /// Reserved, the value read from a reserved bit is not defined.
            RESERVED: u8,
        }), base_address + 0x1c);

        /// address: 0x40048020
        /// Receive frame status. Can only be written when RM in CANMOD is 1.
        pub const RFS = @intToPtr(*volatile Mmio(32, packed struct {
            /// ID Index. If the BP bit (below) is 0, this value is the zero-based number of the
            /// Lookup Table RAM entry at which the Acceptance Filter matched the received
            /// Identifier. Disabled entries in the Standard tables are included in this
            /// numbering, but will not be matched. See Section 21.17 Examples of acceptance
            /// filter tables and ID index values on page 587 for examples of ID Index values.
            IDINDEX: u10,
            /// If this bit is 1, the current message was received in AF Bypass mode, and the ID
            /// Index field (above) is meaningless.
            BP: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u5,
            /// The field contains the Data Length Code (DLC) field of the current received
            /// message. When RTR = 0, this is related to the number of data bytes available in
            /// the CANRDA and CANRDB registers as follows: 0000-0111 = 0 to 7 bytes1000-1111 =
            /// 8 bytes With RTR = 1, this value indicates the number of data bytes requested to
            /// be sent back, with the same encoding.
            DLC: u4,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u10,
            /// This bit contains the Remote Transmission Request bit of the current received
            /// message. 0 indicates a Data Frame, in which (if DLC is non-zero) data can be
            /// read from the CANRDA and possibly the CANRDB registers. 1 indicates a Remote
            /// frame, in which case the DLC value identifies the number of data bytes requested
            /// to be sent using the same Identifier.
            RTR: u1,
            /// A 0 in this bit indicates that the current received message included an 11-bit
            /// Identifier, while a 1 indicates a 29-bit Identifier. This affects the contents
            /// of the CANid register described below.
            FF: u1,
        }), base_address + 0x20);

        /// address: 0x40048024
        /// Received Identifier. Can only be written when RM in CANMOD is 1.
        pub const RID = @intToPtr(*volatile Mmio(32, packed struct {
            /// The 11-bit Identifier field of the current received message. In CAN 2.0A, these
            /// bits are called ID10-0, while in CAN 2.0B they're called ID29-18.
            ID: u11,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u21,
        }), base_address + 0x24);

        /// address: 0x40048028
        /// Received data bytes 1-4. Can only be written when RM in CANMOD is 1.
        pub const RDA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data 1. If the DLC field in CANRFS >= 0001, this contains the first Data byte of
            /// the current received message.
            DATA1: u8,
            /// Data 2. If the DLC field in CANRFS >= 0010, this contains the first Data byte of
            /// the current received message.
            DATA2: u8,
            /// Data 3. If the DLC field in CANRFS >= 0011, this contains the first Data byte of
            /// the current received message.
            DATA3: u8,
            /// Data 4. If the DLC field in CANRFS >= 0100, this contains the first Data byte of
            /// the current received message.
            DATA4: u8,
        }), base_address + 0x28);

        /// address: 0x4004802c
        /// Received data bytes 5-8. Can only be written when RM in CANMOD is 1.
        pub const RDB = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data 5. If the DLC field in CANRFS >= 0101, this contains the first Data byte of
            /// the current received message.
            DATA5: u8,
            /// Data 6. If the DLC field in CANRFS >= 0110, this contains the first Data byte of
            /// the current received message.
            DATA6: u8,
            /// Data 7. If the DLC field in CANRFS >= 0111, this contains the first Data byte of
            /// the current received message.
            DATA7: u8,
            /// Data 8. If the DLC field in CANRFS >= 1000, this contains the first Data byte of
            /// the current received message.
            DATA8: u8,
        }), base_address + 0x2c);

        /// address: 0x40048030
        /// Transmit
        /// frame info (Tx Buffer )
        pub const TFI1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// If the TPM (Transmit Priority Mode) bit in the CANxMOD register is set to 1,
            /// enabled Tx Buffers contend for the right to send their messages based on this
            /// field. The buffer with the lowest TX Priority value wins the prioritization and
            /// is sent first.
            PRIO: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u8,
            /// Data Length Code. This value is sent in the DLC field of the next transmit
            /// message. In addition, if RTR = 0, this value controls the number of Data bytes
            /// sent in the next transmit message, from the CANxTDA and CANxTDB registers:
            /// 0000-0111 = 0-7 bytes 1xxx = 8 bytes
            DLC: u4,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u10,
            /// This value is sent in the RTR bit of the next transmit message. If this bit is
            /// 0, the number of data bytes called out by the DLC field are sent from the
            /// CANxTDA and CANxTDB registers. If this bit is 1, a Remote Frame is sent,
            /// containing a request for that number of bytes.
            RTR: u1,
            /// If this bit is 0, the next transmit message will be sent with an 11-bit
            /// Identifier (standard frame format), while if it's 1, the message will be sent
            /// with a 29-bit Identifier (extended frame format).
            FF: u1,
        }), base_address + 0x30);

        /// address: 0x40048040
        /// Transmit
        /// frame info (Tx Buffer )
        pub const TFI2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// If the TPM (Transmit Priority Mode) bit in the CANxMOD register is set to 1,
            /// enabled Tx Buffers contend for the right to send their messages based on this
            /// field. The buffer with the lowest TX Priority value wins the prioritization and
            /// is sent first.
            PRIO: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u8,
            /// Data Length Code. This value is sent in the DLC field of the next transmit
            /// message. In addition, if RTR = 0, this value controls the number of Data bytes
            /// sent in the next transmit message, from the CANxTDA and CANxTDB registers:
            /// 0000-0111 = 0-7 bytes 1xxx = 8 bytes
            DLC: u4,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u10,
            /// This value is sent in the RTR bit of the next transmit message. If this bit is
            /// 0, the number of data bytes called out by the DLC field are sent from the
            /// CANxTDA and CANxTDB registers. If this bit is 1, a Remote Frame is sent,
            /// containing a request for that number of bytes.
            RTR: u1,
            /// If this bit is 0, the next transmit message will be sent with an 11-bit
            /// Identifier (standard frame format), while if it's 1, the message will be sent
            /// with a 29-bit Identifier (extended frame format).
            FF: u1,
        }), base_address + 0x40);

        /// address: 0x40048050
        /// Transmit
        /// frame info (Tx Buffer )
        pub const TFI3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// If the TPM (Transmit Priority Mode) bit in the CANxMOD register is set to 1,
            /// enabled Tx Buffers contend for the right to send their messages based on this
            /// field. The buffer with the lowest TX Priority value wins the prioritization and
            /// is sent first.
            PRIO: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u8,
            /// Data Length Code. This value is sent in the DLC field of the next transmit
            /// message. In addition, if RTR = 0, this value controls the number of Data bytes
            /// sent in the next transmit message, from the CANxTDA and CANxTDB registers:
            /// 0000-0111 = 0-7 bytes 1xxx = 8 bytes
            DLC: u4,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u10,
            /// This value is sent in the RTR bit of the next transmit message. If this bit is
            /// 0, the number of data bytes called out by the DLC field are sent from the
            /// CANxTDA and CANxTDB registers. If this bit is 1, a Remote Frame is sent,
            /// containing a request for that number of bytes.
            RTR: u1,
            /// If this bit is 0, the next transmit message will be sent with an 11-bit
            /// Identifier (standard frame format), while if it's 1, the message will be sent
            /// with a 29-bit Identifier (extended frame format).
            FF: u1,
        }), base_address + 0x50);

        /// address: 0x40048034
        /// Transmit
        /// Identifier (Tx Buffer)
        pub const TID1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The 11-bit Identifier to be sent in the next transmit message.
            ID: u11,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u21,
        }), base_address + 0x34);

        /// address: 0x40048044
        /// Transmit
        /// Identifier (Tx Buffer)
        pub const TID2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The 11-bit Identifier to be sent in the next transmit message.
            ID: u11,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u21,
        }), base_address + 0x44);

        /// address: 0x40048054
        /// Transmit
        /// Identifier (Tx Buffer)
        pub const TID3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The 11-bit Identifier to be sent in the next transmit message.
            ID: u11,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u21,
        }), base_address + 0x54);

        /// address: 0x40048038
        /// Transmit
        /// data bytes 1-4 (Tx Buffer)
        pub const TDA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data 1. If RTR = 0 and DLC >= 0001 in the corresponding CANxTFI, this byte is
            /// sent as the first Data byte of the next transmit message.
            DATA1: u8,
            /// Data 2. If RTR = 0 and DLC >= 0010 in the corresponding CANxTFI, this byte is
            /// sent as the 2nd Data byte of the next transmit message.
            DATA2: u8,
            /// Data 3. If RTR = 0 and DLC >= 0011 in the corresponding CANxTFI, this byte is
            /// sent as the 3rd Data byte of the next transmit message.
            DATA3: u8,
            /// Data 4. If RTR = 0 and DLC >= 0100 in the corresponding CANxTFI, this byte is
            /// sent as the 4th Data byte of the next transmit message.
            DATA4: u8,
        }), base_address + 0x38);

        /// address: 0x40048048
        /// Transmit
        /// data bytes 1-4 (Tx Buffer)
        pub const TDA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data 1. If RTR = 0 and DLC >= 0001 in the corresponding CANxTFI, this byte is
            /// sent as the first Data byte of the next transmit message.
            DATA1: u8,
            /// Data 2. If RTR = 0 and DLC >= 0010 in the corresponding CANxTFI, this byte is
            /// sent as the 2nd Data byte of the next transmit message.
            DATA2: u8,
            /// Data 3. If RTR = 0 and DLC >= 0011 in the corresponding CANxTFI, this byte is
            /// sent as the 3rd Data byte of the next transmit message.
            DATA3: u8,
            /// Data 4. If RTR = 0 and DLC >= 0100 in the corresponding CANxTFI, this byte is
            /// sent as the 4th Data byte of the next transmit message.
            DATA4: u8,
        }), base_address + 0x48);

        /// address: 0x40048058
        /// Transmit
        /// data bytes 1-4 (Tx Buffer)
        pub const TDA3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data 1. If RTR = 0 and DLC >= 0001 in the corresponding CANxTFI, this byte is
            /// sent as the first Data byte of the next transmit message.
            DATA1: u8,
            /// Data 2. If RTR = 0 and DLC >= 0010 in the corresponding CANxTFI, this byte is
            /// sent as the 2nd Data byte of the next transmit message.
            DATA2: u8,
            /// Data 3. If RTR = 0 and DLC >= 0011 in the corresponding CANxTFI, this byte is
            /// sent as the 3rd Data byte of the next transmit message.
            DATA3: u8,
            /// Data 4. If RTR = 0 and DLC >= 0100 in the corresponding CANxTFI, this byte is
            /// sent as the 4th Data byte of the next transmit message.
            DATA4: u8,
        }), base_address + 0x58);

        /// address: 0x4004803c
        /// Transmit
        /// data bytes 5-8 (Tx Buffer )
        pub const TDB1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data 5. If RTR = 0 and DLC >= 0101 in the corresponding CANTFI, this byte is
            /// sent as the 5th Data byte of the next transmit message.
            DATA5: u8,
            /// Data 6. If RTR = 0 and DLC >= 0110 in the corresponding CANTFI, this byte is
            /// sent as the 6th Data byte of the next transmit message.
            DATA6: u8,
            /// Data 7. If RTR = 0 and DLC >= 0111 in the corresponding CANTFI, this byte is
            /// sent as the 7th Data byte of the next transmit message.
            DATA7: u8,
            /// Data 8. If RTR = 0 and DLC >= 1000 in the corresponding CANTFI, this byte is
            /// sent as the 8th Data byte of the next transmit message.
            DATA8: u8,
        }), base_address + 0x3c);

        /// address: 0x4004804c
        /// Transmit
        /// data bytes 5-8 (Tx Buffer )
        pub const TDB2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data 5. If RTR = 0 and DLC >= 0101 in the corresponding CANTFI, this byte is
            /// sent as the 5th Data byte of the next transmit message.
            DATA5: u8,
            /// Data 6. If RTR = 0 and DLC >= 0110 in the corresponding CANTFI, this byte is
            /// sent as the 6th Data byte of the next transmit message.
            DATA6: u8,
            /// Data 7. If RTR = 0 and DLC >= 0111 in the corresponding CANTFI, this byte is
            /// sent as the 7th Data byte of the next transmit message.
            DATA7: u8,
            /// Data 8. If RTR = 0 and DLC >= 1000 in the corresponding CANTFI, this byte is
            /// sent as the 8th Data byte of the next transmit message.
            DATA8: u8,
        }), base_address + 0x4c);

        /// address: 0x4004805c
        /// Transmit
        /// data bytes 5-8 (Tx Buffer )
        pub const TDB3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data 5. If RTR = 0 and DLC >= 0101 in the corresponding CANTFI, this byte is
            /// sent as the 5th Data byte of the next transmit message.
            DATA5: u8,
            /// Data 6. If RTR = 0 and DLC >= 0110 in the corresponding CANTFI, this byte is
            /// sent as the 6th Data byte of the next transmit message.
            DATA6: u8,
            /// Data 7. If RTR = 0 and DLC >= 0111 in the corresponding CANTFI, this byte is
            /// sent as the 7th Data byte of the next transmit message.
            DATA7: u8,
            /// Data 8. If RTR = 0 and DLC >= 1000 in the corresponding CANTFI, this byte is
            /// sent as the 8th Data byte of the next transmit message.
            DATA8: u8,
        }), base_address + 0x5c);
    };
    pub const I2C1 = struct {
        pub const base_address = 0x4005c000;

        /// address: 0x4005c000
        /// I2C Control Set Register. When a one is written to a bit of this register, the
        /// corresponding bit in the I2C control register is set. Writing a zero has no
        /// effect on the corresponding bit in the I2C control register.
        pub const CONSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. User software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u2,
            /// Assert acknowledge flag.
            AA: u1,
            /// I2C interrupt flag.
            SI: u1,
            /// STOP flag.
            STO: u1,
            /// START flag.
            STA: u1,
            /// I2C interface enable.
            I2EN: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u25,
        }), base_address + 0x0);

        /// address: 0x4005c004
        /// I2C Status Register. During I2C operation, this register provides detailed
        /// status codes that allow software to determine the next action needed.
        pub const STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits are unused and are always 0.
            RESERVED: u3,
            /// These bits give the actual status information about the I 2C interface.
            Status: u5,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x4);

        /// address: 0x4005c008
        /// I2C Data Register. During master or slave transmit mode, data to be transmitted
        /// is written to this register. During master or slave receive mode, data that has
        /// been received may be read from this register.
        pub const DAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register holds data values that have been received or are to be
            /// transmitted.
            Data: u8,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x8);

        /// address: 0x4005c00c
        /// I2C Slave Address Register 0. Contains the 7-bit slave address for operation of
        /// the I2C interface in slave mode, and is not used in master mode. The least
        /// significant bit determines whether a slave responds to the General Call address.
        pub const ADR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// General Call enable bit.
            GC: u1,
            /// The I2C device address for slave mode.
            Address: u7,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0xc);

        /// address: 0x4005c010
        /// SCH Duty Cycle Register High Half Word. Determines the high time of the I2C
        /// clock.
        pub const SCLH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Count for SCL HIGH time period selection.
            SCLH: u16,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u16,
        }), base_address + 0x10);

        /// address: 0x4005c014
        /// SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock.
        /// SCLL and SCLH together determine the clock frequency generated by an I2C master
        /// and certain times used in slave mode.
        pub const SCLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Count for SCL low time period selection.
            SCLL: u16,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u16,
        }), base_address + 0x14);

        /// address: 0x4005c018
        /// I2C Control Clear Register. When a one is written to a bit of this register, the
        /// corresponding bit in the I2C control register is cleared. Writing a zero has no
        /// effect on the corresponding bit in the I2C control register.
        pub const CONCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. User software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u2,
            /// Assert acknowledge Clear bit.
            AAC: u1,
            /// I2C interrupt Clear bit.
            SIC: u1,
            /// Reserved. User software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u1,
            /// START flag Clear bit.
            STAC: u1,
            /// I2C interface Disable bit.
            I2ENC: u1,
            /// Reserved. User software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x18);

        /// address: 0x4005c01c
        /// Monitor mode control register.
        pub const MMCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Monitor mode enable.
            MM_ENA: u1,
            /// SCL output enable.
            ENA_SCL: u1,
            /// Select interrupt register match.
            MATCH_ALL: u1,
            /// Reserved. The value read from reserved bits is not defined.
            RESERVED: u29,
        }), base_address + 0x1c);

        /// address: 0x4005c020
        /// I2C Slave Address Register. Contains the 7-bit slave address for operation of
        /// the I2C interface in slave mode, and is not used in master mode. The least
        /// significant bit determines whether a slave responds to the General Call address.
        pub const ADR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// General Call enable bit.
            GC: u1,
            /// The I2C device address for slave mode.
            Address: u7,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x20);

        /// address: 0x4005c024
        /// I2C Slave Address Register. Contains the 7-bit slave address for operation of
        /// the I2C interface in slave mode, and is not used in master mode. The least
        /// significant bit determines whether a slave responds to the General Call address.
        pub const ADR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// General Call enable bit.
            GC: u1,
            /// The I2C device address for slave mode.
            Address: u7,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x24);

        /// address: 0x4005c028
        /// I2C Slave Address Register. Contains the 7-bit slave address for operation of
        /// the I2C interface in slave mode, and is not used in master mode. The least
        /// significant bit determines whether a slave responds to the General Call address.
        pub const ADR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// General Call enable bit.
            GC: u1,
            /// The I2C device address for slave mode.
            Address: u7,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x28);

        /// address: 0x4005c02c
        /// Data buffer register. The contents of the 8 MSBs of the DAT shift register will
        /// be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of
        /// data plus ACK or NACK) has been received on the bus.
        pub const DATA_BUFFER = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register holds contents of the 8 MSBs of the DAT shift register.
            Data: u8,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x2c);

        /// address: 0x4005c030
        /// I2C Slave address mask register
        pub const MASK = @intToPtr(*volatile [4]Mmio(32, packed struct {
            /// Reserved. User software should not write ones to reserved bits. This bit reads
            /// always back as 0.
            RESERVED: u1,
            /// Mask bits.
            MASK: u7,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x30);
    };
    /// SSP controller
    pub const SSP0 = struct {
        pub const base_address = 0x40088000;

        /// address: 0x40088000
        /// Control Register 0. Selects the serial clock rate, bus type, and data size.
        pub const CR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Size Select. This field controls the number of bits transferred in each
            /// frame. Values 0000-0010 are not supported and should not be used.
            DSS: u4,
            /// Frame Format.
            FRF: u2,
            /// Clock Out Polarity. This bit is only used in SPI mode.
            CPOL: u1,
            /// Clock Out Phase. This bit is only used in SPI mode.
            CPHA: u1,
            /// Serial Clock Rate. The number of prescaler-output clocks per bit on the bus,
            /// minus one. Given that CPSDVSR is the prescale divider, and the APB clock PCLK
            /// clocks the prescaler, the bit frequency is PCLK / (CPSDVSR X [SCR+1]).
            SCR: u8,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u16,
        }), base_address + 0x0);

        /// address: 0x40088004
        /// Control Register 1. Selects master/slave and other modes.
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Loop Back Mode.
            LBM: u1,
            /// SSP Enable.
            SSE: u1,
            /// Master/Slave Mode.This bit can only be written when the SSE bit is 0.
            MS: u1,
            /// Slave Output Disable. This bit is relevant only in slave mode (MS = 1). If it is
            /// 1, this blocks this SSP controller from driving the transmit data line (MISO).
            SOD: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u28,
        }), base_address + 0x4);

        /// address: 0x40088008
        /// Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO.
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write: software can write data to be sent in a future frame to this register
            /// whenever the TNF bit in the Status register is 1, indicating that the Tx FIFO is
            /// not full. If the Tx FIFO was previously empty and the SSP controller is not busy
            /// on the bus, transmission of the data will begin immediately. Otherwise the data
            /// written to this register will be sent as soon as all previous data has been sent
            /// (and received). If the data length is less than 16 bits, software must
            /// right-justify the data written to this register. Read: software can read data
            /// from this register whenever the RNE bit in the Status register is 1, indicating
            /// that the Rx FIFO is not empty. When software reads this register, the SSP
            /// controller returns data from the least recent frame in the Rx FIFO. If the data
            /// length is less than 16 bits, the data is right-justified in this field with
            /// higher order bits filled with 0s.
            DATA: u16,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u16,
        }), base_address + 0x8);

        /// address: 0x4008800c
        /// Status Register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit FIFO Empty. This bit is 1 is the Transmit FIFO is empty, 0 if not.
            TFE: u1,
            /// Transmit FIFO Not Full. This bit is 0 if the Tx FIFO is full, 1 if not.
            TNF: u1,
            /// Receive FIFO Not Empty. This bit is 0 if the Receive FIFO is empty, 1 if not.
            RNE: u1,
            /// Receive FIFO Full. This bit is 1 if the Receive FIFO is full, 0 if not.
            RFF: u1,
            /// Busy. This bit is 0 if the SSPn controller is idle, or 1 if it is currently
            /// sending/receiving a frame and/or the Tx FIFO is not empty.
            BSY: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u27,
        }), base_address + 0xc);

        /// address: 0x40088010
        /// Clock Prescale Register
        pub const CPSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// This even value between 2 and 254, by which PCLK is divided to yield the
            /// prescaler output clock. Bit 0 always reads as 0.
            CPSDVSR: u8,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED0: u8 = 0,
            RESERVED1: u16 = 0,
        }), base_address + 0x10);

        /// address: 0x40088014
        /// Interrupt Mask Set and Clear Register
        pub const IMSC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software should set this bit to enable interrupt when a Receive Overrun occurs,
            /// that is, when the Rx FIFO is full and another frame is completely received. The
            /// ARM spec implies that the preceding frame data is overwritten by the new frame
            /// data when this occurs.
            RORIM: u1,
            /// Software should set this bit to enable interrupt when a Receive Time-out
            /// condition occurs. A Receive Time-out occurs when the Rx FIFO is not empty, and
            /// no has not been read for a time-out period. The time-out period is the same for
            /// master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK /
            /// (CPSDVSR X [SCR+1]).
            RTIM: u1,
            /// Software should set this bit to enable interrupt when the Rx FIFO is at least
            /// half full.
            RXIM: u1,
            /// Software should set this bit to enable interrupt when the Tx FIFO is at least
            /// half empty.
            TXIM: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u28,
        }), base_address + 0x14);

        /// address: 0x40088018
        /// Raw Interrupt Status Register
        pub const RIS = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit is 1 if another frame was completely received while the RxFIFO was
            /// full. The ARM spec implies that the preceding frame data is overwritten by the
            /// new frame data when this occurs.
            RORRIS: u1,
            /// This bit is 1 if the Rx FIFO is not empty, and has not been read for a time-out
            /// period. The time-out period is the same for master and slave modes and is
            /// determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X [SCR+1]).
            RTRIS: u1,
            /// This bit is 1 if the Rx FIFO is at least half full.
            RXRIS: u1,
            /// This bit is 1 if the Tx FIFO is at least half empty.
            TXRIS: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u28,
        }), base_address + 0x18);

        /// address: 0x4008801c
        /// Masked Interrupt Status Register
        pub const MIS = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit is 1 if another frame was completely received while the RxFIFO was
            /// full, and this interrupt is enabled.
            RORMIS: u1,
            /// This bit is 1 if the Rx FIFO is not empty, has not been read for a time-out
            /// period, and this interrupt is enabled. The time-out period is the same for
            /// master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK /
            /// (CPSDVSR X [SCR+1]).
            RTMIS: u1,
            /// This bit is 1 if the Rx FIFO is at least half full, and this interrupt is
            /// enabled.
            RXMIS: u1,
            /// This bit is 1 if the Tx FIFO is at least half empty, and this interrupt is
            /// enabled.
            TXMIS: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u28,
        }), base_address + 0x1c);

        /// address: 0x40088020
        /// SSPICR Interrupt Clear Register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a 1 to this bit clears the frame was received when RxFIFO was full
            /// interrupt.
            RORIC: u1,
            /// Writing a 1 to this bit clears the Rx FIFO was not empty and has not been read
            /// for a time-out period interrupt. The time-out period is the same for master and
            /// slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR /
            /// [SCR+1]).
            RTIC: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u30,
        }), base_address + 0x20);

        /// address: 0x40088024
        /// SSP0 DMA control register
        pub const DMACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive DMA Enable. When this bit is set to one 1, DMA for the receive FIFO is
            /// enabled, otherwise receive DMA is disabled.
            RXDMAE: u1,
            /// Transmit DMA Enable. When this bit is set to one 1, DMA for the transmit FIFO is
            /// enabled, otherwise transmit DMA is disabled
            TXDMAE: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u30,
        }), base_address + 0x24);
    };
    /// Digital-to-Analog Converter (DAC)
    pub const DAC = struct {
        pub const base_address = 0x4008c000;

        /// address: 0x4008c000
        /// D/A Converter Register. This register contains the digital value to be converted
        /// to analog and a power control bit.
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u6,
            /// After the selected settling time after this field is written with a new VALUE,
            /// the voltage on the DAC_OUT pin (with respect to VSSA) is VALUE x ((VREFP - V
            /// REFN)/1024) + VREFN.
            VALUE: u10,
            /// Settling time The settling times noted in the description of the BIAS bit are
            /// valid for a capacitance load on the DAC_OUT pin not exceeding 100 pF. A load
            /// impedance value greater than that value will cause settling time longer than the
            /// specified time. One or more graphs of load impedance vs. settling time will be
            /// included in the final data sheet.
            BIAS: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u15,
        }), base_address + 0x0);

        /// address: 0x4008c004
        /// DAC Control register. This register controls DMA and timer operation.
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA interrupt request
            INT_DMA_REQ: u1,
            /// Double buffering
            DBLBUF_ENA: u1,
            /// Time-out counter operation
            CNT_ENA: u1,
            /// DMA access
            DMA_ENA: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u28,
        }), base_address + 0x4);

        /// address: 0x4008c008
        /// DAC Counter Value register. This register contains the reload value for the DAC
        /// DMA/Interrupt timer.
        pub const CNTVAL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 16-bit reload value for the DAC interrupt/DMA timer.
            VALUE: u16,
            /// Reserved
            RESERVED: u16,
        }), base_address + 0x8);
    };
    pub const TIMER2 = struct {
        pub const base_address = 0x40090000;

        /// address: 0x40090000
        /// Interrupt Register. The IR can be written to clear interrupts. The IR can be
        /// read to identify which of eight possible interrupt sources are pending.
        pub const IR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt flag for match channel 0.
            MR0INT: u1,
            /// Interrupt flag for match channel 1.
            MR1INT: u1,
            /// Interrupt flag for match channel 2.
            MR2INT: u1,
            /// Interrupt flag for match channel 3.
            MR3INT: u1,
            /// Interrupt flag for capture channel 0 event.
            CR0INT: u1,
            /// Interrupt flag for capture channel 1 event.
            CR1INT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u26,
        }), base_address + 0x0);

        /// address: 0x40090004
        /// Timer Control Register. The TCR is used to control the Timer Counter functions.
        /// The Timer Counter can be disabled or reset through the TCR.
        pub const TCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// When one, the Timer Counter and Prescale Counter are enabled for counting. When
            /// zero, the counters are disabled.
            CEN: u1,
            /// When one, the Timer Counter and the Prescale Counter are synchronously reset on
            /// the next positive edge of PCLK. The counters remain reset until TCR[1] is
            /// returned to zero.
            CRST: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u30,
        }), base_address + 0x4);

        /// address: 0x40090008
        /// Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is
        /// controlled through the TCR.
        pub const TC = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4009000c
        /// Prescale Register. When the Prescale Counter (PC) is equal to this value, the
        /// next clock increments the TC and clears the PC.
        pub const PR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescale counter maximum value.
            PM: u32,
        }), base_address + 0xc);

        /// address: 0x40090010
        /// Prescale Counter. The 32 bit PC is a counter which is incremented to the value
        /// stored in PR. When the value in PR is reached, the TC is incremented and the PC
        /// is cleared. The PC is observable and controllable through the bus interface.
        pub const PC = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40090014
        /// Match Control Register. The MCR is used to control if an interrupt is generated
        /// and if the TC is reset when a Match occurs.
        pub const MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt on MR0
            MR0I: u1,
            /// Reset on MR0
            MR0R: u1,
            /// Stop on MR0
            MR0S: u1,
            /// Interrupt on MR1
            MR1I: u1,
            /// Reset on MR1
            MR1R: u1,
            /// Stop on MR1
            MR1S: u1,
            /// Interrupt on MR2
            MR2I: u1,
            /// Reset on MR2
            MR2R: u1,
            /// Stop on MR2.
            MR2S: u1,
            /// Interrupt on MR3
            MR3I: u1,
            /// Reset on MR3
            MR3R: u1,
            /// Stop on MR3
            MR3S: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u20,
        }), base_address + 0x14);

        /// address: 0x40090018
        /// Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both
        /// the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
        pub const MR = @intToPtr(*volatile [4]Mmio(32, packed struct {
            /// Timer counter match value.
            MATCH: u32,
        }), base_address + 0x18);

        /// address: 0x40090028
        /// Capture Control Register. The CCR controls which edges of the capture inputs are
        /// used to load the Capture Registers and whether or not an interrupt is generated
        /// when a capture takes place.
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture on CAPn.0 rising edge
            CAP0RE: u1,
            /// Capture on CAPn.0 falling edge
            CAP0FE: u1,
            /// Interrupt on CAPn.0 event
            CAP0I: u1,
            /// Capture on CAPn.1 rising edge
            CAP1RE: u1,
            /// Capture on CAPn.1 falling edge
            CAP1FE: u1,
            /// Interrupt on CAPn.1 event
            CAP1I: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u26,
        }), base_address + 0x28);

        /// address: 0x4009002c
        /// Capture Register 0. CR0 is loaded with the value of TC when there is an event on
        /// the CAPn.0 input.
        pub const CR = @intToPtr(*volatile [2]Mmio(32, packed struct {
            /// Timer counter capture value.
            CAP: u32,
        }), base_address + 0x2c);

        /// address: 0x4009003c
        /// External Match Register. The EMR controls the external match pins.
        pub const EMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// External Match 0. When a match occurs between the TC and MR0, this bit can
            /// either toggle, go low, go high, or do nothing, depending on bits 5:4 of this
            /// register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner
            /// (0 = low, 1 = high).
            EM0: u1,
            /// External Match 1. When a match occurs between the TC and MR1, this bit can
            /// either toggle, go low, go high, or do nothing, depending on bits 7:6 of this
            /// register. This bit can be driven onto a MATn.1 pin, in a positive-logic manner
            /// (0 = low, 1 = high).
            EM1: u1,
            /// External Match 2. When a match occurs between the TC and MR2, this bit can
            /// either toggle, go low, go high, or do nothing, depending on bits 9:8 of this
            /// register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner
            /// (0 = low, 1 = high).
            EM2: u1,
            /// External Match 3. When a match occurs between the TC and MR3, this bit can
            /// either toggle, go low, go high, or do nothing, depending on bits 11:10 of this
            /// register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner
            /// (0 = low, 1 = high).
            EM3: u1,
            /// External Match Control 0. Determines the functionality of External Match 0.
            EMC0: u2,
            /// External Match Control 1. Determines the functionality of External Match 1.
            EMC1: u2,
            /// External Match Control 2. Determines the functionality of External Match 2.
            EMC2: u2,
            /// External Match Control 3. Determines the functionality of External Match 3.
            EMC3: u2,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u20,
        }), base_address + 0x3c);

        /// address: 0x40090070
        /// Count Control Register. The CTCR selects between Timer and Counter mode, and in
        /// Counter mode selects the signal and edge(s) for counting.
        pub const CTCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter/Timer Mode This field selects which rising PCLK edges can increment
            /// Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC).
            /// Timer Mode: the TC is incremented when the Prescale Counter matches the Prescale
            /// Register.
            CTMODE: u2,
            /// Count Input Select When bits 1:0 in this register are not 00, these bits select
            /// which CAP pin is sampled for clocking. Note: If Counter mode is selected for a
            /// particular CAPn input in the TnCTCR, the 3 bits for that input in the Capture
            /// Control Register (TnCCR) must be programmed as 000. However, capture and/or
            /// interrupt can be selected for the other 3 CAPn inputs in the same timer.
            CINSEL: u2,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u28,
        }), base_address + 0x70);
    };
    pub const TIMER3 = struct {
        pub const base_address = 0x40094000;

        /// address: 0x40094000
        /// Interrupt Register. The IR can be written to clear interrupts. The IR can be
        /// read to identify which of eight possible interrupt sources are pending.
        pub const IR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt flag for match channel 0.
            MR0INT: u1,
            /// Interrupt flag for match channel 1.
            MR1INT: u1,
            /// Interrupt flag for match channel 2.
            MR2INT: u1,
            /// Interrupt flag for match channel 3.
            MR3INT: u1,
            /// Interrupt flag for capture channel 0 event.
            CR0INT: u1,
            /// Interrupt flag for capture channel 1 event.
            CR1INT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u26,
        }), base_address + 0x0);

        /// address: 0x40094004
        /// Timer Control Register. The TCR is used to control the Timer Counter functions.
        /// The Timer Counter can be disabled or reset through the TCR.
        pub const TCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// When one, the Timer Counter and Prescale Counter are enabled for counting. When
            /// zero, the counters are disabled.
            CEN: u1,
            /// When one, the Timer Counter and the Prescale Counter are synchronously reset on
            /// the next positive edge of PCLK. The counters remain reset until TCR[1] is
            /// returned to zero.
            CRST: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u30,
        }), base_address + 0x4);

        /// address: 0x40094008
        /// Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is
        /// controlled through the TCR.
        pub const TC = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4009400c
        /// Prescale Register. When the Prescale Counter (PC) is equal to this value, the
        /// next clock increments the TC and clears the PC.
        pub const PR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescale counter maximum value.
            PM: u32,
        }), base_address + 0xc);

        /// address: 0x40094010
        /// Prescale Counter. The 32 bit PC is a counter which is incremented to the value
        /// stored in PR. When the value in PR is reached, the TC is incremented and the PC
        /// is cleared. The PC is observable and controllable through the bus interface.
        pub const PC = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40094014
        /// Match Control Register. The MCR is used to control if an interrupt is generated
        /// and if the TC is reset when a Match occurs.
        pub const MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt on MR0
            MR0I: u1,
            /// Reset on MR0
            MR0R: u1,
            /// Stop on MR0
            MR0S: u1,
            /// Interrupt on MR1
            MR1I: u1,
            /// Reset on MR1
            MR1R: u1,
            /// Stop on MR1
            MR1S: u1,
            /// Interrupt on MR2
            MR2I: u1,
            /// Reset on MR2
            MR2R: u1,
            /// Stop on MR2.
            MR2S: u1,
            /// Interrupt on MR3
            MR3I: u1,
            /// Reset on MR3
            MR3R: u1,
            /// Stop on MR3
            MR3S: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u20,
        }), base_address + 0x14);

        /// address: 0x40094018
        /// Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both
        /// the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
        pub const MR = @intToPtr(*volatile [4]Mmio(32, packed struct {
            /// Timer counter match value.
            MATCH: u32,
        }), base_address + 0x18);

        /// address: 0x40094028
        /// Capture Control Register. The CCR controls which edges of the capture inputs are
        /// used to load the Capture Registers and whether or not an interrupt is generated
        /// when a capture takes place.
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture on CAPn.0 rising edge
            CAP0RE: u1,
            /// Capture on CAPn.0 falling edge
            CAP0FE: u1,
            /// Interrupt on CAPn.0 event
            CAP0I: u1,
            /// Capture on CAPn.1 rising edge
            CAP1RE: u1,
            /// Capture on CAPn.1 falling edge
            CAP1FE: u1,
            /// Interrupt on CAPn.1 event
            CAP1I: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u26,
        }), base_address + 0x28);

        /// address: 0x4009402c
        /// Capture Register 0. CR0 is loaded with the value of TC when there is an event on
        /// the CAPn.0 input.
        pub const CR = @intToPtr(*volatile [2]Mmio(32, packed struct {
            /// Timer counter capture value.
            CAP: u32,
        }), base_address + 0x2c);

        /// address: 0x4009403c
        /// External Match Register. The EMR controls the external match pins.
        pub const EMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// External Match 0. When a match occurs between the TC and MR0, this bit can
            /// either toggle, go low, go high, or do nothing, depending on bits 5:4 of this
            /// register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner
            /// (0 = low, 1 = high).
            EM0: u1,
            /// External Match 1. When a match occurs between the TC and MR1, this bit can
            /// either toggle, go low, go high, or do nothing, depending on bits 7:6 of this
            /// register. This bit can be driven onto a MATn.1 pin, in a positive-logic manner
            /// (0 = low, 1 = high).
            EM1: u1,
            /// External Match 2. When a match occurs between the TC and MR2, this bit can
            /// either toggle, go low, go high, or do nothing, depending on bits 9:8 of this
            /// register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner
            /// (0 = low, 1 = high).
            EM2: u1,
            /// External Match 3. When a match occurs between the TC and MR3, this bit can
            /// either toggle, go low, go high, or do nothing, depending on bits 11:10 of this
            /// register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner
            /// (0 = low, 1 = high).
            EM3: u1,
            /// External Match Control 0. Determines the functionality of External Match 0.
            EMC0: u2,
            /// External Match Control 1. Determines the functionality of External Match 1.
            EMC1: u2,
            /// External Match Control 2. Determines the functionality of External Match 2.
            EMC2: u2,
            /// External Match Control 3. Determines the functionality of External Match 3.
            EMC3: u2,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u20,
        }), base_address + 0x3c);

        /// address: 0x40094070
        /// Count Control Register. The CTCR selects between Timer and Counter mode, and in
        /// Counter mode selects the signal and edge(s) for counting.
        pub const CTCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter/Timer Mode This field selects which rising PCLK edges can increment
            /// Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC).
            /// Timer Mode: the TC is incremented when the Prescale Counter matches the Prescale
            /// Register.
            CTMODE: u2,
            /// Count Input Select When bits 1:0 in this register are not 00, these bits select
            /// which CAP pin is sampled for clocking. Note: If Counter mode is selected for a
            /// particular CAPn input in the TnCTCR, the 3 bits for that input in the Capture
            /// Control Register (TnCCR) must be programmed as 000. However, capture and/or
            /// interrupt can be selected for the other 3 CAPn inputs in the same timer.
            CINSEL: u2,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u28,
        }), base_address + 0x70);
    };
    pub const UART2 = struct {
        pub const base_address = 0x40098000;

        /// address: 0x40098000
        /// Receiver Buffer Register. Contains the next received character to be read (DLAB
        /// =0).
        pub const RBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The UARTn Receiver Buffer Register contains the oldest received byte in the
            /// UARTn Rx FIFO.
            RBR: u8,
            /// Reserved, the value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x0);

        /// address: 0x40098000
        /// Transmit Holding Regiter. The next character to be transmitted is written here
        /// (DLAB =0).
        pub const THR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing to the UARTn Transmit Holding Register causes the data to be stored in
            /// the UARTn transmit FIFO. The byte will be sent when it reaches the bottom of the
            /// FIFO and the transmitter is available.
            THR: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x0);

        /// address: 0x40098000
        /// Divisor Latch LSB. Least significant byte of the baud rate divisor value. The
        /// full divisor is used to generate a baud rate from the fractional rate divider
        /// (DLAB =1).
        pub const DLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The UARTn Divisor Latch LSB Register, along with the UnDLM register, determines
            /// the baud rate of the UARTn.
            DLLSB: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x0);

        /// address: 0x40098004
        /// Divisor Latch MSB. Most significant byte of the baud rate divisor value. The
        /// full divisor is used to generate a baud rate from the fractional rate divider
        /// (DLAB =1).
        pub const DLM = @intToPtr(*volatile Mmio(32, packed struct {
            /// The UARTn Divisor Latch MSB Register, along with the U0DLL register, determines
            /// the baud rate of the UARTn.
            DLMSB: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x4);

        /// address: 0x40098004
        /// Interrupt Enable Register. Contains individual interrupt enable bits for the 7
        /// potential UART interrupts (DLAB =0).
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// RBR Interrupt Enable. Enables the Receive Data Available interrupt for UARTn. It
            /// also controls the Character Receive Time-out interrupt.
            RBRIE: u1,
            /// THRE Interrupt Enable. Enables the THRE interrupt for UARTn. The status of this
            /// can be read from UnLSR[5].
            THREIE: u1,
            /// RX Line Status Interrupt Enable. Enables the UARTn RX line status interrupts.
            /// The status of this interrupt can be read from UnLSR[4:1].
            RXIE: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u5,
            /// Enables the end of auto-baud interrupt.
            ABEOINTEN: u1,
            /// Enables the auto-baud time-out interrupt.
            ABTOINTEN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u22,
        }), base_address + 0x4);

        /// address: 0x40098008
        /// Interrupt ID Register. Identifies which interrupt(s) are pending.
        pub const IIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt status. Note that UnIIR[0] is active low. The pending interrupt can be
            /// determined by evaluating UnIIR[3:1].
            INTSTATUS: u1,
            /// Interrupt identification. UnIER[3:1] identifies an interrupt corresponding to
            /// the UARTn Rx or TX FIFO. All other combinations of UnIER[3:1] not listed below
            /// are reserved (000,100,101,111).
            INTID: u3,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u2,
            /// Copies of UnFCR[0].
            FIFOENABLE: u2,
            /// End of auto-baud interrupt. True if auto-baud has finished successfully and
            /// interrupt is enabled.
            ABEOINT: u1,
            /// Auto-baud time-out interrupt. True if auto-baud has timed out and interrupt is
            /// enabled.
            ABTOINT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u22,
        }), base_address + 0x8);

        /// address: 0x40098008
        /// FIFO Control Register. Controls UART FIFO usage and modes.
        pub const FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO Enable.
            FIFOEN: u1,
            /// RX FIFO Reset.
            RXFIFORES: u1,
            /// TX FIFO Reset.
            TXFIFORES: u1,
            /// DMA Mode Select. When the FIFO enable (bit 0 of this register) is set, this bit
            /// selects the DMA mode. See Section 18.6.6.1.
            DMAMODE: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u2,
            /// RX Trigger Level. These two bits determine how many receiver UARTn FIFO
            /// characters must be written before an interrupt or DMA request is activated.
            RXTRIGLVL: u2,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x8);

        /// address: 0x4009800c
        /// Line Control Register. Contains controls for frame formatting and break
        /// generation.
        pub const LCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Word Length Select.
            WLS: u2,
            /// Stop Bit Select
            SBS: u1,
            /// Parity Enable.
            PE: u1,
            /// Parity Select
            PS: u2,
            /// Break Control
            BC: u1,
            /// Divisor Latch Access Bit
            DLAB: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0xc);

        /// address: 0x40098014
        /// Line Status Register. Contains flags for transmit and receive status, including
        /// line errors.
        pub const LSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver Data Ready. UnLSR[0] is set when the UnRBR holds an unread character
            /// and is cleared when the UARTn RBR FIFO is empty.
            RDR: u1,
            /// Overrun Error. The overrun error condition is set as soon as it occurs. An UnLSR
            /// read clears UnLSR[1]. UnLSR[1] is set when UARTn RSR has a new character
            /// assembled and the UARTn RBR FIFO is full. In this case, the UARTn RBR FIFO will
            /// not be overwritten and the character in the UARTn RSR will be lost.
            OE: u1,
            /// Parity Error. When the parity bit of a received character is in the wrong state,
            /// a parity error occurs. An UnLSR read clears UnLSR[2]. Time of parity error
            /// detection is dependent on UnFCR[0]. Note: A parity error is associated with the
            /// character at the top of the UARTn RBR FIFO.
            PE: u1,
            /// Framing Error. When the stop bit of a received character is a logic 0, a framing
            /// error occurs. An UnLSR read clears UnLSR[3]. The time of the framing error
            /// detection is dependent on UnFCR[0]. Upon detection of a framing error, the Rx
            /// will attempt to resynchronize to the data and assume that the bad stop bit is
            /// actually an early start bit. However, it cannot be assumed that the next
            /// received byte will be correct even if there is no Framing Error. Note: A framing
            /// error is associated with the character at the top of the UARTn RBR FIFO.
            FE: u1,
            /// Break Interrupt. When RXDn is held in the spacing state (all zeroes) for one
            /// full character transmission (start, data, parity, stop), a break interrupt
            /// occurs. Once the break condition has been detected, the receiver goes idle until
            /// RXDn goes to marking state (all ones). An UnLSR read clears this status bit. The
            /// time of break detection is dependent on UnFCR[0]. Note: The break interrupt is
            /// associated with the character at the top of the UARTn RBR FIFO.
            BI: u1,
            /// Transmitter Holding Register Empty. THRE is set immediately upon detection of an
            /// empty UARTn THR and is cleared on a UnTHR write.
            THRE: u1,
            /// Transmitter Empty. TEMT is set when both UnTHR and UnTSR are empty; TEMT is
            /// cleared when either the UnTSR or the UnTHR contain valid data.
            TEMT: u1,
            /// Error in RX FIFO . UnLSR[7] is set when a character with a Rx error such as
            /// framing error, parity error or break interrupt, is loaded into the UnRBR. This
            /// bit is cleared when the UnLSR register is read and there are no subsequent
            /// errors in the UARTn FIFO.
            RXFE: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x14);

        /// address: 0x4009801c
        /// Scratch Pad Register. 8-bit temporary storage for software.
        pub const SCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// A readable, writable byte.
            PAD: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x1c);

        /// address: 0x40098020
        /// Auto-baud Control Register. Contains controls for the auto-baud feature.
        pub const ACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start bit. This bit is automatically cleared after auto-baud completion.
            START: u1,
            /// Auto-baud mode select bit.
            MODE: u1,
            /// Restart bit.
            AUTORESTART: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u5,
            /// End of auto-baud interrupt clear bit (write-only accessible). Writing a 1 will
            /// clear the corresponding interrupt in the UnIIR. Writing a 0 has no impact.
            ABEOINTCLR: u1,
            /// Auto-baud time-out interrupt clear bit (write-only accessible). Writing a 1 will
            /// clear the corresponding interrupt in the UnIIR. Writing a 0 has no impact.
            ABTOINTCLR: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u22,
        }), base_address + 0x20);

        /// address: 0x40098028
        /// Fractional Divider Register. Generates a clock input for the baud rate divider.
        pub const FDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Baud-rate generation pre-scaler divisor value. If this field is 0, fractional
            /// baud-rate generator will not impact the UARTn baudrate.
            DIVADDVAL: u4,
            /// Baud-rate pre-scaler multiplier value. This field must be greater or equal 1 for
            /// UARTn to operate properly, regardless of whether the fractional baud-rate
            /// generator is used or not.
            MULVAL: u4,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x28);

        /// address: 0x40098030
        /// Transmit Enable Register. Turns off UART transmitter for use with software flow
        /// control.
        pub const TER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u7,
            /// When this bit is 1, as it is after a Reset, data written to the THR is output on
            /// the TXD pin as soon as any preceding data has been sent. If this bit is cleared
            /// to 0 while a character is being sent, the transmission of that character is
            /// completed, but no further characters are sent until this bit is set again. In
            /// other words, a 0 in this bit blocks the transfer of characters from the THR or
            /// TX FIFO into the transmit shift register. Software implementing
            /// software-handshaking can clear this bit when it receives an XOFF character
            /// (DC3). Software can set this bit again when it receives an XON (DC1) character.
            TXEN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x30);

        /// address: 0x4009804c
        /// RS-485/EIA-485 Control. Contains controls to configure various aspects of
        /// RS-485/EIA-485 modes.
        pub const RS485CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// NMM enable.
            NMMEN: u1,
            /// Receiver enable.
            RXDIS: u1,
            /// AAD enable.
            AADEN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u1,
            /// Direction control enable.
            DCTRL: u1,
            /// Direction control pin polarity. This bit reverses the polarity of the direction
            /// control signal on the Un_OE pin.
            OINV: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u26,
        }), base_address + 0x4c);

        /// address: 0x40098050
        /// RS-485/EIA-485 address match. Contains the address match value for
        /// RS-485/EIA-485 mode.
        pub const RS485ADRMATCH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Contains the address match value.
            ADRMATCH: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x50);

        /// address: 0x40098054
        /// RS-485/EIA-485 direction control delay.
        pub const RS485DLY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Contains the direction control (UnOE) delay value. This register works in
            /// conjunction with an 8-bit counter.
            DLY: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x54);
    };
    pub const UART3 = struct {
        pub const base_address = 0x4009c000;

        /// address: 0x4009c000
        /// Receiver Buffer Register. Contains the next received character to be read (DLAB
        /// =0).
        pub const RBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The UARTn Receiver Buffer Register contains the oldest received byte in the
            /// UARTn Rx FIFO.
            RBR: u8,
            /// Reserved, the value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x0);

        /// address: 0x4009c000
        /// Transmit Holding Regiter. The next character to be transmitted is written here
        /// (DLAB =0).
        pub const THR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing to the UARTn Transmit Holding Register causes the data to be stored in
            /// the UARTn transmit FIFO. The byte will be sent when it reaches the bottom of the
            /// FIFO and the transmitter is available.
            THR: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x0);

        /// address: 0x4009c000
        /// Divisor Latch LSB. Least significant byte of the baud rate divisor value. The
        /// full divisor is used to generate a baud rate from the fractional rate divider
        /// (DLAB =1).
        pub const DLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The UARTn Divisor Latch LSB Register, along with the UnDLM register, determines
            /// the baud rate of the UARTn.
            DLLSB: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x0);

        /// address: 0x4009c004
        /// Divisor Latch MSB. Most significant byte of the baud rate divisor value. The
        /// full divisor is used to generate a baud rate from the fractional rate divider
        /// (DLAB =1).
        pub const DLM = @intToPtr(*volatile Mmio(32, packed struct {
            /// The UARTn Divisor Latch MSB Register, along with the U0DLL register, determines
            /// the baud rate of the UARTn.
            DLMSB: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x4);

        /// address: 0x4009c004
        /// Interrupt Enable Register. Contains individual interrupt enable bits for the 7
        /// potential UART interrupts (DLAB =0).
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// RBR Interrupt Enable. Enables the Receive Data Available interrupt for UARTn. It
            /// also controls the Character Receive Time-out interrupt.
            RBRIE: u1,
            /// THRE Interrupt Enable. Enables the THRE interrupt for UARTn. The status of this
            /// can be read from UnLSR[5].
            THREIE: u1,
            /// RX Line Status Interrupt Enable. Enables the UARTn RX line status interrupts.
            /// The status of this interrupt can be read from UnLSR[4:1].
            RXIE: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u5,
            /// Enables the end of auto-baud interrupt.
            ABEOINTEN: u1,
            /// Enables the auto-baud time-out interrupt.
            ABTOINTEN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u22,
        }), base_address + 0x4);

        /// address: 0x4009c008
        /// Interrupt ID Register. Identifies which interrupt(s) are pending.
        pub const IIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt status. Note that UnIIR[0] is active low. The pending interrupt can be
            /// determined by evaluating UnIIR[3:1].
            INTSTATUS: u1,
            /// Interrupt identification. UnIER[3:1] identifies an interrupt corresponding to
            /// the UARTn Rx or TX FIFO. All other combinations of UnIER[3:1] not listed below
            /// are reserved (000,100,101,111).
            INTID: u3,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u2,
            /// Copies of UnFCR[0].
            FIFOENABLE: u2,
            /// End of auto-baud interrupt. True if auto-baud has finished successfully and
            /// interrupt is enabled.
            ABEOINT: u1,
            /// Auto-baud time-out interrupt. True if auto-baud has timed out and interrupt is
            /// enabled.
            ABTOINT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u22,
        }), base_address + 0x8);

        /// address: 0x4009c008
        /// FIFO Control Register. Controls UART FIFO usage and modes.
        pub const FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO Enable.
            FIFOEN: u1,
            /// RX FIFO Reset.
            RXFIFORES: u1,
            /// TX FIFO Reset.
            TXFIFORES: u1,
            /// DMA Mode Select. When the FIFO enable (bit 0 of this register) is set, this bit
            /// selects the DMA mode. See Section 18.6.6.1.
            DMAMODE: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u2,
            /// RX Trigger Level. These two bits determine how many receiver UARTn FIFO
            /// characters must be written before an interrupt or DMA request is activated.
            RXTRIGLVL: u2,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x8);

        /// address: 0x4009c00c
        /// Line Control Register. Contains controls for frame formatting and break
        /// generation.
        pub const LCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Word Length Select.
            WLS: u2,
            /// Stop Bit Select
            SBS: u1,
            /// Parity Enable.
            PE: u1,
            /// Parity Select
            PS: u2,
            /// Break Control
            BC: u1,
            /// Divisor Latch Access Bit
            DLAB: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0xc);

        /// address: 0x4009c014
        /// Line Status Register. Contains flags for transmit and receive status, including
        /// line errors.
        pub const LSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver Data Ready. UnLSR[0] is set when the UnRBR holds an unread character
            /// and is cleared when the UARTn RBR FIFO is empty.
            RDR: u1,
            /// Overrun Error. The overrun error condition is set as soon as it occurs. An UnLSR
            /// read clears UnLSR[1]. UnLSR[1] is set when UARTn RSR has a new character
            /// assembled and the UARTn RBR FIFO is full. In this case, the UARTn RBR FIFO will
            /// not be overwritten and the character in the UARTn RSR will be lost.
            OE: u1,
            /// Parity Error. When the parity bit of a received character is in the wrong state,
            /// a parity error occurs. An UnLSR read clears UnLSR[2]. Time of parity error
            /// detection is dependent on UnFCR[0]. Note: A parity error is associated with the
            /// character at the top of the UARTn RBR FIFO.
            PE: u1,
            /// Framing Error. When the stop bit of a received character is a logic 0, a framing
            /// error occurs. An UnLSR read clears UnLSR[3]. The time of the framing error
            /// detection is dependent on UnFCR[0]. Upon detection of a framing error, the Rx
            /// will attempt to resynchronize to the data and assume that the bad stop bit is
            /// actually an early start bit. However, it cannot be assumed that the next
            /// received byte will be correct even if there is no Framing Error. Note: A framing
            /// error is associated with the character at the top of the UARTn RBR FIFO.
            FE: u1,
            /// Break Interrupt. When RXDn is held in the spacing state (all zeroes) for one
            /// full character transmission (start, data, parity, stop), a break interrupt
            /// occurs. Once the break condition has been detected, the receiver goes idle until
            /// RXDn goes to marking state (all ones). An UnLSR read clears this status bit. The
            /// time of break detection is dependent on UnFCR[0]. Note: The break interrupt is
            /// associated with the character at the top of the UARTn RBR FIFO.
            BI: u1,
            /// Transmitter Holding Register Empty. THRE is set immediately upon detection of an
            /// empty UARTn THR and is cleared on a UnTHR write.
            THRE: u1,
            /// Transmitter Empty. TEMT is set when both UnTHR and UnTSR are empty; TEMT is
            /// cleared when either the UnTSR or the UnTHR contain valid data.
            TEMT: u1,
            /// Error in RX FIFO . UnLSR[7] is set when a character with a Rx error such as
            /// framing error, parity error or break interrupt, is loaded into the UnRBR. This
            /// bit is cleared when the UnLSR register is read and there are no subsequent
            /// errors in the UARTn FIFO.
            RXFE: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x14);

        /// address: 0x4009c01c
        /// Scratch Pad Register. 8-bit temporary storage for software.
        pub const SCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// A readable, writable byte.
            PAD: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x1c);

        /// address: 0x4009c020
        /// Auto-baud Control Register. Contains controls for the auto-baud feature.
        pub const ACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start bit. This bit is automatically cleared after auto-baud completion.
            START: u1,
            /// Auto-baud mode select bit.
            MODE: u1,
            /// Restart bit.
            AUTORESTART: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u5,
            /// End of auto-baud interrupt clear bit (write-only accessible). Writing a 1 will
            /// clear the corresponding interrupt in the UnIIR. Writing a 0 has no impact.
            ABEOINTCLR: u1,
            /// Auto-baud time-out interrupt clear bit (write-only accessible). Writing a 1 will
            /// clear the corresponding interrupt in the UnIIR. Writing a 0 has no impact.
            ABTOINTCLR: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u22,
        }), base_address + 0x20);

        /// address: 0x4009c028
        /// Fractional Divider Register. Generates a clock input for the baud rate divider.
        pub const FDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Baud-rate generation pre-scaler divisor value. If this field is 0, fractional
            /// baud-rate generator will not impact the UARTn baudrate.
            DIVADDVAL: u4,
            /// Baud-rate pre-scaler multiplier value. This field must be greater or equal 1 for
            /// UARTn to operate properly, regardless of whether the fractional baud-rate
            /// generator is used or not.
            MULVAL: u4,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x28);

        /// address: 0x4009c030
        /// Transmit Enable Register. Turns off UART transmitter for use with software flow
        /// control.
        pub const TER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u7,
            /// When this bit is 1, as it is after a Reset, data written to the THR is output on
            /// the TXD pin as soon as any preceding data has been sent. If this bit is cleared
            /// to 0 while a character is being sent, the transmission of that character is
            /// completed, but no further characters are sent until this bit is set again. In
            /// other words, a 0 in this bit blocks the transfer of characters from the THR or
            /// TX FIFO into the transmit shift register. Software implementing
            /// software-handshaking can clear this bit when it receives an XOFF character
            /// (DC3). Software can set this bit again when it receives an XON (DC1) character.
            TXEN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x30);

        /// address: 0x4009c04c
        /// RS-485/EIA-485 Control. Contains controls to configure various aspects of
        /// RS-485/EIA-485 modes.
        pub const RS485CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// NMM enable.
            NMMEN: u1,
            /// Receiver enable.
            RXDIS: u1,
            /// AAD enable.
            AADEN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u1,
            /// Direction control enable.
            DCTRL: u1,
            /// Direction control pin polarity. This bit reverses the polarity of the direction
            /// control signal on the Un_OE pin.
            OINV: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u26,
        }), base_address + 0x4c);

        /// address: 0x4009c050
        /// RS-485/EIA-485 address match. Contains the address match value for
        /// RS-485/EIA-485 mode.
        pub const RS485ADRMATCH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Contains the address match value.
            ADRMATCH: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x50);

        /// address: 0x4009c054
        /// RS-485/EIA-485 direction control delay.
        pub const RS485DLY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Contains the direction control (UnOE) delay value. This register works in
            /// conjunction with an 8-bit counter.
            DLY: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x54);
    };
    pub const I2C2 = struct {
        pub const base_address = 0x400a0000;

        /// address: 0x400a0000
        /// I2C Control Set Register. When a one is written to a bit of this register, the
        /// corresponding bit in the I2C control register is set. Writing a zero has no
        /// effect on the corresponding bit in the I2C control register.
        pub const CONSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. User software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u2,
            /// Assert acknowledge flag.
            AA: u1,
            /// I2C interrupt flag.
            SI: u1,
            /// STOP flag.
            STO: u1,
            /// START flag.
            STA: u1,
            /// I2C interface enable.
            I2EN: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u25,
        }), base_address + 0x0);

        /// address: 0x400a0004
        /// I2C Status Register. During I2C operation, this register provides detailed
        /// status codes that allow software to determine the next action needed.
        pub const STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits are unused and are always 0.
            RESERVED: u3,
            /// These bits give the actual status information about the I 2C interface.
            Status: u5,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x4);

        /// address: 0x400a0008
        /// I2C Data Register. During master or slave transmit mode, data to be transmitted
        /// is written to this register. During master or slave receive mode, data that has
        /// been received may be read from this register.
        pub const DAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register holds data values that have been received or are to be
            /// transmitted.
            Data: u8,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x8);

        /// address: 0x400a000c
        /// I2C Slave Address Register 0. Contains the 7-bit slave address for operation of
        /// the I2C interface in slave mode, and is not used in master mode. The least
        /// significant bit determines whether a slave responds to the General Call address.
        pub const ADR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// General Call enable bit.
            GC: u1,
            /// The I2C device address for slave mode.
            Address: u7,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0xc);

        /// address: 0x400a0010
        /// SCH Duty Cycle Register High Half Word. Determines the high time of the I2C
        /// clock.
        pub const SCLH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Count for SCL HIGH time period selection.
            SCLH: u16,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u16,
        }), base_address + 0x10);

        /// address: 0x400a0014
        /// SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock.
        /// SCLL and SCLH together determine the clock frequency generated by an I2C master
        /// and certain times used in slave mode.
        pub const SCLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Count for SCL low time period selection.
            SCLL: u16,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u16,
        }), base_address + 0x14);

        /// address: 0x400a0018
        /// I2C Control Clear Register. When a one is written to a bit of this register, the
        /// corresponding bit in the I2C control register is cleared. Writing a zero has no
        /// effect on the corresponding bit in the I2C control register.
        pub const CONCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. User software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u2,
            /// Assert acknowledge Clear bit.
            AAC: u1,
            /// I2C interrupt Clear bit.
            SIC: u1,
            /// Reserved. User software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u1,
            /// START flag Clear bit.
            STAC: u1,
            /// I2C interface Disable bit.
            I2ENC: u1,
            /// Reserved. User software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x18);

        /// address: 0x400a001c
        /// Monitor mode control register.
        pub const MMCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Monitor mode enable.
            MM_ENA: u1,
            /// SCL output enable.
            ENA_SCL: u1,
            /// Select interrupt register match.
            MATCH_ALL: u1,
            /// Reserved. The value read from reserved bits is not defined.
            RESERVED: u29,
        }), base_address + 0x1c);

        /// address: 0x400a0020
        /// I2C Slave Address Register. Contains the 7-bit slave address for operation of
        /// the I2C interface in slave mode, and is not used in master mode. The least
        /// significant bit determines whether a slave responds to the General Call address.
        pub const ADR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// General Call enable bit.
            GC: u1,
            /// The I2C device address for slave mode.
            Address: u7,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x20);

        /// address: 0x400a0024
        /// I2C Slave Address Register. Contains the 7-bit slave address for operation of
        /// the I2C interface in slave mode, and is not used in master mode. The least
        /// significant bit determines whether a slave responds to the General Call address.
        pub const ADR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// General Call enable bit.
            GC: u1,
            /// The I2C device address for slave mode.
            Address: u7,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x24);

        /// address: 0x400a0028
        /// I2C Slave Address Register. Contains the 7-bit slave address for operation of
        /// the I2C interface in slave mode, and is not used in master mode. The least
        /// significant bit determines whether a slave responds to the General Call address.
        pub const ADR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// General Call enable bit.
            GC: u1,
            /// The I2C device address for slave mode.
            Address: u7,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x28);

        /// address: 0x400a002c
        /// Data buffer register. The contents of the 8 MSBs of the DAT shift register will
        /// be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of
        /// data plus ACK or NACK) has been received on the bus.
        pub const DATA_BUFFER = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register holds contents of the 8 MSBs of the DAT shift register.
            Data: u8,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x2c);

        /// address: 0x400a0030
        /// I2C Slave address mask register
        pub const MASK = @intToPtr(*volatile [4]Mmio(32, packed struct {
            /// Reserved. User software should not write ones to reserved bits. This bit reads
            /// always back as 0.
            RESERVED: u1,
            /// Mask bits.
            MASK: u7,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x30);
    };
    /// I2S interface
    pub const I2S = struct {
        pub const base_address = 0x400a8000;

        /// address: 0x400a8000
        /// I2S Digital Audio Output Register. Contains control bits for the I2S transmit
        /// channel.
        pub const DAO = @intToPtr(*volatile Mmio(32, packed struct {
            /// Selects the number of bytes in data as follows:
            WORDWIDTH: u2,
            /// When 1, data is of monaural format. When 0, the data is in stereo format.
            MONO: u1,
            /// When 1, disables accesses on FIFOs, places the transmit channel in mute mode.
            STOP: u1,
            /// When 1, asynchronously resets the transmit channel and FIFO.
            RESET: u1,
            /// When 0, the interface is in master mode. When 1, the interface is in slave mode.
            /// See Section 34.7.2 for a summary of useful combinations for this bit with
            /// TXMODE.
            WS_SEL: u1,
            /// Word select half period minus 1, i.e. WS 64clk period -> ws_halfperiod = 31.
            WS_HALFPERIOD: u9,
            /// When 1, the transmit channel sends only zeroes.
            MUTE: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u16,
        }), base_address + 0x0);

        /// address: 0x400a8004
        /// I2S Digital Audio Input Register. Contains control bits for the I2S receive
        /// channel.
        pub const DAI = @intToPtr(*volatile Mmio(32, packed struct {
            /// Selects the number of bytes in data as follows:
            WORDWIDTH: u2,
            /// When 1, data is of monaural format. When 0, the data is in stereo format.
            MONO: u1,
            /// When 1, disables accesses on FIFOs, places the transmit channel in mute mode.
            STOP: u1,
            /// When 1, asynchronously reset the transmit channel and FIFO.
            RESET: u1,
            /// When 0, the interface is in master mode. When 1, the interface is in slave mode.
            /// See Section 34.7.2 for a summary of useful combinations for this bit with
            /// RXMODE.
            WS_SEL: u1,
            /// Word select half period minus 1, i.e. WS 64clk period -> ws_halfperiod = 31.
            WS_HALFPERIOD: u9,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u17,
        }), base_address + 0x4);

        /// address: 0x400a8008
        /// I2S Transmit FIFO. Access register for the 8 x 32-bit transmitter FIFO.
        pub const TXFIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8 x 32-bit transmit FIFO.
            I2STXFIFO: u32,
        }), base_address + 0x8);

        /// address: 0x400a800c
        /// I2S Receive FIFO. Access register for the 8 x 32-bit receiver FIFO.
        pub const RXFIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8 x 32-bit transmit FIFO.
            I2SRXFIFO: u32,
        }), base_address + 0xc);

        /// address: 0x400a8010
        /// I2S Status Feedback Register. Contains status information about the I2S
        /// interface.
        pub const STATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit reflects the presence of Receive Interrupt or Transmit Interrupt. This
            /// is determined by comparing the current FIFO levels to the rx_depth_irq and
            /// tx_depth_irq fields in the IRQ register.
            IRQ: u1,
            /// This bit reflects the presence of Receive or Transmit DMA Request 1. This is
            /// determined by comparing the current FIFO levels to the rx_depth_dma1 and
            /// tx_depth_dma1 fields in the DMA1 register.
            DMAREQ1: u1,
            /// This bit reflects the presence of Receive or Transmit DMA Request 2. This is
            /// determined by comparing the current FIFO levels to the rx_depth_dma2 and
            /// tx_depth_dma2 fields in the DMA2 register.
            DMAREQ2: u1,
            /// Reserved.
            RESERVED: u5,
            /// Reflects the current level of the Receive FIFO.
            RX_LEVEL: u4,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u4,
            /// Reflects the current level of the Transmit FIFO.
            TX_LEVEL: u4,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u12,
        }), base_address + 0x10);

        /// address: 0x400a8014
        /// I2S DMA Configuration Register 1. Contains control information for DMA request
        /// 1.
        pub const DMA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// When 1, enables DMA1 for I2S receive.
            RX_DMA1_ENABLE: u1,
            /// When 1, enables DMA1 for I2S transmit.
            TX_DMA1_ENABLE: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u6,
            /// Set the FIFO level that triggers a receive DMA request on DMA1.
            RX_DEPTH_DMA1: u4,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u4,
            /// Set the FIFO level that triggers a transmit DMA request on DMA1.
            TX_DEPTH_DMA1: u4,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u12,
        }), base_address + 0x14);

        /// address: 0x400a8018
        /// I2S DMA Configuration Register 2. Contains control information for DMA request
        /// 2.
        pub const DMA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// When 1, enables DMA1 for I2S receive.
            RX_DMA2_ENABLE: u1,
            /// When 1, enables DMA1 for I2S transmit.
            TX_DMA2_ENABLE: u1,
            /// Reserved.
            RESERVED: u6,
            /// Set the FIFO level that triggers a receive DMA request on DMA2.
            RX_DEPTH_DMA2: u4,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u4,
            /// Set the FIFO level that triggers a transmit DMA request on DMA2.
            TX_DEPTH_DMA2: u4,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u12,
        }), base_address + 0x18);

        /// address: 0x400a801c
        /// I2S Interrupt Request Control Register. Contains bits that control how the I2S
        /// interrupt request is generated.
        pub const IRQ = @intToPtr(*volatile Mmio(32, packed struct {
            /// When 1, enables I2S receive interrupt.
            RX_IRQ_ENABLE: u1,
            /// When 1, enables I2S transmit interrupt.
            TX_IRQ_ENABLE: u1,
            /// Reserved.
            RESERVED: u6,
            /// Set the FIFO level on which to create an irq request.
            RX_DEPTH_IRQ: u4,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u4,
            /// Set the FIFO level on which to create an irq request.
            TX_DEPTH_IRQ: u4,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u12,
        }), base_address + 0x1c);

        /// address: 0x400a8020
        /// I2S Transmit MCLK divider. This register determines the I2S TX MCLK rate by
        /// specifying the value to divide PCLK by in order to produce MCLK.
        pub const TXRATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S transmit MCLK rate denominator. This value is used to divide PCLK to produce
            /// the transmit MCLK. Eight bits of fractional divide supports a wide range of
            /// possibilities. A value of 0 stops the clock.
            Y_DIVIDER: u8,
            /// I2S transmit MCLK rate numerator. This value is used to multiply PCLK by to
            /// produce the transmit MCLK. A value of 0 stops the clock. Eight bits of
            /// fractional divide supports a wide range of possibilities. Note: the resulting
            /// ratio X/Y is divided by 2.
            X_DIVIDER: u8,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u16,
        }), base_address + 0x20);

        /// address: 0x400a8024
        /// I2S Receive MCLK divider. This register determines the I2S RX MCLK rate by
        /// specifying the value to divide PCLK by in order to produce MCLK.
        pub const RXRATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S receive MCLK rate denominator. This value is used to divide PCLK to produce
            /// the receive MCLK. Eight bits of fractional divide supports a wide range of
            /// possibilities. A value of 0 stops the clock.
            Y_DIVIDER: u8,
            /// I2S receive MCLK rate numerator. This value is used to multiply PCLK by to
            /// produce the receive MCLK. A value of 0 stops the clock. Eight bits of fractional
            /// divide supports a wide range of possibilities. Note: the resulting ratio X/Y is
            /// divided by 2.
            X_DIVIDER: u8,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u16,
        }), base_address + 0x24);

        /// address: 0x400a8028
        /// I2S Transmit bit rate divider. This register determines the I2S transmit bit
        /// rate by specifying the value to divide TX_MCLK by in order to produce the
        /// transmit bit clock.
        pub const TXBITRATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S transmit bit rate. This value plus one is used to divide TX_MCLK to produce
            /// the transmit bit clock.
            TX_BITRATE: u6,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u26,
        }), base_address + 0x28);

        /// address: 0x400a802c
        /// I2S Receive bit rate divider. This register determines the I2S receive bit rate
        /// by specifying the value to divide RX_MCLK by in order to produce the receive bit
        /// clock.
        pub const RXBITRATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S receive bit rate. This value plus one is used to divide RX_MCLK to produce
            /// the receive bit clock.
            RX_BITRATE: u6,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u26,
        }), base_address + 0x2c);

        /// address: 0x400a8030
        /// I2S Transmit mode control.
        pub const TXMODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock source selection for the transmit bit clock divider.
            TXCLKSEL: u2,
            /// Transmit 4-pin mode selection. When 1, enables 4-pin mode.
            TX4PIN: u1,
            /// Enable for the TX_MCLK output. When 0, output of TX_MCLK is not enabled. When 1,
            /// output of TX_MCLK is enabled.
            TXMCENA: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u28,
        }), base_address + 0x30);

        /// address: 0x400a8034
        /// I2S Receive mode control.
        pub const RXMODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock source selection for the receive bit clock divider.
            RXCLKSEL: u2,
            /// Receive 4-pin mode selection. When 1, enables 4-pin mode.
            RX4PIN: u1,
            /// Enable for the RX_MCLK output. When 0, output of RX_MCLK is not enabled. When 1,
            /// output of RX_MCLK is enabled.
            RXMCENA: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u28,
        }), base_address + 0x34);
    };
    /// Repetitive Interrupt Timer (RIT)
    pub const RITIMER = struct {
        pub const base_address = 0x400b0000;

        /// address: 0x400b0000
        /// Compare register
        pub const COMPVAL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Compare register. Holds the compare value which is compared to the counter.
            RICOMP: u32,
        }), base_address + 0x0);

        /// address: 0x400b0004
        /// Mask register. This register holds the 32-bit mask value. A 1 written to any bit
        /// will force a compare on the corresponding bit of the counter and compare
        /// register.
        pub const MASK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Mask register. This register holds the 32-bit mask value. A one written to any
            /// bit overrides the result of the comparison for the corresponding bit of the
            /// counter and compare register (causes the comparison of the register bits to be
            /// always true).
            RIMASK: u32,
        }), base_address + 0x4);

        /// address: 0x400b0008
        /// Control register.
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt flag
            RITINT: u1,
            /// Timer enable clear
            RITENCLR: u1,
            /// Timer enable for debug
            RITENBR: u1,
            /// Timer enable.
            RITEN: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u28,
        }), base_address + 0x8);

        /// address: 0x400b000c
        /// 32-bit counter
        pub const COUNTER = @intToPtr(*volatile Mmio(32, packed struct {
            /// 32-bit up counter. Counts continuously unless RITEN bit in RICTRL register is
            /// cleared or debug mode is entered (if enabled by the RITNEBR bit in RICTRL). Can
            /// be loaded to any value in software.
            RICOUNTER: u32,
        }), base_address + 0xc);
    };
    /// Motor Control PWM
    pub const MCPWM = struct {
        pub const base_address = 0x400b8000;

        /// address: 0x400b8000
        /// PWM Control read address
        pub const CON = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stops/starts timer channel 0.
            RUN0: u1,
            /// Edge/center aligned operation for channel 0.
            CENTER0: u1,
            /// Selects polarity of the MCOA0 and MCOB0 pins.
            POLA0: u1,
            /// Controls the dead-time feature for channel 0.
            DTE0: u1,
            /// Enable/disable updates of functional registers for channel 0 (see Section
            /// 24.8.2).
            DISUP0: u1,
            /// Reserved.
            RESERVED: u3,
            /// Stops/starts timer channel 1.
            RUN1: u1,
            /// Edge/center aligned operation for channel 1.
            CENTER1: u1,
            /// Selects polarity of the MCOA1 and MCOB1 pins.
            POLA1: u1,
            /// Controls the dead-time feature for channel 1.
            DTE1: u1,
            /// Enable/disable updates of functional registers for channel 1 (see Section
            /// 24.8.2).
            DISUP1: u1,
            /// Reserved.
            RESERVED: u3,
            /// Stops/starts timer channel 2.
            RUN2: u1,
            /// Edge/center aligned operation for channel 2.
            CENTER2: u1,
            /// Selects polarity of the MCOA2 and MCOB2 pins.
            POLA2: u1,
            /// Controls the dead-time feature for channel 1.
            DTE2: u1,
            /// Enable/disable updates of functional registers for channel 2 (see Section
            /// 24.8.2).
            DISUP2: u1,
            /// Reserved.
            RESERVED: u8,
            /// Controls the polarity of the MCOB outputs for all 3 channels. This bit is
            /// typically set to 1 only in 3-phase DC mode.
            INVBDC: u1,
            /// 3-phase AC mode select (see Section 24.8.7).
            ACMODE: u1,
            /// 3-phase DC mode select (see Section 24.8.6).
            DCMODE: u1,
        }), base_address + 0x0);

        /// address: 0x400b8004
        /// PWM Control set address
        pub const CON_SET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a one sets the corresponding bit in the CON register.
            RUN0_SET: u1,
            /// Writing a one sets the corresponding bit in the CON register.
            CENTER0_SET: u1,
            /// Writing a one sets the corresponding bit in the CON register.
            POLA0_SET: u1,
            /// Writing a one sets the corresponding bit in the CON register.
            DTE0_SET: u1,
            /// Writing a one sets the corresponding bit in the CON register.
            DISUP0_SET: u1,
            /// Writing a one sets the corresponding bit in the CON register.
            RESERVED: u3,
            /// Writing a one sets the corresponding bit in the CON register.
            RUN1_SET: u1,
            /// Writing a one sets the corresponding bit in the CON register.
            CENTER1_SET: u1,
            /// Writing a one sets the corresponding bit in the CON register.
            POLA1_SET: u1,
            /// Writing a one sets the corresponding bit in the CON register.
            DTE1_SET: u1,
            /// Writing a one sets the corresponding bit in the CON register.
            DISUP1_SET: u1,
            /// Writing a one sets the corresponding bit in the CON register.
            RESERVED: u3,
            /// Writing a one sets the corresponding bit in the CON register.
            RUN2_SET: u1,
            /// Writing a one sets the corresponding bit in the CON register.
            CENTER2_SET: u1,
            /// Writing a one sets the corresponding bit in the CON register.
            POLA2_SET: u1,
            /// Writing a one sets the corresponding bit in the CON register.
            DTE2_SET: u1,
            /// Writing a one sets the corresponding bit in the CON register.
            DISUP2_SET: u1,
            /// Writing a one sets the corresponding bit in the CON register.
            RESERVED: u8,
            /// Writing a one sets the corresponding bit in the CON register.
            INVBDC_SET: u1,
            /// Writing a one sets the corresponding bit in the CON register.
            ACMODE_SET: u1,
            /// Writing a one sets the corresponding bit in the CON register.
            DCMODE_SET: u1,
        }), base_address + 0x4);

        /// address: 0x400b8008
        /// PWM Control clear address
        pub const CON_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a one clears the corresponding bit in the CON register.
            RUN0_CLR: u1,
            /// Writing a one clears the corresponding bit in the CON register.
            CENTER0_CLR: u1,
            /// Writing a one clears the corresponding bit in the CON register.
            POLA0_CLR: u1,
            /// Writing a one clears the corresponding bit in the CON register.
            DTE0_CLR: u1,
            /// Writing a one clears the corresponding bit in the CON register.
            DISUP0_CLR: u1,
            /// Writing a one clears the corresponding bit in the CON register.
            RESERVED: u3,
            /// Writing a one clears the corresponding bit in the CON register.
            RUN1_CLR: u1,
            /// Writing a one clears the corresponding bit in the CON register.
            CENTER1_CLR: u1,
            /// Writing a one clears the corresponding bit in the CON register.
            POLA1_CLR: u1,
            /// Writing a one clears the corresponding bit in the CON register.
            DTE1_CLR: u1,
            /// Writing a one clears the corresponding bit in the CON register.
            DISUP1_CLR: u1,
            /// Writing a one clears the corresponding bit in the CON register.
            RESERVED: u3,
            /// Writing a one clears the corresponding bit in the CON register.
            RUN2_CLR: u1,
            /// Writing a one clears the corresponding bit in the CON register.
            CENTER2_CLR: u1,
            /// Writing a one clears the corresponding bit in the CON register.
            POLA2_CLR: u1,
            /// Writing a one clears the corresponding bit in the CON register.
            DTE2_CLR: u1,
            /// Writing a one clears the corresponding bit in the CON register.
            DISUP2_CLR: u1,
            /// Writing a one clears the corresponding bit in the CON register.
            RESERVED: u8,
            /// Writing a one clears the corresponding bit in the CON register.
            INVBDC_CLR: u1,
            /// Writing a one clears the corresponding bit in the CON register.
            ACMOD_CLR: u1,
            /// Writing a one clears the corresponding bit in the CON register.
            DCMODE_CLR: u1,
        }), base_address + 0x8);

        /// address: 0x400b800c
        /// Capture Control read address
        pub const CAPCON = @intToPtr(*volatile Mmio(32, packed struct {
            /// A 1 in this bit enables a channel 0 capture event on a rising edge on MCI0.
            CAP0MCI0_RE: u1,
            /// A 1 in this bit enables a channel 0 capture event on a falling edge on MCI0.
            CAP0MCI0_FE: u1,
            /// A 1 in this bit enables a channel 0 capture event on a rising edge on MCI1.
            CAP0MCI1_RE: u1,
            /// A 1 in this bit enables a channel 0 capture event on a falling edge on MCI1.
            CAP0MCI1_FE: u1,
            /// A 1 in this bit enables a channel 0 capture event on a rising edge on MCI2.
            CAP0MCI2_RE: u1,
            /// A 1 in this bit enables a channel 0 capture event on a falling edge on MCI2.
            CAP0MCI2_FE: u1,
            /// A 1 in this bit enables a channel 1 capture event on a rising edge on MCI0.
            CAP1MCI0_RE: u1,
            /// A 1 in this bit enables a channel 1 capture event on a falling edge on MCI0.
            CAP1MCI0_FE: u1,
            /// A 1 in this bit enables a channel 1 capture event on a rising edge on MCI1.
            CAP1MCI1_RE: u1,
            /// A 1 in this bit enables a channel 1 capture event on a falling edge on MCI1.
            CAP1MCI1_FE: u1,
            /// A 1 in this bit enables a channel 1 capture event on a rising edge on MCI2.
            CAP1MCI2_RE: u1,
            /// A 1 in this bit enables a channel 1 capture event on a falling edge on MCI2.
            CAP1MCI2_FE: u1,
            /// A 1 in this bit enables a channel 2 capture event on a rising edge on MCI0.
            CAP2MCI0_RE: u1,
            /// A 1 in this bit enables a channel 2 capture event on a falling edge on MCI0.
            CAP2MCI0_FE: u1,
            /// A 1 in this bit enables a channel 2 capture event on a rising edge on MCI1.
            CAP2MCI1_RE: u1,
            /// A 1 in this bit enables a channel 2 capture event on a falling edge on MCI1.
            CAP2MCI1_FE: u1,
            /// A 1 in this bit enables a channel 2 capture event on a rising edge on MCI2.
            CAP2MCI2_RE: u1,
            /// A 1 in this bit enables a channel 2 capture event on a falling edge on MCI2.
            CAP2MCI2_FE: u1,
            /// If this bit is 1, TC0 is reset by a channel 0 capture event.
            RT0: u1,
            /// If this bit is 1, TC1 is reset by a channel 1 capture event.
            RT1: u1,
            /// If this bit is 1, TC2 is reset by a channel 2 capture event.
            RT2: u1,
            /// Reserved.
            RESERVED: u11,
        }), base_address + 0xc);

        /// address: 0x400b8010
        /// Capture Control set address
        pub const CAPCON_SET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a one sets the corresponding bits in the CAPCON register.
            CAP0MCI0_RE_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            CAP0MCI0_FE_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            CAP0MCI1_RE_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            CAP0MCI1_FE_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            CAP0MCI2_RE_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            CAP0MCI2_FE_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            CAP1MCI0_RE_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            CAP1MCI0_FE_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            CAP1MCI1_RE_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            CAP1MCI1_FE_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            CAP1MCI2_RE_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            CAP1MCI2_FE_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            CAP2MCI0_RE_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            CAP2MCI0_FE_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            CAP2MCI1_RE_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            CAP2MCI1_FE_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            CAP2MCI2_RE_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            CAP2MCI2_FE_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            RT0_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            RT1_SET: u1,
            /// Writing a one sets the corresponding bits in the CAPCON register.
            RT2_SET: u1,
            /// Reserved.
            RESERVED: u11,
        }), base_address + 0x10);

        /// address: 0x400b8014
        /// Event Control clear address
        pub const CAPCON_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a one clears the corresponding bits in the CAPCON register.
            CAP0MCI0_RE_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            CAP0MCI0_FE_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            CAP0MCI1_RE_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            CAP0MCI1_FE_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            CAP0MCI2_RE_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            CAP0MCI2_FE_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            CAP1MCI0_RE_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            CAP1MCI0_FE_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            CAP1MCI1_RE_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            CAP1MCI1_FE_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            CAP1MCI2_RE_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            CAP1MCI2_FE_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            CAP2MCI0_RE_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            CAP2MCI0_FE_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            CAP2MCI1_RE_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            CAP2MCI1_FE_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            CAP2MCI2_RE_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            CAP2MCI2_FE_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            RT0_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            RT1_CLR: u1,
            /// Writing a one clears the corresponding bits in the CAPCON register.
            RT2_CLR: u1,
            /// Reserved.
            RESERVED: u11,
        }), base_address + 0x14);

        /// address: 0x400b8018
        /// Timer Counter register
        pub const TC = @intToPtr(*volatile [3]Mmio(32, packed struct {
            /// Timer/Counter value.
            MCTC: u32,
        }), base_address + 0x18);

        /// address: 0x400b8024
        /// Limit register
        pub const LIM = @intToPtr(*volatile [3]Mmio(32, packed struct {
            /// Limit value.
            MCLIM: u32,
        }), base_address + 0x24);

        /// address: 0x400b8030
        /// Match register
        pub const MAT = @intToPtr(*volatile [3]Mmio(32, packed struct {
            /// Match value.
            MCMAT: u32,
        }), base_address + 0x30);

        /// address: 0x400b803c
        /// Dead time register
        pub const DT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dead time for channel 0.[1]
            DT0: u10,
            /// Dead time for channel 1.[2]
            DT1: u10,
            /// Dead time for channel 2.[2]
            DT2: u10,
            /// reserved
            RESERVED: u2,
        }), base_address + 0x3c);

        /// address: 0x400b8040
        /// Communication Pattern register
        pub const CP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Communication pattern output A, channel 0.
            CCPA0: u1,
            /// Communication pattern output B, channel 0.
            CCPB0: u1,
            /// Communication pattern output A, channel 1.
            CCPA1: u1,
            /// Communication pattern output B, channel 1.
            CCPB1: u1,
            /// Communication pattern output A, channel 2.
            CCPA2: u1,
            /// Communication pattern output B, channel 2.
            CCPB2: u1,
            /// Reserved.
            RESERVED: u26,
        }), base_address + 0x40);

        /// address: 0x400b8044
        /// Capture register
        pub const CAP = @intToPtr(*volatile [3]u32, base_address + 0x44);

        /// address: 0x400b8050
        /// Interrupt Enable read address
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Limit interrupt for channel 0.
            ILIM0: u1,
            /// Match interrupt for channel 0.
            IMAT0: u1,
            /// Capture interrupt for channel 0.
            ICAP0: u1,
            /// Reserved.
            RESERVED: u1,
            /// Limit interrupt for channel 1.
            ILIM1: u1,
            /// Match interrupt for channel 1.
            IMAT1: u1,
            /// Capture interrupt for channel 1.
            ICAP1: u1,
            /// Reserved.
            RESERVED: u1,
            /// Limit interrupt for channel 2.
            ILIM2: u1,
            /// Match interrupt for channel 2.
            IMAT2: u1,
            /// Capture interrupt for channel 2.
            ICAP2: u1,
            /// Reserved.
            RESERVED: u4,
            /// Fast abort interrupt.
            ABORT: u1,
            /// Reserved.
            RESERVED: u16,
        }), base_address + 0x50);

        /// address: 0x400b8054
        /// Interrupt Enable set address
        pub const INTEN_SET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
            ILIM0_SET: u1,
            /// Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
            IMAT0_SET: u1,
            /// Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
            ICAP0_SET: u1,
            /// Reserved.
            RESERVED: u1,
            /// Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
            ILIM1_SET: u1,
            /// Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
            IMAT1_SET: u1,
            /// Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
            ICAP1_SET: u1,
            /// Reserved.
            RESERVED: u1,
            reserved0: u1,
            /// Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
            ILIM2_SET: u1,
            /// Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
            IMAT2_SET: u1,
            /// Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
            ICAP2_SET: u1,
            /// Reserved.
            RESERVED: u3,
            /// Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
            ABORT_SET: u1,
            /// Reserved.
            RESERVED: u16,
        }), base_address + 0x54);

        /// address: 0x400b8058
        /// Interrupt Enable clear address
        pub const INTEN_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            ILIM0_CLR: u1,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            IMAT0_CLR: u1,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            ICAP0_CLR: u1,
            /// Reserved.
            RESERVED: u1,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            ILIM1_CLR: u1,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            IMAT1_CLR: u1,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            ICAP1_CLR: u1,
            /// Reserved.
            RESERVED: u1,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            ILIM2_CLR: u1,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            IMAT2_CLR: u1,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            ICAP2_CLR: u1,
            /// Reserved.
            RESERVED: u4,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            ABORT_CLR: u1,
            /// Reserved.
            RESERVED: u16,
        }), base_address + 0x58);

        /// address: 0x400b8068
        /// Interrupt flags read address
        pub const INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Limit interrupt flag for channel 0.
            ILIM0_F: u1,
            /// Match interrupt flag for channel 0.
            IMAT0_F: u1,
            /// Capture interrupt flag for channel 0.
            ICAP0_F: u1,
            /// Reserved.
            RESERVED: u1,
            /// Limit interrupt flag for channel 1.
            ILIM1_F: u1,
            /// Match interrupt flag for channel 1.
            IMAT1_F: u1,
            /// Capture interrupt flag for channel 1.
            ICAP1_F: u1,
            /// Reserved.
            RESERVED: u1,
            /// Limit interrupt flag for channel 2.
            ILIM2_F: u1,
            /// Match interrupt flag for channel 2.
            IMAT2_F: u1,
            /// Capture interrupt flag for channel 2.
            ICAP2_F: u1,
            /// Reserved.
            RESERVED: u4,
            /// Fast abort interrupt flag.
            ABORT_F: u1,
            /// Reserved.
            RESERVED: u16,
        }), base_address + 0x68);

        /// address: 0x400b806c
        /// Interrupt flags set address
        pub const INTF_SET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a one sets the corresponding bit in the INTF register, thus possibly
            /// simulating hardware interrupt.
            ILIM0_F_SET: u1,
            /// Writing a one sets the corresponding bit in the INTF register, thus possibly
            /// simulating hardware interrupt.
            IMAT0_F_SET: u1,
            /// Writing a one sets the corresponding bit in the INTF register, thus possibly
            /// simulating hardware interrupt.
            ICAP0_F_SET: u1,
            /// Reserved.
            RESERVED: u1,
            /// Writing a one sets the corresponding bit in the INTF register, thus possibly
            /// simulating hardware interrupt.
            ILIM1_F_SET: u1,
            /// Writing a one sets the corresponding bit in the INTF register, thus possibly
            /// simulating hardware interrupt.
            IMAT1_F_SET: u1,
            /// Writing a one sets the corresponding bit in the INTF register, thus possibly
            /// simulating hardware interrupt.
            ICAP1_F_SET: u1,
            /// Reserved.
            RESERVED: u1,
            /// Writing a one sets the corresponding bit in the INTF register, thus possibly
            /// simulating hardware interrupt.
            ILIM2_F_SET: u1,
            /// Writing a one sets the corresponding bit in the INTF register, thus possibly
            /// simulating hardware interrupt.
            IMAT2_F_SET: u1,
            /// Writing a one sets the corresponding bit in the INTF register, thus possibly
            /// simulating hardware interrupt.
            ICAP2_F_SET: u1,
            /// Reserved.
            RESERVED: u4,
            /// Writing a one sets the corresponding bit in the INTF register, thus possibly
            /// simulating hardware interrupt.
            ABORT_F_SET: u1,
            /// Reserved.
            RESERVED: u16,
        }), base_address + 0x6c);

        /// address: 0x400b8070
        /// Interrupt flags clear address
        pub const INTF_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a one clears the corresponding bit in the INTF register, thus clearing
            /// the corresponding interrupt request.
            ILIM0_F_CLR: u1,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            IMAT0_F_CLR: u1,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            ICAP0_F_CLR: u1,
            /// Reserved.
            RESERVED: u1,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            ILIM1_F_CLR: u1,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            IMAT1_F_CLR: u1,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            ICAP1_F_CLR: u1,
            /// Reserved.
            RESERVED: u1,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            ILIM2_F_CLR: u1,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            IMAT2_F_CLR: u1,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            ICAP2_F_CLR: u1,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            RESERVED: u4,
            /// Writing a one clears the corresponding bit in INTEN, thus disabling the
            /// interrupt.
            ABORT_F_CLR: u1,
            /// Reserved.
            RESERVED: u16,
        }), base_address + 0x70);

        /// address: 0x400b805c
        /// Count Control read address
        pub const CNTCON = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter 0 rising edge mode, channel 0.
            TC0MCI0_RE: u1,
            /// Counter 0 falling edge mode, channel 0.
            TC0MCI0_FE: u1,
            /// Counter 0 rising edge mode, channel 1.
            TC0MCI1_RE: u1,
            /// Counter 0 falling edge mode, channel 1.
            TC0MCI1_FE: u1,
            /// Counter 0 rising edge mode, channel 2.
            TC0MCI2_RE: u1,
            /// Counter 0 falling edge mode, channel 2.
            TC0MCI2_FE: u1,
            /// Counter 1 rising edge mode, channel 0.
            TC1MCI0_RE: u1,
            /// Counter 1 falling edge mode, channel 0.
            TC1MCI0_FE: u1,
            /// Counter 1 rising edge mode, channel 1.
            TC1MCI1_RE: u1,
            /// Counter 1 falling edge mode, channel 1.
            TC1MCI1_FE: u1,
            /// Counter 1 rising edge mode, channel 2.
            TC1MCI2_RE: u1,
            /// Counter 1 falling edge mode, channel 2.
            TC1MCI2_FE: u1,
            /// Counter 2 rising edge mode, channel 0.
            TC2MCI0_RE: u1,
            /// Counter 2 falling edge mode, channel 0.
            TC2MCI0_FE: u1,
            /// Counter 2 rising edge mode, channel 1.
            TC2MCI1_RE: u1,
            /// Counter 2 falling edge mode, channel 1.
            TC2MCI1_FE: u1,
            /// Counter 2 rising edge mode, channel 2.
            TC2MCI2_RE: u1,
            /// Counter 2 falling edge mode, channel 2.
            TC2MCI2_FE: u1,
            /// Reserved.
            RESERVED: u11,
            /// Channel 0 counter/timer mode.
            CNTR0: u1,
            /// Channel 1 counter/timer mode.
            CNTR1: u1,
            /// Channel 2 counter/timer mode.
            CNTR2: u1,
        }), base_address + 0x5c);

        /// address: 0x400b8060
        /// Count Control set address
        pub const CNTCON_SET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a one sets the corresponding bit in the CNTCON register.
            TC0MCI0_RE_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            TC0MCI0_FE_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            TC0MCI1_RE_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            TC0MCI1_FE_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            TC0MCI2_RE_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            TC0MCI2_FE_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            TC1MCI0_RE_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            TC1MCI0_FE_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            TC1MCI1_RE_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            TC1MCI1_FE_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            TC1MCI2_RE_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            TC1MCI2_FE_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            TC2MCI0_RE_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            TC2MCI0_FE_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            TC2MCI1_RE_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            TC2MCI1_FE_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            TC2MCI2_RE_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            TC2MCI2_FE_SET: u1,
            /// Reserved.
            RESERVED: u11,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            CNTR0_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            CNTR1_SET: u1,
            /// Writing a one sets the corresponding bit in the CNTCON register.
            CNTR2_SET: u1,
        }), base_address + 0x60);

        /// address: 0x400b8064
        /// Count Control clear address
        pub const CNTCON_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a one clears the corresponding bit in the CNTCON register.
            TC0MCI0_RE_CLR: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            TC0MCI0_FE_CLR: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            TC0MCI1_RE_CLR: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            TC0MCI1_FE_CLR: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            TC0MCI2_RE: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            TC0MCI2_FE_CLR: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            TC1MCI0_RE_CLR: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            TC1MCI0_FE_CLR: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            TC1MCI1_RE_CLR: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            TC1MCI1_FE_CLR: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            TC1MCI2_RE_CLR: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            TC1MCI2_FE_CLR: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            TC2MCI0_RE_CLR: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            TC2MCI0_FE_CLR: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            TC2MCI1_RE_CLR: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            TC2MCI1_FE_CLR: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            TC2MCI2_RE_CLR: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            TC2MCI2_FE_CLR: u1,
            /// Reserved.
            RESERVED: u11,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            CNTR0_CLR: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            CNTR1_CLR: u1,
            /// Writing a one clears the corresponding bit in the CNTCON register.
            CNTR2_CLR: u1,
        }), base_address + 0x64);

        /// address: 0x400b8074
        /// Capture clear address
        pub const CAP_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a 1 to this bit clears the CAP0 register.
            CAP_CLR0: u1,
            /// Writing a 1 to this bit clears the CAP1 register.
            CAP_CLR1: u1,
            /// Writing a 1 to this bit clears the CAP2 register.
            CAP_CLR2: u1,
            /// Reserved
            RESERVED: u29,
        }), base_address + 0x74);
    };
    /// Quadrature Encoder Interface (QEI)
    pub const QEI = struct {
        pub const base_address = 0x400bc000;

        /// address: 0x400bc000
        /// Control register
        pub const CON = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reset position counter. When set = 1, resets the position counter to all zeros.
            /// Autoclears when the position counter is cleared.
            RESP: u1,
            /// Reset position counter on index. When set = 1, resets the position counter to
            /// all zeros once only the first time an index pulse occurs. Autoclears when the
            /// position counter is cleared.
            RESPI: u1,
            /// Reset velocity. When set = 1, resets the velocity counter to all zeros, reloads
            /// the velocity timer, and presets the velocity compare register. Autoclears when
            /// the velocity counter is cleared.
            RESV: u1,
            /// Reset index counter. When set = 1, resets the index counter to all zeros.
            /// Autoclears when the index counter is cleared.
            RESI: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u28,
        }), base_address + 0x0);

        /// address: 0x400bc008
        /// Configuration register
        pub const CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Direction invert. When 1, complements the DIR bit.
            DIRINV: u1,
            /// Signal Mode. When 0, PhA and PhB function as quadrature encoder inputs. When 1,
            /// PhA functions as the direction signal and PhB functions as the clock signal.
            SIGMODE: u1,
            /// Capture Mode. When 0, only PhA edges are counted (2X). When 1, BOTH PhA and PhB
            /// edges are counted (4X), increasing resolution but decreasing range.
            CAPMODE: u1,
            /// Invert Index. When 1, inverts the sense of the index input.
            INVINX: u1,
            /// Continuously reset the position counter on index. When 1, resets the position
            /// counter to all zeros whenever an index pulse occurs after the next position
            /// increase (recalibration).
            CRESPI: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u11,
            /// Index gating configuration: When INXGATE[16] = 1, pass the index when PHA = 1
            /// and PHB = 0, otherwise block index. When INXGATE[17] = 1, pass the index when
            /// PHA = 1 and PHB = 1, otherwise block index. When INXGATE[18] = 1, pass the index
            /// when PHA = 0 and PHB = 1, otherwise block index. When INXGATE[19] = 1, pass the
            /// index when PHA = 0 and PHB = 0, otherwise block index.
            INXGATE: u4,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u12,
        }), base_address + 0x8);

        /// address: 0x400bc004
        /// Status register
        pub const STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Direction bit. In combination with DIRINV bit indicates forward or reverse
            /// direction. See Table 597.
            DIR: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u31,
        }), base_address + 0x4);

        /// address: 0x400bc00c
        /// Position register
        pub const POS = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x400bc010
        /// Maximum position register
        pub const MAXPOS = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x400bc014
        /// Position compare register 0
        pub const CMPOS0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Position compare value 0.
            PCMP0: u32,
        }), base_address + 0x14);

        /// address: 0x400bc018
        /// Position compare register 1
        pub const CMPOS1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Position compare value 1.
            PCMP1: u32,
        }), base_address + 0x18);

        /// address: 0x400bc01c
        /// Position compare register 2
        pub const CMPOS2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Position compare value 2.
            PCMP2: u32,
        }), base_address + 0x1c);

        /// address: 0x400bc020
        /// Index count register 0
        pub const INXCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current index counter value.
            ENCPOS: u32,
        }), base_address + 0x20);

        /// address: 0x400bc024
        /// Index compare register 0
        pub const INXCMP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Index compare value 0.
            ICMP0: u32,
        }), base_address + 0x24);

        /// address: 0x400bc028
        /// Velocity timer reload register
        pub const LOAD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current velocity timer load value.
            VELLOAD: u32,
        }), base_address + 0x28);

        /// address: 0x400bc02c
        /// Velocity timer register
        pub const TIME = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current velocity timer value.
            VELVAL: u32,
        }), base_address + 0x2c);

        /// address: 0x400bc030
        /// Velocity counter register
        pub const VEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current velocity pulse count.
            VELPC: u32,
        }), base_address + 0x30);

        /// address: 0x400bc034
        /// Velocity capture register
        pub const CAP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Last velocity capture.
            VELCAP: u32,
        }), base_address + 0x34);

        /// address: 0x400bc038
        /// Velocity compare register
        pub const VELCOMP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Compare velocity pulse count.
            VELPC: u32,
        }), base_address + 0x38);

        /// address: 0x400bc03c
        /// Digital filter register
        pub const FILTER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Digital filter sampling delay.
            FILTA: u32,
        }), base_address + 0x3c);

        /// address: 0x400bcfe0
        /// Interrupt status register
        pub const INTSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates that an index pulse was detected.
            INX_INT: u1,
            /// Indicates that a velocity timer overflow occurred
            TIM_INT: u1,
            /// Indicates that captured velocity is less than compare velocity.
            VELC_INT: u1,
            /// Indicates that a change of direction was detected.
            DIR_INT: u1,
            /// Indicates that an encoder phase error was detected.
            ERR_INT: u1,
            /// Indicates that and encoder clock pulse was detected.
            ENCLK_INT: u1,
            /// Indicates that the position 0 compare value is equal to the current position.
            POS0_INT: u1,
            /// Indicates that the position 1compare value is equal to the current position.
            POS1_INT: u1,
            /// Indicates that the position 2 compare value is equal to the current position.
            POS2_INT: u1,
            /// Indicates that the index compare 0 value is equal to the current index count.
            REV0_INT: u1,
            /// Combined position 0 and revolution count interrupt. Set when both the POS0_Int
            /// bit is set and the REV0_Int is set.
            POS0REV_INT: u1,
            /// Combined position 1 and revolution count interrupt. Set when both the POS1_Int
            /// bit is set and the REV1_Int is set.
            POS1REV_INT: u1,
            /// Combined position 2 and revolution count interrupt. Set when both the POS2_Int
            /// bit is set and the REV2_Int is set.
            POS2REV_INT: u1,
            /// Indicates that the index compare 1value is equal to the current index count.
            REV1_INT: u1,
            /// Indicates that the index compare 2 value is equal to the current index count.
            REV2_INT: u1,
            /// Indicates that the current position count goes through the MAXPOS value to zero
            /// in the forward direction, or through zero to MAXPOS in the reverse direction.
            MAXPOS_INT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u16,
        }), base_address + 0xfe0);

        /// address: 0x400bcfec
        /// Interrupt status set register
        pub const SET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a 1 sets the INX_Int bit in QEIINTSTAT.
            INX_INT: u1,
            /// Writing a 1 sets the TIN_Int bit in QEIINTSTAT.
            TIM_INT: u1,
            /// Writing a 1 sets the VELC_Int bit in QEIINTSTAT.
            VELC_INT: u1,
            /// Writing a 1 sets the DIR_Int bit in QEIINTSTAT.
            DIR_INT: u1,
            /// Writing a 1 sets the ERR_Int bit in QEIINTSTAT.
            ERR_INT: u1,
            /// Writing a 1 sets the ENCLK_Int bit in QEIINTSTAT.
            ENCLK_INT: u1,
            /// Writing a 1 sets the POS0_Int bit in QEIINTSTAT.
            POS0_INT: u1,
            /// Writing a 1 sets the POS1_Int bit in QEIINTSTAT.
            POS1_INT: u1,
            /// Writing a 1 sets the POS2_Int bit in QEIINTSTAT.
            POS2_INT: u1,
            /// Writing a 1 sets the REV0_Int bit in QEIINTSTAT.
            REV0_INT: u1,
            /// Writing a 1 sets the POS0REV_Int bit in QEIINTSTAT.
            POS0REV_INT: u1,
            /// Writing a 1 sets the POS1REV_Int bit in QEIINTSTAT.
            POS1REV_INT: u1,
            /// Writing a 1 sets the POS2REV_Int bit in QEIINTSTAT.
            POS2REV_INT: u1,
            /// Writing a 1 sets the REV1_Int bit in QEIINTSTAT.
            REV1_INT: u1,
            /// Writing a 1 sets the REV2_Int bit in QEIINTSTAT.
            REV2_INT: u1,
            /// Writing a 1 sets the MAXPOS_Int bit in QEIINTSTAT.
            MAXPOS_INT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u16,
        }), base_address + 0xfec);

        /// address: 0x400bcfe8
        /// Interrupt status clear register
        pub const CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a 1 clears the INX_Int bit in QEIINTSTAT.
            INX_INT: u1,
            /// Writing a 1 clears the TIN_Int bit in QEIINTSTAT.
            TIM_INT: u1,
            /// Writing a 1 clears the VELC_Int bit in QEIINTSTAT.
            VELC_INT: u1,
            /// Writing a 1 clears the DIR_Int bit in QEIINTSTAT.
            DIR_INT: u1,
            /// Writing a 1 clears the ERR_Int bit in QEIINTSTAT.
            ERR_INT: u1,
            /// Writing a 1 clears the ENCLK_Int bit in QEIINTSTAT.
            ENCLK_INT: u1,
            /// Writing a 1 clears the POS0_Int bit in QEIINTSTAT.
            POS0_INT: u1,
            /// Writing a 1 clears the POS1_Int bit in QEIINTSTAT.
            POS1_INT: u1,
            /// Writing a 1 clears the POS2_Int bit in QEIINTSTAT.
            POS2_INT: u1,
            /// Writing a 1 clears the REV0_Int bit in QEIINTSTAT.
            REV0_INT: u1,
            /// Writing a 1 clears the POS0REV_Int bit in QEIINTSTAT.
            POS0REV_INT: u1,
            /// Writing a 1 clears the POS1REV_Int bit in QEIINTSTAT.
            POS1REV_INT: u1,
            /// Writing a 1 clears the POS2REV_Int bit in QEIINTSTAT.
            POS2REV_INT: u1,
            /// Writing a 1 clears the REV1_Int bit in QEIINTSTAT.
            REV1_INT: u1,
            /// Writing a 1 clears the REV2_Int bit in QEIINTSTAT.
            REV2_INT: u1,
            /// Writing a 1 clears the MAXPOS_Int bit in QEIINTSTAT.
            MAXPOS_INT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u16,
        }), base_address + 0xfe8);

        /// address: 0x400bcfe4
        /// Interrupt enable register
        pub const IE = @intToPtr(*volatile Mmio(32, packed struct {
            /// When 1, the INX_Int interrupt is enabled.
            INX_INT: u1,
            /// When 1, the TIN_Int interrupt is enabled.
            TIM_INT: u1,
            /// When 1, the VELC_Int interrupt is enabled.
            VELC_INT: u1,
            /// When 1, the DIR_Int interrupt is enabled.
            DIR_INT: u1,
            /// When 1, the ERR_Int interrupt is enabled.
            ERR_INT: u1,
            /// When 1, the ENCLK_Int interrupt is enabled.
            ENCLK_INT: u1,
            /// When 1, the POS0_Int interrupt is enabled.
            POS0_INT: u1,
            /// When 1, the POS1_Int interrupt is enabled.
            POS1_INT: u1,
            /// When 1, the POS2_Int interrupt is enabled.
            POS2_INT: u1,
            /// When 1, the REV0_Int interrupt is enabled.
            REV0_INT: u1,
            /// When 1, the POS0REV_Int interrupt is enabled.
            POS0REV_INT: u1,
            /// When 1, the POS1REV_Int interrupt is enabled.
            POS1REV_INT: u1,
            /// When 1, the POS2REV_Int interrupt is enabled.
            POS2REV_INT: u1,
            /// When 1, the REV1_Int interrupt is enabled.
            REV1_INT: u1,
            /// When 1, the REV2_Int interrupt is enabled.
            REV2_INT: u1,
            /// When 1, the MAXPOS_Int interrupt is enabled.
            MAXPOS_INT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u16,
        }), base_address + 0xfe4);

        /// address: 0x400bcfdc
        /// Interrupt enable set register
        pub const IES = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a 1 enables the INX_Int interrupt in the QEIIE register.
            INX_INT: u1,
            /// Writing a 1 enables the TIN_Int interrupt in the QEIIE register.
            TIM_INT: u1,
            /// Writing a 1 enables the VELC_Int interrupt in the QEIIE register.
            VELC_INT: u1,
            /// Writing a 1 enables the DIR_Int interrupt in the QEIIE register.
            DIR_INT: u1,
            /// Writing a 1 enables the ERR_Int interrupt in the QEIIE register.
            ERR_INT: u1,
            /// Writing a 1 enables the ENCLK_Int interrupt in the QEIIE register.
            ENCLK_INT: u1,
            /// Writing a 1 enables the POS0_Int interrupt in the QEIIE register.
            POS0_INT: u1,
            /// Writing a 1 enables the POS1_Int interrupt in the QEIIE register.
            POS1_INT: u1,
            /// Writing a 1 enables the POS2_Int interrupt in the QEIIE register.
            POS2_INT: u1,
            /// Writing a 1 enables the REV0_Int interrupt in the QEIIE register.
            REV0_INT: u1,
            /// Writing a 1 enables the POS0REV_Int interrupt in the QEIIE register.
            POS0REV_INT: u1,
            /// Writing a 1 enables the POS1REV_Int interrupt in the QEIIE register.
            POS1REV_INT: u1,
            /// Writing a 1 enables the POS2REV_Int interrupt in the QEIIE register.
            POS2REV_INT: u1,
            /// Writing a 1 enables the REV1_Int interrupt in the QEIIE register.
            REV1_INT: u1,
            /// Writing a 1 enables the REV2_Int interrupt in the QEIIE register.
            REV2_INT: u1,
            /// Writing a 1 enables the MAXPOS_Int interrupt in the QEIIE register.
            MAXPOS_INT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u16,
        }), base_address + 0xfdc);

        /// address: 0x400bcfd8
        /// Interrupt enable clear register
        pub const IEC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a 1 disables the INX_Int interrupt in the QEIIE register.
            INX_INT: u1,
            /// Writing a 1 disables the TIN_Int interrupt in the QEIIE register.
            TIM_INT: u1,
            /// Writing a 1 disables the VELC_Int interrupt in the QEIIE register.
            VELC_INT: u1,
            /// Writing a 1 disables the DIR_Int interrupt in the QEIIE register.
            DIR_INT: u1,
            /// Writing a 1 disables the ERR_Int interrupt in the QEIIE register.
            ERR_INT: u1,
            /// Writing a 1 disables the ENCLK_Int interrupt in the QEIIE register.
            ENCLK_INT: u1,
            /// Writing a 1 disables the POS0_Int interrupt in the QEIIE register.
            POS0_INT: u1,
            /// Writing a 1 disables the POS1_Int interrupt in the QEIIE register.
            POS1_INT: u1,
            /// Writing a 1 disables the POS2_Int interrupt in the QEIIE register.
            POS2_INT: u1,
            /// Writing a 1 disables the REV0_Int interrupt in the QEIIE register.
            REV0_INT: u1,
            /// Writing a 1 disables the POS0REV_Int interrupt in the QEIIE register.
            POS0REV_INT: u1,
            /// Writing a 1 disables the POS1REV_Int interrupt in the QEIIE register.
            POS1REV_INT: u1,
            /// Writing a 1 disables the POS2REV_Int interrupt in the QEIIE register.
            POS2REV_INT: u1,
            /// Writing a 1 disables the REV1_Int interrupt in the QEIIE register.
            REV1_INT: u1,
            /// Writing a 1 disables the REV2_Int interrupt in the QEIIE register.
            REV2_INT: u1,
            /// Writing a 1 disables the MAXPOS_Int interrupt in the QEIIE register.
            MAXPOS_INT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u16,
        }), base_address + 0xfd8);
    };
    /// System and clock control
    pub const SYSCON = struct {
        pub const base_address = 0x400fc000;

        /// address: 0x400fc000
        /// Flash Accelerator Configuration Register. Controls flash access timing.
        pub const FLASHCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved, user software should not change these bits from the reset value.
            reserved0: u12 = 0,
            /// Flash access time. The value of this field plus 1 gives the number of CPU clocks
            /// used for a flash access. Warning: improper setting of this value may result in
            /// incorrect operation of the device. Other values are reserved.
            FLASHTIM: u4,
            /// Reserved. The value read from a reserved bit is not defined.
            reserved1: u16 = 0,
        }), base_address + 0x0);

        /// address: 0x400fc080
        /// PLL0 Control Register
        pub const PLL0CON = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLL0 Enable. When one, and after a valid PLL0 feed, this bit will activate PLL0
            /// and allow it to lock to the requested frequency. See PLL0STAT register.
            PLLE0: u1,
            /// PLL0 Connect. Setting PLLC0 to one after PLL0 has been enabled and locked, then
            /// followed by a valid PLL0 feed sequence causes PLL0 to become the clock source
            /// for the CPU, AHB peripherals, and used to derive the clocks for APB peripherals.
            /// The PLL0 output may potentially be used to clock the USB subsystem if the
            /// frequency is 48 MHz. See PLL0STAT register.
            PLLC0: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u30 = 0,
        }), base_address + 0x80);

        /// address: 0x400fc084
        /// PLL0 Configuration Register
        pub const PLL0CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLL0 Multiplier value. Supplies the value M in PLL0 frequency calculations. The
            /// value stored here is M - 1. Note: Not all values of M are needed, and therefore
            /// some are not supported by hardware.
            MSEL0: u15,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            reserved0: u1 = 0,
            /// PLL0 Pre-Divider value. Supplies the value N in PLL0 frequency calculations. The
            /// value stored here is N - 1. Supported values for N are 1 through 32.
            NSEL0: u8,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            reserved1: u8 = 0,
        }), base_address + 0x84);

        /// address: 0x400fc088
        /// PLL0 Status Register
        pub const PLL0STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read-back for the PLL0 Multiplier value. This is the value currently used by
            /// PLL0, and is one less than the actual multiplier.
            MSEL0: u15,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u1,
            /// Read-back for the PLL0 Pre-Divider value. This is the value currently used by
            /// PLL0, and is one less than the actual divider.
            NSEL0: u8,
            /// Read-back for the PLL0 Enable bit. This bit reflects the state of the PLEC0 bit
            /// in PLL0CON after a valid PLL0 feed. When one, PLL0 is currently enabled. When
            /// zero, PLL0 is turned off. This bit is automatically cleared when Power-down mode
            /// is entered.
            PLLE0_STAT: u1,
            /// Read-back for the PLL0 Connect bit. This bit reflects the state of the PLLC0 bit
            /// in PLL0CON after a valid PLL0 feed. When PLLC0 and PLLE0 are both one, PLL0 is
            /// connected as the clock source for the CPU. When either PLLC0 or PLLE0 is zero,
            /// PLL0 is bypassed. This bit is automatically cleared when Power-down mode is
            /// entered.
            PLLC0_STAT: u1,
            /// Reflects the PLL0 Lock status. When zero, PLL0 is not locked. When one, PLL0 is
            /// locked onto the requested frequency. See text for details.
            PLOCK0: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u5,
        }), base_address + 0x88);

        /// address: 0x400fc08c
        /// PLL0 Feed Register
        pub const PLL0FEED = @intToPtr(*volatile Mmio(32, packed struct {
            /// The PLL0 feed sequence must be written to this register in order for PLL0
            /// configuration and control register changes to take effect.
            PLL0FEED: u8,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x8c);

        /// address: 0x400fc0a0
        /// PLL1 Control Register
        pub const PLL1CON = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLL1 Enable. When one, and after a valid PLL1 feed, this bit will activate PLL1
            /// and allow it to lock to the requested frequency.
            PLLE1: u1,
            /// PLL1 Connect. Setting PLLC to one after PLL1 has been enabled and locked, then
            /// followed by a valid PLL1 feed sequence causes PLL1 to become the clock source
            /// for the USB subsystem via the USB clock divider. See PLL1STAT register.
            PLLC1: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u30,
        }), base_address + 0xa0);

        /// address: 0x400fc0a4
        /// PLL1 Configuration Register
        pub const PLL1CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLL1 Multiplier value. Supplies the value M in the PLL1 frequency calculations.
            MSEL1: u5,
            /// PLL1 Divider value. Supplies the value P in the PLL1 frequency calculations.
            PSEL1: u2,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u25,
        }), base_address + 0xa4);

        /// address: 0x400fc0a8
        /// PLL1 Status Register
        pub const PLL1STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read-back for the PLL1 Multiplier value. This is the value currently used by
            /// PLL1.
            MSEL1: u5,
            /// Read-back for the PLL1 Divider value. This is the value currently used by PLL1.
            PSEL1: u2,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u1,
            /// Read-back for the PLL1 Enable bit. When one, PLL1 is currently activated. When
            /// zero, PLL1 is turned off. This bit is automatically cleared when Power-down mode
            /// is activated.
            PLLE1_STAT: u1,
            /// Read-back for the PLL1 Connect bit. When PLLC and PLLE are both one, PLL1 is
            /// connected as the clock source for the microcontroller. When either PLLC or PLLE
            /// is zero, PLL1 is bypassed and the oscillator clock is used directly by the
            /// microcontroller. This bit is automatically cleared when Power-down mode is
            /// activated.
            PLLC1_STAT: u1,
            /// Reflects the PLL1 Lock status. When zero, PLL1 is not locked. When one, PLL1 is
            /// locked onto the requested frequency.
            PLOCK1: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u21,
        }), base_address + 0xa8);

        /// address: 0x400fc0ac
        /// PLL1 Feed Register
        pub const PLL1FEED = @intToPtr(*volatile Mmio(32, packed struct {
            /// The PLL1 feed sequence must be written to this register in order for PLL1
            /// configuration and control register changes to take effect.
            PLL1FEED: u8,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0xac);

        /// address: 0x400fc0c0
        /// Power Control Register
        pub const PCON = @intToPtr(*volatile Mmio(32, packed struct {
            /// Power mode control bit 0. This bit controls entry to the Power-down mode.
            PM0: u1,
            /// Power mode control bit 1. This bit controls entry to the Deep Power-down mode.
            PM1: u1,
            /// Brown-Out Reduced Power Mode. When BODRPM is 1, the Brown-Out Detect circuitry
            /// will be turned off when chip Power-down mode or Deep Sleep mode is entered,
            /// resulting in a further reduction in power usage. However, the possibility of
            /// using Brown-Out Detect as a wake-up source from the reduced power mode will be
            /// lost. When 0, the Brown-Out Detect function remains active during Power-down and
            /// Deep Sleep modes. See the System Control Block chapter for details of Brown-Out
            /// detection.
            BODRPM: u1,
            /// Brown-Out Global Disable. When BOGD is 1, the Brown-Out Detect circuitry is
            /// fully disabled at all times, and does not consume power. When 0, the Brown-Out
            /// Detect circuitry is enabled. See the System Control Block chapter for details of
            /// Brown-Out detection. Note: the Brown-Out Reset Disable (BORD, in this register)
            /// and the Brown-Out Interrupt (xx) must be disabled when software changes the
            /// value of this bit.
            BOGD: u1,
            /// Brown-Out Reset Disable. When BORD is 1, the BOD will not reset the device when
            /// the VDD(REG)(3V3) voltage dips goes below the BOD reset trip level. The
            /// Brown-Out interrupt is not affected. When BORD is 0, the BOD reset is enabled.
            BORD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Sleep Mode entry flag. Set when the Sleep mode is successfully entered. Cleared
            /// by software writing a one to this bit.
            SMFLAG: u1,
            /// Deep Sleep entry flag. Set when the Deep Sleep mode is successfully entered.
            /// Cleared by software writing a one to this bit.
            DSFLAG: u1,
            /// Power-down entry flag. Set when the Power-down mode is successfully entered.
            /// Cleared by software writing a one to this bit.
            PDFLAG: u1,
            /// Deep Power-down entry flag. Set when the Deep Power-down mode is successfully
            /// entered. Cleared by software writing a one to this bit.
            DPDFLAG: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u20,
        }), base_address + 0xc0);

        /// address: 0x400fc0c4
        /// Power Control for Peripherals Register
        pub const PCONP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved.
            reserved0: u1,
            /// Timer/Counter 0 power/clock control bit.
            PCTIM0: u1,
            /// Timer/Counter 1 power/clock control bit.
            PCTIM1: u1,
            /// UART0 power/clock control bit.
            PCUART0: u1,
            /// UART1 power/clock control bit.
            PCUART1: u1,
            /// Reserved.
            reserved1: u1,
            /// PWM1 power/clock control bit.
            PCPWM1: u1,
            /// The I2C0 interface power/clock control bit.
            PCI2C0: u1,
            /// The SPI interface power/clock control bit.
            PCSPI: u1,
            /// The RTC power/clock control bit.
            PCRTC: u1,
            /// The SSP 1 interface power/clock control bit.
            PCSSP1: u1,
            /// Reserved.
            reserved2: u1,
            /// A/D converter (ADC) power/clock control bit. Note: Clear the PDN bit in the
            /// AD0CR before clearing this bit, and set this bit before setting PDN.
            PCADC: u1,
            /// CAN Controller 1 power/clock control bit.
            PCCAN1: u1,
            /// CAN Controller 2 power/clock control bit.
            PCCAN2: u1,
            /// Power/clock control bit for IOCON, GPIO, and GPIO interrupts.
            PCGPIO: u1,
            /// Repetitive Interrupt Timer power/clock control bit.
            PCRIT: u1,
            /// Motor Control PWM
            PCMCPWM: u1,
            /// Quadrature Encoder Interface power/clock control bit.
            PCQEI: u1,
            /// The I2C1 interface power/clock control bit.
            PCI2C1: u1,
            /// Reserved.
            reserved3: u1,
            /// The SSP0 interface power/clock control bit.
            PCSSP0: u1,
            /// Timer 2 power/clock control bit.
            PCTIM2: u1,
            /// Timer 3 power/clock control bit.
            PCTIM3: u1,
            /// UART 2 power/clock control bit.
            PCUART2: u1,
            /// UART 3 power/clock control bit.
            PCUART3: u1,
            /// I2C interface 2 power/clock control bit.
            PCI2C2: u1,
            /// I2S interface power/clock control bit.
            PCI2S: u1,
            /// Reserved.
            reserved4: u1,
            /// GPDMA function power/clock control bit.
            PCGPDMA: u1,
            /// Ethernet block power/clock control bit.
            PCENET: u1,
            /// USB interface power/clock control bit.
            PCUSB: u1,
        }), base_address + 0xc4);

        /// address: 0x400fc104
        /// CPU Clock Configuration Register
        pub const CCLKCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Selects the divide value for creating the CPU clock (CCLK) from the PLL0 output.
            /// 0 = pllclk is divided by 1 to produce the CPU clock. This setting is not allowed
            /// when the PLL0 is connected, because the rate would always be greater than the
            /// maximum allowed CPU clock. 1 = pllclk is divided by 2 to produce the CPU clock.
            /// This setting is not allowed when the PLL0 is connected, because the rate would
            /// always be greater than the maximum allowed CPU clock. 2 = pllclk is divided by 3
            /// to produce the CPU clock. 3 = pllclk is divided by 4 to produce the CPU clock.
            /// ... 255 = pllclk is divided by 256 to produce the CPU clock.
            CCLKSEL: u8,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x104);

        /// address: 0x400fc108
        /// USB Clock Configuration Register
        pub const USBCLKCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Selects the divide value for creating the USB clock from the PLL0 output. Only
            /// the values shown below can produce even number multiples of 48 MHz from the PLL0
            /// output. Warning: Improper setting of this value will result in incorrect
            /// operation of the USB interface. 5 = PLL0 output is divided by 6. PLL0 output
            /// must be 288 MHz. 7 = PLL0 output is divided by 8. PLL0 output must be 384 MHz. 9
            /// = PLL0 output is divided by 10. PLL0 output must be 480 MHz.
            USBSEL: u4,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u28,
        }), base_address + 0x108);

        /// address: 0x400fc10c
        /// Clock Source Select Register
        pub const CLKSRCSEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Selects the clock source for PLL0 as follows. Warning: Improper setting of this
            /// value, or an incorrect sequence of changing this value may result in incorrect
            /// operation of the device.
            CLKSRC: u2,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u30 = 0,
        }), base_address + 0x10c);

        /// address: 0x400fc110
        /// Allows clearing the current CAN channel sleep state as well as reading that
        /// state.
        pub const CANSLEEPCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u1,
            /// Sleep status and control for CAN channel 1. Read: when 1, indicates that CAN
            /// channel 1 is in the sleep mode. Write: writing a 1 causes clocks to be restored
            /// to CAN channel 1.
            CAN1SLEEP: u1,
            /// Sleep status and control for CAN channel 2. Read: when 1, indicates that CAN
            /// channel 2 is in the sleep mode. Write: writing a 1 causes clocks to be restored
            /// to CAN channel 2.
            CAN2SLEEP: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u29,
        }), base_address + 0x110);

        /// address: 0x400fc114
        /// Allows reading the wake-up state of the CAN channels.
        pub const CANWAKEFLAGS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u1,
            /// Wake-up status for CAN channel 1. Read: when 1, indicates that a falling edge
            /// has occurred on the receive data line of CAN channel 1. Write: writing a 1
            /// clears this bit.
            CAN1WAKE: u1,
            /// Wake-up status for CAN channel 2. Read: when 1, indicates that a falling edge
            /// has occurred on the receive data line of CAN channel 2. Write: writing a 1
            /// clears this bit.
            CAN2WAKE: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u29,
        }), base_address + 0x114);

        /// address: 0x400fc140
        /// External Interrupt Flag Register
        pub const EXTINT = @intToPtr(*volatile Mmio(32, packed struct {
            /// In level-sensitive mode, this bit is set if the EINT0 function is selected for
            /// its pin, and the pin is in its active state. In edge-sensitive mode, this bit is
            /// set if the EINT0 function is selected for its pin, and the selected edge occurs
            /// on the pin. This bit is cleared by writing a one to it, except in level
            /// sensitive mode when the pin is in its active state.
            EINT0: u1,
            /// In level-sensitive mode, this bit is set if the EINT1 function is selected for
            /// its pin, and the pin is in its active state. In edge-sensitive mode, this bit is
            /// set if the EINT1 function is selected for its pin, and the selected edge occurs
            /// on the pin. This bit is cleared by writing a one to it, except in level
            /// sensitive mode when the pin is in its active state.
            EINT1: u1,
            /// In level-sensitive mode, this bit is set if the EINT2 function is selected for
            /// its pin, and the pin is in its active state. In edge-sensitive mode, this bit is
            /// set if the EINT2 function is selected for its pin, and the selected edge occurs
            /// on the pin. This bit is cleared by writing a one to it, except in level
            /// sensitive mode when the pin is in its active state.
            EINT2: u1,
            /// In level-sensitive mode, this bit is set if the EINT3 function is selected for
            /// its pin, and the pin is in its active state. In edge-sensitive mode, this bit is
            /// set if the EINT3 function is selected for its pin, and the selected edge occurs
            /// on the pin. This bit is cleared by writing a one to it, except in level
            /// sensitive mode when the pin is in its active state.
            EINT3: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u28,
        }), base_address + 0x140);

        /// address: 0x400fc148
        /// External Interrupt Mode register
        pub const EXTMODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// External interrupt 0 EINT0 mode.
            EXTMODE0: u1,
            /// External interrupt 1 EINT1 mode.
            EXTMODE1: u1,
            /// External interrupt 2 EINT2 mode.
            EXTMODE2: u1,
            /// External interrupt 3 EINT3 mode.
            EXTMODE3: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u28,
        }), base_address + 0x148);

        /// address: 0x400fc14c
        /// External Interrupt Polarity Register
        pub const EXTPOLAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// External interrupt 0 EINT0 polarity.
            EXTPOLAR0: u1,
            /// External interrupt 1 EINT1 polarity.
            EXTPOLAR1: u1,
            /// External interrupt 2 EINT2 polarity.
            EXTPOLAR2: u1,
            /// External interrupt 3 EINT3 polarity.
            EXTPOLAR3: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u28,
        }), base_address + 0x14c);

        /// address: 0x400fc180
        /// Reset Source Identification Register
        pub const RSID = @intToPtr(*volatile Mmio(32, packed struct {
            /// Assertion of the POR signal sets this bit, and clears all of the other bits in
            /// this register. But if another Reset signal (e.g., External Reset) remains
            /// asserted after the POR signal is negated, then its bit is set. This bit is not
            /// affected by any of the other sources of Reset.
            POR: u1,
            /// Assertion of the RESET signal sets this bit. This bit is cleared only by
            /// software or POR.
            EXTR: u1,
            /// This bit is set when the Watchdog Timer times out and the WDTRESET bit in the
            /// Watchdog Mode Register is 1. This bit is cleared only by software or POR.
            WDTR: u1,
            /// This bit is set when the VDD(REG)(3V3) voltage reaches a level below the BOD
            /// reset trip level (typically 1.85 V under nominal room temperature conditions).
            /// If the VDD(REG)(3V3) voltage dips from the normal operating range to below the
            /// BOD reset trip level and recovers, the BODR bit will be set to 1. If the
            /// VDD(REG)(3V3) voltage dips from the normal operating range to below the BOD
            /// reset trip level and continues to decline to the level at which POR is asserted
            /// (nominally 1 V), the BODR bit is cleared. If the VDD(REG)(3V3) voltage rises
            /// continuously from below 1 V to a level above the BOD reset trip level, the BODR
            /// will be set to 1. This bit is cleared only by software or POR. Note: Only in the
            /// case where a reset occurs and the POR = 0, the BODR bit indicates if the
            /// VDD(REG)(3V3) voltage was below the BOD reset trip level or not.
            BODR: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u28,
        }), base_address + 0x180);

        /// address: 0x400fc1a0
        /// System control and status
        pub const SCS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. User software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u4,
            /// Main oscillator range select.
            OSCRANGE: u1,
            /// Main oscillator enable.
            OSCEN: u1,
            /// Main oscillator status.
            OSCSTAT: u1,
            /// Reserved. User software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u25,
        }), base_address + 0x1a0);

        /// address: 0x400fc1a8
        /// Peripheral Clock Selection register 0.
        pub const PCLKSEL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral clock selection for WDT.
            PCLK_WDT: u2,
            /// Peripheral clock selection for TIMER0.
            PCLK_TIMER0: u2,
            /// Peripheral clock selection for TIMER1.
            PCLK_TIMER1: u2,
            /// Peripheral clock selection for UART0.
            PCLK_UART0: u2,
            /// Peripheral clock selection for UART1.
            PCLK_UART1: u2,
            /// Reserved.
            reserved0: u2,
            /// Peripheral clock selection for PWM1.
            PCLK_PWM1: u2,
            /// Peripheral clock selection for I2C0.
            PCLK_I2C0: u2,
            /// Peripheral clock selection for SPI.
            PCLK_SPI: u2,
            /// Reserved.
            reserved1: u2,
            /// Peripheral clock selection for SSP1.
            PCLK_SSP1: u2,
            /// Peripheral clock selection for DAC.
            PCLK_DAC: u2,
            /// Peripheral clock selection for ADC.
            PCLK_ADC: u2,
            /// Peripheral clock selection for CAN1.PCLK_CAN1 and PCLK_CAN2 must have the same
            /// PCLK divide value when the CAN function is used.
            PCLK_CAN1: u2,
            /// Peripheral clock selection for CAN2.PCLK_CAN1 and PCLK_CAN2 must have the same
            /// PCLK divide value when the CAN function is used.
            PCLK_CAN2: u2,
            /// Peripheral clock selection for CAN acceptance filtering.PCLK_CAN1 and PCLK_CAN2
            /// must have the same PCLK divide value when the CAN function is used.
            PCLK_ACF: u2,
        }), base_address + 0x1a8);

        /// address: 0x400fc1ac
        /// Peripheral Clock Selection register 1.
        pub const PCLKSEL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral clock selection for the Quadrature Encoder Interface.
            PCLK_QEI: u2,
            /// Peripheral clock selection for GPIO interrupts.
            PCLK_GPIOINT: u2,
            /// Peripheral clock selection for the Pin Connect block.
            PCLK_PCB: u2,
            /// Peripheral clock selection for I2C1.
            PCLK_I2C1: u2,
            /// Reserved.
            RESERVED0: u2 = 1,
            /// Peripheral clock selection for SSP0.
            PCLK_SSP0: u2,
            /// Peripheral clock selection for TIMER2.
            PCLK_TIMER2: u2,
            /// Peripheral clock selection for TIMER3.
            PCLK_TIMER3: u2,
            /// Peripheral clock selection for UART2.
            PCLK_UART2: u2,
            /// Peripheral clock selection for UART3.
            PCLK_UART3: u2,
            /// Peripheral clock selection for I2C2.
            PCLK_I2C2: u2,
            /// Peripheral clock selection for I2S.
            PCLK_I2S: u2,
            /// Reserved.
            RESERVED1: u2 = 1,
            /// Peripheral clock selection for Repetitive Interrupt Timer.
            PCLK_RIT: u2,
            /// Peripheral clock selection for the System Control block.
            PCLK_SYSCON: u2,
            /// Peripheral clock selection for the Motor Control PWM.
            PCLK_MC: u2,
        }), base_address + 0x1ac);

        /// address: 0x400fc1c0
        /// USB Interrupt Status
        pub const USBINTST = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low priority interrupt line status. This bit is read-only.
            USB_INT_REQ_LP: u1,
            /// High priority interrupt line status. This bit is read-only.
            USB_INT_REQ_HP: u1,
            /// DMA interrupt line status. This bit is read-only.
            USB_INT_REQ_DMA: u1,
            /// USB host interrupt line status. This bit is read-only.
            USB_HOST_INT: u1,
            /// External ATX interrupt line status. This bit is read-only.
            USB_ATX_INT: u1,
            /// OTG interrupt line status. This bit is read-only.
            USB_OTG_INT: u1,
            /// I2C module interrupt line status. This bit is read-only.
            USB_I2C_INT: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u1,
            /// USB need clock indicator. This bit is read-only. This bit is set to 1 when USB
            /// activity or a change of state on the USB data pins is detected, and it indicates
            /// that a PLL supplied clock of 48 MHz is needed. Once USB_NEED_CLK becomes one, it
            /// resets to zero 5 ms after the last packet has been received/sent, or 2 ms after
            /// the Suspend Change (SUS_CH) interrupt has occurred. A change of this bit from 0
            /// to 1 can wake up the microcontroller if activity on the USB bus is selected to
            /// wake up the part from the Power-down mode (see Section 4.7.9 Wake-up from
            /// Reduced Power Modes for details). Also see Section 4.5.8 PLLs and Power-down
            /// mode and Section 4.7.10 Power Control for Peripherals register (PCONP - 0x400F
            /// C0C4) for considerations about the PLL and invoking the Power-down mode. This
            /// bit is read-only.
            USB_NEED_CLK: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u22,
            /// Enable all USB interrupts. When this bit is cleared, the NVIC does not see the
            /// ORed output of the USB interrupt lines.
            EN_USB_INTS: u1,
        }), base_address + 0x1c0);

        /// address: 0x400fc1c4
        /// Selects between alternative requests on DMA channels 0 through 7 and 10 through
        /// 15
        pub const DMACREQSEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Selects the DMA request for GPDMA input 8: 0 - uart0 tx 1 - Timer 0 match 0 is
            /// selected.
            DMASEL08: u1,
            /// Selects the DMA request for GPDMA input 9: 0 - uart0 rx 1 - Timer 0 match 1 is
            /// selected.
            DMASEL09: u1,
            /// Selects the DMA request for GPDMA input 10: 0 - uart1 tx is selected. 1 - Timer
            /// 1 match 0 is selected.
            DMASEL10: u1,
            /// Selects the DMA request for GPDMA input 11: 0 - uart1 rx is selected. 1 - Timer
            /// 1 match 1 is selected.
            DMASEL11: u1,
            /// Selects the DMA request for GPDMA input 12: 0 - uart2 tx is selected. 1 - Timer
            /// 2 match 0 is selected.
            DMASEL12: u1,
            /// Selects the DMA request for GPDMA input 13: 0 - uart2 rx is selected. 1 - Timer
            /// 2 match 1 is selected.
            DMASEL13: u1,
            /// Selects the DMA request for GPDMA input 14: 0 - uart3 tx is selected. 1 - I2S
            /// channel 0 is selected.
            DMASEL14: u1,
            /// Selects the DMA request for GPDMA input 15: 0 - uart3 rx is selected. 1 - I2S
            /// channel 1 is selected.
            DMASEL15: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x1c4);

        /// address: 0x400fc1c8
        /// Clock Output Configuration Register
        pub const CLKOUTCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Selects the clock source for the CLKOUT function. Other values are reserved. Do
            /// not use.
            CLKOUTSEL: u4,
            /// Integer value to divide the output clock by, minus one. 0 = Clock is divided by
            /// 1 1 = Clock is divided by 2. 2 = Clock is divided by 3. ... 15 = Clock is
            /// divided by 16.
            CLKOUTDIV: u4,
            /// CLKOUT enable control, allows switching the CLKOUT source without glitches.
            /// Clear to stop CLKOUT on the next falling edge. Set to enable CLKOUT.
            CLKOUT_EN: u1,
            /// CLKOUT activity indication. Reads as 1 when CLKOUT is enabled. Read as 0 when
            /// CLKOUT has been disabled via the CLKOUT_EN bit and the clock has completed being
            /// stopped.
            CLKOUT_ACT: u1,
            /// Reserved, user software should not write ones to reserved bits. The value read
            /// from a reserved bit is not defined.
            RESERVED: u22,
        }), base_address + 0x1c8);
    };
    /// Ethernet
    pub const EMAC = struct {
        pub const base_address = 0x50000000;

        /// address: 0x50000000
        /// MAC configuration register 1.
        pub const MAC1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RECEIVE ENABLE. Set this to allow receive frames to be received. Internally the
            /// MAC synchronizes this control bit to the incoming receive stream.
            RXENABLE: u1,
            /// PASS ALL RECEIVE FRAMES. When enabled (set to 1), the MAC will pass all frames
            /// regardless of type (normal vs. Control). When disabled, the MAC does not pass
            /// valid Control frames.
            PARF: u1,
            /// RX FLOW CONTROL. When enabled (set to 1), the MAC acts upon received PAUSE Flow
            /// Control frames. When disabled, received PAUSE Flow Control frames are ignored.
            RXFLOWCTRL: u1,
            /// TX FLOW CONTROL. When enabled (set to 1), PAUSE Flow Control frames are allowed
            /// to be transmitted. When disabled, Flow Control frames are blocked.
            TXFLOWCTRL: u1,
            /// Setting this bit will cause the MAC Transmit interface to be looped back to the
            /// MAC Receive interface. Clearing this bit results in normal operation.
            LOOPBACK: u1,
            /// Unused
            RESERVED: u3,
            /// Setting this bit will put the Transmit Function logic in reset.
            RESETTX: u1,
            /// Setting this bit resets the MAC Control Sublayer / Transmit logic. The MCS logic
            /// implements flow control.
            RESETMCSTX: u1,
            /// Setting this bit will put the Ethernet receive logic in reset.
            RESETRX: u1,
            /// Setting this bit resets the MAC Control Sublayer / Receive logic. The MCS logic
            /// implements flow control.
            RESETMCSRX: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u2,
            /// SIMULATION RESET. Setting this bit will cause a reset to the random number
            /// generator within the Transmit Function.
            SIMRESET: u1,
            /// SOFT RESET. Setting this bit will put all modules within the MAC in reset except
            /// the Host Interface.
            SOFTRESET: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u16,
        }), base_address + 0x0);

        /// address: 0x50000004
        /// MAC configuration register 2.
        pub const MAC2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// When enabled (set to 1), the MAC operates in Full-Duplex mode. When disabled,
            /// the MAC operates in Half-Duplex mode.
            FULLDUPLEX: u1,
            /// FRAMELENGTH CHECKING. When enabled (set to 1), both transmit and receive frame
            /// lengths are compared to the Length/Type field. If the Length/Type field
            /// represents a length then the check is performed. Mismatches are reported in the
            /// StatusInfo word for each received frame.
            FLC: u1,
            /// HUGE FRAME ENABLEWhen enabled (set to 1), frames of any length are transmitted
            /// and received.
            HFEN: u1,
            /// DELAYED CRC. This bit determines the number of bytes, if any, of proprietary
            /// header information that exist on the front of IEEE 802.3 frames. When 1, four
            /// bytes of header (ignored by the CRC function) are added. When 0, there is no
            /// proprietary header.
            DELAYEDCRC: u1,
            /// CRC ENABLESet this bit to append a CRC to every frame whether padding was
            /// required or not. Must be set if PAD/CRC ENABLE is set. Clear this bit if frames
            /// presented to the MAC contain a CRC.
            CRCEN: u1,
            /// PAD CRC ENABLE. Set this bit to have the MAC pad all short frames. Clear this
            /// bit if frames presented to the MAC have a valid length. This bit is used in
            /// conjunction with AUTO PAD ENABLE and VLAN PAD ENABLE. See Table 153 - Pad
            /// Operation for details on the pad function.
            PADCRCEN: u1,
            /// VLAN PAD ENABLE. Set this bit to cause the MAC to pad all short frames to 64
            /// bytes and append a valid CRC. Consult Table 153 - Pad Operation for more
            /// information on the various padding features. Note: This bit is ignored if PAD /
            /// CRC ENABLE is cleared.
            VLANPADEN: u1,
            /// AUTODETECTPAD ENABLE. Set this bit to cause the MAC to automatically detect the
            /// type of frame, either tagged or un-tagged, by comparing the two octets following
            /// the source address with 0x8100 (VLAN Protocol ID) and pad accordingly. Table 153
            /// - Pad Operation provides a description of the pad function based on the
            /// configuration of this register. Note: This bit is ignored if PAD / CRC ENABLE is
            /// cleared.
            AUTODETPADEN: u1,
            /// PURE PREAMBLE ENFORCEMEN. When enabled (set to 1), the MAC will verify the
            /// content of the preamble to ensure it contains 0x55 and is error-free. A packet
            /// with an incorrect preamble is discarded. When disabled, no preamble checking is
            /// performed.
            PPENF: u1,
            /// LONG PREAMBLE ENFORCEMENT. When enabled (set to 1), the MAC only allows receive
            /// packets which contain preamble fields less than 12 bytes in length. When
            /// disabled, the MAC allows any length preamble as per the Standard.
            LPENF: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u2,
            /// When enabled (set to 1), the MAC will immediately retransmit following a
            /// collision rather than using the Binary Exponential Backoff algorithm as
            /// specified in the Standard.
            NOBACKOFF: u1,
            /// BACK PRESSURE / NO BACKOFF. When enabled (set to 1), after the MAC incidentally
            /// causes a collision during back pressure, it will immediately retransmit without
            /// backoff, reducing the chance of further collisions and ensuring transmit packets
            /// get sent.
            BP_NOBACKOFF: u1,
            /// When enabled (set to 1) the MAC will defer to carrier indefinitely as per the
            /// Standard. When disabled, the MAC will abort when the excessive deferral limit is
            /// reached.
            EXCESSDEFER: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u17,
        }), base_address + 0x4);

        /// address: 0x50000008
        /// Back-to-Back Inter-Packet-Gap register.
        pub const IPGT = @intToPtr(*volatile Mmio(32, packed struct {
            /// BACK-TO-BACK INTER-PACKET-GAP.This is a programmable field representing the
            /// nibble time offset of the minimum possible period between the end of any
            /// transmitted packet to the beginning of the next. In Full-Duplex mode, the
            /// register value should be the desired period in nibble times minus 3. In
            /// Half-Duplex mode, the register value should be the desired period in nibble
            /// times minus 6. In Full-Duplex the recommended setting is 0x15 (21d), which
            /// represents the minimum IPG of 960 ns (in 100 Mbps mode) or 9.6 us (in 10 Mbps
            /// mode). In Half-Duplex the recommended setting is 0x12 (18d), which also
            /// represents the minimum IPG of 960 ns (in 100 Mbps mode) or 9.6 us (in 10 Mbps
            /// mode).
            BTOBINTEGAP: u7,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u25,
        }), base_address + 0x8);

        /// address: 0x5000000c
        /// Non Back-to-Back Inter-Packet-Gap register.
        pub const IPGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// NON-BACK-TO-BACK INTER-PACKET-GAP PART2. This is a programmable field
            /// representing the Non-Back-to-Back Inter-Packet-Gap. The recommended value is
            /// 0x12 (18d), which represents the minimum IPG of 960 ns (in 100 Mbps mode) or 9.6
            /// us (in 10 Mbps mode).
            NBTOBINTEGAP2: u7,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u1,
            /// NON-BACK-TO-BACK INTER-PACKET-GAP PART1. This is a programmable field
            /// representing the optional carrierSense window referenced in IEEE 802.3/4.2.3.2.1
            /// 'Carrier Deference'. If carrier is detected during the timing of IPGR1, the MAC
            /// defers to carrier. If, however, carrier becomes active after IPGR1, the MAC
            /// continues timing IPGR2 and transmits, knowingly causing a collision, thus
            /// ensuring fair access to medium. Its range of values is 0x0 to IPGR2. The
            /// recommended value is 0xC (12d)
            NBTOBINTEGAP1: u7,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u17,
        }), base_address + 0xc);

        /// address: 0x50000010
        /// Collision window / Retry register.
        pub const CLRT = @intToPtr(*volatile Mmio(32, packed struct {
            /// RETRANSMISSION MAXIMUM.This is a programmable field specifying the number of
            /// retransmission attempts following a collision before aborting the packet due to
            /// excessive collisions. The Standard specifies the attemptLimit to be 0xF (15d).
            /// See IEEE 802.3/4.2.3.2.5.
            RETRANSMAX: u4,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u4,
            /// COLLISION WINDOW. This is a programmable field representing the slot time or
            /// collision window during which collisions occur in properly configured networks.
            /// The default value of 0x37 (55d) represents a 56 byte window following the
            /// preamble and SFD.
            COLLWIN: u6,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u18,
        }), base_address + 0x10);

        /// address: 0x50000014
        /// Maximum Frame register.
        pub const MAXF = @intToPtr(*volatile Mmio(32, packed struct {
            /// MAXIMUM FRAME LENGTH. This field resets to the value 0x0600, which represents a
            /// maximum receive frame of 1536 octets. An untagged maximum size Ethernet frame is
            /// 1518 octets. A tagged frame adds four octets for a total of 1522 octets. If a
            /// shorter maximum length restriction is desired, program this 16-bit field.
            MAXFLEN: u16,
            /// Unused
            RESERVED: u16,
        }), base_address + 0x14);

        /// address: 0x50000018
        /// PHY Support register.
        pub const SUPP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Unused
            RESERVED: u8,
            /// This bit configures the Reduced MII logic for the current operating speed. When
            /// set, 100 Mbps mode is selected. When cleared, 10 Mbps mode is selected.
            SPEED: u1,
            /// Unused
            RESERVED: u23,
        }), base_address + 0x18);

        /// address: 0x5000001c
        /// Test register.
        pub const TEST = @intToPtr(*volatile Mmio(32, packed struct {
            /// SHORTCUT PAUSE QUANTA. This bit reduces the effective PAUSE quanta from 64
            /// byte-times to 1 byte-time.
            SCPQ: u1,
            /// This bit causes the MAC Control sublayer to inhibit transmissions, just as if a
            /// PAUSE Receive Control frame with a nonzero pause time parameter was received.
            TESTPAUSE: u1,
            /// TEST BACKPRESSURE. Setting this bit will cause the MAC to assert backpressure on
            /// the link. Backpressure causes preamble to be transmitted, raising carrier sense.
            /// A transmit packet from the system will be sent during backpressure.
            TESTBP: u1,
            /// Unused
            RESERVED: u29,
        }), base_address + 0x1c);

        /// address: 0x50000020
        /// MII Mgmt Configuration register.
        pub const MCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCAN INCREMENT. Set this bit to cause the MII Management hardware to perform
            /// read cycles across a range of PHYs. When set, the MII Management hardware will
            /// perform read cycles from address 1 through the value set in PHY ADDRESS[4:0].
            /// Clear this bit to allow continuous reads of the same PHY.
            SCANINC: u1,
            /// SUPPRESS PREAMBLE. Set this bit to cause the MII Management hardware to perform
            /// read/write cycles without the 32-bit preamble field. Clear this bit to cause
            /// normal cycles to be performed. Some PHYs support suppressed preamble.
            SUPPPREAMBLE: u1,
            /// CLOCK SELECT. This field is used by the clock divide logic in creating the MII
            /// Management Clock (MDC) which IEEE 802.3u defines to be no faster than 2.5 MHz.
            /// Some PHYs support clock rates up to 12.5 MHz, however. The AHB bus clock (HCLK)
            /// is divided by the specified amount. Refer to Table 160 below for the definition
            /// of values for this field.
            CLOCKSEL: u4,
            /// Unused
            reserved0: u9,
            /// RESET MII MGMT. This bit resets the MII Management hardware.
            RESETMIIMGMT: u1,
            /// Unused
            reserved1: u16,
        }), base_address + 0x20);

        /// address: 0x50000024
        /// MII Mgmt Command register.
        pub const MCMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit causes the MII Management hardware to perform a single Read cycle. The
            /// Read data is returned in Register MRDD (MII Mgmt Read Data).
            READ: u1,
            /// This bit causes the MII Management hardware to perform Read cycles continuously.
            /// This is useful for monitoring Link Fail for example.
            SCAN: u1,
            /// Unused
            RESERVED: u30,
        }), base_address + 0x24);

        /// address: 0x50000028
        /// MII Mgmt Address register.
        pub const MADR = @intToPtr(*volatile Mmio(32, packed struct {
            /// REGISTER ADDRESS. This field represents the 5-bit Register Address field of Mgmt
            /// cycles. Up to 32 registers can be accessed.
            REGADDR: u5,
            /// Unused
            RESERVED: u3,
            /// PHY ADDRESS. This field represents the 5-bit PHY Address field of Mgmt cycles.
            /// Up to 31 PHYs can be addressed (0 is reserved).
            PHYADDR: u5,
            /// Unused
            RESERVED: u19,
        }), base_address + 0x28);

        /// address: 0x5000002c
        /// MII Mgmt Write Data register.
        pub const MWTD = @intToPtr(*volatile Mmio(32, packed struct {
            /// WRITE DATA. When written, an MII Mgmt write cycle is performed using the 16-bit
            /// data and the pre-configured PHY and Register addresses from the MII Mgmt Address
            /// register (MADR).
            WRITEDATA: u16,
            /// Unused
            RESERVED: u16,
        }), base_address + 0x2c);

        /// address: 0x50000030
        /// MII Mgmt Read Data register.
        pub const MRDD = @intToPtr(*volatile Mmio(32, packed struct {
            /// READ DATA. Following an MII Mgmt Read Cycle, the 16-bit data can be read from
            /// this location.
            READDATA: u16,
            /// Unused
            RESERVED: u16,
        }), base_address + 0x30);

        /// address: 0x50000034
        /// MII Mgmt Indicators register.
        pub const MIND = @intToPtr(*volatile Mmio(32, packed struct {
            /// When 1 is returned - indicates MII Mgmt is currently performing an MII Mgmt Read
            /// or Write cycle.
            BUSY: u1,
            /// When 1 is returned - indicates a scan operation (continuous MII Mgmt Read
            /// cycles) is in progress.
            SCANNING: u1,
            /// When 1 is returned - indicates MII Mgmt Read cycle has not completed and the
            /// Read Data is not yet valid.
            NOTVALID: u1,
            /// When 1 is returned - indicates that an MII Mgmt link fail has occurred.
            MIILINKFAIL: u1,
            /// Unused
            RESERVED: u28,
        }), base_address + 0x34);

        /// address: 0x50000040
        /// Station Address 0 register.
        pub const SA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// STATION ADDRESS, 2nd octet. This field holds the second octet of the station
            /// address.
            SADDR2: u8,
            /// STATION ADDRESS, 1st octet. This field holds the first octet of the station
            /// address.
            SADDR1: u8,
            /// Unused
            RESERVED: u16,
        }), base_address + 0x40);

        /// address: 0x50000044
        /// Station Address 1 register.
        pub const SA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// STATION ADDRESS, 4th octet. This field holds the fourth octet of the station
            /// address.
            SADDR4: u8,
            /// STATION ADDRESS, 3rd octet. This field holds the third octet of the station
            /// address.
            SADDR3: u8,
            /// Unused
            RESERVED: u16,
        }), base_address + 0x44);

        /// address: 0x50000048
        /// Station Address 2 register.
        pub const SA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// STATION ADDRESS, 6th octet. This field holds the sixth octet of the station
            /// address.
            SADDR6: u8,
            /// STATION ADDRESS, 5th octet. This field holds the fifth octet of the station
            /// address.
            SADDR5: u8,
            /// Unused
            RESERVED: u16,
        }), base_address + 0x48);

        /// address: 0x50000100
        /// Command register.
        pub const COMMAND = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable receive.
            RXENABLE: u1,
            /// Enable transmit.
            TXENABLE: u1,
            /// Unused
            RESERVED: u1,
            /// When a 1 is written, all datapaths and the host registers are reset. The MAC
            /// needs to be reset separately.
            REGRESET: u1,
            /// When a 1 is written, the transmit datapath is reset.
            TXRESET: u1,
            /// When a 1 is written, the receive datapath is reset.
            RXRESET: u1,
            /// When set to 1 , passes runt frames s1maller than 64 bytes to memory unless they
            /// have a CRC error. If 0 runt frames are filtered out.
            PASSRUNTFRAME: u1,
            /// When set to 1 , disables receive filtering i.e. all frames received are written
            /// to memory.
            PASSRXFILTER: u1,
            /// Enable IEEE 802.3 / clause 31 flow control sending pause frames in full duplex
            /// and continuous preamble in half duplex.
            TXFLOWCONTROL: u1,
            /// When set to 1 , RMII mode is selected; if 0, MII mode is selected.
            RMII: u1,
            /// When set to 1 , indicates full duplex operation.
            FULLDUPLEX: u1,
            /// Unused
            RESERVED: u21,
        }), base_address + 0x100);

        /// address: 0x50000104
        /// Status register.
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// If 1, the receive channel is active. If 0, the receive channel is inactive.
            RXSTATUS: u1,
            /// If 1, the transmit channel is active. If 0, the transmit channel is inactive.
            TXSTATUS: u1,
            /// Unused
            RESERVED: u30,
        }), base_address + 0x104);

        /// address: 0x50000108
        /// Receive descriptor base address register.
        pub const RXDESCRIPTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fixed to 00
            RESERVED: u2,
            /// MSBs of receive descriptor base address.
            RXDESCRIPTOR: u30,
        }), base_address + 0x108);

        /// address: 0x5000010c
        /// Receive status base address register.
        pub const RXSTATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fixed to 000
            RESERVED: u3,
            /// MSBs of receive status base address.
            RXSTATUS: u29,
        }), base_address + 0x10c);

        /// address: 0x50000110
        /// Receive number of descriptors register.
        pub const RXDESCRIPTORNUMBER = @intToPtr(*volatile Mmio(32, packed struct {
            /// RxDescriptorNumber. Number of descriptors in the descriptor array for which
            /// RxDescriptor is the base address. The number of descriptors is minus one
            /// encoded.
            RXDESCRIPTORN: u16,
            /// Unused
            RESERVED: u16,
        }), base_address + 0x110);

        /// address: 0x50000114
        /// Receive produce index register.
        pub const RXPRODUCEINDEX = @intToPtr(*volatile Mmio(32, packed struct {
            /// Index of the descriptor that is going to be filled next by the receive datapath.
            RXPRODUCEIX: u16,
            /// Unused
            RESERVED: u16,
        }), base_address + 0x114);

        /// address: 0x50000118
        /// Receive consume index register.
        pub const RXCONSUMEINDEX = @intToPtr(*volatile Mmio(32, packed struct {
            /// Index of the descriptor that is going to be processed next by the receive
            RXCONSUMEIX: u16,
            /// Unused
            RESERVED: u16,
        }), base_address + 0x118);

        /// address: 0x5000011c
        /// Transmit descriptor base address register.
        pub const TXDESCRIPTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fixed to 00
            RESERVED: u2,
            /// TxDescriptor. MSBs of transmit descriptor base address.
            TXD: u30,
        }), base_address + 0x11c);

        /// address: 0x50000120
        /// Transmit status base address register.
        pub const TXSTATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fixed to 00
            RESERVED: u2,
            /// TxStatus. MSBs of transmit status base address.
            TXSTAT: u30,
        }), base_address + 0x120);

        /// address: 0x50000124
        /// Transmit number of descriptors register.
        pub const TXDESCRIPTORNUMBER = @intToPtr(*volatile Mmio(32, packed struct {
            /// TxDescriptorNumber. Number of descriptors in the descriptor array for which
            /// TxDescriptor is the base address. The register is minus one encoded.
            TXDN: u16,
            /// Unused
            RESERVED: u16,
        }), base_address + 0x124);

        /// address: 0x50000128
        /// Transmit produce index register.
        pub const TXPRODUCEINDEX = @intToPtr(*volatile Mmio(32, packed struct {
            /// TxProduceIndex. Index of the descriptor that is going to be filled next by the
            /// transmit software driver.
            TXPI: u16,
            /// Unused
            RESERVED: u16,
        }), base_address + 0x128);

        /// address: 0x5000012c
        /// Transmit consume index register.
        pub const TXCONSUMEINDEX = @intToPtr(*volatile Mmio(32, packed struct {
            /// TxConsumeIndex. Index of the descriptor that is going to be transmitted next by
            /// the transmit datapath.
            TXCI: u16,
            /// Unused
            RESERVED: u16,
        }), base_address + 0x12c);

        /// address: 0x50000158
        /// Transmit status vector 0 register.
        pub const TSV0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC error. The attached CRC in the packet did not match the internally generated
            /// CRC.
            CRCERR: u1,
            /// Length check error. Indicates the frame length field does not match the actual
            /// number of data items and is not a type field.
            LCE: u1,
            /// Length out of range. Indicates that frame type/length field was larger than 1500
            /// bytes. The EMAC doesn't distinguish the frame type and frame length, so, e.g.
            /// when the IP(0x8000) or ARP(0x0806) packets are received, it compares the frame
            /// type with the max length and gives the "Length out of range" error. In fact,
            /// this bit is not an error indication, but simply a statement by the chip
            /// regarding the status of the received frame.
            LOR: u1,
            /// Transmission of packet was completed.
            DONE: u1,
            /// Packet's destination was a multicast address.
            MULTICAST: u1,
            /// Packet's destination was a broadcast address.
            BROADCAST: u1,
            /// Packet was deferred for at least one attempt, but less than an excessive defer.
            PACKETDEFER: u1,
            /// Excessive Defer. Packet was deferred in excess of 6071 nibble times in 100 Mbps
            /// or 24287 bit times in 10 Mbps mode.
            EXDF: u1,
            /// Excessive Collision. Packet was aborted due to exceeding of maximum allowed
            /// number of collisions.
            EXCOL: u1,
            /// Late Collision. Collision occurred beyond collision window, 512 bit times.
            LCOL: u1,
            /// Byte count in frame was greater than can be represented in the transmit byte
            /// count field in TSV1.
            GIANT: u1,
            /// Host side caused buffer underrun.
            UNDERRUN: u1,
            /// The total number of bytes transferred including collided attempts.
            TOTALBYTES: u16,
            /// The frame was a control frame.
            CONTROLFRAME: u1,
            /// The frame was a control frame with a valid PAUSE opcode.
            PAUSE: u1,
            /// Carrier-sense method backpressure was previously applied.
            BACKPRESSURE: u1,
            /// Frame's length/type field contained 0x8100 which is the VLAN protocol
            /// identifier.
            VLAN: u1,
        }), base_address + 0x158);

        /// address: 0x5000015c
        /// Transmit status vector 1 register.
        pub const TSV1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit byte count. The total number of bytes in the frame, not counting the
            /// collided bytes.
            TBC: u16,
            /// Transmit collision count. Number of collisions the current packet incurred
            /// during transmission attempts. The maximum number of collisions (16) cannot be
            /// represented.
            TCC: u4,
            /// Unused
            RESERVED: u12,
        }), base_address + 0x15c);

        /// address: 0x50000160
        /// Receive status vector register.
        pub const RSV = @intToPtr(*volatile Mmio(32, packed struct {
            /// Received byte count. Indicates length of received frame.
            RBC: u16,
            /// Packet previously ignored. Indicates that a packet was dropped.
            PPI: u1,
            /// RXDV event previously seen. Indicates that the last receive event seen was not
            /// long enough to be a valid packet.
            RXDVSEEN: u1,
            /// Carrier event previously seen. Indicates that at some time since the last
            /// receive statistics, a carrier event was detected.
            CESEEN: u1,
            /// Receive code violation. Indicates that received PHY data does not represent a
            /// valid receive code.
            RCV: u1,
            /// CRC error. The attached CRC in the packet did not match the internally generated
            /// CRC.
            CRCERR: u1,
            /// Length check error. Indicates the frame length field does not match the actual
            /// number of data items and is not a type field.
            LCERR: u1,
            /// Length out of range. Indicates that frame type/length field was larger than 1518
            /// bytes. The EMAC doesn't distinguish the frame type and frame length, so, e.g.
            /// when the IP(0x8000) or ARP(0x0806) packets are received, it compares the frame
            /// type with the max length and gives the "Length out of range" error. In fact,
            /// this bit is not an error indication, but simply a statement by the chip
            /// regarding the status of the received frame.
            LOR: u1,
            /// Receive OK. The packet had valid CRC and no symbol errors.
            ROK: u1,
            /// The packet destination was a multicast address.
            MULTICAST: u1,
            /// The packet destination was a broadcast address.
            BROADCAST: u1,
            /// Indicates that after the end of packet another 1-7 bits were received. A single
            /// nibble, called dribble nibble, is formed but not sent out.
            DRIBBLENIBBLE: u1,
            /// The frame was a control frame.
            CONTROLFRAME: u1,
            /// The frame was a control frame with a valid PAUSE opcode.
            PAUSE: u1,
            /// Unsupported Opcode. The current frame was recognized as a Control Frame but
            /// contains an unknown opcode.
            UO: u1,
            /// Frame's length/type field contained 0x8100 which is the VLAN protocol
            /// identifier.
            VLAN: u1,
            /// Unused
            RESERVED: u1,
        }), base_address + 0x160);

        /// address: 0x50000170
        /// Flow control counter register.
        pub const FLOWCONTROLCOUNTER = @intToPtr(*volatile Mmio(32, packed struct {
            /// MirrorCounter. In full duplex mode the MirrorCounter specifies the number of
            /// cycles before re-issuing the Pause control frame.
            MC: u16,
            /// PauseTimer. In full-duplex mode the PauseTimer specifies the value that is
            /// inserted into the pause timer field of a pause flow control frame. In half
            /// duplex mode the PauseTimer specifies the number of backpressure cycles.
            PT: u16,
        }), base_address + 0x170);

        /// address: 0x50000174
        /// Flow control status register.
        pub const FLOWCONTROLSTATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// MirrorCounterCurrent. In full duplex mode this register represents the current
            /// value of the datapath's mirror counter which counts up to the value specified by
            /// the MirrorCounter field in the FlowControlCounter register. In half duplex mode
            /// the register counts until it reaches the value of the PauseTimer bits in the
            /// FlowControlCounter register.
            MCC: u16,
            /// Unused
            RESERVED: u16,
        }), base_address + 0x174);

        /// address: 0x50000200
        /// Receive filter control register.
        pub const RXFILTERCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// AcceptUnicastEn. When set to 1, all unicast frames are accepted.
            AUE: u1,
            /// AcceptBroadcastEn. When set to 1, all broadcast frames are accepted.
            ABE: u1,
            /// AcceptMulticastEn. When set to 1, all multicast frames are accepted.
            AME: u1,
            /// AcceptUnicastHashEn. When set to 1, unicast frames that pass the imperfect hash
            /// filter are accepted.
            AUHE: u1,
            /// AcceptMulticastHashEn. When set to 1, multicast frames that pass the imperfect
            /// hash filter are accepted.
            AMHE: u1,
            /// AcceptPerfectEn. When set to 1, the frames with a destination address identical
            /// to the station address are accepted.
            APE: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u6,
            /// MagicPacketEnWoL. When set to 1, the result of the magic packet filter will
            /// generate a WoL interrupt when there is a match.
            MPEW: u1,
            /// RxFilterEnWoL. When set to 1, the result of the perfect address matching filter
            /// and the imperfect hash filter will generate a WoL interrupt when there is a
            /// match.
            RFEW: u1,
            /// Unused
            RESERVED: u18,
        }), base_address + 0x200);

        /// address: 0x50000204
        /// Receive filter WoL status register.
        pub const RXFILTERWOLSTATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// AcceptUnicastWoL. When the value is 1, a unicast frames caused WoL.
            AUW: u1,
            /// AcceptBroadcastWoL. When the value is 1, a broadcast frame caused WoL.
            ABW: u1,
            /// AcceptMulticastWoL. When the value is 1, a multicast frame caused WoL.
            AMW: u1,
            /// AcceptUnicastHashWoL. When the value is 1, a unicast frame that passes the
            /// imperfect hash filter caused WoL.
            AUHW: u1,
            /// AcceptMulticastHashWoL. When the value is 1, a multicast frame that passes the
            /// imperfect hash filter caused WoL.
            AMHW: u1,
            /// AcceptPerfectWoL. When the value is 1, the perfect address matching filter
            /// caused WoL.
            APW: u1,
            /// Unused
            RESERVED: u1,
            /// RxFilterWoL. When the value is 1, the receive filter caused WoL.
            RFW: u1,
            /// MagicPacketWoL. When the value is 1, the magic packet filter caused WoL.
            MPW: u1,
            /// Unused
            RESERVED: u23,
        }), base_address + 0x204);

        /// address: 0x50000208
        /// Receive filter WoL clear register.
        pub const RXFILTERWOLCLEAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// AcceptUnicastWoLClr. When a 1 is written, the corresponding status bit in the
            /// RxFilterWoLStatus register is cleared.
            AUWCLR: u1,
            /// AcceptBroadcastWoLClr. When a 1 is written, the corresponding status bit in the
            /// RxFilterWoLStatus register is cleared.
            ABWCLR: u1,
            /// AcceptMulticastWoLClr. When a 1 is written, the corresponding status bit in the
            /// RxFilterWoLStatus register is cleared.
            AMWCLR: u1,
            /// AcceptUnicastHashWoLClr. When a 1 is written, the corresponding status bit in
            /// the RxFilterWoLStatus register is cleared.
            AUHWCLR: u1,
            /// AcceptMulticastHashWoLClr. When a 1 is written, the corresponding status bit in
            /// the RxFilterWoLStatus register is cleared.
            AMHWCLR: u1,
            /// AcceptPerfectWoLClr. When a 1 is written, the corresponding status bit in the
            /// RxFilterWoLStatus register is cleared.
            APWCLR: u1,
            /// Unused
            RESERVED: u1,
            /// RxFilterWoLClr. When a 1 is written, the corresponding status bit in the
            /// RxFilterWoLStatus register is cleared.
            RFWCLR: u1,
            /// MagicPacketWoLClr. When a 1 is written, the corresponding status bit in the
            /// RxFilterWoLStatus register is cleared.
            MPWCLR: u1,
            /// Unused
            RESERVED: u23,
        }), base_address + 0x208);

        /// address: 0x50000210
        /// Hash filter table LSBs register.
        pub const HASHFILTERL = @intToPtr(*volatile Mmio(32, packed struct {
            /// HashFilterL. Bits 31:0 of the imperfect filter hash table for receive filtering.
            HFL: u32,
        }), base_address + 0x210);

        /// address: 0x50000214
        /// Hash filter table MSBs register.
        pub const HASHFILTERH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bits 63:32 of the imperfect filter hash table for receive filtering.
            HFH: u32,
        }), base_address + 0x214);

        /// address: 0x50000fe0
        /// Interrupt status register.
        pub const INTSTATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt set on a fatal overrun error in the receive queue. The fatal interrupt
            /// should be resolved by a Rx soft-reset. The bit is not set when there is a
            /// nonfatal overrun error.
            RXOVERRUNINT: u1,
            /// Interrupt trigger on receive errors: AlignmentError, RangeError, LengthError,
            /// SymbolError, CRCError or NoDescriptor or Overrun.
            RXERRORINT: u1,
            /// Interrupt triggered when all receive descriptors have been processed i.e. on the
            /// transition to the situation where ProduceIndex == ConsumeIndex.
            RXFINISHEDINT: u1,
            /// Interrupt triggered when a receive descriptor has been processed while the
            /// Interrupt bit in the Control field of the descriptor was set.
            RXDONEINT: u1,
            /// Interrupt set on a fatal underrun error in the transmit queue. The fatal
            /// interrupt should be resolved by a Tx soft-reset. The bit is not set when there
            /// is a nonfatal underrun error.
            TXUNDERRUNINT: u1,
            /// Interrupt trigger on transmit errors: LateCollision, ExcessiveCollision and
            /// ExcessiveDefer, NoDescriptor or Underrun.
            TXERRORINT: u1,
            /// Interrupt triggered when all transmit descriptors have been processed i.e. on
            /// the transition to the situation where ProduceIndex == ConsumeIndex.
            TXFINISHEDINT: u1,
            /// Interrupt triggered when a descriptor has been transmitted while the Interrupt
            /// bit in the Control field of the descriptor was set.
            TXDONEINT: u1,
            /// Unused
            RESERVED: u4,
            /// Interrupt triggered by software writing a 1 to the SoftIntSet bit in the IntSet
            /// register.
            SOFTINT: u1,
            /// Interrupt triggered by a Wake-up event detected by the receive filter.
            WAKEUPINT: u1,
            /// Unused
            RESERVED: u18,
        }), base_address + 0xfe0);

        /// address: 0x50000fe4
        /// Interrupt enable register.
        pub const INTENABLE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable for interrupt trigger on receive buffer overrun or descriptor underrun
            /// situations.
            RXOVERRUNINTEN: u1,
            /// Enable for interrupt trigger on receive errors.
            RXERRORINTEN: u1,
            /// Enable for interrupt triggered when all receive descriptors have been processed
            /// i.e. on the transition to the situation where ProduceIndex == ConsumeIndex.
            RXFINISHEDINTEN: u1,
            /// Enable for interrupt triggered when a receive descriptor has been processed
            /// while the Interrupt bit in the Control field of the descriptor was set.
            RXDONEINTEN: u1,
            /// Enable for interrupt trigger on transmit buffer or descriptor underrun
            /// situations.
            TXUNDERRUNINTEN: u1,
            /// Enable for interrupt trigger on transmit errors.
            TXERRORINTEN: u1,
            /// Enable for interrupt triggered when all transmit descriptors have been processed
            /// i.e. on the transition to the situation where ProduceIndex == ConsumeIndex.
            TXFINISHEDINTEN: u1,
            /// Enable for interrupt triggered when a descriptor has been transmitted while the
            /// Interrupt bit in the Control field of the descriptor was set.
            TXDONEINTEN: u1,
            /// Unused
            RESERVED: u4,
            /// Enable for interrupt triggered by the SoftInt bit in the IntStatus register,
            /// caused by software writing a 1 to the SoftIntSet bit in the IntSet register.
            SOFTINTEN: u1,
            /// Enable for interrupt triggered by a Wake-up event detected by the receive
            /// filter.
            WAKEUPINTEN: u1,
            /// Unused
            RESERVED: u18,
        }), base_address + 0xfe4);

        /// address: 0x50000fe8
        /// Interrupt clear register.
        pub const INTCLEAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a 1 clears the corresponding status bit in interrupt status register
            /// IntStatus.
            RXOVERRUNINTCLR: u1,
            /// Writing a 1 clears the corresponding status bit in interrupt status register
            /// IntStatus.
            RXERRORINTCLR: u1,
            /// Writing a 1 clears the corresponding status bit in interrupt status register
            /// IntStatus.
            RXFINISHEDINTCLR: u1,
            /// Writing a 1 clears the corresponding status bit in interrupt status register
            /// IntStatus.
            RXDONEINTCLR: u1,
            /// Writing a 1 clears the corresponding status bit in interrupt status register
            /// IntStatus.
            TXUNDERRUNINTCLR: u1,
            /// Writing a 1 clears the corresponding status bit in interrupt status register
            /// IntStatus.
            TXERRORINTCLR: u1,
            /// Writing a 1 clears the corresponding status bit in interrupt status register
            /// IntStatus.
            TXFINISHEDINTCLR: u1,
            /// Writing a 1 clears the corresponding status bit in interrupt status register
            /// IntStatus.
            TXDONEINTCLR: u1,
            /// Unused
            RESERVED: u4,
            /// Writing a 1 clears the corresponding status bit in interrupt status register
            /// IntStatus.
            SOFTINTCLR: u1,
            /// Writing a 1 clears the corresponding status bit in interrupt status register
            /// IntStatus.
            WAKEUPINTCLR: u1,
            /// Unused
            RESERVED: u18,
        }), base_address + 0xfe8);

        /// address: 0x50000fec
        /// Interrupt set register.
        pub const INTSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a 1 to one sets the corresponding status bit in interrupt status
            /// register IntStatus.
            RXOVERRUNINTSET: u1,
            /// Writing a 1 to one sets the corresponding status bit in interrupt status
            /// register IntStatus.
            RXERRORINTSET: u1,
            /// Writing a 1 to one sets the corresponding status bit in interrupt status
            /// register IntStatus.
            RXFINISHEDINTSET: u1,
            /// Writing a 1 to one sets the corresponding status bit in interrupt status
            /// register IntStatus.
            RXDONEINTSET: u1,
            /// Writing a 1 to one sets the corresponding status bit in interrupt status
            /// register IntStatus.
            TXUNDERRUNINTSET: u1,
            /// Writing a 1 to one sets the corresponding status bit in interrupt status
            /// register IntStatus.
            TXERRORINTSET: u1,
            /// Writing a 1 to one sets the corresponding status bit in interrupt status
            /// register IntStatus.
            TXFINISHEDINTSET: u1,
            /// Writing a 1 to one sets the corresponding status bit in interrupt status
            /// register IntStatus.
            TXDONEINTSET: u1,
            /// Unused
            RESERVED: u4,
            /// Writing a 1 to one sets the corresponding status bit in interrupt status
            /// register IntStatus.
            SOFTINTSET: u1,
            /// Writing a 1 to one sets the corresponding status bit in interrupt status
            /// register IntStatus.
            WAKEUPINTSET: u1,
            /// Unused
            RESERVED: u18,
        }), base_address + 0xfec);

        /// address: 0x50000ff4
        /// Power-down register.
        pub const POWERDOWN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Unused
            RESERVED: u31,
            /// PowerDownMACAHB. If true, all AHB accesses will return a read/write error,
            /// except accesses to the Power-Down register.
            PD: u1,
        }), base_address + 0xff4);
    };
    /// General purpose DMA controller
    pub const GPDMA = struct {
        pub const base_address = 0x50004000;

        /// address: 0x50004000
        /// DMA Interrupt Status Register
        pub const INTSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Status of DMA channel interrupts after masking. Each bit represents one channel:
            /// 0 - the corresponding channel has no active interrupt request. 1 - the
            /// corresponding channel does have an active interrupt request.
            INTSTAT0: u1,
            /// Status of DMA channel interrupts after masking. Each bit represents one channel:
            /// 0 - the corresponding channel has no active interrupt request. 1 - the
            /// corresponding channel does have an active interrupt request.
            INTSTAT1: u1,
            /// Status of DMA channel interrupts after masking. Each bit represents one channel:
            /// 0 - the corresponding channel has no active interrupt request. 1 - the
            /// corresponding channel does have an active interrupt request.
            INTSTAT2: u1,
            /// Status of DMA channel interrupts after masking. Each bit represents one channel:
            /// 0 - the corresponding channel has no active interrupt request. 1 - the
            /// corresponding channel does have an active interrupt request.
            INTSTAT3: u1,
            /// Status of DMA channel interrupts after masking. Each bit represents one channel:
            /// 0 - the corresponding channel has no active interrupt request. 1 - the
            /// corresponding channel does have an active interrupt request.
            INTSTAT4: u1,
            /// Status of DMA channel interrupts after masking. Each bit represents one channel:
            /// 0 - the corresponding channel has no active interrupt request. 1 - the
            /// corresponding channel does have an active interrupt request.
            INTSTAT5: u1,
            /// Status of DMA channel interrupts after masking. Each bit represents one channel:
            /// 0 - the corresponding channel has no active interrupt request. 1 - the
            /// corresponding channel does have an active interrupt request.
            INTSTAT6: u1,
            /// Status of DMA channel interrupts after masking. Each bit represents one channel:
            /// 0 - the corresponding channel has no active interrupt request. 1 - the
            /// corresponding channel does have an active interrupt request.
            INTSTAT7: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x0);

        /// address: 0x50004004
        /// DMA Interrupt Terminal Count Request Status Register
        pub const INTTCSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Terminal count interrupt request status for DMA channels. Each bit represents
            /// one channel: 0 - the corresponding channel has no active terminal count
            /// interrupt request. 1 - the corresponding channel does have an active terminal
            /// count interrupt request.
            INTTCSTAT0: u1,
            /// Terminal count interrupt request status for DMA channels. Each bit represents
            /// one channel: 0 - the corresponding channel has no active terminal count
            /// interrupt request. 1 - the corresponding channel does have an active terminal
            /// count interrupt request.
            INTTCSTAT1: u1,
            /// Terminal count interrupt request status for DMA channels. Each bit represents
            /// one channel: 0 - the corresponding channel has no active terminal count
            /// interrupt request. 1 - the corresponding channel does have an active terminal
            /// count interrupt request.
            INTTCSTAT2: u1,
            /// Terminal count interrupt request status for DMA channels. Each bit represents
            /// one channel: 0 - the corresponding channel has no active terminal count
            /// interrupt request. 1 - the corresponding channel does have an active terminal
            /// count interrupt request.
            INTTCSTAT3: u1,
            /// Terminal count interrupt request status for DMA channels. Each bit represents
            /// one channel: 0 - the corresponding channel has no active terminal count
            /// interrupt request. 1 - the corresponding channel does have an active terminal
            /// count interrupt request.
            INTTCSTAT4: u1,
            /// Terminal count interrupt request status for DMA channels. Each bit represents
            /// one channel: 0 - the corresponding channel has no active terminal count
            /// interrupt request. 1 - the corresponding channel does have an active terminal
            /// count interrupt request.
            INTTCSTAT5: u1,
            /// Terminal count interrupt request status for DMA channels. Each bit represents
            /// one channel: 0 - the corresponding channel has no active terminal count
            /// interrupt request. 1 - the corresponding channel does have an active terminal
            /// count interrupt request.
            INTTCSTAT6: u1,
            /// Terminal count interrupt request status for DMA channels. Each bit represents
            /// one channel: 0 - the corresponding channel has no active terminal count
            /// interrupt request. 1 - the corresponding channel does have an active terminal
            /// count interrupt request.
            INTTCSTAT7: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x4);

        /// address: 0x50004008
        /// DMA Interrupt Terminal Count Request Clear Register
        pub const INTTCCLEAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Allows clearing the Terminal count interrupt request (IntTCStat) for DMA
            /// channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 -
            /// clears the corresponding channel terminal count interrupt.
            INTTCCLEAR0: u1,
            /// Allows clearing the Terminal count interrupt request (IntTCStat) for DMA
            /// channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 -
            /// clears the corresponding channel terminal count interrupt.
            INTTCCLEAR1: u1,
            /// Allows clearing the Terminal count interrupt request (IntTCStat) for DMA
            /// channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 -
            /// clears the corresponding channel terminal count interrupt.
            INTTCCLEAR2: u1,
            /// Allows clearing the Terminal count interrupt request (IntTCStat) for DMA
            /// channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 -
            /// clears the corresponding channel terminal count interrupt.
            INTTCCLEAR3: u1,
            /// Allows clearing the Terminal count interrupt request (IntTCStat) for DMA
            /// channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 -
            /// clears the corresponding channel terminal count interrupt.
            INTTCCLEAR4: u1,
            /// Allows clearing the Terminal count interrupt request (IntTCStat) for DMA
            /// channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 -
            /// clears the corresponding channel terminal count interrupt.
            INTTCCLEAR5: u1,
            /// Allows clearing the Terminal count interrupt request (IntTCStat) for DMA
            /// channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 -
            /// clears the corresponding channel terminal count interrupt.
            INTTCCLEAR6: u1,
            /// Allows clearing the Terminal count interrupt request (IntTCStat) for DMA
            /// channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 -
            /// clears the corresponding channel terminal count interrupt.
            INTTCCLEAR7: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x8);

        /// address: 0x5000400c
        /// DMA Interrupt Error Status Register
        pub const INTERRSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt error status for DMA channels. Each bit represents one channel: 0 -
            /// the corresponding channel has no active error interrupt request. 1 - the
            /// corresponding channel does have an active error interrupt request.
            INTERRSTAT0: u1,
            /// Interrupt error status for DMA channels. Each bit represents one channel: 0 -
            /// the corresponding channel has no active error interrupt request. 1 - the
            /// corresponding channel does have an active error interrupt request.
            INTERRSTAT1: u1,
            /// Interrupt error status for DMA channels. Each bit represents one channel: 0 -
            /// the corresponding channel has no active error interrupt request. 1 - the
            /// corresponding channel does have an active error interrupt request.
            INTERRSTAT2: u1,
            /// Interrupt error status for DMA channels. Each bit represents one channel: 0 -
            /// the corresponding channel has no active error interrupt request. 1 - the
            /// corresponding channel does have an active error interrupt request.
            INTERRSTAT3: u1,
            /// Interrupt error status for DMA channels. Each bit represents one channel: 0 -
            /// the corresponding channel has no active error interrupt request. 1 - the
            /// corresponding channel does have an active error interrupt request.
            INTERRSTAT4: u1,
            /// Interrupt error status for DMA channels. Each bit represents one channel: 0 -
            /// the corresponding channel has no active error interrupt request. 1 - the
            /// corresponding channel does have an active error interrupt request.
            INTERRSTAT5: u1,
            /// Interrupt error status for DMA channels. Each bit represents one channel: 0 -
            /// the corresponding channel has no active error interrupt request. 1 - the
            /// corresponding channel does have an active error interrupt request.
            INTERRSTAT6: u1,
            /// Interrupt error status for DMA channels. Each bit represents one channel: 0 -
            /// the corresponding channel has no active error interrupt request. 1 - the
            /// corresponding channel does have an active error interrupt request.
            INTERRSTAT7: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0xc);

        /// address: 0x50004010
        /// DMA Interrupt Error Clear Register
        pub const INTERRCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Writing a 1 clears the error interrupt request (IntErrStat) for DMA channels.
            /// Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the
            /// corresponding channel error interrupt.
            INTERRCLR0: u1,
            /// Writing a 1 clears the error interrupt request (IntErrStat) for DMA channels.
            /// Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the
            /// corresponding channel error interrupt.
            INTERRCLR1: u1,
            /// Writing a 1 clears the error interrupt request (IntErrStat) for DMA channels.
            /// Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the
            /// corresponding channel error interrupt.
            INTERRCLR2: u1,
            /// Writing a 1 clears the error interrupt request (IntErrStat) for DMA channels.
            /// Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the
            /// corresponding channel error interrupt.
            INTERRCLR3: u1,
            /// Writing a 1 clears the error interrupt request (IntErrStat) for DMA channels.
            /// Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the
            /// corresponding channel error interrupt.
            INTERRCLR4: u1,
            /// Writing a 1 clears the error interrupt request (IntErrStat) for DMA channels.
            /// Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the
            /// corresponding channel error interrupt.
            INTERRCLR5: u1,
            /// Writing a 1 clears the error interrupt request (IntErrStat) for DMA channels.
            /// Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the
            /// corresponding channel error interrupt.
            INTERRCLR6: u1,
            /// Writing a 1 clears the error interrupt request (IntErrStat) for DMA channels.
            /// Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the
            /// corresponding channel error interrupt.
            INTERRCLR7: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x10);

        /// address: 0x50004014
        /// DMA Raw Interrupt Terminal Count Status Register
        pub const RAWINTTCSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Status of the terminal count interrupt for DMA channels prior to masking. Each
            /// bit represents one channel: 0 - the corresponding channel has no active terminal
            /// count interrupt request. 1 - the corresponding channel does have an active
            /// terminal count interrupt request.
            RAWINTTCSTAT0: u1,
            /// Status of the terminal count interrupt for DMA channels prior to masking. Each
            /// bit represents one channel: 0 - the corresponding channel has no active terminal
            /// count interrupt request. 1 - the corresponding channel does have an active
            /// terminal count interrupt request.
            RAWINTTCSTAT1: u1,
            /// Status of the terminal count interrupt for DMA channels prior to masking. Each
            /// bit represents one channel: 0 - the corresponding channel has no active terminal
            /// count interrupt request. 1 - the corresponding channel does have an active
            /// terminal count interrupt request.
            RAWINTTCSTAT2: u1,
            /// Status of the terminal count interrupt for DMA channels prior to masking. Each
            /// bit represents one channel: 0 - the corresponding channel has no active terminal
            /// count interrupt request. 1 - the corresponding channel does have an active
            /// terminal count interrupt request.
            RAWINTTCSTAT3: u1,
            /// Status of the terminal count interrupt for DMA channels prior to masking. Each
            /// bit represents one channel: 0 - the corresponding channel has no active terminal
            /// count interrupt request. 1 - the corresponding channel does have an active
            /// terminal count interrupt request.
            RAWINTTCSTAT4: u1,
            /// Status of the terminal count interrupt for DMA channels prior to masking. Each
            /// bit represents one channel: 0 - the corresponding channel has no active terminal
            /// count interrupt request. 1 - the corresponding channel does have an active
            /// terminal count interrupt request.
            RAWINTTCSTAT5: u1,
            /// Status of the terminal count interrupt for DMA channels prior to masking. Each
            /// bit represents one channel: 0 - the corresponding channel has no active terminal
            /// count interrupt request. 1 - the corresponding channel does have an active
            /// terminal count interrupt request.
            RAWINTTCSTAT6: u1,
            /// Status of the terminal count interrupt for DMA channels prior to masking. Each
            /// bit represents one channel: 0 - the corresponding channel has no active terminal
            /// count interrupt request. 1 - the corresponding channel does have an active
            /// terminal count interrupt request.
            RAWINTTCSTAT7: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x14);

        /// address: 0x50004018
        /// DMA Raw Error Interrupt Status Register
        pub const RAWINTERRSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Status of the error interrupt for DMA channels prior to masking. Each bit
            /// represents one channel: 0 - the corresponding channel has no active error
            /// interrupt request. 1 - the corresponding channel does have an active error
            /// interrupt request.
            RAWINTERRSTAT0: u1,
            /// Status of the error interrupt for DMA channels prior to masking. Each bit
            /// represents one channel: 0 - the corresponding channel has no active error
            /// interrupt request. 1 - the corresponding channel does have an active error
            /// interrupt request.
            RAWINTERRSTAT1: u1,
            /// Status of the error interrupt for DMA channels prior to masking. Each bit
            /// represents one channel: 0 - the corresponding channel has no active error
            /// interrupt request. 1 - the corresponding channel does have an active error
            /// interrupt request.
            RAWINTERRSTAT2: u1,
            /// Status of the error interrupt for DMA channels prior to masking. Each bit
            /// represents one channel: 0 - the corresponding channel has no active error
            /// interrupt request. 1 - the corresponding channel does have an active error
            /// interrupt request.
            RAWINTERRSTAT3: u1,
            /// Status of the error interrupt for DMA channels prior to masking. Each bit
            /// represents one channel: 0 - the corresponding channel has no active error
            /// interrupt request. 1 - the corresponding channel does have an active error
            /// interrupt request.
            RAWINTERRSTAT4: u1,
            /// Status of the error interrupt for DMA channels prior to masking. Each bit
            /// represents one channel: 0 - the corresponding channel has no active error
            /// interrupt request. 1 - the corresponding channel does have an active error
            /// interrupt request.
            RAWINTERRSTAT5: u1,
            /// Status of the error interrupt for DMA channels prior to masking. Each bit
            /// represents one channel: 0 - the corresponding channel has no active error
            /// interrupt request. 1 - the corresponding channel does have an active error
            /// interrupt request.
            RAWINTERRSTAT6: u1,
            /// Status of the error interrupt for DMA channels prior to masking. Each bit
            /// represents one channel: 0 - the corresponding channel has no active error
            /// interrupt request. 1 - the corresponding channel does have an active error
            /// interrupt request.
            RAWINTERRSTAT7: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x18);

        /// address: 0x5000401c
        /// DMA Enabled Channel Register
        pub const ENBLDCHNS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable status for DMA channels. Each bit represents one channel: 0 - DMA channel
            /// is disabled. 1 - DMA channel is enabled.
            ENABLEDCHANNELS0: u1,
            /// Enable status for DMA channels. Each bit represents one channel: 0 - DMA channel
            /// is disabled. 1 - DMA channel is enabled.
            ENABLEDCHANNELS1: u1,
            /// Enable status for DMA channels. Each bit represents one channel: 0 - DMA channel
            /// is disabled. 1 - DMA channel is enabled.
            ENABLEDCHANNELS2: u1,
            /// Enable status for DMA channels. Each bit represents one channel: 0 - DMA channel
            /// is disabled. 1 - DMA channel is enabled.
            ENABLEDCHANNELS3: u1,
            /// Enable status for DMA channels. Each bit represents one channel: 0 - DMA channel
            /// is disabled. 1 - DMA channel is enabled.
            ENABLEDCHANNELS4: u1,
            /// Enable status for DMA channels. Each bit represents one channel: 0 - DMA channel
            /// is disabled. 1 - DMA channel is enabled.
            ENABLEDCHANNELS5: u1,
            /// Enable status for DMA channels. Each bit represents one channel: 0 - DMA channel
            /// is disabled. 1 - DMA channel is enabled.
            ENABLEDCHANNELS6: u1,
            /// Enable status for DMA channels. Each bit represents one channel: 0 - DMA channel
            /// is disabled. 1 - DMA channel is enabled.
            ENABLEDCHANNELS7: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x1c);

        /// address: 0x50004020
        /// DMA Software Burst Request Register
        pub const SOFTBREQ = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral Description (refer to Table 672
            /// for peripheral hardware connections to the DMA controller): 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA burst request for the corresponding
            /// request line.
            SOFTBREQ0: u1,
            /// Software burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral Description (refer to Table 672
            /// for peripheral hardware connections to the DMA controller): 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA burst request for the corresponding
            /// request line.
            SOFTBREQ1: u1,
            /// Software burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral Description (refer to Table 672
            /// for peripheral hardware connections to the DMA controller): 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA burst request for the corresponding
            /// request line.
            SOFTBREQ2: u1,
            /// Software burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral Description (refer to Table 672
            /// for peripheral hardware connections to the DMA controller): 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA burst request for the corresponding
            /// request line.
            SOFTBREQ3: u1,
            /// Software burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral Description (refer to Table 672
            /// for peripheral hardware connections to the DMA controller): 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA burst request for the corresponding
            /// request line.
            SOFTBREQ4: u1,
            /// Software burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral Description (refer to Table 672
            /// for peripheral hardware connections to the DMA controller): 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA burst request for the corresponding
            /// request line.
            SOFTBREQ5: u1,
            /// Software burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral Description (refer to Table 672
            /// for peripheral hardware connections to the DMA controller): 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA burst request for the corresponding
            /// request line.
            SOFTBREQ6: u1,
            /// Software burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral Description (refer to Table 672
            /// for peripheral hardware connections to the DMA controller): 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA burst request for the corresponding
            /// request line.
            SOFTBREQ7: u1,
            /// Software burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral Description (refer to Table 672
            /// for peripheral hardware connections to the DMA controller): 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA burst request for the corresponding
            /// request line.
            SOFTBREQ8: u1,
            /// Software burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral Description (refer to Table 672
            /// for peripheral hardware connections to the DMA controller): 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA burst request for the corresponding
            /// request line.
            SOFTBREQ9: u1,
            /// Software burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral Description (refer to Table 672
            /// for peripheral hardware connections to the DMA controller): 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA burst request for the corresponding
            /// request line.
            SOFTBREQ10: u1,
            /// Software burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral Description (refer to Table 672
            /// for peripheral hardware connections to the DMA controller): 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA burst request for the corresponding
            /// request line.
            SOFTBREQ11: u1,
            /// Software burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral Description (refer to Table 672
            /// for peripheral hardware connections to the DMA controller): 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA burst request for the corresponding
            /// request line.
            SOFTBREQ12: u1,
            /// Software burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral Description (refer to Table 672
            /// for peripheral hardware connections to the DMA controller): 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA burst request for the corresponding
            /// request line.
            SOFTBREQ13: u1,
            /// Software burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral Description (refer to Table 672
            /// for peripheral hardware connections to the DMA controller): 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA burst request for the corresponding
            /// request line.
            SOFTBREQ14: u1,
            /// Software burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral Description (refer to Table 672
            /// for peripheral hardware connections to the DMA controller): 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA burst request for the corresponding
            /// request line.
            SOFTBREQ15: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u16,
        }), base_address + 0x20);

        /// address: 0x50004024
        /// DMA Software Single Request Register
        pub const SOFTSREQ = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software single transfer request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA single transfer request for the
            /// corresponding request line.
            SOFTSREQ0: u1,
            /// Software single transfer request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA single transfer request for the
            /// corresponding request line.
            SOFTSREQ1: u1,
            /// Software single transfer request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA single transfer request for the
            /// corresponding request line.
            SOFTSREQ2: u1,
            /// Software single transfer request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA single transfer request for the
            /// corresponding request line.
            SOFTSREQ3: u1,
            /// Software single transfer request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA single transfer request for the
            /// corresponding request line.
            SOFTSREQ4: u1,
            /// Software single transfer request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA single transfer request for the
            /// corresponding request line.
            SOFTSREQ5: u1,
            /// Software single transfer request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA single transfer request for the
            /// corresponding request line.
            SOFTSREQ6: u1,
            /// Software single transfer request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA single transfer request for the
            /// corresponding request line.
            SOFTSREQ7: u1,
            /// Software single transfer request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA single transfer request for the
            /// corresponding request line.
            SOFTSREQ8: u1,
            /// Software single transfer request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA single transfer request for the
            /// corresponding request line.
            SOFTSREQ9: u1,
            /// Software single transfer request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA single transfer request for the
            /// corresponding request line.
            SOFTSREQ10: u1,
            /// Software single transfer request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA single transfer request for the
            /// corresponding request line.
            SOFTSREQ11: u1,
            /// Software single transfer request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA single transfer request for the
            /// corresponding request line.
            SOFTSREQ12: u1,
            /// Software single transfer request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA single transfer request for the
            /// corresponding request line.
            SOFTSREQ13: u1,
            /// Software single transfer request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA single transfer request for the
            /// corresponding request line.
            SOFTSREQ14: u1,
            /// Software single transfer request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA single transfer request for the
            /// corresponding request line.
            SOFTSREQ15: u1,
            /// Reserved. Read undefined. Write reserved bits as zero.
            RESERVED: u16,
        }), base_address + 0x24);

        /// address: 0x50004028
        /// DMA Software Last Burst Request Register
        pub const SOFTLBREQ = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software last burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA last burst request for the corresponding
            /// request line.
            SOFTLBREQ0: u1,
            /// Software last burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA last burst request for the corresponding
            /// request line.
            SOFTLBREQ1: u1,
            /// Software last burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA last burst request for the corresponding
            /// request line.
            SOFTLBREQ2: u1,
            /// Software last burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA last burst request for the corresponding
            /// request line.
            SOFTLBREQ3: u1,
            /// Software last burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA last burst request for the corresponding
            /// request line.
            SOFTLBREQ4: u1,
            /// Software last burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA last burst request for the corresponding
            /// request line.
            SOFTLBREQ5: u1,
            /// Software last burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA last burst request for the corresponding
            /// request line.
            SOFTLBREQ6: u1,
            /// Software last burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA last burst request for the corresponding
            /// request line.
            SOFTLBREQ7: u1,
            /// Software last burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA last burst request for the corresponding
            /// request line.
            SOFTLBREQ8: u1,
            /// Software last burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA last burst request for the corresponding
            /// request line.
            SOFTLBREQ9: u1,
            /// Software last burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA last burst request for the corresponding
            /// request line.
            SOFTLBREQ10: u1,
            /// Software last burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA last burst request for the corresponding
            /// request line.
            SOFTLBREQ11: u1,
            /// Software last burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA last burst request for the corresponding
            /// request line.
            SOFTLBREQ12: u1,
            /// Software last burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA last burst request for the corresponding
            /// request line.
            SOFTLBREQ13: u1,
            /// Software last burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA last burst request for the corresponding
            /// request line.
            SOFTLBREQ14: u1,
            /// Software last burst request flags for each of 16 possible sources. Each bit
            /// represents one DMA request line or peripheral function: 0 - writing 0 has no
            /// effect. 1 - writing 1 generates a DMA last burst request for the corresponding
            /// request line.
            SOFTLBREQ15: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u16,
        }), base_address + 0x28);

        /// address: 0x5000402c
        /// DMA Software Last Single Request Register
        pub const SOFTLSREQ = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software last single transfer request flags for each of 16 possible sources.
            /// Each bit represents one DMA request line or peripheral function: 0 - writing 0
            /// has no effect. 1 - writing 1 generates a DMA last single transfer request for
            /// the corresponding request line.
            SOFTLSREQ0: u1,
            /// Software last single transfer request flags for each of 16 possible sources.
            /// Each bit represents one DMA request line or peripheral function: 0 - writing 0
            /// has no effect. 1 - writing 1 generates a DMA last single transfer request for
            /// the corresponding request line.
            SOFTLSREQ1: u1,
            /// Software last single transfer request flags for each of 16 possible sources.
            /// Each bit represents one DMA request line or peripheral function: 0 - writing 0
            /// has no effect. 1 - writing 1 generates a DMA last single transfer request for
            /// the corresponding request line.
            SOFTLSREQ2: u1,
            /// Software last single transfer request flags for each of 16 possible sources.
            /// Each bit represents one DMA request line or peripheral function: 0 - writing 0
            /// has no effect. 1 - writing 1 generates a DMA last single transfer request for
            /// the corresponding request line.
            SOFTLSREQ3: u1,
            /// Software last single transfer request flags for each of 16 possible sources.
            /// Each bit represents one DMA request line or peripheral function: 0 - writing 0
            /// has no effect. 1 - writing 1 generates a DMA last single transfer request for
            /// the corresponding request line.
            SOFTLSREQ4: u1,
            /// Software last single transfer request flags for each of 16 possible sources.
            /// Each bit represents one DMA request line or peripheral function: 0 - writing 0
            /// has no effect. 1 - writing 1 generates a DMA last single transfer request for
            /// the corresponding request line.
            SOFTLSREQ5: u1,
            /// Software last single transfer request flags for each of 16 possible sources.
            /// Each bit represents one DMA request line or peripheral function: 0 - writing 0
            /// has no effect. 1 - writing 1 generates a DMA last single transfer request for
            /// the corresponding request line.
            SOFTLSREQ6: u1,
            /// Software last single transfer request flags for each of 16 possible sources.
            /// Each bit represents one DMA request line or peripheral function: 0 - writing 0
            /// has no effect. 1 - writing 1 generates a DMA last single transfer request for
            /// the corresponding request line.
            SOFTLSREQ7: u1,
            /// Software last single transfer request flags for each of 16 possible sources.
            /// Each bit represents one DMA request line or peripheral function: 0 - writing 0
            /// has no effect. 1 - writing 1 generates a DMA last single transfer request for
            /// the corresponding request line.
            SOFTLSREQ8: u1,
            /// Software last single transfer request flags for each of 16 possible sources.
            /// Each bit represents one DMA request line or peripheral function: 0 - writing 0
            /// has no effect. 1 - writing 1 generates a DMA last single transfer request for
            /// the corresponding request line.
            SOFTLSREQ9: u1,
            /// Software last single transfer request flags for each of 16 possible sources.
            /// Each bit represents one DMA request line or peripheral function: 0 - writing 0
            /// has no effect. 1 - writing 1 generates a DMA last single transfer request for
            /// the corresponding request line.
            SOFTLSREQ10: u1,
            /// Software last single transfer request flags for each of 16 possible sources.
            /// Each bit represents one DMA request line or peripheral function: 0 - writing 0
            /// has no effect. 1 - writing 1 generates a DMA last single transfer request for
            /// the corresponding request line.
            SOFTLSREQ11: u1,
            /// Software last single transfer request flags for each of 16 possible sources.
            /// Each bit represents one DMA request line or peripheral function: 0 - writing 0
            /// has no effect. 1 - writing 1 generates a DMA last single transfer request for
            /// the corresponding request line.
            SOFTLSREQ12: u1,
            /// Software last single transfer request flags for each of 16 possible sources.
            /// Each bit represents one DMA request line or peripheral function: 0 - writing 0
            /// has no effect. 1 - writing 1 generates a DMA last single transfer request for
            /// the corresponding request line.
            SOFTLSREQ13: u1,
            /// Software last single transfer request flags for each of 16 possible sources.
            /// Each bit represents one DMA request line or peripheral function: 0 - writing 0
            /// has no effect. 1 - writing 1 generates a DMA last single transfer request for
            /// the corresponding request line.
            SOFTLSREQ14: u1,
            /// Software last single transfer request flags for each of 16 possible sources.
            /// Each bit represents one DMA request line or peripheral function: 0 - writing 0
            /// has no effect. 1 - writing 1 generates a DMA last single transfer request for
            /// the corresponding request line.
            SOFTLSREQ15: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u16,
        }), base_address + 0x2c);

        /// address: 0x50004030
        /// DMA Configuration Register
        pub const CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Controller enable: 0 = disabled (default). Disabling the DMA Controller
            /// reduces power consumption. 1 = enabled.
            E: u1,
            /// AHB Master endianness configuration: 0 = little-endian mode (default). 1 =
            /// big-endian mode.
            M: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u30,
        }), base_address + 0x30);

        /// address: 0x50004034
        /// DMA Synchronization Register
        pub const SYNC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Controls the synchronization logic for DMA request signals. Each bit represents
            /// one set of DMA request lines as described in the preceding text: 0 -
            /// synchronization logic for the corresponding DMA request signals are enabled. 1 -
            /// synchronization logic for the corresponding DMA request signals are disabled.
            DMACSYNC0: u1,
            /// Controls the synchronization logic for DMA request signals. Each bit represents
            /// one set of DMA request lines as described in the preceding text: 0 -
            /// synchronization logic for the corresponding DMA request signals are enabled. 1 -
            /// synchronization logic for the corresponding DMA request signals are disabled.
            DMACSYNC1: u1,
            /// Controls the synchronization logic for DMA request signals. Each bit represents
            /// one set of DMA request lines as described in the preceding text: 0 -
            /// synchronization logic for the corresponding DMA request signals are enabled. 1 -
            /// synchronization logic for the corresponding DMA request signals are disabled.
            DMACSYNC2: u1,
            /// Controls the synchronization logic for DMA request signals. Each bit represents
            /// one set of DMA request lines as described in the preceding text: 0 -
            /// synchronization logic for the corresponding DMA request signals are enabled. 1 -
            /// synchronization logic for the corresponding DMA request signals are disabled.
            DMACSYNC3: u1,
            /// Controls the synchronization logic for DMA request signals. Each bit represents
            /// one set of DMA request lines as described in the preceding text: 0 -
            /// synchronization logic for the corresponding DMA request signals are enabled. 1 -
            /// synchronization logic for the corresponding DMA request signals are disabled.
            DMACSYNC4: u1,
            /// Controls the synchronization logic for DMA request signals. Each bit represents
            /// one set of DMA request lines as described in the preceding text: 0 -
            /// synchronization logic for the corresponding DMA request signals are enabled. 1 -
            /// synchronization logic for the corresponding DMA request signals are disabled.
            DMACSYNC5: u1,
            /// Controls the synchronization logic for DMA request signals. Each bit represents
            /// one set of DMA request lines as described in the preceding text: 0 -
            /// synchronization logic for the corresponding DMA request signals are enabled. 1 -
            /// synchronization logic for the corresponding DMA request signals are disabled.
            DMACSYNC6: u1,
            /// Controls the synchronization logic for DMA request signals. Each bit represents
            /// one set of DMA request lines as described in the preceding text: 0 -
            /// synchronization logic for the corresponding DMA request signals are enabled. 1 -
            /// synchronization logic for the corresponding DMA request signals are disabled.
            DMACSYNC7: u1,
            /// Controls the synchronization logic for DMA request signals. Each bit represents
            /// one set of DMA request lines as described in the preceding text: 0 -
            /// synchronization logic for the corresponding DMA request signals are enabled. 1 -
            /// synchronization logic for the corresponding DMA request signals are disabled.
            DMACSYNC8: u1,
            /// Controls the synchronization logic for DMA request signals. Each bit represents
            /// one set of DMA request lines as described in the preceding text: 0 -
            /// synchronization logic for the corresponding DMA request signals are enabled. 1 -
            /// synchronization logic for the corresponding DMA request signals are disabled.
            DMACSYNC9: u1,
            /// Controls the synchronization logic for DMA request signals. Each bit represents
            /// one set of DMA request lines as described in the preceding text: 0 -
            /// synchronization logic for the corresponding DMA request signals are enabled. 1 -
            /// synchronization logic for the corresponding DMA request signals are disabled.
            DMACSYNC10: u1,
            /// Controls the synchronization logic for DMA request signals. Each bit represents
            /// one set of DMA request lines as described in the preceding text: 0 -
            /// synchronization logic for the corresponding DMA request signals are enabled. 1 -
            /// synchronization logic for the corresponding DMA request signals are disabled.
            DMACSYNC11: u1,
            /// Controls the synchronization logic for DMA request signals. Each bit represents
            /// one set of DMA request lines as described in the preceding text: 0 -
            /// synchronization logic for the corresponding DMA request signals are enabled. 1 -
            /// synchronization logic for the corresponding DMA request signals are disabled.
            DMACSYNC12: u1,
            /// Controls the synchronization logic for DMA request signals. Each bit represents
            /// one set of DMA request lines as described in the preceding text: 0 -
            /// synchronization logic for the corresponding DMA request signals are enabled. 1 -
            /// synchronization logic for the corresponding DMA request signals are disabled.
            DMACSYNC13: u1,
            /// Controls the synchronization logic for DMA request signals. Each bit represents
            /// one set of DMA request lines as described in the preceding text: 0 -
            /// synchronization logic for the corresponding DMA request signals are enabled. 1 -
            /// synchronization logic for the corresponding DMA request signals are disabled.
            DMACSYNC14: u1,
            /// Controls the synchronization logic for DMA request signals. Each bit represents
            /// one set of DMA request lines as described in the preceding text: 0 -
            /// synchronization logic for the corresponding DMA request signals are enabled. 1 -
            /// synchronization logic for the corresponding DMA request signals are disabled.
            DMACSYNC15: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u16,
        }), base_address + 0x34);

        /// address: 0x50004100
        /// DMA Channel 0 Source Address Register
        pub const SRCADDR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA source address. Reading this register will return the current source
            /// address.
            SRCADDR: u32,
        }), base_address + 0x100);

        /// address: 0x50004120
        /// DMA Channel 0 Source Address Register
        pub const SRCADDR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA source address. Reading this register will return the current source
            /// address.
            SRCADDR: u32,
        }), base_address + 0x120);

        /// address: 0x50004140
        /// DMA Channel 0 Source Address Register
        pub const SRCADDR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA source address. Reading this register will return the current source
            /// address.
            SRCADDR: u32,
        }), base_address + 0x140);

        /// address: 0x50004160
        /// DMA Channel 0 Source Address Register
        pub const SRCADDR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA source address. Reading this register will return the current source
            /// address.
            SRCADDR: u32,
        }), base_address + 0x160);

        /// address: 0x50004180
        /// DMA Channel 0 Source Address Register
        pub const SRCADDR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA source address. Reading this register will return the current source
            /// address.
            SRCADDR: u32,
        }), base_address + 0x180);

        /// address: 0x500041a0
        /// DMA Channel 0 Source Address Register
        pub const SRCADDR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA source address. Reading this register will return the current source
            /// address.
            SRCADDR: u32,
        }), base_address + 0x1a0);

        /// address: 0x500041c0
        /// DMA Channel 0 Source Address Register
        pub const SRCADDR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA source address. Reading this register will return the current source
            /// address.
            SRCADDR: u32,
        }), base_address + 0x1c0);

        /// address: 0x500041e0
        /// DMA Channel 0 Source Address Register
        pub const SRCADDR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA source address. Reading this register will return the current source
            /// address.
            SRCADDR: u32,
        }), base_address + 0x1e0);

        /// address: 0x50004104
        /// DMA Channel 0 Destination Address Register
        pub const DESTADDR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Destination address. Reading this register will return the current
            /// destination address.
            DESTADDR: u32,
        }), base_address + 0x104);

        /// address: 0x50004124
        /// DMA Channel 0 Destination Address Register
        pub const DESTADDR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Destination address. Reading this register will return the current
            /// destination address.
            DESTADDR: u32,
        }), base_address + 0x124);

        /// address: 0x50004144
        /// DMA Channel 0 Destination Address Register
        pub const DESTADDR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Destination address. Reading this register will return the current
            /// destination address.
            DESTADDR: u32,
        }), base_address + 0x144);

        /// address: 0x50004164
        /// DMA Channel 0 Destination Address Register
        pub const DESTADDR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Destination address. Reading this register will return the current
            /// destination address.
            DESTADDR: u32,
        }), base_address + 0x164);

        /// address: 0x50004184
        /// DMA Channel 0 Destination Address Register
        pub const DESTADDR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Destination address. Reading this register will return the current
            /// destination address.
            DESTADDR: u32,
        }), base_address + 0x184);

        /// address: 0x500041a4
        /// DMA Channel 0 Destination Address Register
        pub const DESTADDR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Destination address. Reading this register will return the current
            /// destination address.
            DESTADDR: u32,
        }), base_address + 0x1a4);

        /// address: 0x500041c4
        /// DMA Channel 0 Destination Address Register
        pub const DESTADDR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Destination address. Reading this register will return the current
            /// destination address.
            DESTADDR: u32,
        }), base_address + 0x1c4);

        /// address: 0x500041e4
        /// DMA Channel 0 Destination Address Register
        pub const DESTADDR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Destination address. Reading this register will return the current
            /// destination address.
            DESTADDR: u32,
        }), base_address + 0x1e4);

        /// address: 0x50004108
        /// DMA Channel 0 Linked List Item Register
        pub const LLI0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved, and must be written as 0.
            RESERVED: u2,
            /// Linked list item. Bits [31:2] of the address for the next LLI. Address bits
            /// [1:0] are 0.
            LLI: u30,
        }), base_address + 0x108);

        /// address: 0x50004128
        /// DMA Channel 0 Linked List Item Register
        pub const LLI1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved, and must be written as 0.
            RESERVED: u2,
            /// Linked list item. Bits [31:2] of the address for the next LLI. Address bits
            /// [1:0] are 0.
            LLI: u30,
        }), base_address + 0x128);

        /// address: 0x50004148
        /// DMA Channel 0 Linked List Item Register
        pub const LLI2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved, and must be written as 0.
            RESERVED: u2,
            /// Linked list item. Bits [31:2] of the address for the next LLI. Address bits
            /// [1:0] are 0.
            LLI: u30,
        }), base_address + 0x148);

        /// address: 0x50004168
        /// DMA Channel 0 Linked List Item Register
        pub const LLI3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved, and must be written as 0.
            RESERVED: u2,
            /// Linked list item. Bits [31:2] of the address for the next LLI. Address bits
            /// [1:0] are 0.
            LLI: u30,
        }), base_address + 0x168);

        /// address: 0x50004188
        /// DMA Channel 0 Linked List Item Register
        pub const LLI4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved, and must be written as 0.
            RESERVED: u2,
            /// Linked list item. Bits [31:2] of the address for the next LLI. Address bits
            /// [1:0] are 0.
            LLI: u30,
        }), base_address + 0x188);

        /// address: 0x500041a8
        /// DMA Channel 0 Linked List Item Register
        pub const LLI5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved, and must be written as 0.
            RESERVED: u2,
            /// Linked list item. Bits [31:2] of the address for the next LLI. Address bits
            /// [1:0] are 0.
            LLI: u30,
        }), base_address + 0x1a8);

        /// address: 0x500041c8
        /// DMA Channel 0 Linked List Item Register
        pub const LLI6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved, and must be written as 0.
            RESERVED: u2,
            /// Linked list item. Bits [31:2] of the address for the next LLI. Address bits
            /// [1:0] are 0.
            LLI: u30,
        }), base_address + 0x1c8);

        /// address: 0x500041e8
        /// DMA Channel 0 Linked List Item Register
        pub const LLI7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved, and must be written as 0.
            RESERVED: u2,
            /// Linked list item. Bits [31:2] of the address for the next LLI. Address bits
            /// [1:0] are 0.
            LLI: u30,
        }), base_address + 0x1e8);

        /// address: 0x5000410c
        /// DMA Channel 0 Control Register
        pub const CONTROL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size. This field sets the size of the transfer when the DMA controller
            /// is the flow controller, in which case the value must be set before the channel
            /// is enabled. Transfer size is updated as data transfers are completed. A read
            /// from this field indicates the number of transfers completed on the destination
            /// bus. Reading the register when the channel is active does not give useful
            /// information because by the time that the software has processed the value read,
            /// the channel might have progressed. It is intended to be used only when a channel
            /// is enabled and then disabled. The transfer size value is not used if a
            /// peripheral is the flow controller.
            TRANSFERSIZE: u12,
            /// Source burst size. Indicates the number of transfers that make up a source
            /// burst. This value must be set to the burst size of the source peripheral, or if
            /// the source is memory, to the memory boundary size. The burst size is the amount
            /// of data that is transferred when the DMACBREQ signal goes active in the source
            /// peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 -
            /// 256
            SBSIZE: u3,
            /// Destination burst size. Indicates the number of transfers that make up a
            /// destination burst transfer request. This value must be set to the burst size of
            /// the destination peripheral or, if the destination is memory, to the memory
            /// boundary size. The burst size is the amount of data that is transferred when the
            /// DMACBREQ signal goes active in the destination peripheral. 000 - 1 001 - 4 010 -
            /// 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
            DBSIZE: u3,
            /// Source transfer width. The source and destination widths can be different from
            /// each other. The hardware automatically packs and unpacks the data as required.
            /// 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 -
            /// Reserved
            SWIDTH: u3,
            /// Destination transfer width. The source and destination widths can be different
            /// from each other. The hardware automatically packs and unpacks the data as
            /// required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to
            /// 111 - Reserved
            DWIDTH: u3,
            /// Reserved, and must be written as 0.
            RESERVED: u2,
            /// Source increment: 0 - the source address is not incremented after each transfer.
            /// 1 - the source address is incremented after each transfer.
            SI: u1,
            /// Destination increment: 0 - the destination address is not incremented after each
            /// transfer. 1 - the destination address is incremented after each transfer.
            DI: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates that
            /// the access is in user mode or privileged mode. This information is not used in
            /// the LPC178x/177x. 0 - access is in user mode. 1 - access is in privileged mode.
            PROT1: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates to the
            /// peripheral that the access is bufferable or not bufferable. This information is
            /// not used in the LPC178x/177x. 0 - access is not bufferable. 1 - access is
            /// bufferable.
            PROT2: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates to the
            /// peripheral that the access is cacheable or not cacheable. This information is
            /// not used in the LPC178x/177x. 0 - access is not cacheable. 1 - access is
            /// cacheable.
            PROT3: u1,
            /// Terminal count interrupt enable bit. 0 - the terminal count interrupt is
            /// disabled. 1 - the terminal count interrupt is enabled.
            I: u1,
        }), base_address + 0x10c);

        /// address: 0x5000412c
        /// DMA Channel 0 Control Register
        pub const CONTROL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size. This field sets the size of the transfer when the DMA controller
            /// is the flow controller, in which case the value must be set before the channel
            /// is enabled. Transfer size is updated as data transfers are completed. A read
            /// from this field indicates the number of transfers completed on the destination
            /// bus. Reading the register when the channel is active does not give useful
            /// information because by the time that the software has processed the value read,
            /// the channel might have progressed. It is intended to be used only when a channel
            /// is enabled and then disabled. The transfer size value is not used if a
            /// peripheral is the flow controller.
            TRANSFERSIZE: u12,
            /// Source burst size. Indicates the number of transfers that make up a source
            /// burst. This value must be set to the burst size of the source peripheral, or if
            /// the source is memory, to the memory boundary size. The burst size is the amount
            /// of data that is transferred when the DMACBREQ signal goes active in the source
            /// peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 -
            /// 256
            SBSIZE: u3,
            /// Destination burst size. Indicates the number of transfers that make up a
            /// destination burst transfer request. This value must be set to the burst size of
            /// the destination peripheral or, if the destination is memory, to the memory
            /// boundary size. The burst size is the amount of data that is transferred when the
            /// DMACBREQ signal goes active in the destination peripheral. 000 - 1 001 - 4 010 -
            /// 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
            DBSIZE: u3,
            /// Source transfer width. The source and destination widths can be different from
            /// each other. The hardware automatically packs and unpacks the data as required.
            /// 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 -
            /// Reserved
            SWIDTH: u3,
            /// Destination transfer width. The source and destination widths can be different
            /// from each other. The hardware automatically packs and unpacks the data as
            /// required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to
            /// 111 - Reserved
            DWIDTH: u3,
            /// Reserved, and must be written as 0.
            RESERVED: u2,
            /// Source increment: 0 - the source address is not incremented after each transfer.
            /// 1 - the source address is incremented after each transfer.
            SI: u1,
            /// Destination increment: 0 - the destination address is not incremented after each
            /// transfer. 1 - the destination address is incremented after each transfer.
            DI: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates that
            /// the access is in user mode or privileged mode. This information is not used in
            /// the LPC178x/177x. 0 - access is in user mode. 1 - access is in privileged mode.
            PROT1: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates to the
            /// peripheral that the access is bufferable or not bufferable. This information is
            /// not used in the LPC178x/177x. 0 - access is not bufferable. 1 - access is
            /// bufferable.
            PROT2: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates to the
            /// peripheral that the access is cacheable or not cacheable. This information is
            /// not used in the LPC178x/177x. 0 - access is not cacheable. 1 - access is
            /// cacheable.
            PROT3: u1,
            /// Terminal count interrupt enable bit. 0 - the terminal count interrupt is
            /// disabled. 1 - the terminal count interrupt is enabled.
            I: u1,
        }), base_address + 0x12c);

        /// address: 0x5000414c
        /// DMA Channel 0 Control Register
        pub const CONTROL2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size. This field sets the size of the transfer when the DMA controller
            /// is the flow controller, in which case the value must be set before the channel
            /// is enabled. Transfer size is updated as data transfers are completed. A read
            /// from this field indicates the number of transfers completed on the destination
            /// bus. Reading the register when the channel is active does not give useful
            /// information because by the time that the software has processed the value read,
            /// the channel might have progressed. It is intended to be used only when a channel
            /// is enabled and then disabled. The transfer size value is not used if a
            /// peripheral is the flow controller.
            TRANSFERSIZE: u12,
            /// Source burst size. Indicates the number of transfers that make up a source
            /// burst. This value must be set to the burst size of the source peripheral, or if
            /// the source is memory, to the memory boundary size. The burst size is the amount
            /// of data that is transferred when the DMACBREQ signal goes active in the source
            /// peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 -
            /// 256
            SBSIZE: u3,
            /// Destination burst size. Indicates the number of transfers that make up a
            /// destination burst transfer request. This value must be set to the burst size of
            /// the destination peripheral or, if the destination is memory, to the memory
            /// boundary size. The burst size is the amount of data that is transferred when the
            /// DMACBREQ signal goes active in the destination peripheral. 000 - 1 001 - 4 010 -
            /// 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
            DBSIZE: u3,
            /// Source transfer width. The source and destination widths can be different from
            /// each other. The hardware automatically packs and unpacks the data as required.
            /// 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 -
            /// Reserved
            SWIDTH: u3,
            /// Destination transfer width. The source and destination widths can be different
            /// from each other. The hardware automatically packs and unpacks the data as
            /// required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to
            /// 111 - Reserved
            DWIDTH: u3,
            /// Reserved, and must be written as 0.
            RESERVED: u2,
            /// Source increment: 0 - the source address is not incremented after each transfer.
            /// 1 - the source address is incremented after each transfer.
            SI: u1,
            /// Destination increment: 0 - the destination address is not incremented after each
            /// transfer. 1 - the destination address is incremented after each transfer.
            DI: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates that
            /// the access is in user mode or privileged mode. This information is not used in
            /// the LPC178x/177x. 0 - access is in user mode. 1 - access is in privileged mode.
            PROT1: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates to the
            /// peripheral that the access is bufferable or not bufferable. This information is
            /// not used in the LPC178x/177x. 0 - access is not bufferable. 1 - access is
            /// bufferable.
            PROT2: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates to the
            /// peripheral that the access is cacheable or not cacheable. This information is
            /// not used in the LPC178x/177x. 0 - access is not cacheable. 1 - access is
            /// cacheable.
            PROT3: u1,
            /// Terminal count interrupt enable bit. 0 - the terminal count interrupt is
            /// disabled. 1 - the terminal count interrupt is enabled.
            I: u1,
        }), base_address + 0x14c);

        /// address: 0x5000416c
        /// DMA Channel 0 Control Register
        pub const CONTROL3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size. This field sets the size of the transfer when the DMA controller
            /// is the flow controller, in which case the value must be set before the channel
            /// is enabled. Transfer size is updated as data transfers are completed. A read
            /// from this field indicates the number of transfers completed on the destination
            /// bus. Reading the register when the channel is active does not give useful
            /// information because by the time that the software has processed the value read,
            /// the channel might have progressed. It is intended to be used only when a channel
            /// is enabled and then disabled. The transfer size value is not used if a
            /// peripheral is the flow controller.
            TRANSFERSIZE: u12,
            /// Source burst size. Indicates the number of transfers that make up a source
            /// burst. This value must be set to the burst size of the source peripheral, or if
            /// the source is memory, to the memory boundary size. The burst size is the amount
            /// of data that is transferred when the DMACBREQ signal goes active in the source
            /// peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 -
            /// 256
            SBSIZE: u3,
            /// Destination burst size. Indicates the number of transfers that make up a
            /// destination burst transfer request. This value must be set to the burst size of
            /// the destination peripheral or, if the destination is memory, to the memory
            /// boundary size. The burst size is the amount of data that is transferred when the
            /// DMACBREQ signal goes active in the destination peripheral. 000 - 1 001 - 4 010 -
            /// 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
            DBSIZE: u3,
            /// Source transfer width. The source and destination widths can be different from
            /// each other. The hardware automatically packs and unpacks the data as required.
            /// 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 -
            /// Reserved
            SWIDTH: u3,
            /// Destination transfer width. The source and destination widths can be different
            /// from each other. The hardware automatically packs and unpacks the data as
            /// required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to
            /// 111 - Reserved
            DWIDTH: u3,
            /// Reserved, and must be written as 0.
            RESERVED: u2,
            /// Source increment: 0 - the source address is not incremented after each transfer.
            /// 1 - the source address is incremented after each transfer.
            SI: u1,
            /// Destination increment: 0 - the destination address is not incremented after each
            /// transfer. 1 - the destination address is incremented after each transfer.
            DI: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates that
            /// the access is in user mode or privileged mode. This information is not used in
            /// the LPC178x/177x. 0 - access is in user mode. 1 - access is in privileged mode.
            PROT1: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates to the
            /// peripheral that the access is bufferable or not bufferable. This information is
            /// not used in the LPC178x/177x. 0 - access is not bufferable. 1 - access is
            /// bufferable.
            PROT2: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates to the
            /// peripheral that the access is cacheable or not cacheable. This information is
            /// not used in the LPC178x/177x. 0 - access is not cacheable. 1 - access is
            /// cacheable.
            PROT3: u1,
            /// Terminal count interrupt enable bit. 0 - the terminal count interrupt is
            /// disabled. 1 - the terminal count interrupt is enabled.
            I: u1,
        }), base_address + 0x16c);

        /// address: 0x5000418c
        /// DMA Channel 0 Control Register
        pub const CONTROL4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size. This field sets the size of the transfer when the DMA controller
            /// is the flow controller, in which case the value must be set before the channel
            /// is enabled. Transfer size is updated as data transfers are completed. A read
            /// from this field indicates the number of transfers completed on the destination
            /// bus. Reading the register when the channel is active does not give useful
            /// information because by the time that the software has processed the value read,
            /// the channel might have progressed. It is intended to be used only when a channel
            /// is enabled and then disabled. The transfer size value is not used if a
            /// peripheral is the flow controller.
            TRANSFERSIZE: u12,
            /// Source burst size. Indicates the number of transfers that make up a source
            /// burst. This value must be set to the burst size of the source peripheral, or if
            /// the source is memory, to the memory boundary size. The burst size is the amount
            /// of data that is transferred when the DMACBREQ signal goes active in the source
            /// peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 -
            /// 256
            SBSIZE: u3,
            /// Destination burst size. Indicates the number of transfers that make up a
            /// destination burst transfer request. This value must be set to the burst size of
            /// the destination peripheral or, if the destination is memory, to the memory
            /// boundary size. The burst size is the amount of data that is transferred when the
            /// DMACBREQ signal goes active in the destination peripheral. 000 - 1 001 - 4 010 -
            /// 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
            DBSIZE: u3,
            /// Source transfer width. The source and destination widths can be different from
            /// each other. The hardware automatically packs and unpacks the data as required.
            /// 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 -
            /// Reserved
            SWIDTH: u3,
            /// Destination transfer width. The source and destination widths can be different
            /// from each other. The hardware automatically packs and unpacks the data as
            /// required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to
            /// 111 - Reserved
            DWIDTH: u3,
            /// Reserved, and must be written as 0.
            RESERVED: u2,
            /// Source increment: 0 - the source address is not incremented after each transfer.
            /// 1 - the source address is incremented after each transfer.
            SI: u1,
            /// Destination increment: 0 - the destination address is not incremented after each
            /// transfer. 1 - the destination address is incremented after each transfer.
            DI: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates that
            /// the access is in user mode or privileged mode. This information is not used in
            /// the LPC178x/177x. 0 - access is in user mode. 1 - access is in privileged mode.
            PROT1: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates to the
            /// peripheral that the access is bufferable or not bufferable. This information is
            /// not used in the LPC178x/177x. 0 - access is not bufferable. 1 - access is
            /// bufferable.
            PROT2: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates to the
            /// peripheral that the access is cacheable or not cacheable. This information is
            /// not used in the LPC178x/177x. 0 - access is not cacheable. 1 - access is
            /// cacheable.
            PROT3: u1,
            /// Terminal count interrupt enable bit. 0 - the terminal count interrupt is
            /// disabled. 1 - the terminal count interrupt is enabled.
            I: u1,
        }), base_address + 0x18c);

        /// address: 0x500041ac
        /// DMA Channel 0 Control Register
        pub const CONTROL5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size. This field sets the size of the transfer when the DMA controller
            /// is the flow controller, in which case the value must be set before the channel
            /// is enabled. Transfer size is updated as data transfers are completed. A read
            /// from this field indicates the number of transfers completed on the destination
            /// bus. Reading the register when the channel is active does not give useful
            /// information because by the time that the software has processed the value read,
            /// the channel might have progressed. It is intended to be used only when a channel
            /// is enabled and then disabled. The transfer size value is not used if a
            /// peripheral is the flow controller.
            TRANSFERSIZE: u12,
            /// Source burst size. Indicates the number of transfers that make up a source
            /// burst. This value must be set to the burst size of the source peripheral, or if
            /// the source is memory, to the memory boundary size. The burst size is the amount
            /// of data that is transferred when the DMACBREQ signal goes active in the source
            /// peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 -
            /// 256
            SBSIZE: u3,
            /// Destination burst size. Indicates the number of transfers that make up a
            /// destination burst transfer request. This value must be set to the burst size of
            /// the destination peripheral or, if the destination is memory, to the memory
            /// boundary size. The burst size is the amount of data that is transferred when the
            /// DMACBREQ signal goes active in the destination peripheral. 000 - 1 001 - 4 010 -
            /// 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
            DBSIZE: u3,
            /// Source transfer width. The source and destination widths can be different from
            /// each other. The hardware automatically packs and unpacks the data as required.
            /// 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 -
            /// Reserved
            SWIDTH: u3,
            /// Destination transfer width. The source and destination widths can be different
            /// from each other. The hardware automatically packs and unpacks the data as
            /// required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to
            /// 111 - Reserved
            DWIDTH: u3,
            /// Reserved, and must be written as 0.
            RESERVED: u2,
            /// Source increment: 0 - the source address is not incremented after each transfer.
            /// 1 - the source address is incremented after each transfer.
            SI: u1,
            /// Destination increment: 0 - the destination address is not incremented after each
            /// transfer. 1 - the destination address is incremented after each transfer.
            DI: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates that
            /// the access is in user mode or privileged mode. This information is not used in
            /// the LPC178x/177x. 0 - access is in user mode. 1 - access is in privileged mode.
            PROT1: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates to the
            /// peripheral that the access is bufferable or not bufferable. This information is
            /// not used in the LPC178x/177x. 0 - access is not bufferable. 1 - access is
            /// bufferable.
            PROT2: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates to the
            /// peripheral that the access is cacheable or not cacheable. This information is
            /// not used in the LPC178x/177x. 0 - access is not cacheable. 1 - access is
            /// cacheable.
            PROT3: u1,
            /// Terminal count interrupt enable bit. 0 - the terminal count interrupt is
            /// disabled. 1 - the terminal count interrupt is enabled.
            I: u1,
        }), base_address + 0x1ac);

        /// address: 0x500041cc
        /// DMA Channel 0 Control Register
        pub const CONTROL6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size. This field sets the size of the transfer when the DMA controller
            /// is the flow controller, in which case the value must be set before the channel
            /// is enabled. Transfer size is updated as data transfers are completed. A read
            /// from this field indicates the number of transfers completed on the destination
            /// bus. Reading the register when the channel is active does not give useful
            /// information because by the time that the software has processed the value read,
            /// the channel might have progressed. It is intended to be used only when a channel
            /// is enabled and then disabled. The transfer size value is not used if a
            /// peripheral is the flow controller.
            TRANSFERSIZE: u12,
            /// Source burst size. Indicates the number of transfers that make up a source
            /// burst. This value must be set to the burst size of the source peripheral, or if
            /// the source is memory, to the memory boundary size. The burst size is the amount
            /// of data that is transferred when the DMACBREQ signal goes active in the source
            /// peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 -
            /// 256
            SBSIZE: u3,
            /// Destination burst size. Indicates the number of transfers that make up a
            /// destination burst transfer request. This value must be set to the burst size of
            /// the destination peripheral or, if the destination is memory, to the memory
            /// boundary size. The burst size is the amount of data that is transferred when the
            /// DMACBREQ signal goes active in the destination peripheral. 000 - 1 001 - 4 010 -
            /// 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
            DBSIZE: u3,
            /// Source transfer width. The source and destination widths can be different from
            /// each other. The hardware automatically packs and unpacks the data as required.
            /// 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 -
            /// Reserved
            SWIDTH: u3,
            /// Destination transfer width. The source and destination widths can be different
            /// from each other. The hardware automatically packs and unpacks the data as
            /// required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to
            /// 111 - Reserved
            DWIDTH: u3,
            /// Reserved, and must be written as 0.
            RESERVED: u2,
            /// Source increment: 0 - the source address is not incremented after each transfer.
            /// 1 - the source address is incremented after each transfer.
            SI: u1,
            /// Destination increment: 0 - the destination address is not incremented after each
            /// transfer. 1 - the destination address is incremented after each transfer.
            DI: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates that
            /// the access is in user mode or privileged mode. This information is not used in
            /// the LPC178x/177x. 0 - access is in user mode. 1 - access is in privileged mode.
            PROT1: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates to the
            /// peripheral that the access is bufferable or not bufferable. This information is
            /// not used in the LPC178x/177x. 0 - access is not bufferable. 1 - access is
            /// bufferable.
            PROT2: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates to the
            /// peripheral that the access is cacheable or not cacheable. This information is
            /// not used in the LPC178x/177x. 0 - access is not cacheable. 1 - access is
            /// cacheable.
            PROT3: u1,
            /// Terminal count interrupt enable bit. 0 - the terminal count interrupt is
            /// disabled. 1 - the terminal count interrupt is enabled.
            I: u1,
        }), base_address + 0x1cc);

        /// address: 0x500041ec
        /// DMA Channel 0 Control Register
        pub const CONTROL7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer size. This field sets the size of the transfer when the DMA controller
            /// is the flow controller, in which case the value must be set before the channel
            /// is enabled. Transfer size is updated as data transfers are completed. A read
            /// from this field indicates the number of transfers completed on the destination
            /// bus. Reading the register when the channel is active does not give useful
            /// information because by the time that the software has processed the value read,
            /// the channel might have progressed. It is intended to be used only when a channel
            /// is enabled and then disabled. The transfer size value is not used if a
            /// peripheral is the flow controller.
            TRANSFERSIZE: u12,
            /// Source burst size. Indicates the number of transfers that make up a source
            /// burst. This value must be set to the burst size of the source peripheral, or if
            /// the source is memory, to the memory boundary size. The burst size is the amount
            /// of data that is transferred when the DMACBREQ signal goes active in the source
            /// peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 -
            /// 256
            SBSIZE: u3,
            /// Destination burst size. Indicates the number of transfers that make up a
            /// destination burst transfer request. This value must be set to the burst size of
            /// the destination peripheral or, if the destination is memory, to the memory
            /// boundary size. The burst size is the amount of data that is transferred when the
            /// DMACBREQ signal goes active in the destination peripheral. 000 - 1 001 - 4 010 -
            /// 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
            DBSIZE: u3,
            /// Source transfer width. The source and destination widths can be different from
            /// each other. The hardware automatically packs and unpacks the data as required.
            /// 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 -
            /// Reserved
            SWIDTH: u3,
            /// Destination transfer width. The source and destination widths can be different
            /// from each other. The hardware automatically packs and unpacks the data as
            /// required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to
            /// 111 - Reserved
            DWIDTH: u3,
            /// Reserved, and must be written as 0.
            RESERVED: u2,
            /// Source increment: 0 - the source address is not incremented after each transfer.
            /// 1 - the source address is incremented after each transfer.
            SI: u1,
            /// Destination increment: 0 - the destination address is not incremented after each
            /// transfer. 1 - the destination address is incremented after each transfer.
            DI: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates that
            /// the access is in user mode or privileged mode. This information is not used in
            /// the LPC178x/177x. 0 - access is in user mode. 1 - access is in privileged mode.
            PROT1: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates to the
            /// peripheral that the access is bufferable or not bufferable. This information is
            /// not used in the LPC178x/177x. 0 - access is not bufferable. 1 - access is
            /// bufferable.
            PROT2: u1,
            /// This is provided to the peripheral during a DMA bus access and indicates to the
            /// peripheral that the access is cacheable or not cacheable. This information is
            /// not used in the LPC178x/177x. 0 - access is not cacheable. 1 - access is
            /// cacheable.
            PROT3: u1,
            /// Terminal count interrupt enable bit. 0 - the terminal count interrupt is
            /// disabled. 1 - the terminal count interrupt is enabled.
            I: u1,
        }), base_address + 0x1ec);

        /// address: 0x50004110
        /// DMA Channel 0 Configuration Register[1]
        pub const CONFIG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable. Reading this bit indicates whether a channel is currently
            /// enabled or disabled: 0 = channel disabled. 1 = channel enabled. The Channel
            /// Enable bit status can also be found by reading the DMACEnbldChns Register. A
            /// channel is enabled by setting this bit. A channel can be disabled by clearing
            /// the Enable bit. This causes the current AHB transfer (if one is in progress) to
            /// complete and the channel is then disabled. Any data in the FIFO of the relevant
            /// channel is lost. Restarting the channel by setting the Channel Enable bit has
            /// unpredictable effects, the channel must be fully re-initialized. The channel is
            /// also disabled, and Channel Enable bit cleared, when the last LLI is reached, the
            /// DMA transfer is completed, or if a channel error is encountered. If a channel
            /// must be disabled without losing data in the FIFO, the Halt bit must be set so
            /// that further DMA requests are ignored. The Active bit must then be polled until
            /// it reaches 0, indicating that there is no data left in the FIFO. Finally, the
            /// Channel Enable bit can be cleared.
            E: u1,
            /// Source peripheral. This value selects the DMA source request peripheral. This
            /// field is ignored if the source of the transfer is from memory. See Table 672 for
            /// peripheral identification.
            SRCPERIPHERAL: u5,
            /// Destination peripheral. This value selects the DMA destination request
            /// peripheral. This field is ignored if the destination of the transfer is to
            /// memory. See Table 672 for peripheral identification.
            DESTPERIPHERAL: u5,
            /// This value indicates the type of transfer and specifies the flow controller. The
            /// transfer type can be memory-to-memory, memory-to-peripheral,
            /// peripheral-to-memory, or peripheral-to-peripheral. Flow can be controlled by the
            /// DMA controller, the source peripheral, or the destination peripheral. Refer to
            /// Table 694 for the encoding of this field.
            TRANSFERTYPE: u3,
            /// Interrupt error mask. When cleared, this bit masks out the error interrupt of
            /// the relevant channel.
            IE: u1,
            /// Terminal count interrupt mask. When cleared, this bit masks out the terminal
            /// count interrupt of the relevant channel.
            ITC: u1,
            /// Lock. When set, this bit enables locked transfers. This information is not used
            /// in the LPC178x/177x.
            L: u1,
            /// Active: 0 = there is no data in the FIFO of the channel. 1 = the channel FIFO
            /// has data. This value can be used with the Halt and Channel Enable bits to
            /// cleanly disable a DMA channel. This is a read-only bit.
            A: u1,
            /// Halt: 0 = enable DMA requests. 1 = ignore further source DMA requests. The
            /// contents of the channel FIFO are drained. This value can be used with the Active
            /// and Channel Enable bits to cleanly disable a DMA channel.
            H: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u13,
        }), base_address + 0x110);

        /// address: 0x50004130
        /// DMA Channel 0 Configuration Register[1]
        pub const CONFIG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable. Reading this bit indicates whether a channel is currently
            /// enabled or disabled: 0 = channel disabled. 1 = channel enabled. The Channel
            /// Enable bit status can also be found by reading the DMACEnbldChns Register. A
            /// channel is enabled by setting this bit. A channel can be disabled by clearing
            /// the Enable bit. This causes the current AHB transfer (if one is in progress) to
            /// complete and the channel is then disabled. Any data in the FIFO of the relevant
            /// channel is lost. Restarting the channel by setting the Channel Enable bit has
            /// unpredictable effects, the channel must be fully re-initialized. The channel is
            /// also disabled, and Channel Enable bit cleared, when the last LLI is reached, the
            /// DMA transfer is completed, or if a channel error is encountered. If a channel
            /// must be disabled without losing data in the FIFO, the Halt bit must be set so
            /// that further DMA requests are ignored. The Active bit must then be polled until
            /// it reaches 0, indicating that there is no data left in the FIFO. Finally, the
            /// Channel Enable bit can be cleared.
            E: u1,
            /// Source peripheral. This value selects the DMA source request peripheral. This
            /// field is ignored if the source of the transfer is from memory. See Table 672 for
            /// peripheral identification.
            SRCPERIPHERAL: u5,
            /// Destination peripheral. This value selects the DMA destination request
            /// peripheral. This field is ignored if the destination of the transfer is to
            /// memory. See Table 672 for peripheral identification.
            DESTPERIPHERAL: u5,
            /// This value indicates the type of transfer and specifies the flow controller. The
            /// transfer type can be memory-to-memory, memory-to-peripheral,
            /// peripheral-to-memory, or peripheral-to-peripheral. Flow can be controlled by the
            /// DMA controller, the source peripheral, or the destination peripheral. Refer to
            /// Table 694 for the encoding of this field.
            TRANSFERTYPE: u3,
            /// Interrupt error mask. When cleared, this bit masks out the error interrupt of
            /// the relevant channel.
            IE: u1,
            /// Terminal count interrupt mask. When cleared, this bit masks out the terminal
            /// count interrupt of the relevant channel.
            ITC: u1,
            /// Lock. When set, this bit enables locked transfers. This information is not used
            /// in the LPC178x/177x.
            L: u1,
            /// Active: 0 = there is no data in the FIFO of the channel. 1 = the channel FIFO
            /// has data. This value can be used with the Halt and Channel Enable bits to
            /// cleanly disable a DMA channel. This is a read-only bit.
            A: u1,
            /// Halt: 0 = enable DMA requests. 1 = ignore further source DMA requests. The
            /// contents of the channel FIFO are drained. This value can be used with the Active
            /// and Channel Enable bits to cleanly disable a DMA channel.
            H: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u13,
        }), base_address + 0x130);

        /// address: 0x50004150
        /// DMA Channel 0 Configuration Register[1]
        pub const CONFIG2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable. Reading this bit indicates whether a channel is currently
            /// enabled or disabled: 0 = channel disabled. 1 = channel enabled. The Channel
            /// Enable bit status can also be found by reading the DMACEnbldChns Register. A
            /// channel is enabled by setting this bit. A channel can be disabled by clearing
            /// the Enable bit. This causes the current AHB transfer (if one is in progress) to
            /// complete and the channel is then disabled. Any data in the FIFO of the relevant
            /// channel is lost. Restarting the channel by setting the Channel Enable bit has
            /// unpredictable effects, the channel must be fully re-initialized. The channel is
            /// also disabled, and Channel Enable bit cleared, when the last LLI is reached, the
            /// DMA transfer is completed, or if a channel error is encountered. If a channel
            /// must be disabled without losing data in the FIFO, the Halt bit must be set so
            /// that further DMA requests are ignored. The Active bit must then be polled until
            /// it reaches 0, indicating that there is no data left in the FIFO. Finally, the
            /// Channel Enable bit can be cleared.
            E: u1,
            /// Source peripheral. This value selects the DMA source request peripheral. This
            /// field is ignored if the source of the transfer is from memory. See Table 672 for
            /// peripheral identification.
            SRCPERIPHERAL: u5,
            /// Destination peripheral. This value selects the DMA destination request
            /// peripheral. This field is ignored if the destination of the transfer is to
            /// memory. See Table 672 for peripheral identification.
            DESTPERIPHERAL: u5,
            /// This value indicates the type of transfer and specifies the flow controller. The
            /// transfer type can be memory-to-memory, memory-to-peripheral,
            /// peripheral-to-memory, or peripheral-to-peripheral. Flow can be controlled by the
            /// DMA controller, the source peripheral, or the destination peripheral. Refer to
            /// Table 694 for the encoding of this field.
            TRANSFERTYPE: u3,
            /// Interrupt error mask. When cleared, this bit masks out the error interrupt of
            /// the relevant channel.
            IE: u1,
            /// Terminal count interrupt mask. When cleared, this bit masks out the terminal
            /// count interrupt of the relevant channel.
            ITC: u1,
            /// Lock. When set, this bit enables locked transfers. This information is not used
            /// in the LPC178x/177x.
            L: u1,
            /// Active: 0 = there is no data in the FIFO of the channel. 1 = the channel FIFO
            /// has data. This value can be used with the Halt and Channel Enable bits to
            /// cleanly disable a DMA channel. This is a read-only bit.
            A: u1,
            /// Halt: 0 = enable DMA requests. 1 = ignore further source DMA requests. The
            /// contents of the channel FIFO are drained. This value can be used with the Active
            /// and Channel Enable bits to cleanly disable a DMA channel.
            H: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u13,
        }), base_address + 0x150);

        /// address: 0x50004170
        /// DMA Channel 0 Configuration Register[1]
        pub const CONFIG3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable. Reading this bit indicates whether a channel is currently
            /// enabled or disabled: 0 = channel disabled. 1 = channel enabled. The Channel
            /// Enable bit status can also be found by reading the DMACEnbldChns Register. A
            /// channel is enabled by setting this bit. A channel can be disabled by clearing
            /// the Enable bit. This causes the current AHB transfer (if one is in progress) to
            /// complete and the channel is then disabled. Any data in the FIFO of the relevant
            /// channel is lost. Restarting the channel by setting the Channel Enable bit has
            /// unpredictable effects, the channel must be fully re-initialized. The channel is
            /// also disabled, and Channel Enable bit cleared, when the last LLI is reached, the
            /// DMA transfer is completed, or if a channel error is encountered. If a channel
            /// must be disabled without losing data in the FIFO, the Halt bit must be set so
            /// that further DMA requests are ignored. The Active bit must then be polled until
            /// it reaches 0, indicating that there is no data left in the FIFO. Finally, the
            /// Channel Enable bit can be cleared.
            E: u1,
            /// Source peripheral. This value selects the DMA source request peripheral. This
            /// field is ignored if the source of the transfer is from memory. See Table 672 for
            /// peripheral identification.
            SRCPERIPHERAL: u5,
            /// Destination peripheral. This value selects the DMA destination request
            /// peripheral. This field is ignored if the destination of the transfer is to
            /// memory. See Table 672 for peripheral identification.
            DESTPERIPHERAL: u5,
            /// This value indicates the type of transfer and specifies the flow controller. The
            /// transfer type can be memory-to-memory, memory-to-peripheral,
            /// peripheral-to-memory, or peripheral-to-peripheral. Flow can be controlled by the
            /// DMA controller, the source peripheral, or the destination peripheral. Refer to
            /// Table 694 for the encoding of this field.
            TRANSFERTYPE: u3,
            /// Interrupt error mask. When cleared, this bit masks out the error interrupt of
            /// the relevant channel.
            IE: u1,
            /// Terminal count interrupt mask. When cleared, this bit masks out the terminal
            /// count interrupt of the relevant channel.
            ITC: u1,
            /// Lock. When set, this bit enables locked transfers. This information is not used
            /// in the LPC178x/177x.
            L: u1,
            /// Active: 0 = there is no data in the FIFO of the channel. 1 = the channel FIFO
            /// has data. This value can be used with the Halt and Channel Enable bits to
            /// cleanly disable a DMA channel. This is a read-only bit.
            A: u1,
            /// Halt: 0 = enable DMA requests. 1 = ignore further source DMA requests. The
            /// contents of the channel FIFO are drained. This value can be used with the Active
            /// and Channel Enable bits to cleanly disable a DMA channel.
            H: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u13,
        }), base_address + 0x170);

        /// address: 0x50004190
        /// DMA Channel 0 Configuration Register[1]
        pub const CONFIG4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable. Reading this bit indicates whether a channel is currently
            /// enabled or disabled: 0 = channel disabled. 1 = channel enabled. The Channel
            /// Enable bit status can also be found by reading the DMACEnbldChns Register. A
            /// channel is enabled by setting this bit. A channel can be disabled by clearing
            /// the Enable bit. This causes the current AHB transfer (if one is in progress) to
            /// complete and the channel is then disabled. Any data in the FIFO of the relevant
            /// channel is lost. Restarting the channel by setting the Channel Enable bit has
            /// unpredictable effects, the channel must be fully re-initialized. The channel is
            /// also disabled, and Channel Enable bit cleared, when the last LLI is reached, the
            /// DMA transfer is completed, or if a channel error is encountered. If a channel
            /// must be disabled without losing data in the FIFO, the Halt bit must be set so
            /// that further DMA requests are ignored. The Active bit must then be polled until
            /// it reaches 0, indicating that there is no data left in the FIFO. Finally, the
            /// Channel Enable bit can be cleared.
            E: u1,
            /// Source peripheral. This value selects the DMA source request peripheral. This
            /// field is ignored if the source of the transfer is from memory. See Table 672 for
            /// peripheral identification.
            SRCPERIPHERAL: u5,
            /// Destination peripheral. This value selects the DMA destination request
            /// peripheral. This field is ignored if the destination of the transfer is to
            /// memory. See Table 672 for peripheral identification.
            DESTPERIPHERAL: u5,
            /// This value indicates the type of transfer and specifies the flow controller. The
            /// transfer type can be memory-to-memory, memory-to-peripheral,
            /// peripheral-to-memory, or peripheral-to-peripheral. Flow can be controlled by the
            /// DMA controller, the source peripheral, or the destination peripheral. Refer to
            /// Table 694 for the encoding of this field.
            TRANSFERTYPE: u3,
            /// Interrupt error mask. When cleared, this bit masks out the error interrupt of
            /// the relevant channel.
            IE: u1,
            /// Terminal count interrupt mask. When cleared, this bit masks out the terminal
            /// count interrupt of the relevant channel.
            ITC: u1,
            /// Lock. When set, this bit enables locked transfers. This information is not used
            /// in the LPC178x/177x.
            L: u1,
            /// Active: 0 = there is no data in the FIFO of the channel. 1 = the channel FIFO
            /// has data. This value can be used with the Halt and Channel Enable bits to
            /// cleanly disable a DMA channel. This is a read-only bit.
            A: u1,
            /// Halt: 0 = enable DMA requests. 1 = ignore further source DMA requests. The
            /// contents of the channel FIFO are drained. This value can be used with the Active
            /// and Channel Enable bits to cleanly disable a DMA channel.
            H: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u13,
        }), base_address + 0x190);

        /// address: 0x500041b0
        /// DMA Channel 0 Configuration Register[1]
        pub const CONFIG5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable. Reading this bit indicates whether a channel is currently
            /// enabled or disabled: 0 = channel disabled. 1 = channel enabled. The Channel
            /// Enable bit status can also be found by reading the DMACEnbldChns Register. A
            /// channel is enabled by setting this bit. A channel can be disabled by clearing
            /// the Enable bit. This causes the current AHB transfer (if one is in progress) to
            /// complete and the channel is then disabled. Any data in the FIFO of the relevant
            /// channel is lost. Restarting the channel by setting the Channel Enable bit has
            /// unpredictable effects, the channel must be fully re-initialized. The channel is
            /// also disabled, and Channel Enable bit cleared, when the last LLI is reached, the
            /// DMA transfer is completed, or if a channel error is encountered. If a channel
            /// must be disabled without losing data in the FIFO, the Halt bit must be set so
            /// that further DMA requests are ignored. The Active bit must then be polled until
            /// it reaches 0, indicating that there is no data left in the FIFO. Finally, the
            /// Channel Enable bit can be cleared.
            E: u1,
            /// Source peripheral. This value selects the DMA source request peripheral. This
            /// field is ignored if the source of the transfer is from memory. See Table 672 for
            /// peripheral identification.
            SRCPERIPHERAL: u5,
            /// Destination peripheral. This value selects the DMA destination request
            /// peripheral. This field is ignored if the destination of the transfer is to
            /// memory. See Table 672 for peripheral identification.
            DESTPERIPHERAL: u5,
            /// This value indicates the type of transfer and specifies the flow controller. The
            /// transfer type can be memory-to-memory, memory-to-peripheral,
            /// peripheral-to-memory, or peripheral-to-peripheral. Flow can be controlled by the
            /// DMA controller, the source peripheral, or the destination peripheral. Refer to
            /// Table 694 for the encoding of this field.
            TRANSFERTYPE: u3,
            /// Interrupt error mask. When cleared, this bit masks out the error interrupt of
            /// the relevant channel.
            IE: u1,
            /// Terminal count interrupt mask. When cleared, this bit masks out the terminal
            /// count interrupt of the relevant channel.
            ITC: u1,
            /// Lock. When set, this bit enables locked transfers. This information is not used
            /// in the LPC178x/177x.
            L: u1,
            /// Active: 0 = there is no data in the FIFO of the channel. 1 = the channel FIFO
            /// has data. This value can be used with the Halt and Channel Enable bits to
            /// cleanly disable a DMA channel. This is a read-only bit.
            A: u1,
            /// Halt: 0 = enable DMA requests. 1 = ignore further source DMA requests. The
            /// contents of the channel FIFO are drained. This value can be used with the Active
            /// and Channel Enable bits to cleanly disable a DMA channel.
            H: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u13,
        }), base_address + 0x1b0);

        /// address: 0x500041d0
        /// DMA Channel 0 Configuration Register[1]
        pub const CONFIG6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable. Reading this bit indicates whether a channel is currently
            /// enabled or disabled: 0 = channel disabled. 1 = channel enabled. The Channel
            /// Enable bit status can also be found by reading the DMACEnbldChns Register. A
            /// channel is enabled by setting this bit. A channel can be disabled by clearing
            /// the Enable bit. This causes the current AHB transfer (if one is in progress) to
            /// complete and the channel is then disabled. Any data in the FIFO of the relevant
            /// channel is lost. Restarting the channel by setting the Channel Enable bit has
            /// unpredictable effects, the channel must be fully re-initialized. The channel is
            /// also disabled, and Channel Enable bit cleared, when the last LLI is reached, the
            /// DMA transfer is completed, or if a channel error is encountered. If a channel
            /// must be disabled without losing data in the FIFO, the Halt bit must be set so
            /// that further DMA requests are ignored. The Active bit must then be polled until
            /// it reaches 0, indicating that there is no data left in the FIFO. Finally, the
            /// Channel Enable bit can be cleared.
            E: u1,
            /// Source peripheral. This value selects the DMA source request peripheral. This
            /// field is ignored if the source of the transfer is from memory. See Table 672 for
            /// peripheral identification.
            SRCPERIPHERAL: u5,
            /// Destination peripheral. This value selects the DMA destination request
            /// peripheral. This field is ignored if the destination of the transfer is to
            /// memory. See Table 672 for peripheral identification.
            DESTPERIPHERAL: u5,
            /// This value indicates the type of transfer and specifies the flow controller. The
            /// transfer type can be memory-to-memory, memory-to-peripheral,
            /// peripheral-to-memory, or peripheral-to-peripheral. Flow can be controlled by the
            /// DMA controller, the source peripheral, or the destination peripheral. Refer to
            /// Table 694 for the encoding of this field.
            TRANSFERTYPE: u3,
            /// Interrupt error mask. When cleared, this bit masks out the error interrupt of
            /// the relevant channel.
            IE: u1,
            /// Terminal count interrupt mask. When cleared, this bit masks out the terminal
            /// count interrupt of the relevant channel.
            ITC: u1,
            /// Lock. When set, this bit enables locked transfers. This information is not used
            /// in the LPC178x/177x.
            L: u1,
            /// Active: 0 = there is no data in the FIFO of the channel. 1 = the channel FIFO
            /// has data. This value can be used with the Halt and Channel Enable bits to
            /// cleanly disable a DMA channel. This is a read-only bit.
            A: u1,
            /// Halt: 0 = enable DMA requests. 1 = ignore further source DMA requests. The
            /// contents of the channel FIFO are drained. This value can be used with the Active
            /// and Channel Enable bits to cleanly disable a DMA channel.
            H: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u13,
        }), base_address + 0x1d0);

        /// address: 0x500041f0
        /// DMA Channel 0 Configuration Register[1]
        pub const CONFIG7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable. Reading this bit indicates whether a channel is currently
            /// enabled or disabled: 0 = channel disabled. 1 = channel enabled. The Channel
            /// Enable bit status can also be found by reading the DMACEnbldChns Register. A
            /// channel is enabled by setting this bit. A channel can be disabled by clearing
            /// the Enable bit. This causes the current AHB transfer (if one is in progress) to
            /// complete and the channel is then disabled. Any data in the FIFO of the relevant
            /// channel is lost. Restarting the channel by setting the Channel Enable bit has
            /// unpredictable effects, the channel must be fully re-initialized. The channel is
            /// also disabled, and Channel Enable bit cleared, when the last LLI is reached, the
            /// DMA transfer is completed, or if a channel error is encountered. If a channel
            /// must be disabled without losing data in the FIFO, the Halt bit must be set so
            /// that further DMA requests are ignored. The Active bit must then be polled until
            /// it reaches 0, indicating that there is no data left in the FIFO. Finally, the
            /// Channel Enable bit can be cleared.
            E: u1,
            /// Source peripheral. This value selects the DMA source request peripheral. This
            /// field is ignored if the source of the transfer is from memory. See Table 672 for
            /// peripheral identification.
            SRCPERIPHERAL: u5,
            /// Destination peripheral. This value selects the DMA destination request
            /// peripheral. This field is ignored if the destination of the transfer is to
            /// memory. See Table 672 for peripheral identification.
            DESTPERIPHERAL: u5,
            /// This value indicates the type of transfer and specifies the flow controller. The
            /// transfer type can be memory-to-memory, memory-to-peripheral,
            /// peripheral-to-memory, or peripheral-to-peripheral. Flow can be controlled by the
            /// DMA controller, the source peripheral, or the destination peripheral. Refer to
            /// Table 694 for the encoding of this field.
            TRANSFERTYPE: u3,
            /// Interrupt error mask. When cleared, this bit masks out the error interrupt of
            /// the relevant channel.
            IE: u1,
            /// Terminal count interrupt mask. When cleared, this bit masks out the terminal
            /// count interrupt of the relevant channel.
            ITC: u1,
            /// Lock. When set, this bit enables locked transfers. This information is not used
            /// in the LPC178x/177x.
            L: u1,
            /// Active: 0 = there is no data in the FIFO of the channel. 1 = the channel FIFO
            /// has data. This value can be used with the Halt and Channel Enable bits to
            /// cleanly disable a DMA channel. This is a read-only bit.
            A: u1,
            /// Halt: 0 = enable DMA requests. 1 = ignore further source DMA requests. The
            /// contents of the channel FIFO are drained. This value can be used with the Active
            /// and Channel Enable bits to cleanly disable a DMA channel.
            H: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u13,
        }), base_address + 0x1f0);
    };
    /// USB device/host/OTG controller
    pub const USB = struct {
        pub const base_address = 0x50008000;

        /// address: 0x50008100
        /// OTG Interrupt Status
        pub const INTST = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer time-out.
            TMR: u1,
            /// Remove pull-up. This bit is set by hardware to indicate that software needs to
            /// disable the D+ pull-up resistor.
            REMOVE_PU: u1,
            /// HNP failed. This bit is set by hardware to indicate that the HNP switching has
            /// failed.
            HNP_FAILURE: u1,
            /// HNP succeeded. This bit is set by hardware to indicate that the HNP switching
            /// has succeeded.
            HNP_SUCCESS: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u28,
        }), base_address + 0x100);

        /// address: 0x50008104
        /// OTG Interrupt Enable
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1 = enable the corresponding bit in the IntSt register.
            TMR_EN: u1,
            /// 1 = enable the corresponding bit in the IntSt register.
            REMOVE_PU_EN: u1,
            /// 1 = enable the corresponding bit in the IntSt register.
            HNP_FAILURE_EN: u1,
            /// 1 = enable the corresponding bit in the IntSt register.
            HNP_SUCCES_EN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u28,
        }), base_address + 0x104);

        /// address: 0x50008108
        /// OTG Interrupt Set
        pub const INTSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0 = no effect. 1 = set the corresponding bit in the IntSt register.
            TMR_SET: u1,
            /// 0 = no effect. 1 = set the corresponding bit in the IntSt register.
            REMOVE_PU_SET: u1,
            /// 0 = no effect. 1 = set the corresponding bit in the IntSt register.
            HNP_FAILURE_SET: u1,
            /// 0 = no effect. 1 = set the corresponding bit in the IntSt register.
            HNP_SUCCES_SET: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u28,
        }), base_address + 0x108);

        /// address: 0x5000810c
        /// OTG Interrupt Clear
        pub const INTCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0 = no effect. 1 = clear the corresponding bit in the IntSt register.
            TMR_CLR: u1,
            /// 0 = no effect. 1 = clear the corresponding bit in the IntSt register.
            REMOVE_PU_CLR: u1,
            /// 0 = no effect. 1 = clear the corresponding bit in the IntSt register.
            HNP_FAILURE_CLR: u1,
            /// 0 = no effect. 1 = clear the corresponding bit in the IntSt register.
            HNP_SUCCES_CLR: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u28,
        }), base_address + 0x10c);

        /// address: 0x50008110
        /// OTG Status and Control and USB port select
        pub const STCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Controls connection of USB functions (see Figure 51). Bit 0 is set or cleared by
            /// hardware when B_HNP_TRACK or A_HNP_TRACK is set and HNP succeeds. See Section
            /// 14.9. 00: U1 = device (OTG), U2 = host 01: U1 = host (OTG), U2 = host 10:
            /// Reserved 11: U1 = host, U2 = device In a device-only configuration, the
            /// following values are allowed: 00: U1 = device. The USB device controller signals
            /// are mapped to the U1 port: USB_CONNECT1, USB_UP_LED1, USB_D+1, USB_D-1. 11: U2 =
            /// device. The USB device controller signals are mapped to the U2 port:
            /// USB_CONNECT2, USB_UP_LED2, USB_D+2, USB_D-2.
            PORT_FUNC: u2,
            /// Timer scale selection. This field determines the duration of each timer count.
            /// 00: 10 ms (100 KHz) 01: 100 ms (10 KHz) 10: 1000 ms (1 KHz) 11: Reserved
            TMR_SCALE: u2,
            /// Timer mode selection. 0: monoshot 1: free running
            TMR_MODE: u1,
            /// Timer enable. When set, TMR_CNT increments. When cleared, TMR_CNT is reset to 0.
            TMR_EN: u1,
            /// Timer reset. Writing one to this bit resets TMR_CNT to 0. This provides a single
            /// bit control for the software to restart the timer when the timer is enabled.
            TMR_RST: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u1,
            /// Enable HNP tracking for B-device (peripheral), see Section 14.9. Hardware clears
            /// this bit when HNP_SUCCESS or HNP_FAILURE is set.
            B_HNP_TRACK: u1,
            /// Enable HNP tracking for A-device (host), see Section 14.9. Hardware clears this
            /// bit when HNP_SUCCESS or HNP_FAILURE is set.
            A_HNP_TRACK: u1,
            /// When the B-device changes its role from peripheral to host, software sets this
            /// bit when it removes the D+ pull-up, see Section 14.9. Hardware clears this bit
            /// when HNP_SUCCESS or HNP_FAILURE is set.
            PU_REMOVED: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u5,
            /// Current timer count value.
            TMR_CNT: u16,
        }), base_address + 0x110);

        /// address: 0x50008114
        /// OTG Timer
        pub const TMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The TMR interrupt is set when TMR_CNT reaches this value.
            TIMEOUT_CNT: u16,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u16,
        }), base_address + 0x114);

        /// address: 0x50008200
        /// USB Device Interrupt Status
        pub const DEVINTST = @intToPtr(*volatile Mmio(32, packed struct {
            /// The frame interrupt occurs every 1 ms. This is used in isochronous packet
            /// transfers.
            FRAME: u1,
            /// Fast endpoint interrupt. If an Endpoint Interrupt Priority register
            /// (USBEpIntPri) bit is set, the corresponding endpoint interrupt will be routed to
            /// this bit.
            EP_FAST: u1,
            /// Slow endpoints interrupt. If an Endpoint Interrupt Priority Register
            /// (USBEpIntPri) bit is not set, the corresponding endpoint interrupt will be
            /// routed to this bit.
            EP_SLOW: u1,
            /// Set when USB Bus reset, USB suspend change or Connect change event occurs. Refer
            /// to Section 13.12.6 Set Device Status (Command: 0xFE, Data: write 1 byte) on page
            /// 366.
            DEV_STAT: u1,
            /// The command code register (USBCmdCode) is empty (New command can be written).
            CCEMPTY: u1,
            /// Command data register (USBCmdData) is full (Data can be read now).
            CDFULL: u1,
            /// The current packet in the endpoint buffer is transferred to the CPU.
            RxENDPKT: u1,
            /// The number of data bytes transferred to the endpoint buffer equals the number of
            /// bytes programmed in the TxPacket length register (USBTxPLen).
            TxENDPKT: u1,
            /// Endpoints realized. Set when Realize Endpoint register (USBReEp) or
            /// MaxPacketSize register (USBMaxPSize) is updated and the corresponding operation
            /// is completed.
            EP_RLZED: u1,
            /// Error Interrupt. Any bus error interrupt from the USB device. Refer to Section
            /// 13.12.9 Read Error Status (Command: 0xFB, Data: read 1 byte) on page 368
            ERR_INT: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u22,
        }), base_address + 0x200);

        /// address: 0x50008204
        /// USB Device Interrupt Enable
        pub const DEVINTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0 = No interrupt is generated. 1 = An interrupt will be generated when the
            /// corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table
            /// 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt
            /// line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the
            /// USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
            FRAMEEN: u1,
            /// 0 = No interrupt is generated. 1 = An interrupt will be generated when the
            /// corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table
            /// 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt
            /// line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the
            /// USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
            EP_FASTEN: u1,
            /// 0 = No interrupt is generated. 1 = An interrupt will be generated when the
            /// corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table
            /// 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt
            /// line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the
            /// USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
            EP_SLOWEN: u1,
            /// 0 = No interrupt is generated. 1 = An interrupt will be generated when the
            /// corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table
            /// 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt
            /// line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the
            /// USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
            DEV_STATEN: u1,
            /// 0 = No interrupt is generated. 1 = An interrupt will be generated when the
            /// corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table
            /// 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt
            /// line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the
            /// USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
            CCEMPTYEN: u1,
            /// 0 = No interrupt is generated. 1 = An interrupt will be generated when the
            /// corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table
            /// 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt
            /// line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the
            /// USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
            CDFULLEN: u1,
            /// 0 = No interrupt is generated. 1 = An interrupt will be generated when the
            /// corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table
            /// 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt
            /// line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the
            /// USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
            RxENDPKTEN: u1,
            /// 0 = No interrupt is generated. 1 = An interrupt will be generated when the
            /// corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table
            /// 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt
            /// line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the
            /// USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
            TxENDPKTEN: u1,
            /// 0 = No interrupt is generated. 1 = An interrupt will be generated when the
            /// corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table
            /// 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt
            /// line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the
            /// USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
            EP_RLZEDEN: u1,
            /// 0 = No interrupt is generated. 1 = An interrupt will be generated when the
            /// corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table
            /// 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt
            /// line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the
            /// USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
            ERR_INTEN: u1,
            /// Reserved
            RESERVED: u22,
        }), base_address + 0x204);

        /// address: 0x50008208
        /// USB Device Interrupt Clear
        pub const DEVINTCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// cleared.
            FRAMECLR: u1,
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// cleared.
            EP_FASTCLR: u1,
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// cleared.
            EP_SLOWCLR: u1,
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// cleared.
            DEV_STATCLR: u1,
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// cleared.
            CCEMPTYCLR: u1,
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// cleared.
            CDFULLCLR: u1,
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// cleared.
            RxENDPKTCLR: u1,
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// cleared.
            TxENDPKTCLR: u1,
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// cleared.
            EP_RLZEDCLR: u1,
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// cleared.
            ERR_INTCLR: u1,
            /// Reserved
            RESERVED: u22,
        }), base_address + 0x208);

        /// address: 0x5000820c
        /// USB Device Interrupt Set
        pub const DEVINTSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// set.
            FRAMESET: u1,
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// set.
            EP_FASTSET: u1,
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// set.
            EP_SLOWSET: u1,
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// set.
            DEV_STATSET: u1,
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// set.
            CCEMPTYSET: u1,
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// set.
            CDFULLSET: u1,
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// set.
            RxENDPKTSET: u1,
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// set.
            TxENDPKTSET: u1,
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// set.
            EP_RLZEDSET: u1,
            /// 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is
            /// set.
            ERR_INTSET: u1,
            /// Reserved
            RESERVED: u22,
        }), base_address + 0x20c);

        /// address: 0x50008210
        /// USB Command Code
        pub const CMDCODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u8,
            /// The command phase:
            CMD_PHASE: u8,
            /// This is a multi-purpose field. When CMD_PHASE is Command or Read, this field
            /// contains the code for the command (CMD_CODE). When CMD_PHASE is Write, this
            /// field contains the command write data (CMD_WDATA).
            CMD_CODE_WDATA: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u8,
        }), base_address + 0x210);

        /// address: 0x50008214
        /// USB Command Data
        pub const CMDDATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command Read Data.
            CMD_RDATA: u8,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u24,
        }), base_address + 0x214);

        /// address: 0x50008218
        /// USB Receive Data
        pub const RXDATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data received.
            RX_DATA: u32,
        }), base_address + 0x218);

        /// address: 0x5000821c
        /// USB Transmit Data
        pub const TXDATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Data.
            TX_DATA: u32,
        }), base_address + 0x21c);

        /// address: 0x500080dc
        /// USB Receive Packet Length
        pub const RXPLEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// The remaining number of bytes to be read from the currently selected endpoint's
            /// buffer. When this field decrements to 0, the RxENDPKT bit will be set in
            /// USBDevIntSt.
            PKT_LNGTH: u10,
            /// Data valid. This bit is useful for isochronous endpoints. Non-isochronous
            /// endpoints do not raise an interrupt when an erroneous data packet is received.
            /// But invalid data packet can be produced with a bus reset. For isochronous
            /// endpoints, data transfer will happen even if an erroneous packet is received. In
            /// this case DV bit will not be set for the packet.
            DV: u1,
            /// The PKT_LNGTH field is valid and the packet is ready for reading.
            PKT_RDY: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u20,
        }), base_address + 0xdc);

        /// address: 0x50008224
        /// USB Transmit Packet Length
        pub const TXPLEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// The remaining number of bytes to be written to the selected endpoint buffer.
            /// This field is decremented by 4 by hardware after each write to USBTxData. When
            /// this field decrements to 0, the TxENDPKT bit will be set in USBDevIntSt.
            PKT_LNGTH: u10,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u22,
        }), base_address + 0x224);

        /// address: 0x50008228
        /// USB Control
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read mode control. Enables reading data from the OUT endpoint buffer for the
            /// endpoint specified in the LOG_ENDPOINT field using the USBRxData register. This
            /// bit is cleared by hardware when the last word of the current packet is read from
            /// USBRxData.
            RD_EN: u1,
            /// Write mode control. Enables writing data to the IN endpoint buffer for the
            /// endpoint specified in the LOG_ENDPOINT field using the USBTxData register. This
            /// bit is cleared by hardware when the number of bytes in USBTxLen have been sent.
            WR_EN: u1,
            /// Logical Endpoint number.
            LOG_ENDPOINT: u4,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u26,
        }), base_address + 0x228);

        /// address: 0x5000822c
        /// USB Device Interrupt Priority
        pub const DEVINTPRI = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame interrupt routing
            FRAME: u1,
            /// Fast endpoint interrupt routing
            EP_FAST: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u30,
        }), base_address + 0x22c);

        /// address: 0x50008230
        /// USB Endpoint Interrupt Status
        pub const EPINTST = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST0: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST1: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST2: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST3: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST4: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST5: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST6: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST7: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST8: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST9: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST10: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST11: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST12: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST13: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST14: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST15: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST16: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST17: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST18: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST19: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST20: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST21: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST22: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST23: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST24: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST25: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST26: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST27: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST28: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST29: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST30: u1,
            /// 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5,
            /// ..., 31) Interrupt received.
            EPST31: u1,
        }), base_address + 0x230);

        /// address: 0x50008234
        /// USB Endpoint Interrupt Enable
        pub const EPINTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN0: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN1: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN2: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN3: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN4: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN5: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN6: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN7: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN8: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN9: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN10: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN11: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN12: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN13: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN14: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN15: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN16: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN17: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN18: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN19: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN20: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN21: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN22: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN23: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN24: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN25: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN26: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN27: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN28: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN29: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN30: u1,
            /// 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this
            /// endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt
            /// occurs for this endpoint. Implies Slave mode for this endpoint.
            EPEN31: u1,
        }), base_address + 0x234);

        /// address: 0x50008238
        /// USB Endpoint Interrupt Clear
        pub const EPINTCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR0: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR1: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR2: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR3: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR4: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR5: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR6: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR7: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR8: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR9: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR10: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR11: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR12: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR13: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR14: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR15: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR16: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR17: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR18: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR19: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR20: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR21: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR22: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR23: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR24: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR25: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR26: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR27: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR28: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR29: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR30: u1,
            /// 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the
            /// SIE Select Endpoint/Clear Interrupt command for this endpoint.
            EPCLR31: u1,
        }), base_address + 0x238);

        /// address: 0x5000823c
        /// USB Endpoint Interrupt Set
        pub const EPINTSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET0: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET1: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET2: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET3: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET4: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET5: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET6: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET7: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET8: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET9: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET10: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET11: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET12: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET13: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET14: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET15: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET16: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET17: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET18: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET19: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET20: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET21: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET22: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET23: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET24: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET25: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET26: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET27: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET28: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET29: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET30: u1,
            /// 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
            EPSET31: u1,
        }), base_address + 0x23c);

        /// address: 0x50008240
        /// USB Endpoint Priority
        pub const EPINTPRI = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI0: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI1: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI2: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI3: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI4: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI5: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI6: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI7: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI8: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI9: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI10: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI11: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI12: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI13: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI14: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI15: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI16: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI17: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI18: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI19: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI20: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI21: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI22: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI23: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI24: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI25: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI26: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI27: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI28: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI29: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI30: u1,
            /// 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 =
            /// The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
            EPPRI31: u1,
        }), base_address + 0x240);

        /// address: 0x50008244
        /// USB Realize Endpoint
        pub const REEP = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR0: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR1: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR2: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR3: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR4: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR5: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR6: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR7: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR8: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR9: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR10: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR11: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR12: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR13: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR14: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR15: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR16: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR17: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR18: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR19: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR20: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR21: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR22: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR23: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR24: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR25: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR26: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR27: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR28: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR29: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR30: u1,
            /// 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
            EPR31: u1,
        }), base_address + 0x244);

        /// address: 0x50008248
        /// USB Endpoint Index
        pub const EPIND = @intToPtr(*volatile Mmio(32, packed struct {
            /// Physical endpoint number (0-31)
            PHY_EP: u5,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u27,
        }), base_address + 0x248);

        /// address: 0x5000824c
        /// USB MaxPacketSize
        pub const MAXPSIZE = @intToPtr(*volatile Mmio(32, packed struct {
            /// The maximum packet size value.
            MPS: u10,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u22,
        }), base_address + 0x24c);

        /// address: 0x50008250
        /// USB DMA Request Status
        pub const DMARST = @intToPtr(*volatile Mmio(32, packed struct {
            /// Control endpoint OUT (DMA cannot be enabled for this endpoint and EP0 bit must
            /// be 0).
            EPRST0: u1,
            /// Control endpoint IN (DMA cannot be enabled for this endpoint and EP1 bit must be
            /// 0).
            EPRST1: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST2: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST3: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST4: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST5: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST6: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST7: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST8: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST9: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST10: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST11: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST12: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST13: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST14: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST15: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST16: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST17: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST18: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST19: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST20: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST21: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST22: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST23: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST24: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST25: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST26: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST27: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST28: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST29: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST30: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1
            /// = DMA requested by endpoint xx.
            EPRST31: u1,
        }), base_address + 0x250);

        /// address: 0x50008254
        /// USB DMA Request Clear
        pub const DMARCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Control endpoint OUT (DMA cannot be enabled for this endpoint and the EP0 bit
            /// must be 0).
            EPRCLR0: u1,
            /// Control endpoint IN (DMA cannot be enabled for this endpoint and the EP1 bit
            /// must be 0).
            EPRCLR1: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR2: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR3: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR4: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR5: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR6: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR7: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR8: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR9: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR10: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR11: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR12: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR13: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR14: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR15: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR16: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR17: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR18: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR19: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR20: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR21: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR22: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR23: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR24: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR25: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR26: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR27: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR28: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR29: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR30: u1,
            /// Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the
            /// corresponding bit in USBDMARSt.
            EPRCLR31: u1,
        }), base_address + 0x254);

        /// address: 0x50008258
        /// USB DMA Request Set
        pub const DMARSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Control endpoint OUT (DMA cannot be enabled for this endpoint and the EP0 bit
            /// must be 0).
            EPRSET0: u1,
            /// Control endpoint IN (DMA cannot be enabled for this endpoint and the EP1 bit
            /// must be 0).
            EPRSET1: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET2: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET3: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET4: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET5: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET6: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET7: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET8: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET9: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET10: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET11: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET12: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET13: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET14: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET15: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET16: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET17: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET18: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET19: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET20: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET21: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET22: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET23: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET24: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET25: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET26: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET27: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET28: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET29: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET30: u1,
            /// Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the
            /// corresponding bit in USBDMARSt.
            EPRSET31: u1,
        }), base_address + 0x258);

        /// address: 0x50008280
        /// USB UDCA Head
        pub const UDCAH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written. The UDCA is
            /// aligned to 128-byte boundaries.
            RESERVED: u7,
            /// Start address of the UDCA.
            UDCA_ADDR: u25,
        }), base_address + 0x280);

        /// address: 0x50008284
        /// USB Endpoint DMA Status
        pub const EPDMAST = @intToPtr(*volatile Mmio(32, packed struct {
            /// Control endpoint OUT (DMA cannot be enabled for this endpoint and the
            /// EP0_DMA_ENABLE bit must be 0).
            EP_DMA_ST0: u1,
            /// Control endpoint IN (DMA cannot be enabled for this endpoint and the
            /// EP1_DMA_ENABLE bit must be 0).
            EP_DMA_ST1: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST2: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST3: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST4: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST5: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST6: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST7: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST8: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST9: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST10: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST11: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST12: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST13: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST14: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST15: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST16: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST17: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST18: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST19: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST20: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST21: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST22: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST23: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST24: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST25: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST26: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST27: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST28: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST29: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST30: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is
            /// disabled. 1 = The DMA for endpoint EPxx is enabled.
            EP_DMA_ST31: u1,
        }), base_address + 0x284);

        /// address: 0x50008288
        /// USB Endpoint DMA Enable
        pub const EPDMAEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Control endpoint OUT (DMA cannot be enabled for this endpoint and the
            /// EP0_DMA_ENABLE bit value must be 0).
            EP_DMA_EN0: u1,
            /// Control endpoint IN (DMA cannot be enabled for this endpoint and the
            /// EP1_DMA_ENABLE bit must be 0).
            EP_DMA_EN1: u1,
            /// Endpoint xx(2 <= xx <= 31) DMA enable control bit. 0 = No effect. 1 = Enable the
            /// DMA operation for endpoint EPxx.
            EP_DMA_EN: u30,
        }), base_address + 0x288);

        /// address: 0x5000828c
        /// USB Endpoint DMA Disable
        pub const EPDMADIS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Control endpoint OUT (DMA cannot be enabled for this endpoint and the
            /// EP0_DMA_DISABLE bit value must be 0).
            EP_DMA_DIS0: u1,
            /// Control endpoint IN (DMA cannot be enabled for this endpoint and the
            /// EP1_DMA_DISABLE bit value must be 0).
            EP_DMA_DIS1: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS2: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS3: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS4: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS5: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS6: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS7: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS8: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS9: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS10: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS11: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS12: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS13: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS14: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS15: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS16: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS17: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS18: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS19: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS20: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS21: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS22: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS23: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS24: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS25: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS26: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS27: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS28: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS29: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS30: u1,
            /// Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable
            /// the DMA operation for endpoint EPxx.
            EP_DMA_DIS31: u1,
        }), base_address + 0x28c);

        /// address: 0x50008290
        /// USB DMA Interrupt Status
        pub const DMAINTST = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of Transfer Interrupt bit.
            EOT: u1,
            /// New DD Request Interrupt bit.
            NDDR: u1,
            /// System Error Interrupt bit.
            ERR: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u29,
        }), base_address + 0x290);

        /// address: 0x50008294
        /// USB DMA Interrupt Enable
        pub const DMAINTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of Transfer Interrupt enable bit.
            EOT: u1,
            /// New DD Request Interrupt enable bit.
            NDDR: u1,
            /// System Error Interrupt enable bit.
            ERR: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u29,
        }), base_address + 0x294);

        /// address: 0x500082a0
        /// USB End of Transfer Interrupt Status
        pub const EOTINTST = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST0: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST1: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST2: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST3: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST4: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST5: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST6: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST7: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST8: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST9: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST10: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST11: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST12: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST13: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST14: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST15: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST16: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST17: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST18: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST19: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST20: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST21: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST22: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST23: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST24: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST25: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST26: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST27: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST28: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST29: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST30: u1,
            /// Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no
            /// End of Transfer interrupt request for endpoint xx. 1 = There is an End of
            /// Transfer Interrupt request for endpoint xx.
            EPTXINTST31: u1,
        }), base_address + 0x2a0);

        /// address: 0x500082a4
        /// USB End of Transfer Interrupt Clear
        pub const EOTINTCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR0: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR1: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR2: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR3: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR4: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR5: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR6: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR7: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR8: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR9: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR10: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR11: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR12: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR13: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR14: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR15: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR16: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR17: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR18: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR19: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR20: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR21: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR22: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR23: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR24: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR25: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR26: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR27: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR28: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR29: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR30: u1,
            /// Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTCLR31: u1,
        }), base_address + 0x2a4);

        /// address: 0x500082a8
        /// USB End of Transfer Interrupt Set
        pub const EOTINTSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET0: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET1: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET2: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET3: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET4: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET5: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET6: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET7: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET8: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET9: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET10: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET11: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET12: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET13: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET14: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET15: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET16: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET17: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET18: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET19: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET20: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET21: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET22: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET23: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET24: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET25: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET26: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET27: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET28: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET29: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET30: u1,
            /// Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No
            /// effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt
            /// register.
            EPTXINTSET31: u1,
        }), base_address + 0x2a8);

        /// address: 0x500082ac
        /// USB New DD Request Interrupt Status
        pub const NDDRINTST = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST0: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST1: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST2: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST3: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST4: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST5: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST6: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST7: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST8: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST9: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST10: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST11: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST12: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST13: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST14: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST15: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST16: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST17: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST18: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST19: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST20: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST21: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST22: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST23: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST24: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST25: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST26: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST27: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST28: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST29: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST30: u1,
            /// Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD
            /// interrupt request for endpoint xx. 1 = There is a new DD interrupt request for
            /// endpoint xx.
            EPNDDINTST31: u1,
        }), base_address + 0x2ac);

        /// address: 0x500082b0
        /// USB New DD Request Interrupt Clear
        pub const NDDRINTCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR0: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR1: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR2: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR3: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR4: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR5: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR6: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR7: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR8: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR9: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR10: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR11: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR12: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR13: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR14: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR15: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR16: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR17: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR18: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR19: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR20: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR21: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR22: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR23: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR24: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR25: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR26: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR27: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR28: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR29: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR30: u1,
            /// Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 =
            /// Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTCLR31: u1,
        }), base_address + 0x2b0);

        /// address: 0x500082b4
        /// USB New DD Request Interrupt Set
        pub const NDDRINTSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET0: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET1: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET2: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET3: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET4: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET5: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET6: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET7: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET8: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET9: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET10: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET11: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET12: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET13: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET14: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET15: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET16: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET17: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET18: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET19: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET20: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET21: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET22: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET23: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET24: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET25: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET26: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET27: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET28: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET29: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET30: u1,
            /// Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set
            /// the EPxx new DD interrupt request in the USBNDDRIntSt register.
            EPNDDINTSET31: u1,
        }), base_address + 0x2b4);

        /// address: 0x500082b8
        /// USB System Error Interrupt Status
        pub const SYSERRINTST = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST0: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST1: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST2: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST3: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST4: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST5: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST6: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST7: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST8: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST9: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST10: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST11: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST12: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST13: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST14: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST15: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST16: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST17: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST18: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST19: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST20: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST21: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST22: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST23: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST24: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST25: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST26: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST27: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST28: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST29: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST30: u1,
            /// Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no
            /// System Error Interrupt request for endpoint xx. 1 = There is a System Error
            /// Interrupt request for endpoint xx.
            EPERRINTST31: u1,
        }), base_address + 0x2b8);

        /// address: 0x500082bc
        /// USB System Error Interrupt Clear
        pub const SYSERRINTCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR0: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR1: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR2: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR3: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR4: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR5: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR6: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR7: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR8: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR9: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR10: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR11: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR12: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR13: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR14: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR15: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR16: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR17: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR18: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR19: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR20: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR21: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR22: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR23: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR24: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR25: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR26: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR27: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR28: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR29: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR30: u1,
            /// Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect.
            /// 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt
            /// register.
            EPERRINTCLR31: u1,
        }), base_address + 0x2bc);

        /// address: 0x500082c0
        /// USB System Error Interrupt Set
        pub const SYSERRINTSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET0: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET1: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET2: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET3: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET4: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET5: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET6: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET7: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET8: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET9: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET10: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET11: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET12: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET13: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET14: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET15: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET16: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET17: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET18: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET19: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET20: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET21: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET22: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET23: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET24: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET25: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET26: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET27: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET28: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET29: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET30: u1,
            /// Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1
            /// = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
            EPERRINTSET31: u1,
        }), base_address + 0x2c0);

        /// address: 0x50008300
        /// I2C Receive
        pub const I2C_RX = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive data.
            RXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x300);

        /// address: 0x50008300
        /// I2C Transmit
        pub const I2C_WO = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data.
            TXDATA: u8,
            /// When 1, issue a START condition before transmitting this byte.
            START: u1,
            /// When 1, issue a STOP condition after transmitting this byte.
            STOP: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u22,
        }), base_address + 0x300);

        /// address: 0x50008304
        /// I2C Status
        pub const I2C_STS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transaction Done Interrupt. This flag is set if a transaction completes
            /// successfully. It is cleared by writing a one to bit 0 of the status register. It
            /// is unaffected by slave transactions.
            TDI: u1,
            /// Arbitration Failure Interrupt. When transmitting, if the SDA is low when SDAOUT
            /// is high, then this I2C has lost the arbitration to another device on the bus.
            /// The Arbitration Failure bit is set when this happens. It is cleared by writing a
            /// one to bit 1 of the status register.
            AFI: u1,
            /// No Acknowledge Interrupt. After every byte of data is sent, the transmitter
            /// expects an acknowledge from the receiver. This bit is set if the acknowledge is
            /// not received. It is cleared when a byte is written to the master TX FIFO.
            NAI: u1,
            /// Master Data Request Interrupt. Once a transmission is started, the transmitter
            /// must have data to transmit as long as it isn't followed by a stop condition or
            /// it will hold SCL low until more data is available. The Master Data Request bit
            /// is set when the master transmitter is data-starved. If the master TX FIFO is
            /// empty and the last byte did not have a STOP condition flag, then SCL is held low
            /// until the CPU writes another byte to transmit. This bit is cleared when a byte
            /// is written to the master TX FIFO.
            DRMI: u1,
            /// Slave Data Request Interrupt. Once a transmission is started, the transmitter
            /// must have data to transmit as long as it isn't followed by a STOP condition or
            /// it will hold SCL low until more data is available. The Slave Data Request bit is
            /// set when the slave transmitter is data-starved. If the slave TX FIFO is empty
            /// and the last byte transmitted was acknowledged, then SCL is held low until the
            /// CPU writes another byte to transmit. This bit is cleared when a byte is written
            /// to the slave Tx FIFO.
            DRSI: u1,
            /// Indicates whether the bus is busy. This bit is set when a START condition has
            /// been seen. It is cleared when a STOP condition is seen..
            Active: u1,
            /// The current value of the SCL signal.
            SCL: u1,
            /// The current value of the SDA signal.
            SDA: u1,
            /// Receive FIFO Full (RFF). This bit is set when the RX FIFO is full and cannot
            /// accept any more data. It is cleared when the RX FIFO is not full. If a byte
            /// arrives when the Receive FIFO is full, the SCL is held low until the CPU reads
            /// the RX FIFO and makes room for it.
            RFF: u1,
            /// Receive FIFO Empty. RFE is set when the RX FIFO is empty and is cleared when the
            /// RX FIFO contains valid data.
            RFE: u1,
            /// Transmit FIFO Full. TFF is set when the TX FIFO is full and is cleared when the
            /// TX FIFO is not full.
            TFF: u1,
            /// Transmit FIFO Empty. TFE is set when the TX FIFO is empty and is cleared when
            /// the TX FIFO contains valid data.
            TFE: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u20,
        }), base_address + 0x304);

        /// address: 0x50008308
        /// I2C Control
        pub const I2C_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Done Interrupt Enable. This enables the TDI interrupt signalling that
            /// this I2C issued a STOP condition.
            TDIE: u1,
            /// Transmitter Arbitration Failure Interrupt Enable. This enables the AFI interrupt
            /// which is asserted during transmission when trying to set SDA high, but the bus
            /// is driven low by another device.
            AFIE: u1,
            /// Transmitter No Acknowledge Interrupt Enable. This enables the NAI interrupt
            /// signalling that transmitted byte was not acknowledged.
            NAIE: u1,
            /// Master Transmitter Data Request Interrupt Enable. This enables the DRMI
            /// interrupt which signals that the master transmitter has run out of data, has not
            /// issued a STOP, and is holding the SCL line low.
            DRMIE: u1,
            /// Slave Transmitter Data Request Interrupt Enable. This enables the DRSI interrupt
            /// which signals that the slave transmitter has run out of data and the last byte
            /// was acknowledged, so the SCL line is being held low.
            DRSIE: u1,
            /// Receive FIFO Full Interrupt Enable. This enables the Receive FIFO Full interrupt
            /// to indicate that the receive FIFO cannot accept any more data.
            REFIE: u1,
            /// Receive Data Available Interrupt Enable. This enables the DAI interrupt to
            /// indicate that data is available in the receive FIFO (i.e. not empty).
            RFDAIE: u1,
            /// Transmit FIFO Not Full Interrupt Enable. This enables the Transmit FIFO Not Full
            /// interrupt to indicate that the more data can be written to the transmit FIFO.
            /// Note that this is not full. It is intended help the CPU to write to the I2C
            /// block only when there is room in the FIFO and do this without polling the status
            /// register.
            TFFIE: u1,
            /// Soft reset. This is only needed in unusual circumstances. If a device issues a
            /// start condition without issuing a stop condition. A system timer may be used to
            /// reset the I2C if the bus remains busy longer than the time-out period. On a soft
            /// reset, the Tx and Rx FIFOs are flushed, I2C_STS register is cleared, and all
            /// internal state machines are reset to appear idle. The I2C_CLKHI, I2C_CLKLO and
            /// I2C_CTL (except Soft Reset Bit) are NOT modified by a soft reset.
            SRST: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u23,
        }), base_address + 0x308);

        /// address: 0x5000830c
        /// I2C Clock High
        pub const I2C_CLKHI = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock divisor high. This value is the number of 48 MHz clocks the serial clock
            /// (SCL) will be high.
            CDHI: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x30c);

        /// address: 0x50008310
        /// I2C Clock Low
        pub const I2C_CLKLO = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock divisor low. This value is the number of 48 MHz clocks the serial clock
            /// (SCL) will be low.
            CDLO: u8,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u24,
        }), base_address + 0x310);

        /// address: 0x50008ff4
        /// USB Clock Control
        pub const USBCLKCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u1,
            /// Device clock enable. Enables the usbclk input to the device controller
            DEV_CLK_EN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u1,
            /// Port select register clock enable.
            PORTSEL_CLK_EN: u1,
            /// AHB clock enable
            AHB_CLK_EN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u27,
        }), base_address + 0xff4);

        /// address: 0x50008ff4
        /// OTG clock controller
        pub const OTGCLKCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Host clock enable
            HOST_CLK_EN: u1,
            /// Device clock enable
            DEV_CLK_EN: u1,
            /// I2C clock enable
            I2C_CLK_EN: u1,
            /// OTG clock enable. In device-only applications, this bit enables access to the
            /// PORTSEL register.
            OTG_CLK_EN: u1,
            /// AHB master clock enable
            AHB_CLK_EN: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u27,
        }), base_address + 0xff4);

        /// address: 0x50008ff8
        /// USB Clock Status
        pub const USBCLKST = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u1,
            /// Device clock on. The usbclk input to the device controller is active .
            DEV_CLK_ON: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u1,
            /// Port select register clock on.
            PORTSEL_CLK_ON: u1,
            /// AHB clock on.
            AHB_CLK_ON: u1,
            /// Reserved. The value read from a reserved bit is not defined.
            RESERVED: u27,
        }), base_address + 0xff8);

        /// address: 0x50008ff8
        /// OTG clock status
        pub const OTGCLKST = @intToPtr(*volatile Mmio(32, packed struct {
            /// Host clock status.
            HOST_CLK_ON: u1,
            /// Device clock status.
            DEV_CLK_ON: u1,
            /// I2C clock status.
            I2C_CLK_ON: u1,
            /// OTG clock status.
            OTG_CLK_ON: u1,
            /// AHB master clock status.
            AHB_CLK_ON: u1,
            /// Reserved. Read value is undefined, only zero should be written.
            RESERVED: u27,
        }), base_address + 0xff8);
    };
    /// General Purpose I/O
    pub const GPIO = struct {
        pub const base_address = 0x2009c000;

        /// address: 0x2009c000
        /// GPIO Port Direction control register.
        pub const DIR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR0: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR1: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR2: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR3: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR4: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR5: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR6: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR7: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR8: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR9: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR10: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR11: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR12: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR13: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR14: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR15: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR16: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR17: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR18: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR19: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR20: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR21: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR22: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR23: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR24: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR25: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR26: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR27: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR28: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR29: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR30: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR31: u1,
        }), base_address + 0x0);

        /// address: 0x2009c020
        /// GPIO Port Direction control register.
        pub const DIR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR0: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR1: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR2: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR3: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR4: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR5: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR6: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR7: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR8: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR9: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR10: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR11: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR12: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR13: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR14: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR15: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR16: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR17: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR18: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR19: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR20: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR21: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR22: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR23: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR24: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR25: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR26: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR27: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR28: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR29: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR30: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR31: u1,
        }), base_address + 0x20);

        /// address: 0x2009c040
        /// GPIO Port Direction control register.
        pub const DIR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR0: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR1: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR2: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR3: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR4: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR5: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR6: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR7: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR8: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR9: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR10: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR11: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR12: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR13: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR14: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR15: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR16: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR17: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR18: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR19: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR20: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR21: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR22: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR23: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR24: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR25: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR26: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR27: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR28: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR29: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR30: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR31: u1,
        }), base_address + 0x40);

        /// address: 0x2009c060
        /// GPIO Port Direction control register.
        pub const DIR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR0: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR1: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR2: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR3: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR4: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR5: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR6: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR7: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR8: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR9: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR10: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR11: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR12: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR13: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR14: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR15: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR16: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR17: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR18: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR19: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR20: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR21: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR22: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR23: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR24: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR25: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR26: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR27: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR28: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR29: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR30: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR31: u1,
        }), base_address + 0x60);

        /// address: 0x2009c080
        /// GPIO Port Direction control register.
        pub const DIR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR0: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR1: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR2: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR3: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR4: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR5: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR6: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR7: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR8: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR9: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR10: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR11: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR12: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR13: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR14: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR15: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR16: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR17: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR18: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR19: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR20: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR21: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR22: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR23: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR24: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR25: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR26: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR27: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR28: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR29: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR30: u1,
            /// Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31
            /// in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is
            /// output.
            PINDIR31: u1,
        }), base_address + 0x80);

        /// address: 0x2009c010
        /// Mask register for Port.
        pub const MASK0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK0: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK1: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK2: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK3: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK4: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK5: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK6: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK7: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK8: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK9: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK10: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK11: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK12: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK13: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK14: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK15: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK16: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK17: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK18: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK19: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK20: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK21: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK22: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK23: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK24: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK25: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK26: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK27: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK28: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK29: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK30: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK31: u1,
        }), base_address + 0x10);

        /// address: 0x2009c030
        /// Mask register for Port.
        pub const MASK1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK0: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK1: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK2: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK3: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK4: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK5: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK6: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK7: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK8: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK9: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK10: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK11: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK12: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK13: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK14: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK15: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK16: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK17: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK18: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK19: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK20: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK21: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK22: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK23: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK24: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK25: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK26: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK27: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK28: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK29: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK30: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK31: u1,
        }), base_address + 0x30);

        /// address: 0x2009c050
        /// Mask register for Port.
        pub const MASK2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK0: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK1: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK2: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK3: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK4: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK5: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK6: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK7: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK8: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK9: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK10: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK11: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK12: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK13: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK14: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK15: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK16: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK17: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK18: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK19: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK20: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK21: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK22: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK23: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK24: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK25: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK26: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK27: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK28: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK29: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK30: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK31: u1,
        }), base_address + 0x50);

        /// address: 0x2009c070
        /// Mask register for Port.
        pub const MASK3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK0: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK1: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK2: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK3: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK4: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK5: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK6: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK7: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK8: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK9: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK10: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK11: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK12: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK13: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK14: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK15: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK16: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK17: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK18: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK19: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK20: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK21: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK22: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK23: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK24: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK25: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK26: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK27: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK28: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK29: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK30: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK31: u1,
        }), base_address + 0x70);

        /// address: 0x2009c090
        /// Mask register for Port.
        pub const MASK4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK0: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK1: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK2: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK3: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK4: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK5: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK6: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK7: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK8: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK9: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK10: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK11: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK12: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK13: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK14: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK15: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK16: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK17: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK18: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK19: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK20: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK21: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK22: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK23: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK24: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK25: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK26: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK27: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK28: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK29: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK30: u1,
            /// Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes
            /// to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be
            /// read from the PINx register. 1 = Controlled pin is not affected by writes into
            /// the port's SETx, CLRx and PINx register(s). When the PINx register is read, this
            /// bit will not be updated with the state of the physical pin.
            PINMASK31: u1,
        }), base_address + 0x90);

        /// address: 0x2009c014
        /// Port Pin value register using FIOMASK.
        pub const PIN0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL0: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL1: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL2: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL3: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL4: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL5: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL6: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL7: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL8: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL9: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL10: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL11: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL12: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL13: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL14: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL15: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL16: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL17: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL18: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL19: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL20: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL21: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL22: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL23: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL24: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL25: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL26: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL27: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL28: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL29: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL30: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL31: u1,
        }), base_address + 0x14);

        /// address: 0x2009c034
        /// Port Pin value register using FIOMASK.
        pub const PIN1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL0: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL1: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL2: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL3: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL4: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL5: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL6: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL7: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL8: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL9: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL10: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL11: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL12: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL13: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL14: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL15: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL16: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL17: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL18: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL19: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL20: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL21: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL22: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL23: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL24: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL25: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL26: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL27: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL28: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL29: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL30: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL31: u1,
        }), base_address + 0x34);

        /// address: 0x2009c054
        /// Port Pin value register using FIOMASK.
        pub const PIN2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL0: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL1: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL2: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL3: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL4: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL5: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL6: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL7: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL8: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL9: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL10: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL11: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL12: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL13: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL14: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL15: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL16: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL17: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL18: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL19: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL20: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL21: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL22: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL23: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL24: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL25: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL26: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL27: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL28: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL29: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL30: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL31: u1,
        }), base_address + 0x54);

        /// address: 0x2009c074
        /// Port Pin value register using FIOMASK.
        pub const PIN3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL0: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL1: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL2: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL3: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL4: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL5: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL6: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL7: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL8: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL9: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL10: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL11: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL12: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL13: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL14: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL15: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL16: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL17: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL18: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL19: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL20: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL21: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL22: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL23: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL24: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL25: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL26: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL27: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL28: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL29: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL30: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL31: u1,
        }), base_address + 0x74);

        /// address: 0x2009c094
        /// Port Pin value register using FIOMASK.
        pub const PIN4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL0: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL1: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL2: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL3: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL4: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL5: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL6: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL7: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL8: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL9: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL10: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL11: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL12: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL13: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL14: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL15: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL16: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL17: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL18: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL19: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL20: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL21: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL22: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL23: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL24: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL25: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL26: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL27: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL28: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL29: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL30: u1,
            /// Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31
            /// in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 =
            /// Controlled pin output is set to HIGH.
            PINVAL31: u1,
        }), base_address + 0x94);

        /// address: 0x2009c018
        /// Port Output Set register using FIOMASK.
        pub const SET0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET0: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET1: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET2: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET3: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET4: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET5: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET6: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET7: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET8: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET9: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET10: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET11: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET12: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET13: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET14: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET15: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET16: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET17: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET18: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET19: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET20: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET21: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET22: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET23: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET24: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET25: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET26: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET27: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET28: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET29: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET30: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET31: u1,
        }), base_address + 0x18);

        /// address: 0x2009c038
        /// Port Output Set register using FIOMASK.
        pub const SET1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET0: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET1: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET2: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET3: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET4: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET5: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET6: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET7: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET8: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET9: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET10: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET11: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET12: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET13: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET14: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET15: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET16: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET17: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET18: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET19: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET20: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET21: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET22: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET23: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET24: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET25: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET26: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET27: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET28: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET29: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET30: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET31: u1,
        }), base_address + 0x38);

        /// address: 0x2009c058
        /// Port Output Set register using FIOMASK.
        pub const SET2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET0: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET1: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET2: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET3: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET4: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET5: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET6: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET7: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET8: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET9: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET10: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET11: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET12: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET13: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET14: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET15: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET16: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET17: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET18: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET19: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET20: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET21: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET22: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET23: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET24: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET25: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET26: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET27: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET28: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET29: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET30: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET31: u1,
        }), base_address + 0x58);

        /// address: 0x2009c078
        /// Port Output Set register using FIOMASK.
        pub const SET3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET0: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET1: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET2: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET3: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET4: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET5: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET6: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET7: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET8: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET9: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET10: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET11: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET12: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET13: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET14: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET15: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET16: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET17: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET18: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET19: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET20: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET21: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET22: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET23: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET24: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET25: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET26: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET27: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET28: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET29: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET30: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET31: u1,
        }), base_address + 0x78);

        /// address: 0x2009c098
        /// Port Output Set register using FIOMASK.
        pub const SET4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET0: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET1: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET2: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET3: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET4: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET5: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET6: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET7: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET8: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET9: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET10: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET11: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET12: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET13: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET14: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET15: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET16: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET17: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET18: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET19: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET20: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET21: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET22: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET23: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET24: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET25: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET26: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET27: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET28: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET29: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET30: u1,
            /// Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in
            /// SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to HIGH.
            PINSET31: u1,
        }), base_address + 0x98);

        /// address: 0x2009c01c
        /// Port Output Clear register using FIOMASK.
        pub const CLR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR0: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR1: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR2: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR3: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR4: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR5: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR6: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR7: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR8: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR9: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR10: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR11: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR12: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR13: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR14: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR15: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR16: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR17: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR18: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR19: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR20: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR21: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR22: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR23: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR24: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR25: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR26: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR27: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR28: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR29: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR30: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR31: u1,
        }), base_address + 0x1c);

        /// address: 0x2009c03c
        /// Port Output Clear register using FIOMASK.
        pub const CLR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR0: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR1: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR2: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR3: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR4: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR5: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR6: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR7: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR8: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR9: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR10: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR11: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR12: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR13: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR14: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR15: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR16: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR17: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR18: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR19: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR20: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR21: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR22: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR23: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR24: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR25: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR26: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR27: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR28: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR29: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR30: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR31: u1,
        }), base_address + 0x3c);

        /// address: 0x2009c05c
        /// Port Output Clear register using FIOMASK.
        pub const CLR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR0: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR1: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR2: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR3: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR4: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR5: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR6: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR7: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR8: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR9: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR10: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR11: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR12: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR13: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR14: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR15: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR16: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR17: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR18: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR19: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR20: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR21: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR22: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR23: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR24: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR25: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR26: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR27: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR28: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR29: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR30: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR31: u1,
        }), base_address + 0x5c);

        /// address: 0x2009c07c
        /// Port Output Clear register using FIOMASK.
        pub const CLR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR0: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR1: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR2: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR3: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR4: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR5: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR6: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR7: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR8: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR9: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR10: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR11: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR12: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR13: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR14: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR15: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR16: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR17: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR18: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR19: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR20: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR21: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR22: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR23: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR24: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR25: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR26: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR27: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR28: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR29: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR30: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR31: u1,
        }), base_address + 0x7c);

        /// address: 0x2009c09c
        /// Port Output Clear register using FIOMASK.
        pub const CLR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR0: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR1: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR2: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR3: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR4: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR5: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR6: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR7: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR8: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR9: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR10: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR11: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR12: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR13: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR14: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR15: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR16: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR17: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR18: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR19: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR20: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR21: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR22: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR23: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR24: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR25: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR26: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR27: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR28: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR29: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR30: u1,
            /// Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in
            /// CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled
            /// pin output is set to LOW.
            PINCLR31: u1,
        }), base_address + 0x9c);
    };
};

const std = @import("std");

pub fn mmio(addr: usize, comptime size: u8, comptime PackedT: type) *volatile Mmio(size, PackedT) {
    return @intToPtr(*volatile Mmio(size, PackedT), addr);
}

pub fn Mmio(comptime size: u8, comptime PackedT: type) type {
    if ((size % 8) != 0)
        @compileError("size must be divisible by 8!");

    if (!std.math.isPowerOfTwo(size / 8))
        @compileError("size must encode a power of two number of bytes!");

    const IntT = std.meta.Int(.unsigned, size);

    if (@sizeOf(PackedT) != (size / 8))
        @compileError(std.fmt.comptimePrint("IntT and PackedT must have the same size!, they are {} and {} bytes respectively", .{ size / 8, @sizeOf(PackedT) }));

    return extern struct {
        const Self = @This();

        raw: IntT,

        pub const underlying_type = PackedT;

        pub fn read(addr: *volatile Self) PackedT {
            return @bitCast(PackedT, addr.raw);
        }

        pub fn write(addr: *volatile Self, val: PackedT) void {
            // This is a workaround for a compiler bug related to miscompilation
            // If the tmp var is not used, result location will fuck things up
            var tmp = @bitCast(IntT, val);
            addr.raw = tmp;
        }

        pub fn modify(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, field.name) = @field(fields, field.name);
            }
            write(addr, val);
        }

        pub fn toggle(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, @tagName(field.default_value.?)) = !@field(val, @tagName(field.default_value.?));
            }
            write(addr, val);
        }
    };
}

pub fn MmioInt(comptime size: u8, comptime T: type) type {
    return extern struct {
        const Self = @This();

        raw: std.meta.Int(.unsigned, size),

        pub fn read(addr: *volatile Self) T {
            return @truncate(T, addr.raw);
        }

        pub fn modify(addr: *volatile Self, val: T) void {
            const Int = std.meta.Int(.unsigned, size);
            const mask = ~@as(Int, (1 << @bitSizeOf(T)) - 1);

            var tmp = addr.raw;
            addr.raw = (tmp & mask) | val;
        }
    };
}

pub fn mmioInt(addr: usize, comptime size: usize, comptime T: type) *volatile MmioInt(size, T) {
    return @intToPtr(*volatile MmioInt(size, T), addr);
}

pub const InterruptVector = extern union {
    C: fn () callconv(.C) void,
    Naked: fn () callconv(.Naked) void,
    // Interrupt is not supported on arm
};

const unhandled = InterruptVector{
    .C = struct {
        fn tmp() callconv(.C) noreturn {
            @panic("unhandled interrupt");
        }
    }.tmp,
};
