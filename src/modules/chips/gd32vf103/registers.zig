// this file was generated by regz: https://github.com/ZigEmbeddedGroup/regz
// commit: 341b0177d90a56f4307cc3226d552b39b048e7fa
//
// device: GD32VF103
// cpu: CM3

pub const VectorTable = extern struct {
    initial_stack_pointer: u32,
    Reset: InterruptVector = unhandled,
    NMI: InterruptVector = unhandled,
    HardFault: InterruptVector = unhandled,
    MemManage: InterruptVector = unhandled,
    BusFault: InterruptVector = unhandled,
    UsageFault: InterruptVector = unhandled,
    reserved0: [4]u32 = undefined,
    SVCall: InterruptVector = unhandled,
    reserved1: [2]u32 = undefined,
    PendSV: InterruptVector = unhandled,
    SysTick: InterruptVector = unhandled,
    reserved2: u32 = undefined,
    reserved3: u32 = undefined,
    reserved4: u32 = undefined,
    /// Software interrupt
    INT_SFT: InterruptVector = unhandled,
    reserved5: u32 = undefined,
    reserved6: u32 = undefined,
    reserved7: u32 = undefined,
    /// Timer interrupt
    INT_TMR: InterruptVector = unhandled,
    reserved8: u32 = undefined,
    reserved9: u32 = undefined,
    reserved10: u32 = undefined,
    reserved11: u32 = undefined,
    reserved12: u32 = undefined,
    reserved13: u32 = undefined,
    reserved14: u32 = undefined,
    reserved15: u32 = undefined,
    reserved16: u32 = undefined,
    /// Bus Error interrupt
    INT_BWEI: InterruptVector = unhandled,
    /// Performance Monitor interrupt
    INT_PMOVI: InterruptVector = unhandled,
    WWDGT: InterruptVector = unhandled,
    EXTI_LVD: InterruptVector = unhandled,
    Tamper: InterruptVector = unhandled,
    RTC: InterruptVector = unhandled,
    FMC: InterruptVector = unhandled,
    RCU: InterruptVector = unhandled,
    EXTI_Line0: InterruptVector = unhandled,
    EXTI_Line1: InterruptVector = unhandled,
    EXTI_Line2: InterruptVector = unhandled,
    EXTI_Line3: InterruptVector = unhandled,
    EXTI_Line4: InterruptVector = unhandled,
    DMA0_Channel0: InterruptVector = unhandled,
    DMA0_Channel1: InterruptVector = unhandled,
    DMA0_Channel2: InterruptVector = unhandled,
    DMA0_Channel3: InterruptVector = unhandled,
    DMA0_Channel4: InterruptVector = unhandled,
    DMA0_Channel5: InterruptVector = unhandled,
    DMA0_Channel6: InterruptVector = unhandled,
    ADC0_1: InterruptVector = unhandled,
    CAN0_TX: InterruptVector = unhandled,
    CAN0_RX0: InterruptVector = unhandled,
    CAN0_RX1: InterruptVector = unhandled,
    CAN0_EWMC: InterruptVector = unhandled,
    EXTI_line9_5: InterruptVector = unhandled,
    TIMER0_BRK: InterruptVector = unhandled,
    TIMER0_UP: InterruptVector = unhandled,
    TIMER0_TRG_CMT: InterruptVector = unhandled,
    TIMER0_Channel: InterruptVector = unhandled,
    TIMER1: InterruptVector = unhandled,
    TIMER2: InterruptVector = unhandled,
    TIMER3: InterruptVector = unhandled,
    I2C0_EV: InterruptVector = unhandled,
    I2C0_ER: InterruptVector = unhandled,
    I2C1_EV: InterruptVector = unhandled,
    I2C1_ER: InterruptVector = unhandled,
    SPI0: InterruptVector = unhandled,
    SPI1: InterruptVector = unhandled,
    USART0: InterruptVector = unhandled,
    USART1: InterruptVector = unhandled,
    USART2: InterruptVector = unhandled,
    EXTI_line15_10: InterruptVector = unhandled,
    RTC_Alarm: InterruptVector = unhandled,
    USBFS_WKUP: InterruptVector = unhandled,
    reserved17: u32 = undefined,
    reserved18: u32 = undefined,
    reserved19: u32 = undefined,
    reserved20: u32 = undefined,
    reserved21: u32 = undefined,
    reserved22: u32 = undefined,
    reserved23: u32 = undefined,
    TIMER4: InterruptVector = unhandled,
    SPI2: InterruptVector = unhandled,
    UART3: InterruptVector = unhandled,
    UART4: InterruptVector = unhandled,
    TIMER5: InterruptVector = unhandled,
    TIMER6: InterruptVector = unhandled,
    DMA1_Channel0: InterruptVector = unhandled,
    DMA1_Channel1: InterruptVector = unhandled,
    DMA1_Channel2: InterruptVector = unhandled,
    DMA1_Channel3: InterruptVector = unhandled,
    DMA1_Channel4: InterruptVector = unhandled,
    reserved24: u32 = undefined,
    reserved25: u32 = undefined,
    CAN1_TX: InterruptVector = unhandled,
    CAN1_RX0: InterruptVector = unhandled,
    CAN1_RX1: InterruptVector = unhandled,
    CAN1_EWMC: InterruptVector = unhandled,
    USBFS: InterruptVector = unhandled,
};

pub const registers = struct {
    /// System Control Space
    pub const SCS = struct {
        pub const base_address = 0xe000e000;

        /// System Tick Timer
        pub const SysTick = struct {
            /// address: 0xe000e010
            /// SysTick Control and Status Register
            pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
                ENABLE: u1,
                TICKINT: u1,
                CLKSOURCE: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                COUNTFLAG: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
            }), base_address + 0x10);

            /// address: 0xe000e014
            /// SysTick Reload Value Register
            pub const LOAD = @intToPtr(*volatile Mmio(32, packed struct {
                RELOAD: u24,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x14);

            /// address: 0xe000e018
            /// SysTick Current Value Register
            pub const VAL = @intToPtr(*volatile Mmio(32, packed struct {
                CURRENT: u24,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x18);

            /// address: 0xe000e01c
            /// SysTick Calibration Register
            pub const CALIB = @intToPtr(*volatile Mmio(32, packed struct {
                TENMS: u24,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                SKEW: u1,
                NOREF: u1,
            }), base_address + 0x1c);
        };
    };

    /// Analog to digital converter
    pub const ADC0 = struct {
        pub const base_address = 0x40012400;

        /// address: 0x40012400
        /// status register
        pub const STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog event flag
            WDE: u1,
            /// End of group conversion flag
            EOC: u1,
            /// End of inserted group conversion flag
            EOIC: u1,
            /// Start flag of inserted channel group
            STIC: u1,
            /// Start flag of regular channel group
            STRC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x0);

        /// address: 0x40012404
        /// control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog channel select
            WDCHSEL: u5,
            /// Interrupt enable for EOC
            EOCIE: u1,
            /// Interrupt enable for WDE
            WDEIE: u1,
            /// Interrupt enable for EOIC
            EOICIE: u1,
            /// Scan mode
            SM: u1,
            /// When in scan mode, analog watchdog
            /// is effective on a single channel
            WDSC: u1,
            /// Inserted channel group convert
            /// automatically
            ICA: u1,
            /// Discontinuous mode on regular
            /// channels
            DISRC: u1,
            /// Discontinuous mode on
            /// inserted channels
            DISIC: u1,
            /// Number of conversions in
            /// discontinuous mode
            DISNUM: u3,
            /// sync mode selection
            SYNCM: u4,
            reserved0: u1,
            reserved1: u1,
            /// Inserted channel analog watchdog
            /// enable
            IWDEN: u1,
            /// Regular channel analog watchdog enable
            RWDEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40012408
        /// control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC on
            ADCON: u1,
            /// Continuous mode
            CTN: u1,
            /// ADC calibration
            CLB: u1,
            /// Reset calibration
            RSTCLB: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DMA request enable
            DMA: u1,
            reserved4: u1,
            reserved5: u1,
            /// Data alignment
            DAL: u1,
            /// External trigger select for inserted channel
            ETSIC: u3,
            /// External trigger select for inserted channel
            ETEIC: u1,
            reserved6: u1,
            /// External trigger select for regular channel
            ETSRC: u3,
            /// External trigger enable for regular channel
            ETERC: u1,
            /// Start on inserted channel
            SWICST: u1,
            /// Start on regular channel
            SWRCST: u1,
            /// Channel 16 and 17 enable of ADC0
            TSVREN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x8);

        /// address: 0x4001240c
        /// Sample time register 0
        pub const SAMPT0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 10 sample time
            /// selection
            SPT10: u3,
            /// Channel 11 sample time
            /// selection
            SPT11: u3,
            /// Channel 12 sample time
            /// selection
            SPT12: u3,
            /// Channel 13 sample time
            /// selection
            SPT13: u3,
            /// Channel 14 sample time
            /// selection
            SPT14: u3,
            /// Channel 15 sample time
            /// selection
            SPT15: u3,
            /// Channel 16 sample time
            /// selection
            SPT16: u3,
            /// Channel 17 sample time
            /// selection
            SPT17: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xc);

        /// address: 0x40012410
        /// Sample time register 1
        pub const SAMPT1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 0 sample time
            /// selection
            SPT0: u3,
            /// Channel 1 sample time
            /// selection
            SPT1: u3,
            /// Channel 2 sample time
            /// selection
            SPT2: u3,
            /// Channel 3 sample time
            /// selection
            SPT3: u3,
            /// Channel 4 sample time
            /// selection
            SPT4: u3,
            /// Channel 5 sample time
            /// selection
            SPT5: u3,
            /// Channel 6 sample time
            /// selection
            SPT6: u3,
            /// Channel 7 sample time
            /// selection
            SPT7: u3,
            /// Channel 8 sample time
            /// selection
            SPT8: u3,
            /// Channel 9 sample time
            /// selection
            SPT9: u3,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x10);

        /// address: 0x40012414
        /// Inserted channel data offset register
        /// 0
        pub const IOFF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for inserted channel
            /// 0
            IOFF: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x14);

        /// address: 0x40012418
        /// Inserted channel data offset register
        /// 1
        pub const IOFF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for inserted channel
            /// 1
            IOFF: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x18);

        /// address: 0x4001241c
        /// Inserted channel data offset register
        /// 2
        pub const IOFF2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for inserted channel
            /// 2
            IOFF: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40012420
        /// Inserted channel data offset register
        /// 3
        pub const IOFF3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for inserted channel
            /// 3
            IOFF: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x20);

        /// address: 0x40012424
        /// watchdog higher threshold
        /// register
        pub const WDHT = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x24);

        /// address: 0x40012428
        /// watchdog lower threshold
        /// register
        pub const WDLT = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x28);

        /// address: 0x4001242c
        /// regular sequence register 0
        pub const RSQ0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 13th conversion in regular
            /// sequence
            RSQ12: u5,
            /// 14th conversion in regular
            /// sequence
            RSQ13: u5,
            /// 15th conversion in regular
            /// sequence
            RSQ14: u5,
            /// 16th conversion in regular
            /// sequence
            RSQ15: u5,
            /// Regular channel group
            /// length
            RL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x2c);

        /// address: 0x40012430
        /// regular sequence register 1
        pub const RSQ1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7th conversion in regular
            /// sequence
            RSQ6: u5,
            /// 8th conversion in regular
            /// sequence
            RSQ7: u5,
            /// 9th conversion in regular
            /// sequence
            RSQ8: u5,
            /// 10th conversion in regular
            /// sequence
            RSQ9: u5,
            /// 11th conversion in regular
            /// sequence
            RSQ10: u5,
            /// 12th conversion in regular
            /// sequence
            RSQ11: u5,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x30);

        /// address: 0x40012434
        /// regular sequence register 2
        pub const RSQ2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1st conversion in regular
            /// sequence
            RSQ0: u5,
            /// 2nd conversion in regular
            /// sequence
            RSQ1: u5,
            /// 3rd conversion in regular
            /// sequence
            RSQ2: u5,
            /// 4th conversion in regular
            /// sequence
            RSQ3: u5,
            /// 5th conversion in regular
            /// sequence
            RSQ4: u5,
            /// 6th conversion in regular
            /// sequence
            RSQ5: u5,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x34);

        /// address: 0x40012438
        /// Inserted sequence register
        pub const ISQ = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1st conversion in inserted
            /// sequence
            ISQ0: u5,
            /// 2nd conversion in inserted
            /// sequence
            ISQ1: u5,
            /// 3rd conversion in inserted
            /// sequence
            ISQ2: u5,
            /// 4th conversion in inserted
            /// sequence
            ISQ3: u5,
            /// Inserted channel group length
            IL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x38);

        /// address: 0x4001243c
        /// Inserted data register 0
        pub const IDATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Inserted number n conversion data
            IDATAn: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x3c);

        /// address: 0x40012440
        /// Inserted data register 1
        pub const IDATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Inserted number n conversion data
            IDATAn: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x40012444
        /// Inserted data register 2
        pub const IDATA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Inserted number n conversion data
            IDATAn: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);

        /// address: 0x40012448
        /// Inserted data register 3
        pub const IDATA3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Inserted number n conversion data
            IDATAn: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4001244c
        /// regular data register
        pub const RDATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Regular channel data
            RDATA: u16,
            /// ADC regular channel data
            ADC1RDTR: u16,
        }), base_address + 0x4c);

        /// address: 0x40012480
        /// Oversample control register
        pub const OVSAMPCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Oversampler Enable
            OVSEN: u1,
            reserved0: u1,
            /// Oversampling ratio
            OVSR: u3,
            /// Oversampling shift
            OVSS: u4,
            /// Triggered Oversampling
            TOVS: u1,
            reserved1: u1,
            reserved2: u1,
            /// ADC resolution
            DRES: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x80);
    };

    /// Analog to digital converter
    pub const ADC1 = struct {
        pub const base_address = 0x40012800;

        /// address: 0x40012800
        /// status register
        pub const STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog event flag
            WDE: u1,
            /// End of group conversion flag
            EOC: u1,
            /// End of inserted group conversion flag
            EOIC: u1,
            /// Start flag of inserted channel group
            STIC: u1,
            /// Start flag of regular channel group
            STRC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x0);

        /// address: 0x40012804
        /// control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog channel select
            WDCHSEL: u5,
            /// Interrupt enable for EOC
            EOCIE: u1,
            /// Interrupt enable for WDE
            WDEIE: u1,
            /// Interrupt enable for EOIC
            EOICIE: u1,
            /// Scan mode
            SM: u1,
            /// When in scan mode, analog watchdog
            /// is effective on a single channel
            WDSC: u1,
            /// Inserted channel group convert
            /// automatically
            ICA: u1,
            /// Discontinuous mode on regular
            /// channels
            DISRC: u1,
            /// Discontinuous mode on
            /// inserted channels
            DISIC: u1,
            /// Number of conversions in
            /// discontinuous mode
            DISNUM: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Inserted channel analog watchdog
            /// enable
            IWDEN: u1,
            /// Regular channel analog watchdog
            /// enable
            RWDEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40012808
        /// control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC on
            ADCON: u1,
            /// Continuous mode
            CTN: u1,
            /// ADC calibration
            CLB: u1,
            /// Reset calibration
            RSTCLB: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DMA request enable
            DMA: u1,
            reserved4: u1,
            reserved5: u1,
            /// Data alignment
            DAL: u1,
            /// External trigger select for inserted channel
            ETSIC: u3,
            /// External trigger enable for inserted channel
            ETEIC: u1,
            reserved6: u1,
            /// External trigger select for regular channel
            ETSRC: u3,
            /// External trigger enable for regular channel
            ETERC: u1,
            /// Start on inserted channel
            SWICST: u1,
            /// Start on regular channel
            SWRCST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4001280c
        /// Sample time register 0
        pub const SAMPT0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 10 sample time
            /// selection
            SPT10: u3,
            /// Channel 11 sample time
            /// selection
            SPT11: u3,
            /// Channel 12 sample time
            /// selection
            SPT12: u3,
            /// Channel 13 sample time
            /// selection
            SPT13: u3,
            /// Channel 14 sample time
            /// selection
            SPT14: u3,
            /// Channel 15 sample time
            /// selection
            SPT15: u3,
            /// Channel 16 sample time
            /// selection
            SPT16: u3,
            /// Channel 17 sample time
            /// selection
            SPT17: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xc);

        /// address: 0x40012810
        /// Sample time register 1
        pub const SAMPT1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 0 sample time
            /// selection
            SPT0: u3,
            /// Channel 1 sample time
            /// selection
            SPT1: u3,
            /// Channel 2 sample time
            /// selection
            SPT2: u3,
            /// Channel 3 sample time
            /// selection
            SPT3: u3,
            /// Channel 4 sample time
            /// selection
            SPT4: u3,
            /// Channel 5 sample time
            /// selection
            SPT5: u3,
            /// Channel 6 sample time
            /// selection
            SPT6: u3,
            /// Channel 7 sample time
            /// selection
            SPT7: u3,
            /// Channel 8 sample time
            /// selection
            SPT8: u3,
            /// Channel 9 sample time
            /// selection
            SPT9: u3,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x10);

        /// address: 0x40012814
        /// Inserted channel data offset register
        /// 0
        pub const IOFF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for inserted channel
            /// 0
            IOFF: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x14);

        /// address: 0x40012818
        /// Inserted channel data offset register
        /// 1
        pub const IOFF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for inserted channel
            /// 1
            IOFF: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x18);

        /// address: 0x4001281c
        /// Inserted channel data offset register
        /// 2
        pub const IOFF2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for inserted channel
            /// 2
            IOFF: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40012820
        /// Inserted channel data offset register
        /// 3
        pub const IOFF3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for inserted channel
            /// 3
            IOFF: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x20);

        /// address: 0x40012824
        /// watchdog higher threshold
        /// register
        pub const WDHT = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x24);

        /// address: 0x40012828
        /// watchdog lower threshold
        /// register
        pub const WDLT = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x28);

        /// address: 0x4001282c
        /// regular sequence register 0
        pub const RSQ0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 13th conversion in regular
            /// sequence
            RSQ12: u5,
            /// 14th conversion in regular
            /// sequence
            RSQ13: u5,
            /// 15th conversion in regular
            /// sequence
            RSQ14: u5,
            /// 16th conversion in regular
            /// sequence
            RSQ15: u5,
            /// Regular channel group
            /// length
            RL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x2c);

        /// address: 0x40012830
        /// regular sequence register 1
        pub const RSQ1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7th conversion in regular
            /// sequence
            RSQ6: u5,
            /// 8th conversion in regular
            /// sequence
            RSQ7: u5,
            /// 9th conversion in regular
            /// sequence
            RSQ8: u5,
            /// 10th conversion in regular
            /// sequence
            RSQ9: u5,
            /// 11th conversion in regular
            /// sequence
            RSQ10: u5,
            /// 12th conversion in regular
            /// sequence
            RSQ11: u5,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x30);

        /// address: 0x40012834
        /// regular sequence register 2
        pub const RSQ2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1st conversion in regular
            /// sequence
            RSQ0: u5,
            /// 2nd conversion in regular
            /// sequence
            RSQ1: u5,
            /// 3rd conversion in regular
            /// sequence
            RSQ2: u5,
            /// 4th conversion in regular
            /// sequence
            RSQ3: u5,
            /// 5th conversion in regular
            /// sequence
            RSQ4: u5,
            /// 6th conversion in regular
            /// sequence
            RSQ5: u5,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x34);

        /// address: 0x40012838
        /// Inserted sequence register
        pub const ISQ = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1st conversion in inserted
            /// sequence
            ISQ0: u5,
            /// 2nd conversion in inserted
            /// sequence
            ISQ1: u5,
            /// 3rd conversion in inserted
            /// sequence
            ISQ2: u5,
            /// 4th conversion in inserted
            /// sequence
            ISQ3: u5,
            /// Inserted channel group length
            IL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x38);

        /// address: 0x4001283c
        /// Inserted data register 0
        pub const IDATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Inserted number n conversion data
            IDATAn: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x3c);

        /// address: 0x40012840
        /// Inserted data register 1
        pub const IDATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Inserted number n conversion data
            IDATAn: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x40012844
        /// Inserted data register 2
        pub const IDATA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Inserted number n conversion data
            IDATAn: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);

        /// address: 0x40012848
        /// Inserted data register 3
        pub const IDATA3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Inserted number n conversion data
            IDATAn: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4001284c
        /// regular data register
        pub const RDATA = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x4c);
    };

    /// Alternate-function I/Os
    pub const AFIO = struct {
        pub const base_address = 0x40010000;

        /// address: 0x40010000
        /// Event control register
        pub const EC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Event output pin selection
            PIN: u4,
            /// Event output port selection
            PORT: u3,
            /// Event output enable
            EOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40010004
        /// AFIO port configuration register 0
        pub const PCF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SPI0 remapping
            SPI0_REMAP: u1,
            /// I2C0 remapping
            I2C0_REMAP: u1,
            /// USART0 remapping
            USART0_REMAP: u1,
            /// USART1 remapping
            USART1_REMAP: u1,
            /// USART2 remapping
            USART2_REMAP: u2,
            /// TIMER0 remapping
            TIMER0_REMAP: u2,
            /// TIMER1 remapping
            TIMER1_REMAP: u2,
            /// TIMER2 remapping
            TIMER2_REMAP: u2,
            /// TIMER3 remapping
            TIMER3_REMAP: u1,
            /// CAN0 alternate interface remapping
            CAN0_REMAP: u2,
            /// Port D0/Port D1 mapping on OSC_IN/OSC_OUT
            PD01_REMAP: u1,
            /// TIMER4 channel3 internal remapping
            TIMER4CH3_IREMAP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// CAN1 I/O remapping
            CAN1_REMAP: u1,
            reserved5: u1,
            /// Serial wire JTAG configuration
            SWJ_CFG: u3,
            reserved6: u1,
            /// SPI2/I2S2 remapping
            SPI2_REMAP: u1,
            /// TIMER1 internal trigger 1 remapping
            TIMER1ITI1_REMAP: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x4);

        /// address: 0x40010008
        /// EXTI sources selection register 0
        pub const EXTISS0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI 0 sources selection
            EXTI0_SS: u4,
            /// EXTI 1 sources selection
            EXTI1_SS: u4,
            /// EXTI 2 sources selection
            EXTI2_SS: u4,
            /// EXTI 3 sources selection
            EXTI3_SS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001000c
        /// EXTI sources selection register 1
        pub const EXTISS1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI 4 sources selection
            EXTI4_SS: u4,
            /// EXTI 5 sources selection
            EXTI5_SS: u4,
            /// EXTI 6 sources selection
            EXTI6_SS: u4,
            /// EXTI 7 sources selection
            EXTI7_SS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40010010
        /// EXTI sources selection register 2
        pub const EXTISS2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI 8 sources selection
            EXTI8_SS: u4,
            /// EXTI 9 sources selection
            EXTI9_SS: u4,
            /// EXTI 10 sources selection
            EXTI10_SS: u4,
            /// EXTI 11 sources selection
            EXTI11_SS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40010014
        /// EXTI sources selection register 3
        pub const EXTISS3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI 12 sources selection
            EXTI12_SS: u4,
            /// EXTI 13 sources selection
            EXTI13_SS: u4,
            /// EXTI 14 sources selection
            EXTI14_SS: u4,
            /// EXTI 15 sources selection
            EXTI15_SS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x4001001c
        /// AFIO port configuration register 1
        pub const PCF1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// EXMC_NADV connect/disconnect
            EXMC_NADV: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1c);
    };

    /// Backup registers
    pub const BKP = struct {
        pub const base_address = 0x40006c00;

        /// address: 0x40006c04
        /// Backup data register 0
        pub const DATA0 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x4);

        /// address: 0x40006c08
        /// Backup data register 1
        pub const DATA1 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x8);

        /// address: 0x40006c0c
        /// Backup data register 2
        pub const DATA2 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0xc);

        /// address: 0x40006c10
        /// Backup data register 3
        pub const DATA3 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x10);

        /// address: 0x40006c14
        /// Backup data register 4
        pub const DATA4 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x14);

        /// address: 0x40006c18
        /// Backup data register 5
        pub const DATA5 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x18);

        /// address: 0x40006c1c
        /// Backup data register 6
        pub const DATA6 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x1c);

        /// address: 0x40006c20
        /// Backup data register 7
        pub const DATA7 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x20);

        /// address: 0x40006c24
        /// Backup data register 8
        pub const DATA8 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x24);

        /// address: 0x40006c28
        /// Backup data register 9
        pub const DATA9 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x28);

        /// address: 0x40006c40
        /// Backup data register 10
        pub const DATA10 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x40);

        /// address: 0x40006c44
        /// Backup data register 11
        pub const DATA11 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x44);

        /// address: 0x40006c48
        /// Backup data register 12
        pub const DATA12 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x48);

        /// address: 0x40006c4c
        /// Backup data register 13
        pub const DATA13 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x4c);

        /// address: 0x40006c50
        /// Backup data register 14
        pub const DATA14 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x50);

        /// address: 0x40006c54
        /// Backup data register 15
        pub const DATA15 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x54);

        /// address: 0x40006c58
        /// Backup data register 16
        pub const DATA16 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x58);

        /// address: 0x40006c5c
        /// Backup data register 17
        pub const DATA17 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x5c);

        /// address: 0x40006c60
        /// Backup data register 18
        pub const DATA18 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x60);

        /// address: 0x40006c64
        /// Backup data register 19
        pub const DATA19 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x64);

        /// address: 0x40006c68
        /// Backup data register 20
        pub const DATA20 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x68);

        /// address: 0x40006c6c
        /// Backup data register 21
        pub const DATA21 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x6c);

        /// address: 0x40006c70
        /// Backup data register 22
        pub const DATA22 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x70);

        /// address: 0x40006c74
        /// Backup data register 23
        pub const DATA23 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x74);

        /// address: 0x40006c78
        /// Backup data register 24
        pub const DATA24 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x78);

        /// address: 0x40006c7c
        /// Backup data register 25
        pub const DATA25 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x7c);

        /// address: 0x40006c80
        /// Backup data register 26
        pub const DATA26 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x80);

        /// address: 0x40006c84
        /// Backup data register 27
        pub const DATA27 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x84);

        /// address: 0x40006c88
        /// Backup data register 28
        pub const DATA28 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x88);

        /// address: 0x40006c8c
        /// Backup data register 29
        pub const DATA29 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x8c);

        /// address: 0x40006c90
        /// Backup data register 30
        pub const DATA30 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x90);

        /// address: 0x40006c94
        /// Backup data register 31
        pub const DATA31 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x94);

        /// address: 0x40006c98
        /// Backup data register 32
        pub const DATA32 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x98);

        /// address: 0x40006c9c
        /// Backup data register 33
        pub const DATA33 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0x9c);

        /// address: 0x40006ca0
        /// Backup data register 34
        pub const DATA34 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0xa0);

        /// address: 0x40006ca4
        /// Backup data register 35
        pub const DATA35 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0xa4);

        /// address: 0x40006ca8
        /// Backup data register 36
        pub const DATA36 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0xa8);

        /// address: 0x40006cac
        /// Backup data register 37
        pub const DATA37 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0xac);

        /// address: 0x40006cb0
        /// Backup data register 38
        pub const DATA38 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0xb0);

        /// address: 0x40006cb4
        /// Backup data register 39
        pub const DATA39 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0xb4);

        /// address: 0x40006cb8
        /// Backup data register 40
        pub const DATA40 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0xb8);

        /// address: 0x40006cbc
        /// Backup data register 41
        pub const DATA41 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Backup data
            DATA: u16,
        }), base_address + 0xbc);

        /// address: 0x40006c2c
        /// RTC signal output control register
        pub const OCTL = @intToPtr(*volatile Mmio(16, packed struct {
            /// RTC clock calibration value
            RCCV: u7,
            /// RTC clock calibration output enable
            COEN: u1,
            /// RTC alarm or second signal output enable
            ASOEN: u1,
            /// RTC output selection
            ROSEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x2c);

        /// address: 0x40006c30
        /// Tamper pin control register
        pub const TPCTL = @intToPtr(*volatile Mmio(16, packed struct {
            /// TAMPER detection enable
            TPEN: u1,
            /// TAMPER pin active level
            TPAL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x30);

        /// address: 0x40006c34
        /// Tamper control and status register
        pub const TPCS = @intToPtr(*volatile Mmio(16, packed struct {
            /// Tamper event reset
            TER: u1,
            /// Tamper interrupt reset
            TIR: u1,
            /// Tamper interrupt enable
            TPIE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Tamper event flag
            TEF: u1,
            /// Tamper interrupt flag
            TIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x34);
    };

    /// Controller area network
    pub const CAN0 = struct {
        pub const base_address = 0x40006400;

        /// address: 0x40006400
        /// Control register
        pub const CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Initial working mode
            IWMOD: u1,
            /// Sleep working mode
            SLPWMOD: u1,
            /// Transmit FIFO order
            TFO: u1,
            /// Receive FIFO overwrite disable
            RFOD: u1,
            /// Automatic retransmission disable
            ARD: u1,
            /// Automatic wakeup
            AWU: u1,
            /// Automatic bus-off recovery
            ABOR: u1,
            /// Time-triggered communication
            TTC: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Software reset
            SWRST: u1,
            /// Debug freeze
            DFZ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x0);

        /// address: 0x40006404
        /// Status register
        pub const STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Initial working state
            IWS: u1,
            /// Sleep working state
            SLPWS: u1,
            /// Error interrupt flag
            ERRIF: u1,
            /// Status change interrupt flag of wakeup
            /// from sleep working mode
            WUIF: u1,
            /// Status change interrupt flag of sleep
            /// working mode entering
            SLPIF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Transmitting state
            TS: u1,
            /// Receiving state
            RS: u1,
            /// Last sample value of RX pin
            LASTRX: u1,
            /// RX level
            RXL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x4);

        /// address: 0x40006408
        /// Transmit status register
        pub const TSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Mailbox 0 transmit finished
            MTF0: u1,
            /// Mailbox 0 transmit finished and no error
            MTFNERR0: u1,
            /// Mailbox 0 arbitration lost
            MAL0: u1,
            /// Mailbox 0 transmit error
            MTE0: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Mailbox 0 stop transmitting
            MST0: u1,
            /// Mailbox 1 transmit finished
            MTF1: u1,
            /// Mailbox 1 transmit finished and no error
            MTFNERR1: u1,
            /// Mailbox 1 arbitration lost
            MAL1: u1,
            /// Mailbox 1 transmit error
            MTE1: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Mailbox 1 stop transmitting
            MST1: u1,
            /// Mailbox 2 transmit finished
            MTF2: u1,
            /// Mailbox 2 transmit finished and no error
            MTFNERR2: u1,
            /// Mailbox 2 arbitration lost
            MAL2: u1,
            /// Mailbox 2 transmit error
            MTE2: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Mailbox 2 stop transmitting
            MST2: u1,
            /// number of the transmit FIFO mailbox in
            /// which the frame will be transmitted if at least one mailbox is empty
            NUM: u2,
            /// Transmit mailbox 0 empty
            TME0: u1,
            /// Transmit mailbox 1 empty
            TME1: u1,
            /// Transmit mailbox 2 empty
            TME2: u1,
            /// Transmit mailbox 0 last sending
            /// in transmit FIFO
            TMLS0: u1,
            /// Transmit mailbox 1 last sending
            /// in transmit FIFO
            TMLS1: u1,
            /// Transmit mailbox 2 last sending
            /// in transmit FIFO
            TMLS2: u1,
        }), base_address + 0x8);

        /// address: 0x4000640c
        /// Receive message FIFO0 register
        pub const RFIFO0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive FIFO0 length
            RFL0: u2,
            reserved0: u1,
            /// Receive FIFO0 full
            RFF0: u1,
            /// Receive FIFO0 overfull
            RFO0: u1,
            /// Receive FIFO0 dequeue
            RFD0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xc);

        /// address: 0x40006410
        /// Receive message FIFO1 register
        pub const RFIFO1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive FIFO1 length
            RFL1: u2,
            reserved0: u1,
            /// Receive FIFO1 full
            RFF1: u1,
            /// Receive FIFO1 overfull
            RFO1: u1,
            /// Receive FIFO1 dequeue
            RFD1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x10);

        /// address: 0x40006414
        /// Interrupt enable register
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit mailbox empty interrupt enable
            TMEIE: u1,
            /// Receive FIFO0 not empty interrupt enable
            RFNEIE0: u1,
            /// Receive FIFO0 full interrupt enable
            RFFIE0: u1,
            /// Receive FIFO0 overfull interrupt enable
            RFOIE0: u1,
            /// Receive FIFO1 not empty interrupt enable
            RFNEIE1: u1,
            /// Receive FIFO1 full interrupt enable
            RFFIE1: u1,
            /// Receive FIFO1 overfull interrupt enable
            RFOIE1: u1,
            reserved0: u1,
            /// Warning error interrupt enable
            WERRIE: u1,
            /// Passive error interrupt enable
            PERRIE: u1,
            /// Bus-off interrupt enable
            BOIE: u1,
            /// Error number interrupt enable
            ERRNIE: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// Wakeup interrupt enable
            WIE: u1,
            /// Sleep working interrupt enable
            SLPWIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x14);

        /// address: 0x40006418
        /// Error register
        pub const ERR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Warning error
            WERR: u1,
            /// Passive error
            PERR: u1,
            /// Bus-off error
            BOERR: u1,
            reserved0: u1,
            /// Error number
            ERRN: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Transmit Error Count defined
            /// by the CAN standard
            TECNT: u8,
            /// Receive Error Count defined
            /// by the CAN standard
            RECNT: u8,
        }), base_address + 0x18);

        /// address: 0x4000641c
        /// Bit timing register
        pub const BT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Baud rate prescaler
            BAUDPSC: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Bit segment 1
            BS1: u4,
            /// Bit segment 2
            BS2: u3,
            reserved6: u1,
            /// Resynchronization jump width
            SJW: u2,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Loopback communication mode
            LCMOD: u1,
            /// Silent communication mode
            SCMOD: u1,
        }), base_address + 0x1c);

        /// address: 0x40006580
        /// Transmit mailbox identifier register 0
        pub const TMI0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit enable
            TEN: u1,
            /// Frame type
            FT: u1,
            /// Frame format
            FF: u1,
            /// The frame identifier
            EFID: u18,
            /// The frame identifier
            SFID_EFID: u11,
        }), base_address + 0x180);

        /// address: 0x40006584
        /// Transmit mailbox property register 0
        pub const TMP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data length code
            DLENC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Time stamp enable
            TSEN: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Time stamp
            TS: u16,
        }), base_address + 0x184);

        /// address: 0x40006588
        /// Transmit mailbox data0 register
        pub const TMDATA00 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 0
            DB0: u8,
            /// Data byte 1
            DB1: u8,
            /// Data byte 2
            DB2: u8,
            /// Data byte 3
            DB3: u8,
        }), base_address + 0x188);

        /// address: 0x4000658c
        /// Transmit mailbox data1 register
        pub const TMDATA10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 4
            DB4: u8,
            /// Data byte 5
            DB5: u8,
            /// Data byte 6
            DB6: u8,
            /// Data byte 7
            DB7: u8,
        }), base_address + 0x18c);

        /// address: 0x40006590
        /// Transmit mailbox identifier register 1
        pub const TMI1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit enable
            TEN: u1,
            /// Frame type
            FT: u1,
            /// Frame format
            FF: u1,
            /// The frame identifier
            EFID: u18,
            /// The frame identifier
            SFID_EFID: u11,
        }), base_address + 0x190);

        /// address: 0x40006594
        /// Transmit mailbox property register 1
        pub const TMP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data length code
            DLENC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Time stamp enable
            TSEN: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Time stamp
            TS: u16,
        }), base_address + 0x194);

        /// address: 0x40006598
        /// Transmit mailbox data0 register
        pub const TMDATA01 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 0
            DB0: u8,
            /// Data byte 1
            DB1: u8,
            /// Data byte 2
            DB2: u8,
            /// Data byte 3
            DB3: u8,
        }), base_address + 0x198);

        /// address: 0x4000659c
        /// Transmit mailbox data1 register
        pub const TMDATA11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 4
            DB4: u8,
            /// Data byte 5
            DB5: u8,
            /// Data byte 6
            DB6: u8,
            /// Data byte 7
            DB7: u8,
        }), base_address + 0x19c);

        /// address: 0x400065a0
        /// Transmit mailbox identifier register 2
        pub const TMI2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit enable
            TEN: u1,
            /// Frame type
            FT: u1,
            /// Frame format
            FF: u1,
            /// The frame identifier
            EFID: u18,
            /// The frame identifier
            SFID_EFID: u11,
        }), base_address + 0x1a0);

        /// address: 0x400065a4
        /// Transmit mailbox property register 2
        pub const TMP2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data length code
            DLENC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Time stamp enable
            TSEN: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Time stamp
            TS: u16,
        }), base_address + 0x1a4);

        /// address: 0x400065a8
        /// Transmit mailbox data0 register
        pub const TMDATA02 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 0
            DB0: u8,
            /// Data byte 1
            DB1: u8,
            /// Data byte 2
            DB2: u8,
            /// Data byte 3
            DB3: u8,
        }), base_address + 0x1a8);

        /// address: 0x400065ac
        /// Transmit mailbox data1 register
        pub const TMDATA12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 4
            DB4: u8,
            /// Data byte 5
            DB5: u8,
            /// Data byte 6
            DB6: u8,
            /// Data byte 7
            DB7: u8,
        }), base_address + 0x1ac);

        /// address: 0x400065b0
        /// Receive FIFO mailbox identifier register
        pub const RFIFOMI0 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Frame type
            FT: u1,
            /// Frame format
            FF: u1,
            /// The frame identifier
            EFID: u18,
            /// The frame identifier
            SFID_EFID: u11,
        }), base_address + 0x1b0);

        /// address: 0x400065b4
        /// Receive FIFO0 mailbox property register
        pub const RFIFOMP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data length code
            DLENC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Filtering index
            FI: u8,
            /// Time stamp
            TS: u16,
        }), base_address + 0x1b4);

        /// address: 0x400065b8
        /// Receive FIFO0 mailbox data0 register
        pub const RFIFOMDATA00 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 0
            DB0: u8,
            /// Data byte 1
            DB1: u8,
            /// Data byte 2
            DB2: u8,
            /// Data byte 3
            DB3: u8,
        }), base_address + 0x1b8);

        /// address: 0x400065bc
        /// Receive FIFO0 mailbox data1 register
        pub const RFIFOMDATA10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 4
            DB4: u8,
            /// Data byte 5
            DB5: u8,
            /// Data byte 6
            DB6: u8,
            /// Data byte 7
            DB7: u8,
        }), base_address + 0x1bc);

        /// address: 0x400065c0
        /// Receive FIFO1 mailbox identifier register
        pub const RFIFOMI1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Frame type
            FT: u1,
            /// Frame format
            FF: u1,
            /// The frame identifier
            EFID: u18,
            /// The frame identifier
            SFID_EFID: u11,
        }), base_address + 0x1c0);

        /// address: 0x400065c4
        /// Receive FIFO1 mailbox property register
        pub const RFIFOMP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data length code
            DLENC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Filtering index
            FI: u8,
            /// Time stamp
            TS: u16,
        }), base_address + 0x1c4);

        /// address: 0x400065c8
        /// Receive FIFO1 mailbox data0 register
        pub const RFIFOMDATA01 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 0
            DB0: u8,
            /// Data byte 1
            DB1: u8,
            /// Data byte 2
            DB2: u8,
            /// Data byte 3
            DB3: u8,
        }), base_address + 0x1c8);

        /// address: 0x400065cc
        /// Receive FIFO1 mailbox data1 register
        pub const RFIFOMDATA11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 4
            DB4: u8,
            /// Data byte 5
            DB5: u8,
            /// Data byte 6
            DB6: u8,
            /// Data byte 7
            DB7: u8,
        }), base_address + 0x1cc);

        /// address: 0x40006600
        /// Filter control register
        pub const FCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter lock disable
            FLD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Header bank of CAN1 filter
            HBC1F: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x200);

        /// address: 0x40006604
        /// Filter mode configuration register
        pub const FMCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter mode
            FMOD0: u1,
            /// Filter mode
            FMOD1: u1,
            /// Filter mode
            FMOD2: u1,
            /// Filter mode
            FMOD3: u1,
            /// Filter mode
            FMOD4: u1,
            /// Filter mode
            FMOD5: u1,
            /// Filter mode
            FMOD6: u1,
            /// Filter mode
            FMOD7: u1,
            /// Filter mode
            FMOD8: u1,
            /// Filter mode
            FMOD9: u1,
            /// Filter mode
            FMOD10: u1,
            /// Filter mode
            FMOD11: u1,
            /// Filter mode
            FMOD12: u1,
            /// Filter mode
            FMOD13: u1,
            /// Filter mode
            FMOD14: u1,
            /// Filter mode
            FMOD15: u1,
            /// Filter mode
            FMOD16: u1,
            /// Filter mode
            FMOD17: u1,
            /// Filter mode
            FMOD18: u1,
            /// Filter mode
            FMOD19: u1,
            /// Filter mode
            FMOD20: u1,
            /// Filter mode
            FMOD21: u1,
            /// Filter mode
            FMOD22: u1,
            /// Filter mode
            FMOD23: u1,
            /// Filter mode
            FMOD24: u1,
            /// Filter mode
            FMOD25: u1,
            /// Filter mode
            FMOD26: u1,
            /// Filter mode
            FMOD27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x204);

        /// address: 0x4000660c
        /// Filter scale configuration register
        pub const FSCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter scale configuration
            FS0: u1,
            /// Filter scale configuration
            FS1: u1,
            /// Filter scale configuration
            FS2: u1,
            /// Filter scale configuration
            FS3: u1,
            /// Filter scale configuration
            FS4: u1,
            /// Filter scale configuration
            FS5: u1,
            /// Filter scale configuration
            FS6: u1,
            /// Filter scale configuration
            FS7: u1,
            /// Filter scale configuration
            FS8: u1,
            /// Filter scale configuration
            FS9: u1,
            /// Filter scale configuration
            FS10: u1,
            /// Filter scale configuration
            FS11: u1,
            /// Filter scale configuration
            FS12: u1,
            /// Filter scale configuration
            FS13: u1,
            /// Filter scale configuration
            FS14: u1,
            /// Filter scale configuration
            FS15: u1,
            /// Filter scale configuration
            FS16: u1,
            /// Filter scale configuration
            FS17: u1,
            /// Filter scale configuration
            FS18: u1,
            /// Filter scale configuration
            FS19: u1,
            /// Filter scale configuration
            FS20: u1,
            /// Filter scale configuration
            FS21: u1,
            /// Filter scale configuration
            FS22: u1,
            /// Filter scale configuration
            FS23: u1,
            /// Filter scale configuration
            FS24: u1,
            /// Filter scale configuration
            FS25: u1,
            /// Filter scale configuration
            FS26: u1,
            /// Filter scale configuration
            FS27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20c);

        /// address: 0x40006614
        /// Filter associated FIFO register
        pub const FAFIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter 0 associated with FIFO
            FAF0: u1,
            /// Filter 1 associated with FIFO
            FAF1: u1,
            /// Filter 2 associated with FIFO
            FAF2: u1,
            /// Filter 3 associated with FIFO
            FAF3: u1,
            /// Filter 4 associated with FIFO
            FAF4: u1,
            /// Filter 5 associated with FIFO
            FAF5: u1,
            /// Filter 6 associated with FIFO
            FAF6: u1,
            /// Filter 7 associated with FIFO
            FAF7: u1,
            /// Filter 8 associated with FIFO
            FAF8: u1,
            /// Filter 9 associated with FIFO
            FAF9: u1,
            /// Filter 10 associated with FIFO
            FAF10: u1,
            /// Filter 11 associated with FIFO
            FAF11: u1,
            /// Filter 12 associated with FIFO
            FAF12: u1,
            /// Filter 13 associated with FIFO
            FAF13: u1,
            /// Filter 14 associated with FIFO
            FAF14: u1,
            /// Filter 15 associated with FIFO
            FAF15: u1,
            /// Filter 16 associated with FIFO
            FAF16: u1,
            /// Filter 17 associated with FIFO
            FAF17: u1,
            /// Filter 18 associated with FIFO
            FAF18: u1,
            /// Filter 19 associated with FIFO
            FAF19: u1,
            /// Filter 20 associated with FIFO
            FAF20: u1,
            /// Filter 21 associated with FIFO
            FAF21: u1,
            /// Filter 22 associated with FIFO
            FAF22: u1,
            /// Filter 23 associated with FIFO
            FAF23: u1,
            /// Filter 24 associated with FIFO
            FAF24: u1,
            /// Filter 25 associated with FIFO
            FAF25: u1,
            /// Filter 26 associated with FIFO
            FAF26: u1,
            /// Filter 27 associated with FIFO
            FAF27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x214);

        /// address: 0x4000661c
        /// Filter working register
        pub const FW = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter working
            FW0: u1,
            /// Filter working
            FW1: u1,
            /// Filter working
            FW2: u1,
            /// Filter working
            FW3: u1,
            /// Filter working
            FW4: u1,
            /// Filter working
            FW5: u1,
            /// Filter working
            FW6: u1,
            /// Filter working
            FW7: u1,
            /// Filter working
            FW8: u1,
            /// Filter working
            FW9: u1,
            /// Filter working
            FW10: u1,
            /// Filter working
            FW11: u1,
            /// Filter working
            FW12: u1,
            /// Filter working
            FW13: u1,
            /// Filter working
            FW14: u1,
            /// Filter working
            FW15: u1,
            /// Filter working
            FW16: u1,
            /// Filter working
            FW17: u1,
            /// Filter working
            FW18: u1,
            /// Filter working
            FW19: u1,
            /// Filter working
            FW20: u1,
            /// Filter working
            FW21: u1,
            /// Filter working
            FW22: u1,
            /// Filter working
            FW23: u1,
            /// Filter working
            FW24: u1,
            /// Filter working
            FW25: u1,
            /// Filter working
            FW26: u1,
            /// Filter working
            FW27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x21c);

        /// address: 0x40006640
        /// Filter 0 data 0 register
        pub const F0DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x240);

        /// address: 0x40006644
        /// Filter 0 data 1 register
        pub const F0DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x244);

        /// address: 0x40006648
        /// Filter 1 data 0 register
        pub const F1DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x248);

        /// address: 0x4000664c
        /// Filter 1 data 1 register
        pub const F1DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x24c);

        /// address: 0x40006650
        /// Filter 2 data 0 register
        pub const F2DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x250);

        /// address: 0x40006654
        /// Filter 2 data 1 register
        pub const F2DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x254);

        /// address: 0x40006658
        /// Filter 3 data 0 register
        pub const F3DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x258);

        /// address: 0x4000665c
        /// Filter 3 data 1 register
        pub const F3DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x25c);

        /// address: 0x40006660
        /// Filter 4 data 0 register
        pub const F4DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x260);

        /// address: 0x40006664
        /// Filter 4 data 1 register
        pub const F4DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x264);

        /// address: 0x40006668
        /// Filter 5 data 0 register
        pub const F5DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x268);

        /// address: 0x4000666c
        /// Filter 5 data 1 register
        pub const F5DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x26c);

        /// address: 0x40006670
        /// Filter 6 data 0 register
        pub const F6DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x270);

        /// address: 0x40006674
        /// Filter 6 data 1 register
        pub const F6DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x274);

        /// address: 0x40006678
        /// Filter 7 data 0 register
        pub const F7DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x278);

        /// address: 0x4000667c
        /// Filter 7 data 1 register
        pub const F7DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x27c);

        /// address: 0x40006680
        /// Filter 8 data 0 register
        pub const F8DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x280);

        /// address: 0x40006684
        /// Filter 8 data 1 register
        pub const F8DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x284);

        /// address: 0x40006688
        /// Filter 9 data 0 register
        pub const F9DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x288);

        /// address: 0x4000668c
        /// Filter 9 data 1 register
        pub const F9DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x28c);

        /// address: 0x40006690
        /// Filter 10 data 0 register
        pub const F10DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x290);

        /// address: 0x40006694
        /// Filter 10 data 1 register
        pub const F10DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x294);

        /// address: 0x40006698
        /// Filter 11 data 0 register
        pub const F11DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x298);

        /// address: 0x4000669c
        /// Filter 11 data 1 register
        pub const F11DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x29c);

        /// address: 0x400066a0
        /// Filter 12 data 0 register
        pub const F12DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2a0);

        /// address: 0x400066a4
        /// Filter 12 data 1 register
        pub const F12DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2a4);

        /// address: 0x400066a8
        /// Filter 13 data 0 register
        pub const F13DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2a8);

        /// address: 0x400066ac
        /// Filter 13 data 1 register
        pub const F13DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2ac);

        /// address: 0x400066b0
        /// Filter 14 data 0 register
        pub const F14DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2b0);

        /// address: 0x400066b4
        /// Filter 14 data 1 register
        pub const F14DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2b4);

        /// address: 0x400066b8
        /// Filter 15 data 0 register
        pub const F15DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2b8);

        /// address: 0x400066bc
        /// Filter 15 data 1 register
        pub const F15DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2bc);

        /// address: 0x400066c0
        /// Filter 16 data 0 register
        pub const F16DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2c0);

        /// address: 0x400066c4
        /// Filter 16 data 1 register
        pub const F16DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2c4);

        /// address: 0x400066c8
        /// Filter 17 data 0 register
        pub const F17DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2c8);

        /// address: 0x400066cc
        /// Filter 17 data 1 register
        pub const F17DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2cc);

        /// address: 0x400066d0
        /// Filter 18 data 0 register
        pub const F18DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2d0);

        /// address: 0x400066d4
        /// Filter 18 data 1 register
        pub const F18DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2d4);

        /// address: 0x400066d8
        /// Filter 19 data 0 register
        pub const F19DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2d8);

        /// address: 0x400066dc
        /// Filter 19 data 1 register
        pub const F19DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2dc);

        /// address: 0x400066e0
        /// Filter 20 data 0 register
        pub const F20DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2e0);

        /// address: 0x400066e4
        /// Filter 20 data 1 register
        pub const F20DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2e4);

        /// address: 0x400066e8
        /// Filter 21 data 0 register
        pub const F21DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2e8);

        /// address: 0x400066ec
        /// Filter 21 data 1 register
        pub const F21DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2ec);

        /// address: 0x400066f0
        /// Filter 22 data 0 register
        pub const F22DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2f0);

        /// address: 0x400066f4
        /// Filter 22 data 1 register
        pub const F22DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2f4);

        /// address: 0x400066f8
        /// Filter 23 data 0 register
        pub const F23DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2f8);

        /// address: 0x400066fc
        /// Filter 23 data 1 register
        pub const F23DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2fc);

        /// address: 0x40006700
        /// Filter 24 data 0 register
        pub const F24DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x300);

        /// address: 0x40006704
        /// Filter 24 data 1 register
        pub const F24DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x304);

        /// address: 0x40006708
        /// Filter 25 data 0 register
        pub const F25DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x308);

        /// address: 0x4000670c
        /// Filter 25 data 1 register
        pub const F25DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x30c);

        /// address: 0x40006710
        /// Filter 26 data 0 register
        pub const F26DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x310);

        /// address: 0x40006714
        /// Filter 26 data 1 register
        pub const F26DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x314);

        /// address: 0x40006718
        /// Filter 27 data 0 register
        pub const F27DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x318);

        /// address: 0x4000671c
        /// Filter 27 data 1 register
        pub const F27DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x31c);
    };
    pub const CAN1 = struct {
        pub const base_address = 0x40006800;

        /// address: 0x40006800
        /// Control register
        pub const CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Initial working mode
            IWMOD: u1,
            /// Sleep working mode
            SLPWMOD: u1,
            /// Transmit FIFO order
            TFO: u1,
            /// Receive FIFO overwrite disable
            RFOD: u1,
            /// Automatic retransmission disable
            ARD: u1,
            /// Automatic wakeup
            AWU: u1,
            /// Automatic bus-off recovery
            ABOR: u1,
            /// Time-triggered communication
            TTC: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Software reset
            SWRST: u1,
            /// Debug freeze
            DFZ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x0);

        /// address: 0x40006804
        /// Status register
        pub const STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Initial working state
            IWS: u1,
            /// Sleep working state
            SLPWS: u1,
            /// Error interrupt flag
            ERRIF: u1,
            /// Status change interrupt flag of wakeup
            /// from sleep working mode
            WUIF: u1,
            /// Status change interrupt flag of sleep
            /// working mode entering
            SLPIF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Transmitting state
            TS: u1,
            /// Receiving state
            RS: u1,
            /// Last sample value of RX pin
            LASTRX: u1,
            /// RX level
            RXL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x4);

        /// address: 0x40006808
        /// Transmit status register
        pub const TSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Mailbox 0 transmit finished
            MTF0: u1,
            /// Mailbox 0 transmit finished and no error
            MTFNERR0: u1,
            /// Mailbox 0 arbitration lost
            MAL0: u1,
            /// Mailbox 0 transmit error
            MTE0: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Mailbox 0 stop transmitting
            MST0: u1,
            /// Mailbox 1 transmit finished
            MTF1: u1,
            /// Mailbox 1 transmit finished and no error
            MTFNERR1: u1,
            /// Mailbox 1 arbitration lost
            MAL1: u1,
            /// Mailbox 1 transmit error
            MTE1: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Mailbox 1 stop transmitting
            MST1: u1,
            /// Mailbox 2 transmit finished
            MTF2: u1,
            /// Mailbox 2 transmit finished and no error
            MTFNERR2: u1,
            /// Mailbox 2 arbitration lost
            MAL2: u1,
            /// Mailbox 2 transmit error
            MTE2: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Mailbox 2 stop transmitting
            MST2: u1,
            /// number of the transmit FIFO mailbox in
            /// which the frame will be transmitted if at least one mailbox is empty
            NUM: u2,
            /// Transmit mailbox 0 empty
            TME0: u1,
            /// Transmit mailbox 1 empty
            TME1: u1,
            /// Transmit mailbox 2 empty
            TME2: u1,
            /// Transmit mailbox 0 last sending
            /// in transmit FIFO
            TMLS0: u1,
            /// Transmit mailbox 1 last sending
            /// in transmit FIFO
            TMLS1: u1,
            /// Transmit mailbox 2 last sending
            /// in transmit FIFO
            TMLS2: u1,
        }), base_address + 0x8);

        /// address: 0x4000680c
        /// Receive message FIFO0 register
        pub const RFIFO0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive FIFO0 length
            RFL0: u2,
            reserved0: u1,
            /// Receive FIFO0 full
            RFF0: u1,
            /// Receive FIFO0 overfull
            RFO0: u1,
            /// Receive FIFO0 dequeue
            RFD0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xc);

        /// address: 0x40006810
        /// Receive message FIFO1 register
        pub const RFIFO1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive FIFO1 length
            RFL1: u2,
            reserved0: u1,
            /// Receive FIFO1 full
            RFF1: u1,
            /// Receive FIFO1 overfull
            RFO1: u1,
            /// Receive FIFO1 dequeue
            RFD1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x10);

        /// address: 0x40006814
        /// Interrupt enable register
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit mailbox empty interrupt enable
            TMEIE: u1,
            /// Receive FIFO0 not empty interrupt enable
            RFNEIE0: u1,
            /// Receive FIFO0 full interrupt enable
            RFFIE0: u1,
            /// Receive FIFO0 overfull interrupt enable
            RFOIE0: u1,
            /// Receive FIFO1 not empty interrupt enable
            RFNEIE1: u1,
            /// Receive FIFO1 full interrupt enable
            RFFIE1: u1,
            /// Receive FIFO1 overfull interrupt enable
            RFOIE1: u1,
            reserved0: u1,
            /// Warning error interrupt enable
            WERRIE: u1,
            /// Passive error interrupt enable
            PERRIE: u1,
            /// Bus-off interrupt enable
            BOIE: u1,
            /// Error number interrupt enable
            ERRNIE: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// Wakeup interrupt enable
            WIE: u1,
            /// Sleep working interrupt enable
            SLPWIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x14);

        /// address: 0x40006818
        /// Error register
        pub const ERR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Warning error
            WERR: u1,
            /// Passive error
            PERR: u1,
            /// Bus-off error
            BOERR: u1,
            reserved0: u1,
            /// Error number
            ERRN: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Transmit Error Count defined
            /// by the CAN standard
            TECNT: u8,
            /// Receive Error Count defined
            /// by the CAN standard
            RECNT: u8,
        }), base_address + 0x18);

        /// address: 0x4000681c
        /// Bit timing register
        pub const BT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Baud rate prescaler
            BAUDPSC: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Bit segment 1
            BS1: u4,
            /// Bit segment 2
            BS2: u3,
            reserved6: u1,
            /// Resynchronization jump width
            SJW: u2,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Loopback communication mode
            LCMOD: u1,
            /// Silent communication mode
            SCMOD: u1,
        }), base_address + 0x1c);

        /// address: 0x40006980
        /// Transmit mailbox identifier register 0
        pub const TMI0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit enable
            TEN: u1,
            /// Frame type
            FT: u1,
            /// Frame format
            FF: u1,
            /// The frame identifier
            EFID: u18,
            /// The frame identifier
            SFID_EFID: u11,
        }), base_address + 0x180);

        /// address: 0x40006984
        /// Transmit mailbox property register 0
        pub const TMP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data length code
            DLENC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Time stamp enable
            TSEN: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Time stamp
            TS: u16,
        }), base_address + 0x184);

        /// address: 0x40006988
        /// Transmit mailbox data0 register
        pub const TMDATA00 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 0
            DB0: u8,
            /// Data byte 1
            DB1: u8,
            /// Data byte 2
            DB2: u8,
            /// Data byte 3
            DB3: u8,
        }), base_address + 0x188);

        /// address: 0x4000698c
        /// Transmit mailbox data1 register
        pub const TMDATA10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 4
            DB4: u8,
            /// Data byte 5
            DB5: u8,
            /// Data byte 6
            DB6: u8,
            /// Data byte 7
            DB7: u8,
        }), base_address + 0x18c);

        /// address: 0x40006990
        /// Transmit mailbox identifier register 1
        pub const TMI1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit enable
            TEN: u1,
            /// Frame type
            FT: u1,
            /// Frame format
            FF: u1,
            /// The frame identifier
            EFID: u18,
            /// The frame identifier
            SFID_EFID: u11,
        }), base_address + 0x190);

        /// address: 0x40006994
        /// Transmit mailbox property register 1
        pub const TMP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data length code
            DLENC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Time stamp enable
            TSEN: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Time stamp
            TS: u16,
        }), base_address + 0x194);

        /// address: 0x40006998
        /// Transmit mailbox data0 register
        pub const TMDATA01 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 0
            DB0: u8,
            /// Data byte 1
            DB1: u8,
            /// Data byte 2
            DB2: u8,
            /// Data byte 3
            DB3: u8,
        }), base_address + 0x198);

        /// address: 0x4000699c
        /// Transmit mailbox data1 register
        pub const TMDATA11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 4
            DB4: u8,
            /// Data byte 5
            DB5: u8,
            /// Data byte 6
            DB6: u8,
            /// Data byte 7
            DB7: u8,
        }), base_address + 0x19c);

        /// address: 0x400069a0
        /// Transmit mailbox identifier register 2
        pub const TMI2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit enable
            TEN: u1,
            /// Frame type
            FT: u1,
            /// Frame format
            FF: u1,
            /// The frame identifier
            EFID: u18,
            /// The frame identifier
            SFID_EFID: u11,
        }), base_address + 0x1a0);

        /// address: 0x400069a4
        /// Transmit mailbox property register 2
        pub const TMP2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data length code
            DLENC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Time stamp enable
            TSEN: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Time stamp
            TS: u16,
        }), base_address + 0x1a4);

        /// address: 0x400069a8
        /// Transmit mailbox data0 register
        pub const TMDATA02 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 0
            DB0: u8,
            /// Data byte 1
            DB1: u8,
            /// Data byte 2
            DB2: u8,
            /// Data byte 3
            DB3: u8,
        }), base_address + 0x1a8);

        /// address: 0x400069ac
        /// Transmit mailbox data1 register
        pub const TMDATA12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 4
            DB4: u8,
            /// Data byte 5
            DB5: u8,
            /// Data byte 6
            DB6: u8,
            /// Data byte 7
            DB7: u8,
        }), base_address + 0x1ac);

        /// address: 0x400069b0
        /// Receive FIFO mailbox identifier register
        pub const RFIFOMI0 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Frame type
            FT: u1,
            /// Frame format
            FF: u1,
            /// The frame identifier
            EFID: u18,
            /// The frame identifier
            SFID_EFID: u11,
        }), base_address + 0x1b0);

        /// address: 0x400069b4
        /// Receive FIFO0 mailbox property register
        pub const RFIFOMP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data length code
            DLENC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Filtering index
            FI: u8,
            /// Time stamp
            TS: u16,
        }), base_address + 0x1b4);

        /// address: 0x400069b8
        /// Receive FIFO0 mailbox data0 register
        pub const RFIFOMDATA00 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 0
            DB0: u8,
            /// Data byte 1
            DB1: u8,
            /// Data byte 2
            DB2: u8,
            /// Data byte 3
            DB3: u8,
        }), base_address + 0x1b8);

        /// address: 0x400069bc
        /// Receive FIFO0 mailbox data1 register
        pub const RFIFOMDATA10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 4
            DB4: u8,
            /// Data byte 5
            DB5: u8,
            /// Data byte 6
            DB6: u8,
            /// Data byte 7
            DB7: u8,
        }), base_address + 0x1bc);

        /// address: 0x400069c0
        /// Receive FIFO1 mailbox identifier register
        pub const RFIFOMI1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Frame type
            FT: u1,
            /// Frame format
            FF: u1,
            /// The frame identifier
            EFID: u18,
            /// The frame identifier
            SFID_EFID: u11,
        }), base_address + 0x1c0);

        /// address: 0x400069c4
        /// Receive FIFO1 mailbox property register
        pub const RFIFOMP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data length code
            DLENC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Filtering index
            FI: u8,
            /// Time stamp
            TS: u16,
        }), base_address + 0x1c4);

        /// address: 0x400069c8
        /// Receive FIFO1 mailbox data0 register
        pub const RFIFOMDATA01 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 0
            DB0: u8,
            /// Data byte 1
            DB1: u8,
            /// Data byte 2
            DB2: u8,
            /// Data byte 3
            DB3: u8,
        }), base_address + 0x1c8);

        /// address: 0x400069cc
        /// Receive FIFO1 mailbox data1 register
        pub const RFIFOMDATA11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data byte 4
            DB4: u8,
            /// Data byte 5
            DB5: u8,
            /// Data byte 6
            DB6: u8,
            /// Data byte 7
            DB7: u8,
        }), base_address + 0x1cc);

        /// address: 0x40006a00
        /// Filter control register
        pub const FCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter lock disable
            FLD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Header bank of CAN1 filter
            HBC1F: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x200);

        /// address: 0x40006a04
        /// Filter mode configuration register
        pub const FMCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter mode
            FMOD0: u1,
            /// Filter mode
            FMOD1: u1,
            /// Filter mode
            FMOD2: u1,
            /// Filter mode
            FMOD3: u1,
            /// Filter mode
            FMOD4: u1,
            /// Filter mode
            FMOD5: u1,
            /// Filter mode
            FMOD6: u1,
            /// Filter mode
            FMOD7: u1,
            /// Filter mode
            FMOD8: u1,
            /// Filter mode
            FMOD9: u1,
            /// Filter mode
            FMOD10: u1,
            /// Filter mode
            FMOD11: u1,
            /// Filter mode
            FMOD12: u1,
            /// Filter mode
            FMOD13: u1,
            /// Filter mode
            FMOD14: u1,
            /// Filter mode
            FMOD15: u1,
            /// Filter mode
            FMOD16: u1,
            /// Filter mode
            FMOD17: u1,
            /// Filter mode
            FMOD18: u1,
            /// Filter mode
            FMOD19: u1,
            /// Filter mode
            FMOD20: u1,
            /// Filter mode
            FMOD21: u1,
            /// Filter mode
            FMOD22: u1,
            /// Filter mode
            FMOD23: u1,
            /// Filter mode
            FMOD24: u1,
            /// Filter mode
            FMOD25: u1,
            /// Filter mode
            FMOD26: u1,
            /// Filter mode
            FMOD27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x204);

        /// address: 0x40006a0c
        /// Filter scale configuration register
        pub const FSCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter scale configuration
            FS0: u1,
            /// Filter scale configuration
            FS1: u1,
            /// Filter scale configuration
            FS2: u1,
            /// Filter scale configuration
            FS3: u1,
            /// Filter scale configuration
            FS4: u1,
            /// Filter scale configuration
            FS5: u1,
            /// Filter scale configuration
            FS6: u1,
            /// Filter scale configuration
            FS7: u1,
            /// Filter scale configuration
            FS8: u1,
            /// Filter scale configuration
            FS9: u1,
            /// Filter scale configuration
            FS10: u1,
            /// Filter scale configuration
            FS11: u1,
            /// Filter scale configuration
            FS12: u1,
            /// Filter scale configuration
            FS13: u1,
            /// Filter scale configuration
            FS14: u1,
            /// Filter scale configuration
            FS15: u1,
            /// Filter scale configuration
            FS16: u1,
            /// Filter scale configuration
            FS17: u1,
            /// Filter scale configuration
            FS18: u1,
            /// Filter scale configuration
            FS19: u1,
            /// Filter scale configuration
            FS20: u1,
            /// Filter scale configuration
            FS21: u1,
            /// Filter scale configuration
            FS22: u1,
            /// Filter scale configuration
            FS23: u1,
            /// Filter scale configuration
            FS24: u1,
            /// Filter scale configuration
            FS25: u1,
            /// Filter scale configuration
            FS26: u1,
            /// Filter scale configuration
            FS27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20c);

        /// address: 0x40006a14
        /// Filter associated FIFO register
        pub const FAFIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter 0 associated with FIFO
            FAF0: u1,
            /// Filter 1 associated with FIFO
            FAF1: u1,
            /// Filter 2 associated with FIFO
            FAF2: u1,
            /// Filter 3 associated with FIFO
            FAF3: u1,
            /// Filter 4 associated with FIFO
            FAF4: u1,
            /// Filter 5 associated with FIFO
            FAF5: u1,
            /// Filter 6 associated with FIFO
            FAF6: u1,
            /// Filter 7 associated with FIFO
            FAF7: u1,
            /// Filter 8 associated with FIFO
            FAF8: u1,
            /// Filter 9 associated with FIFO
            FAF9: u1,
            /// Filter 10 associated with FIFO
            FAF10: u1,
            /// Filter 11 associated with FIFO
            FAF11: u1,
            /// Filter 12 associated with FIFO
            FAF12: u1,
            /// Filter 13 associated with FIFO
            FAF13: u1,
            /// Filter 14 associated with FIFO
            FAF14: u1,
            /// Filter 15 associated with FIFO
            FAF15: u1,
            /// Filter 16 associated with FIFO
            FAF16: u1,
            /// Filter 17 associated with FIFO
            FAF17: u1,
            /// Filter 18 associated with FIFO
            FAF18: u1,
            /// Filter 19 associated with FIFO
            FAF19: u1,
            /// Filter 20 associated with FIFO
            FAF20: u1,
            /// Filter 21 associated with FIFO
            FAF21: u1,
            /// Filter 22 associated with FIFO
            FAF22: u1,
            /// Filter 23 associated with FIFO
            FAF23: u1,
            /// Filter 24 associated with FIFO
            FAF24: u1,
            /// Filter 25 associated with FIFO
            FAF25: u1,
            /// Filter 26 associated with FIFO
            FAF26: u1,
            /// Filter 27 associated with FIFO
            FAF27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x214);

        /// address: 0x40006a1c
        /// Filter working register
        pub const FW = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter working
            FW0: u1,
            /// Filter working
            FW1: u1,
            /// Filter working
            FW2: u1,
            /// Filter working
            FW3: u1,
            /// Filter working
            FW4: u1,
            /// Filter working
            FW5: u1,
            /// Filter working
            FW6: u1,
            /// Filter working
            FW7: u1,
            /// Filter working
            FW8: u1,
            /// Filter working
            FW9: u1,
            /// Filter working
            FW10: u1,
            /// Filter working
            FW11: u1,
            /// Filter working
            FW12: u1,
            /// Filter working
            FW13: u1,
            /// Filter working
            FW14: u1,
            /// Filter working
            FW15: u1,
            /// Filter working
            FW16: u1,
            /// Filter working
            FW17: u1,
            /// Filter working
            FW18: u1,
            /// Filter working
            FW19: u1,
            /// Filter working
            FW20: u1,
            /// Filter working
            FW21: u1,
            /// Filter working
            FW22: u1,
            /// Filter working
            FW23: u1,
            /// Filter working
            FW24: u1,
            /// Filter working
            FW25: u1,
            /// Filter working
            FW26: u1,
            /// Filter working
            FW27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x21c);

        /// address: 0x40006a40
        /// Filter 0 data 0 register
        pub const F0DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x240);

        /// address: 0x40006a44
        /// Filter 0 data 1 register
        pub const F0DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x244);

        /// address: 0x40006a48
        /// Filter 1 data 0 register
        pub const F1DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x248);

        /// address: 0x40006a4c
        /// Filter 1 data 1 register
        pub const F1DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x24c);

        /// address: 0x40006a50
        /// Filter 2 data 0 register
        pub const F2DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x250);

        /// address: 0x40006a54
        /// Filter 2 data 1 register
        pub const F2DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x254);

        /// address: 0x40006a58
        /// Filter 3 data 0 register
        pub const F3DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x258);

        /// address: 0x40006a5c
        /// Filter 3 data 1 register
        pub const F3DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x25c);

        /// address: 0x40006a60
        /// Filter 4 data 0 register
        pub const F4DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x260);

        /// address: 0x40006a64
        /// Filter 4 data 1 register
        pub const F4DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x264);

        /// address: 0x40006a68
        /// Filter 5 data 0 register
        pub const F5DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x268);

        /// address: 0x40006a6c
        /// Filter 5 data 1 register
        pub const F5DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x26c);

        /// address: 0x40006a70
        /// Filter 6 data 0 register
        pub const F6DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x270);

        /// address: 0x40006a74
        /// Filter 6 data 1 register
        pub const F6DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x274);

        /// address: 0x40006a78
        /// Filter 7 data 0 register
        pub const F7DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x278);

        /// address: 0x40006a7c
        /// Filter 7 data 1 register
        pub const F7DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x27c);

        /// address: 0x40006a80
        /// Filter 8 data 0 register
        pub const F8DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x280);

        /// address: 0x40006a84
        /// Filter 8 data 1 register
        pub const F8DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x284);

        /// address: 0x40006a88
        /// Filter 9 data 0 register
        pub const F9DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x288);

        /// address: 0x40006a8c
        /// Filter 9 data 1 register
        pub const F9DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x28c);

        /// address: 0x40006a90
        /// Filter 10 data 0 register
        pub const F10DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x290);

        /// address: 0x40006a94
        /// Filter 10 data 1 register
        pub const F10DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x294);

        /// address: 0x40006a98
        /// Filter 11 data 0 register
        pub const F11DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x298);

        /// address: 0x40006a9c
        /// Filter 11 data 1 register
        pub const F11DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x29c);

        /// address: 0x40006aa0
        /// Filter 12 data 0 register
        pub const F12DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2a0);

        /// address: 0x40006aa4
        /// Filter 12 data 1 register
        pub const F12DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2a4);

        /// address: 0x40006aa8
        /// Filter 13 data 0 register
        pub const F13DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2a8);

        /// address: 0x40006aac
        /// Filter 13 data 1 register
        pub const F13DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2ac);

        /// address: 0x40006ab0
        /// Filter 14 data 0 register
        pub const F14DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2b0);

        /// address: 0x40006ab4
        /// Filter 14 data 1 register
        pub const F14DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2b4);

        /// address: 0x40006ab8
        /// Filter 15 data 0 register
        pub const F15DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2b8);

        /// address: 0x40006abc
        /// Filter 15 data 1 register
        pub const F15DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2bc);

        /// address: 0x40006ac0
        /// Filter 16 data 0 register
        pub const F16DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2c0);

        /// address: 0x40006ac4
        /// Filter 16 data 1 register
        pub const F16DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2c4);

        /// address: 0x40006ac8
        /// Filter 17 data 0 register
        pub const F17DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2c8);

        /// address: 0x40006acc
        /// Filter 17 data 1 register
        pub const F17DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2cc);

        /// address: 0x40006ad0
        /// Filter 18 data 0 register
        pub const F18DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2d0);

        /// address: 0x40006ad4
        /// Filter 18 data 1 register
        pub const F18DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2d4);

        /// address: 0x40006ad8
        /// Filter 19 data 0 register
        pub const F19DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2d8);

        /// address: 0x40006adc
        /// Filter 19 data 1 register
        pub const F19DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2dc);

        /// address: 0x40006ae0
        /// Filter 20 data 0 register
        pub const F20DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2e0);

        /// address: 0x40006ae4
        /// Filter 20 data 1 register
        pub const F20DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2e4);

        /// address: 0x40006ae8
        /// Filter 21 data 0 register
        pub const F21DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2e8);

        /// address: 0x40006aec
        /// Filter 21 data 1 register
        pub const F21DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2ec);

        /// address: 0x40006af0
        /// Filter 22 data 0 register
        pub const F22DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2f0);

        /// address: 0x40006af4
        /// Filter 22 data 1 register
        pub const F22DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2f4);

        /// address: 0x40006af8
        /// Filter 23 data 0 register
        pub const F23DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2f8);

        /// address: 0x40006afc
        /// Filter 23 data 1 register
        pub const F23DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x2fc);

        /// address: 0x40006b00
        /// Filter 24 data 0 register
        pub const F24DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x300);

        /// address: 0x40006b04
        /// Filter 24 data 1 register
        pub const F24DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x304);

        /// address: 0x40006b08
        /// Filter 25 data 0 register
        pub const F25DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x308);

        /// address: 0x40006b0c
        /// Filter 25 data 1 register
        pub const F25DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x30c);

        /// address: 0x40006b10
        /// Filter 26 data 0 register
        pub const F26DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x310);

        /// address: 0x40006b14
        /// Filter 26 data 1 register
        pub const F26DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x314);

        /// address: 0x40006b18
        /// Filter 27 data 0 register
        pub const F27DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x318);

        /// address: 0x40006b1c
        /// Filter 27 data 1 register
        pub const F27DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FD0: u1,
            /// Filter bits
            FD1: u1,
            /// Filter bits
            FD2: u1,
            /// Filter bits
            FD3: u1,
            /// Filter bits
            FD4: u1,
            /// Filter bits
            FD5: u1,
            /// Filter bits
            FD6: u1,
            /// Filter bits
            FD7: u1,
            /// Filter bits
            FD8: u1,
            /// Filter bits
            FD9: u1,
            /// Filter bits
            FD10: u1,
            /// Filter bits
            FD11: u1,
            /// Filter bits
            FD12: u1,
            /// Filter bits
            FD13: u1,
            /// Filter bits
            FD14: u1,
            /// Filter bits
            FD15: u1,
            /// Filter bits
            FD16: u1,
            /// Filter bits
            FD17: u1,
            /// Filter bits
            FD18: u1,
            /// Filter bits
            FD19: u1,
            /// Filter bits
            FD20: u1,
            /// Filter bits
            FD21: u1,
            /// Filter bits
            FD22: u1,
            /// Filter bits
            FD23: u1,
            /// Filter bits
            FD24: u1,
            /// Filter bits
            FD25: u1,
            /// Filter bits
            FD26: u1,
            /// Filter bits
            FD27: u1,
            /// Filter bits
            FD28: u1,
            /// Filter bits
            FD29: u1,
            /// Filter bits
            FD30: u1,
            /// Filter bits
            FD31: u1,
        }), base_address + 0x31c);
    };

    /// cyclic redundancy check calculation unit
    pub const CRC = struct {
        pub const base_address = 0x40023000;

        /// address: 0x40023000
        /// Data register
        pub const DATA = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40023004
        /// Free data register
        pub const FDATA = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x4);

        /// address: 0x40023008
        /// Control register
        pub const CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// reset bit
            RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x8);
    };

    /// Digital-to-analog converter
    pub const DAC = struct {
        pub const base_address = 0x40007400;

        /// address: 0x40007400
        /// control register
        pub const CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC0 enable
            DEN0: u1,
            /// DAC0 output buffer turn off
            DBOFF0: u1,
            /// DAC0 trigger enable
            DTEN0: u1,
            /// DAC0 trigger selection
            DTSEL0: u3,
            /// DAC0 noise wave mode
            DWM0: u2,
            /// DAC0 noise wave bit width
            DWBW0: u4,
            /// DAC0 DMA enable
            DDMAEN0: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DAC1 enable
            DEN1: u1,
            /// DAC1 output buffer turn off
            DBOFF1: u1,
            /// DAC1 trigger enable
            DTEN1: u1,
            /// DAC1 trigger selection
            DTSEL1: u3,
            /// DAC1 noise wave mode
            DWM1: u2,
            /// DAC1 noise wave bit width
            DWBW1: u4,
            /// DAC1 DMA enable
            DDMAEN1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40007404
        /// software trigger register
        pub const SWT = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC0 software trigger
            SWTR0: u1,
            /// DAC1 software trigger
            SWTR1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x4);

        /// address: 0x40007408
        /// DAC0 12-bit right-aligned data holding register
        pub const DAC0_R12DH = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC0 12-bit right-aligned
            /// data
            DAC0_DH: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x8);

        /// address: 0x4000740c
        /// DAC0 12-bit left-aligned data holding register
        pub const DAC0_L12DH = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC0 12-bit left-aligned
            /// data
            DAC0_DH: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40007410
        /// DAC0 8-bit right aligned data holding
        /// register
        pub const DAC0_R8DH = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC0 8-bit right-aligned
            /// data
            DAC0_DH: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x40007414
        /// DAC1 12-bit right-aligned data holding
        /// register
        pub const DAC1_R12DH = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC1 12-bit right-aligned
            /// data
            DAC1_DH: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x14);

        /// address: 0x40007418
        /// DAC1 12-bit left aligned data holding
        /// register
        pub const DAC1_L12DH = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC1 12-bit left-aligned
            /// data
            DAC1_DH: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000741c
        /// DAC1 8-bit right aligned data holding
        /// register
        pub const DAC1_R8DH = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC1 8-bit right-aligned
            /// data
            DAC1_DH: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x40007420
        /// DAC concurrent mode 12-bit right-aligned data holding
        /// register
        pub const DACC_R12DH = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC0 12-bit right-aligned
            /// data
            DAC0_DH: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC1 12-bit right-aligned
            /// data
            DAC1_DH: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20);

        /// address: 0x40007424
        /// DAC concurrent mode 12-bit left aligned data holding
        /// register
        pub const DACC_L12DH = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC0 12-bit left-aligned
            /// data
            DAC0_DH: u12,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// DAC1 12-bit left-aligned
            /// data
            DAC1_DH: u12,
        }), base_address + 0x24);

        /// address: 0x40007428
        /// DAC concurrent mode 8-bit right aligned data holding
        /// register
        pub const DACC_R8DH = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC0 8-bit right-aligned
            /// data
            DAC0_DH: u8,
            /// DAC1 8-bit right-aligned
            /// data
            DAC1_DH: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x4000742c
        /// DAC0 data output register
        pub const DAC0_DO = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x2c);

        /// address: 0x40007430
        /// DAC1 data output register
        pub const DAC1_DO = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x30);
    };

    /// Debug support
    pub const DBG = struct {
        pub const base_address = 0xe0042000;

        /// address: 0xe0042000
        /// ID code register
        pub const ID = @intToPtr(*volatile Mmio(32, packed struct {
            /// DBG ID code register
            ID_CODE: u32,
        }), base_address + 0x0);

        /// address: 0xe0042004
        /// Control register 0
        pub const CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sleep mode hold register
            SLP_HOLD: u1,
            /// Deep-sleep mode hold register
            DSLP_HOLD: u1,
            /// Standby mode hold register
            STB_HOLD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// FWDGT hold bit
            FWDGT_HOLD: u1,
            /// WWDGT hold bit
            WWDGT_HOLD: u1,
            /// TIMER 0 hold bit
            TIMER0_HOLD: u1,
            /// TIMER 1 hold bit
            TIMER1_HOLD: u1,
            /// TIMER 2 hold bit
            TIMER2_HOLD: u1,
            /// TIMER 23 hold bit
            TIMER3_HOLD: u1,
            /// CAN0 hold bit
            CAN0_HOLD: u1,
            /// I2C0 hold bit
            I2C0_HOLD: u1,
            /// I2C1 hold bit
            I2C1_HOLD: u1,
            reserved5: u1,
            /// TIMER4_HOLD
            TIMER4_HOLD: u1,
            /// TIMER 5 hold bit
            TIMER5_HOLD: u1,
            /// TIMER 6 hold bit
            TIMER6_HOLD: u1,
            /// CAN1 hold bit
            CAN1_HOLD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x4);
    };

    /// DMA controller
    pub const DMA0 = struct {
        pub const base_address = 0x40020000;

        /// address: 0x40020000
        /// Interrupt flag register
        pub const INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Global interrupt flag of channel 0
            GIF0: u1,
            /// Full Transfer finish flag of channe 0
            FTFIF0: u1,
            /// Half transfer finish flag of channel 0
            HTFIF0: u1,
            /// Error flag of channel 0
            ERRIF0: u1,
            /// Global interrupt flag of channel 1
            GIF1: u1,
            /// Full Transfer finish flag of channe 1
            FTFIF1: u1,
            /// Half transfer finish flag of channel 1
            HTFIF1: u1,
            /// Error flag of channel 1
            ERRIF1: u1,
            /// Global interrupt flag of channel 2
            GIF2: u1,
            /// Full Transfer finish flag of channe 2
            FTFIF2: u1,
            /// Half transfer finish flag of channel 2
            HTFIF2: u1,
            /// Error flag of channel 2
            ERRIF2: u1,
            /// Global interrupt flag of channel 3
            GIF3: u1,
            /// Full Transfer finish flag of channe 3
            FTFIF3: u1,
            /// Half transfer finish flag of channel 3
            HTFIF3: u1,
            /// Error flag of channel 3
            ERRIF3: u1,
            /// Global interrupt flag of channel 4
            GIF4: u1,
            /// Full Transfer finish flag of channe 4
            FTFIF4: u1,
            /// Half transfer finish flag of channel 4
            HTFIF4: u1,
            /// Error flag of channel 4
            ERRIF4: u1,
            /// Global interrupt flag of channel 5
            GIF5: u1,
            /// Full Transfer finish flag of channe 5
            FTFIF5: u1,
            /// Half transfer finish flag of channel 5
            HTFIF5: u1,
            /// Error flag of channel 5
            ERRIF5: u1,
            /// Global interrupt flag of channel 6
            GIF6: u1,
            /// Full Transfer finish flag of channe 6
            FTFIF6: u1,
            /// Half transfer finish flag of channel 6
            HTFIF6: u1,
            /// Error flag of channel 6
            ERRIF6: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x40020004
        /// Interrupt flag clear register
        pub const INTC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear global interrupt flag of channel 0
            GIFC0: u1,
            /// Clear bit for full transfer finish flag of channel 0
            FTFIFC0: u1,
            /// Clear bit for half transfer finish flag of channel 0
            HTFIFC0: u1,
            /// Clear bit for error flag of channel 0
            ERRIFC0: u1,
            /// Clear global interrupt flag of channel 1
            GIFC1: u1,
            /// Clear bit for full transfer finish flag of channel 1
            FTFIFC1: u1,
            /// Clear bit for half transfer finish flag of channel 1
            HTFIFC1: u1,
            /// Clear bit for error flag of channel 1
            ERRIFC1: u1,
            /// Clear global interrupt flag of channel 2
            GIFC2: u1,
            /// Clear bit for full transfer finish flag of channel 2
            FTFIFC2: u1,
            /// Clear bit for half transfer finish flag of channel 2
            HTFIFC2: u1,
            /// Clear bit for error flag of channel 2
            ERRIFC2: u1,
            /// Clear global interrupt flag of channel 3
            GIFC3: u1,
            /// Clear bit for full transfer finish flag of channel 3
            FTFIFC3: u1,
            /// Clear bit for half transfer finish flag of channel 3
            HTFIFC3: u1,
            /// Clear bit for error flag of channel 3
            ERRIFC3: u1,
            /// Clear global interrupt flag of channel 4
            GIFC4: u1,
            /// Clear bit for full transfer finish flag of channel 4
            FTFIFC4: u1,
            /// Clear bit for half transfer finish flag of channel 4
            HTFIFC4: u1,
            /// Clear bit for error flag of channel 4
            ERRIFC4: u1,
            /// Clear global interrupt flag of channel 5
            GIFC5: u1,
            /// Clear bit for full transfer finish flag of channel 5
            FTFIFC5: u1,
            /// Clear bit for half transfer finish flag of channel 5
            HTFIFC5: u1,
            /// Clear bit for error flag of channel 5
            ERRIFC5: u1,
            /// Clear global interrupt flag of channel 6
            GIFC6: u1,
            /// Clear bit for full transfer finish flag of channel 6
            FTFIFC6: u1,
            /// Clear bit for half transfer finish flag of channel 6
            HTFIFC6: u1,
            /// Clear bit for error flag of channel 6
            ERRIFC6: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x4);

        /// address: 0x40020008
        /// Channel 0 control register
        pub const CH0CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            CHEN: u1,
            /// Enable bit for channel full transfer finish interrupt
            FTFIE: u1,
            /// Enable bit for channel half transfer finish interrupt
            HTFIE: u1,
            /// Enable bit for channel error interrupt
            ERRIE: u1,
            /// Transfer direction
            DIR: u1,
            /// Circular mode enable
            CMEN: u1,
            /// Next address generation algorithm of peripheral
            PNAGA: u1,
            /// Next address generation algorithm of memory
            MNAGA: u1,
            /// Transfer data size of peripheral
            PWIDTH: u2,
            /// Transfer data size of memory
            MWIDTH: u2,
            /// Priority level
            PRIO: u2,
            /// Memory to Memory Mode
            M2M: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x8);

        /// address: 0x4002000c
        /// Channel 0 counter register
        pub const CH0CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer counter
            CNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40020010
        /// Channel 0 peripheral base address register
        pub const CH0PADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral base address
            PADDR: u32,
        }), base_address + 0x10);

        /// address: 0x40020014
        /// Channel 0 memory base address register
        pub const CH0MADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory base address
            MADDR: u32,
        }), base_address + 0x14);

        /// address: 0x4002001c
        /// Channel 1 control register
        pub const CH1CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            CHEN: u1,
            /// Enable bit for channel full transfer finish interrupt
            FTFIE: u1,
            /// Enable bit for channel half transfer finish interrupt
            HTFIE: u1,
            /// Enable bit for channel error interrupt
            ERRIE: u1,
            /// Transfer direction
            DIR: u1,
            /// Circular mode enable
            CMEN: u1,
            /// Next address generation algorithm of peripheral
            PNAGA: u1,
            /// Next address generation algorithm of memory
            MNAGA: u1,
            /// Transfer data size of peripheral
            PWIDTH: u2,
            /// Transfer data size of memory
            MWIDTH: u2,
            /// Priority level
            PRIO: u2,
            /// Memory to Memory Mode
            M2M: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x1c);

        /// address: 0x40020020
        /// Channel 1 counter register
        pub const CH1CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer counter
            CNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40020024
        /// Channel 1 peripheral base address register
        pub const CH1PADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral base address
            PADDR: u32,
        }), base_address + 0x24);

        /// address: 0x40020028
        /// Channel 1 memory base address register
        pub const CH1MADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory base address
            MADDR: u32,
        }), base_address + 0x28);

        /// address: 0x40020030
        /// Channel 2 control register
        pub const CH2CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            CHEN: u1,
            /// Enable bit for channel full transfer finish interrupt
            FTFIE: u1,
            /// Enable bit for channel half transfer finish interrupt
            HTFIE: u1,
            /// Enable bit for channel error interrupt
            ERRIE: u1,
            /// Transfer direction
            DIR: u1,
            /// Circular mode enable
            CMEN: u1,
            /// Next address generation algorithm of peripheral
            PNAGA: u1,
            /// Next address generation algorithm of memory
            MNAGA: u1,
            /// Transfer data size of peripheral
            PWIDTH: u2,
            /// Transfer data size of memory
            MWIDTH: u2,
            /// Priority level
            PRIO: u2,
            /// Memory to Memory Mode
            M2M: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x30);

        /// address: 0x40020034
        /// Channel 2 counter register
        pub const CH2CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer counter
            CNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40020038
        /// Channel 2 peripheral base address register
        pub const CH2PADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral base address
            PADDR: u32,
        }), base_address + 0x38);

        /// address: 0x4002003c
        /// Channel 2 memory base address register
        pub const CH2MADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory base address
            MADDR: u32,
        }), base_address + 0x3c);

        /// address: 0x40020044
        /// Channel 3 control register
        pub const CH3CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            CHEN: u1,
            /// Enable bit for channel full transfer finish interrupt
            FTFIE: u1,
            /// Enable bit for channel half transfer finish interrupt
            HTFIE: u1,
            /// Enable bit for channel error interrupt
            ERRIE: u1,
            /// Transfer direction
            DIR: u1,
            /// Circular mode enable
            CMEN: u1,
            /// Next address generation algorithm of peripheral
            PNAGA: u1,
            /// Next address generation algorithm of memory
            MNAGA: u1,
            /// Transfer data size of peripheral
            PWIDTH: u2,
            /// Transfer data size of memory
            MWIDTH: u2,
            /// Priority level
            PRIO: u2,
            /// Memory to Memory Mode
            M2M: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x44);

        /// address: 0x40020048
        /// Channel 3 counter register
        pub const CH3CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer counter
            CNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4002004c
        /// Channel 3 peripheral base address register
        pub const CH3PADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral base address
            PADDR: u32,
        }), base_address + 0x4c);

        /// address: 0x40020050
        /// Channel 3 memory base address register
        pub const CH3MADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory base address
            MADDR: u32,
        }), base_address + 0x50);

        /// address: 0x40020058
        /// Channel 4 control register
        pub const CH4CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            CHEN: u1,
            /// Enable bit for channel full transfer finish interrupt
            FTFIE: u1,
            /// Enable bit for channel half transfer finish interrupt
            HTFIE: u1,
            /// Enable bit for channel error interrupt
            ERRIE: u1,
            /// Transfer direction
            DIR: u1,
            /// Circular mode enable
            CMEN: u1,
            /// Next address generation algorithm of peripheral
            PNAGA: u1,
            /// Next address generation algorithm of memory
            MNAGA: u1,
            /// Transfer data size of peripheral
            PWIDTH: u2,
            /// Transfer data size of memory
            MWIDTH: u2,
            /// Priority level
            PRIO: u2,
            /// Memory to Memory Mode
            M2M: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x58);

        /// address: 0x4002005c
        /// Channel 4 counter register
        pub const CH4CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer counter
            CNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x40020060
        /// Channel 4 peripheral base address register
        pub const CH4PADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral base address
            PADDR: u32,
        }), base_address + 0x60);

        /// address: 0x40020064
        /// Channel 4 memory base address register
        pub const CH4MADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory base address
            MADDR: u32,
        }), base_address + 0x64);

        /// address: 0x4002006c
        /// Channel 5 control register
        pub const CH5CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            CHEN: u1,
            /// Enable bit for channel full transfer finish interrupt
            FTFIE: u1,
            /// Enable bit for channel half transfer finish interrupt
            HTFIE: u1,
            /// Enable bit for channel error interrupt
            ERRIE: u1,
            /// Transfer direction
            DIR: u1,
            /// Circular mode enable
            CMEN: u1,
            /// Next address generation algorithm of peripheral
            PNAGA: u1,
            /// Next address generation algorithm of memory
            MNAGA: u1,
            /// Transfer data size of peripheral
            PWIDTH: u2,
            /// Transfer data size of memory
            MWIDTH: u2,
            /// Priority level
            PRIO: u2,
            /// Memory to Memory Mode
            M2M: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x6c);

        /// address: 0x40020070
        /// Channel 5 counter register
        pub const CH5CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer counter
            CNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x70);

        /// address: 0x40020074
        /// Channel 5 peripheral base address register
        pub const CH5PADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral base address
            PADDR: u32,
        }), base_address + 0x74);

        /// address: 0x40020078
        /// Channel 5 memory base address register
        pub const CH5MADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory base address
            MADDR: u32,
        }), base_address + 0x78);

        /// address: 0x40020080
        /// Channel 6 control register
        pub const CH6CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            CHEN: u1,
            /// Enable bit for channel full transfer finish interrupt
            FTFIE: u1,
            /// Enable bit for channel half transfer finish interrupt
            HTFIE: u1,
            /// Enable bit for channel error interrupt
            ERRIE: u1,
            /// Transfer direction
            DIR: u1,
            /// Circular mode enable
            CMEN: u1,
            /// Next address generation algorithm of peripheral
            PNAGA: u1,
            /// Next address generation algorithm of memory
            MNAGA: u1,
            /// Transfer data size of peripheral
            PWIDTH: u2,
            /// Transfer data size of memory
            MWIDTH: u2,
            /// Priority level
            PRIO: u2,
            /// Memory to Memory Mode
            M2M: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x80);

        /// address: 0x40020084
        /// Channel 6 counter register
        pub const CH6CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer counter
            CNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x40020088
        /// Channel 6 peripheral base address register
        pub const CH6PADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral base address
            PADDR: u32,
        }), base_address + 0x88);

        /// address: 0x4002008c
        /// Channel 6 memory base address register
        pub const CH6MADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory base address
            MADDR: u32,
        }), base_address + 0x8c);
    };

    /// Direct memory access controller
    pub const DMA1 = struct {
        pub const base_address = 0x40020000;

        /// address: 0x40020000
        /// Interrupt flag register
        pub const INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Global interrupt flag of channel 0
            GIF0: u1,
            /// Full Transfer finish flag of channe 0
            FTFIF0: u1,
            /// Half transfer finish flag of channel 0
            HTFIF0: u1,
            /// Error flag of channel 0
            ERRIF0: u1,
            /// Global interrupt flag of channel 1
            GIF1: u1,
            /// Full Transfer finish flag of channe 1
            FTFIF1: u1,
            /// Half transfer finish flag of channel 1
            HTFIF1: u1,
            /// Error flag of channel 1
            ERRIF1: u1,
            /// Global interrupt flag of channel 2
            GIF2: u1,
            /// Full Transfer finish flag of channe 2
            FTFIF2: u1,
            /// Half transfer finish flag of channel 2
            HTFIF2: u1,
            /// Error flag of channel 2
            ERRIF2: u1,
            /// Global interrupt flag of channel 3
            GIF3: u1,
            /// Full Transfer finish flag of channe 3
            FTFIF3: u1,
            /// Half transfer finish flag of channel 3
            HTFIF3: u1,
            /// Error flag of channel 3
            ERRIF3: u1,
            /// Global interrupt flag of channel 4
            GIF4: u1,
            /// Full Transfer finish flag of channe 4
            FTFIF4: u1,
            /// Half transfer finish flag of channel 4
            HTFIF4: u1,
            /// Error flag of channel 4
            ERRIF4: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x0);

        /// address: 0x40020004
        /// Interrupt flag clear register
        pub const INTC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear global interrupt flag of channel 0
            GIFC0: u1,
            /// Clear bit for full transfer finish flag of channel 0
            FTFIFC0: u1,
            /// Clear bit for half transfer finish flag of channel 0
            HTFIFC0: u1,
            /// Clear bit for error flag of channel 0
            ERRIFC0: u1,
            /// Clear global interrupt flag of channel 1
            GIFC1: u1,
            /// Clear bit for full transfer finish flag of channel 1
            FTFIFC1: u1,
            /// Clear bit for half transfer finish flag of channel 1
            HTFIFC1: u1,
            /// Clear bit for error flag of channel 1
            ERRIFC1: u1,
            /// Clear global interrupt flag of channel 2
            GIFC2: u1,
            /// Clear bit for full transfer finish flag of channel 2
            FTFIFC2: u1,
            /// Clear bit for half transfer finish flag of channel 2
            HTFIFC2: u1,
            /// Clear bit for error flag of channel 2
            ERRIFC2: u1,
            /// Clear global interrupt flag of channel 3
            GIFC3: u1,
            /// Clear bit for full transfer finish flag of channel 3
            FTFIFC3: u1,
            /// Clear bit for half transfer finish flag of channel 3
            HTFIFC3: u1,
            /// Clear bit for error flag of channel 3
            ERRIFC3: u1,
            /// Clear global interrupt flag of channel 4
            GIFC4: u1,
            /// Clear bit for full transfer finish flag of channel 4
            FTFIFC4: u1,
            /// Clear bit for half transfer finish flag of channel 4
            HTFIFC4: u1,
            /// Clear bit for error flag of channel 4
            ERRIFC4: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x4);

        /// address: 0x40020008
        /// Channel 0 control register
        pub const CH0CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            CHEN: u1,
            /// Enable bit for channel full transfer finish interrupt
            FTFIE: u1,
            /// Enable bit for channel half transfer finish interrupt
            HTFIE: u1,
            /// Enable bit for channel error interrupt
            ERRIE: u1,
            /// Transfer direction
            DIR: u1,
            /// Circular mode enable
            CMEN: u1,
            /// Next address generation algorithm of peripheral
            PNAGA: u1,
            /// Next address generation algorithm of memory
            MNAGA: u1,
            /// Transfer data size of peripheral
            PWIDTH: u2,
            /// Transfer data size of memory
            MWIDTH: u2,
            /// Priority level
            PRIO: u2,
            /// Memory to Memory Mode
            M2M: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x8);

        /// address: 0x4002000c
        /// Channel 0 counter register
        pub const CH0CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer counter
            CNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40020010
        /// Channel 0 peripheral base address register
        pub const CH0PADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral base address
            PADDR: u32,
        }), base_address + 0x10);

        /// address: 0x40020014
        /// Channel 0 memory base address register
        pub const CH0MADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory base address
            MADDR: u32,
        }), base_address + 0x14);

        /// address: 0x4002001c
        /// Channel 1 control register
        pub const CH1CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            CHEN: u1,
            /// Enable bit for channel full transfer finish interrupt
            FTFIE: u1,
            /// Enable bit for channel half transfer finish interrupt
            HTFIE: u1,
            /// Enable bit for channel error interrupt
            ERRIE: u1,
            /// Transfer direction
            DIR: u1,
            /// Circular mode enable
            CMEN: u1,
            /// Next address generation algorithm of peripheral
            PNAGA: u1,
            /// Next address generation algorithm of memory
            MNAGA: u1,
            /// Transfer data size of peripheral
            PWIDTH: u2,
            /// Transfer data size of memory
            MWIDTH: u2,
            /// Priority level
            PRIO: u2,
            /// Memory to Memory Mode
            M2M: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x1c);

        /// address: 0x40020020
        /// Channel 1 counter register
        pub const CH1CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer counter
            CNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40020024
        /// Channel 1 peripheral base address register
        pub const CH1PADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral base address
            PADDR: u32,
        }), base_address + 0x24);

        /// address: 0x40020028
        /// Channel 1 memory base address register
        pub const CH1MADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory base address
            MADDR: u32,
        }), base_address + 0x28);

        /// address: 0x40020030
        /// Channel 2 control register
        pub const CH2CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            CHEN: u1,
            /// Enable bit for channel full transfer finish interrupt
            FTFIE: u1,
            /// Enable bit for channel half transfer finish interrupt
            HTFIE: u1,
            /// Enable bit for channel error interrupt
            ERRIE: u1,
            /// Transfer direction
            DIR: u1,
            /// Circular mode enable
            CMEN: u1,
            /// Next address generation algorithm of peripheral
            PNAGA: u1,
            /// Next address generation algorithm of memory
            MNAGA: u1,
            /// Transfer data size of peripheral
            PWIDTH: u2,
            /// Transfer data size of memory
            MWIDTH: u2,
            /// Priority level
            PRIO: u2,
            /// Memory to Memory Mode
            M2M: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x30);

        /// address: 0x40020034
        /// Channel 2 counter register
        pub const CH2CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer counter
            CNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40020038
        /// Channel 2 peripheral base address register
        pub const CH2PADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral base address
            PADDR: u32,
        }), base_address + 0x38);

        /// address: 0x4002003c
        /// Channel 2 memory base address register
        pub const CH2MADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory base address
            MADDR: u32,
        }), base_address + 0x3c);

        /// address: 0x40020044
        /// Channel 3 control register
        pub const CH3CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            CHEN: u1,
            /// Enable bit for channel full transfer finish interrupt
            FTFIE: u1,
            /// Enable bit for channel half transfer finish interrupt
            HTFIE: u1,
            /// Enable bit for channel error interrupt
            ERRIE: u1,
            /// Transfer direction
            DIR: u1,
            /// Circular mode enable
            CMEN: u1,
            /// Next address generation algorithm of peripheral
            PNAGA: u1,
            /// Next address generation algorithm of memory
            MNAGA: u1,
            /// Transfer data size of peripheral
            PWIDTH: u2,
            /// Transfer data size of memory
            MWIDTH: u2,
            /// Priority level
            PRIO: u2,
            /// Memory to Memory Mode
            M2M: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x44);

        /// address: 0x40020048
        /// Channel 3 counter register
        pub const CH3CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer counter
            CNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4002004c
        /// Channel 3 peripheral base address register
        pub const CH3PADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral base address
            PADDR: u32,
        }), base_address + 0x4c);

        /// address: 0x40020050
        /// Channel 3 memory base address register
        pub const CH3MADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory base address
            MADDR: u32,
        }), base_address + 0x50);

        /// address: 0x40020058
        /// Channel 4 control register
        pub const CH4CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            CHEN: u1,
            /// Enable bit for channel full transfer finish interrupt
            FTFIE: u1,
            /// Enable bit for channel half transfer finish interrupt
            HTFIE: u1,
            /// Enable bit for channel error interrupt
            ERRIE: u1,
            /// Transfer direction
            DIR: u1,
            /// Circular mode enable
            CMEN: u1,
            /// Next address generation algorithm of peripheral
            PNAGA: u1,
            /// Next address generation algorithm of memory
            MNAGA: u1,
            /// Transfer data size of peripheral
            PWIDTH: u2,
            /// Transfer data size of memory
            MWIDTH: u2,
            /// Priority level
            PRIO: u2,
            /// Memory to Memory Mode
            M2M: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x58);

        /// address: 0x4002005c
        /// Channel 4 counter register
        pub const CH4CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer counter
            CNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x40020060
        /// Channel 4 peripheral base address register
        pub const CH4PADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral base address
            PADDR: u32,
        }), base_address + 0x60);

        /// address: 0x40020064
        /// Channel 4 memory base address register
        pub const CH4MADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory base address
            MADDR: u32,
        }), base_address + 0x64);
    };

    /// External memory controller
    pub const EXMC = struct {
        pub const base_address = 0xa0000000;

        /// address: 0xa0000000
        /// SRAM/NOR flash control register 0
        pub const SNCTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// NOR bank enable
            NRBKEN: u1,
            /// NOR bank memory address/data multiplexing
            NRMUX: u1,
            /// NOR bank memory type
            NRTP: u2,
            /// NOR bank memory data bus width
            NRW: u2,
            /// NOR Flash access enable
            NREN: u1,
            reserved0: u1,
            reserved1: u1,
            /// NWAIT signal polarity
            NRWTPOL: u1,
            reserved2: u1,
            reserved3: u1,
            /// Write enable
            WREN: u1,
            /// NWAIT signal enable
            NRWTEN: u1,
            reserved4: u1,
            /// Asynchronous wait
            ASYNCWAIT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0xa0000004
        /// SRAM/NOR flash timing configuration register 0
        pub const SNTCFG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address setup time
            ASET: u4,
            /// Address hold time
            AHLD: u4,
            /// Data setup time
            DSET: u8,
            /// Bus latency
            BUSLAT: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x4);

        /// address: 0xa0000008
        /// SRAM/NOR flash control register 1
        pub const SNCTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// NOR bank enable
            NRBKEN: u1,
            /// NOR bank memory address/data multiplexing
            NRMUX: u1,
            /// NOR bank memory type
            NRTP: u2,
            /// NOR bank memory data bus width
            NRW: u2,
            /// NOR Flash access enable
            NREN: u1,
            reserved0: u1,
            reserved1: u1,
            /// NWAIT signal polarity
            NRWTPOL: u1,
            reserved2: u1,
            reserved3: u1,
            /// Write enable
            WREN: u1,
            /// NWAIT signal enable
            NRWTEN: u1,
            reserved4: u1,
            /// Asynchronous wait
            ASYNCWAIT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);
    };

    /// External interrupt/event
    /// controller
    pub const EXTI = struct {
        pub const base_address = 0x40010400;

        /// address: 0x40010400
        /// Interrupt enable register
        /// (EXTI_INTEN)
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable Interrupt on line 0
            INTEN0: u1,
            /// Enable Interrupt on line 1
            INTEN1: u1,
            /// Enable Interrupt on line 2
            INTEN2: u1,
            /// Enable Interrupt on line 3
            INTEN3: u1,
            /// Enable Interrupt on line 4
            INTEN4: u1,
            /// Enable Interrupt on line 5
            INTEN5: u1,
            /// Enable Interrupt on line 6
            INTEN6: u1,
            /// Enable Interrupt on line 7
            INTEN7: u1,
            /// Enable Interrupt on line 8
            INTEN8: u1,
            /// Enable Interrupt on line 9
            INTEN9: u1,
            /// Enable Interrupt on line 10
            INTEN10: u1,
            /// Enable Interrupt on line 11
            INTEN11: u1,
            /// Enable Interrupt on line 12
            INTEN12: u1,
            /// Enable Interrupt on line 13
            INTEN13: u1,
            /// Enable Interrupt on line 14
            INTEN14: u1,
            /// Enable Interrupt on line 15
            INTEN15: u1,
            /// Enable Interrupt on line 16
            INTEN16: u1,
            /// Enable Interrupt on line 17
            INTEN17: u1,
            /// Enable Interrupt on line 18
            INTEN18: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x0);

        /// address: 0x40010404
        /// Event enable register (EXTI_EVEN)
        pub const EVEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable Event on line 0
            EVEN0: u1,
            /// Enable Event on line 1
            EVEN1: u1,
            /// Enable Event on line 2
            EVEN2: u1,
            /// Enable Event on line 3
            EVEN3: u1,
            /// Enable Event on line 4
            EVEN4: u1,
            /// Enable Event on line 5
            EVEN5: u1,
            /// Enable Event on line 6
            EVEN6: u1,
            /// Enable Event on line 7
            EVEN7: u1,
            /// Enable Event on line 8
            EVEN8: u1,
            /// Enable Event on line 9
            EVEN9: u1,
            /// Enable Event on line 10
            EVEN10: u1,
            /// Enable Event on line 11
            EVEN11: u1,
            /// Enable Event on line 12
            EVEN12: u1,
            /// Enable Event on line 13
            EVEN13: u1,
            /// Enable Event on line 14
            EVEN14: u1,
            /// Enable Event on line 15
            EVEN15: u1,
            /// Enable Event on line 16
            EVEN16: u1,
            /// Enable Event on line 17
            EVEN17: u1,
            /// Enable Event on line 18
            EVEN18: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x4);

        /// address: 0x40010408
        /// Rising Edge Trigger Enable register
        /// (EXTI_RTEN)
        pub const RTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rising edge trigger enable of
            /// line 0
            RTEN0: u1,
            /// Rising edge trigger enable of
            /// line 1
            RTEN1: u1,
            /// Rising edge trigger enable of
            /// line 2
            RTEN2: u1,
            /// Rising edge trigger enable of
            /// line 3
            RTEN3: u1,
            /// Rising edge trigger enable of
            /// line 4
            RTEN4: u1,
            /// Rising edge trigger enable of
            /// line 5
            RTEN5: u1,
            /// Rising edge trigger enable of
            /// line 6
            RTEN6: u1,
            /// Rising edge trigger enable of
            /// line 7
            RTEN7: u1,
            /// Rising edge trigger enable of
            /// line 8
            RTEN8: u1,
            /// Rising edge trigger enable of
            /// line 9
            RTEN9: u1,
            /// Rising edge trigger enable of
            /// line 10
            RTEN10: u1,
            /// Rising edge trigger enable of
            /// line 11
            RTEN11: u1,
            /// Rising edge trigger enable of
            /// line 12
            RTEN12: u1,
            /// Rising edge trigger enable of
            /// line 13
            RTEN13: u1,
            /// Rising edge trigger enable of
            /// line 14
            RTEN14: u1,
            /// Rising edge trigger enable of
            /// line 15
            RTEN15: u1,
            /// Rising edge trigger enable of
            /// line 16
            RTEN16: u1,
            /// Rising edge trigger enable of
            /// line 17
            RTEN17: u1,
            /// Rising edge trigger enable of
            /// line 18
            RTEN18: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x8);

        /// address: 0x4001040c
        /// Falling Egde Trigger Enable register
        /// (EXTI_FTEN)
        pub const FTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Falling edge trigger enable of
            /// line 0
            FTEN0: u1,
            /// Falling edge trigger enable of
            /// line 1
            FTEN1: u1,
            /// Falling edge trigger enable of
            /// line 2
            FTEN2: u1,
            /// Falling edge trigger enable of
            /// line 3
            FTEN3: u1,
            /// Falling edge trigger enable of
            /// line 4
            FTEN4: u1,
            /// Falling edge trigger enable of
            /// line 5
            FTEN5: u1,
            /// Falling edge trigger enable of
            /// line 6
            FTEN6: u1,
            /// Falling edge trigger enable of
            /// line 7
            FTEN7: u1,
            /// Falling edge trigger enable of
            /// line 8
            FTEN8: u1,
            /// Falling edge trigger enable of
            /// line 9
            FTEN9: u1,
            /// Falling edge trigger enable of
            /// line 10
            FTEN10: u1,
            /// Falling edge trigger enable of
            /// line 11
            FTEN11: u1,
            /// Falling edge trigger enable of
            /// line 12
            FTEN12: u1,
            /// Falling edge trigger enable of
            /// line 13
            FTEN13: u1,
            /// Falling edge trigger enable of
            /// line 14
            FTEN14: u1,
            /// Falling edge trigger enable of
            /// line 15
            FTEN15: u1,
            /// Falling edge trigger enable of
            /// line 16
            FTEN16: u1,
            /// Falling edge trigger enable of
            /// line 17
            FTEN17: u1,
            /// Falling edge trigger enable of
            /// line 18
            FTEN18: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xc);

        /// address: 0x40010410
        /// Software interrupt event register
        /// (EXTI_SWIEV)
        pub const SWIEV = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt/Event software trigger on line
            /// 0
            SWIEV0: u1,
            /// Interrupt/Event software trigger on line
            /// 1
            SWIEV1: u1,
            /// Interrupt/Event software trigger on line
            /// 2
            SWIEV2: u1,
            /// Interrupt/Event software trigger on line
            /// 3
            SWIEV3: u1,
            /// Interrupt/Event software trigger on line
            /// 4
            SWIEV4: u1,
            /// Interrupt/Event software trigger on line
            /// 5
            SWIEV5: u1,
            /// Interrupt/Event software trigger on line
            /// 6
            SWIEV6: u1,
            /// Interrupt/Event software trigger on line
            /// 7
            SWIEV7: u1,
            /// Interrupt/Event software trigger on line
            /// 8
            SWIEV8: u1,
            /// Interrupt/Event software trigger on line
            /// 9
            SWIEV9: u1,
            /// Interrupt/Event software trigger on line
            /// 10
            SWIEV10: u1,
            /// Interrupt/Event software trigger on line
            /// 11
            SWIEV11: u1,
            /// Interrupt/Event software trigger on line
            /// 12
            SWIEV12: u1,
            /// Interrupt/Event software trigger on line
            /// 13
            SWIEV13: u1,
            /// Interrupt/Event software trigger on line
            /// 14
            SWIEV14: u1,
            /// Interrupt/Event software trigger on line
            /// 15
            SWIEV15: u1,
            /// Interrupt/Event software trigger on line
            /// 16
            SWIEV16: u1,
            /// Interrupt/Event software trigger on line
            /// 17
            SWIEV17: u1,
            /// Interrupt/Event software trigger on line
            /// 18
            SWIEV18: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x10);

        /// address: 0x40010414
        /// Pending register (EXTI_PD)
        pub const PD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt pending status of line 0
            PD0: u1,
            /// Interrupt pending status of line 1
            PD1: u1,
            /// Interrupt pending status of line 2
            PD2: u1,
            /// Interrupt pending status of line 3
            PD3: u1,
            /// Interrupt pending status of line 4
            PD4: u1,
            /// Interrupt pending status of line 5
            PD5: u1,
            /// Interrupt pending status of line 6
            PD6: u1,
            /// Interrupt pending status of line 7
            PD7: u1,
            /// Interrupt pending status of line 8
            PD8: u1,
            /// Interrupt pending status of line 9
            PD9: u1,
            /// Interrupt pending status of line 10
            PD10: u1,
            /// Interrupt pending status of line 11
            PD11: u1,
            /// Interrupt pending status of line 12
            PD12: u1,
            /// Interrupt pending status of line 13
            PD13: u1,
            /// Interrupt pending status of line 14
            PD14: u1,
            /// Interrupt pending status of line 15
            PD15: u1,
            /// Interrupt pending status of line 16
            PD16: u1,
            /// Interrupt pending status of line 17
            PD17: u1,
            /// Interrupt pending status of line 18
            PD18: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x14);
    };

    /// FMC
    pub const FMC = struct {
        pub const base_address = 0x40022000;

        /// address: 0x40022000
        /// wait state counter register
        pub const WS = @intToPtr(*volatile Mmio(32, packed struct {
            /// wait state counter register
            WSCNT: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x0);

        /// address: 0x40022004
        /// Unlock key register 0
        pub const KEY0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// FMC_CTL0 unlock key
            KEY: u32,
        }), base_address + 0x4);

        /// address: 0x40022008
        /// Option byte unlock key register
        pub const OBKEY = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4002200c
        /// Status register 0
        pub const STAT0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The flash is busy bit
            BUSY: u1,
            reserved0: u1,
            /// Program error flag bit
            PGERR: u1,
            reserved1: u1,
            /// Erase/Program protection error flag bit
            WPERR: u1,
            /// End of operation flag bit
            ENDF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xc);

        /// address: 0x40022010
        /// Control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Main flash program for bank0 command bit
            PG: u1,
            /// Main flash page erase for bank0 command bit
            PER: u1,
            /// Main flash mass erase for bank0 command bit
            MER: u1,
            reserved0: u1,
            /// Option bytes program command bit
            OBPG: u1,
            /// Option bytes erase command bit
            OBER: u1,
            /// Send erase command to FMC bit
            START: u1,
            /// FMC_CTL0 lock bit
            LK: u1,
            reserved1: u1,
            /// Option byte erase/program enable bit
            OBWEN: u1,
            /// Error interrupt enable bit
            ERRIE: u1,
            reserved2: u1,
            /// End of operation interrupt enable bit
            ENDIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40022014
        /// Address register 0
        pub const ADDR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Flash erase/program command address bits
            ADDR: u32,
        }), base_address + 0x14);

        /// address: 0x4002201c
        /// Option byte status register
        pub const OBSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Option bytes read error bit
            OBERR: u1,
            /// Option bytes security protection code
            SPC: u1,
            /// Store USER of option bytes block after system reset
            USER: u8,
            /// Store DATA[15:0] of option bytes block after system reset
            DATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x1c);

        /// address: 0x40022020
        /// Erase/Program Protection register
        pub const WP = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x40022100
        /// Product ID register
        pub const PID = @intToPtr(*volatile u32, base_address + 0x100);
    };

    /// free watchdog timer
    pub const FWDGT = struct {
        pub const base_address = 0x40003000;

        /// address: 0x40003000
        /// Control register
        pub const CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Key value
            CMD: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40003004
        /// Prescaler register
        pub const PSC = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x4);

        /// address: 0x40003008
        /// Reload register
        pub const RLD = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x8);

        /// address: 0x4000300c
        /// Status register
        pub const STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Free watchdog timer prescaler value update
            PUD: u1,
            /// Free watchdog timer counter reload value update
            RUD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);
    };

    /// General-purpose I/Os
    pub const GPIOA = struct {
        pub const base_address = 0x40010800;

        /// address: 0x40010800
        /// port control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x mode bits (x =
            /// 0)
            MD0: u2,
            /// Port x configuration bits (x =
            /// 0)
            CTL0: u2,
            /// Port x mode bits (x =
            /// 1)
            MD1: u2,
            /// Port x configuration bits (x =
            /// 1)
            CTL1: u2,
            /// Port x mode bits (x =
            /// 2 )
            MD2: u2,
            /// Port x configuration bits (x =
            /// 2)
            CTL2: u2,
            /// Port x mode bits (x =
            /// 3 )
            MD3: u2,
            /// Port x configuration bits (x =
            /// 3)
            CTL3: u2,
            /// Port x mode bits (x =
            /// 4)
            MD4: u2,
            /// Port x configuration bits (x =
            /// 4)
            CTL4: u2,
            /// Port x mode bits (x =
            /// 5)
            MD5: u2,
            /// Port x configuration bits (x =
            /// 5)
            CTL5: u2,
            /// Port x mode bits (x =
            /// 6)
            MD6: u2,
            /// Port x configuration bits (x =
            /// 6)
            CTL6: u2,
            /// Port x mode bits (x =
            /// 7)
            MD7: u2,
            /// Port x configuration bits (x =
            /// 7)
            CTL7: u2,
        }), base_address + 0x0);

        /// address: 0x40010804
        /// port control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x mode bits (x =
            /// 8)
            MD8: u2,
            /// Port x configuration bits (x =
            /// 8)
            CTL8: u2,
            /// Port x mode bits (x =
            /// 9)
            MD9: u2,
            /// Port x configuration bits (x =
            /// 9)
            CTL9: u2,
            /// Port x mode bits (x =
            /// 10 )
            MD10: u2,
            /// Port x configuration bits (x =
            /// 10)
            CTL10: u2,
            /// Port x mode bits (x =
            /// 11 )
            MD11: u2,
            /// Port x configuration bits (x =
            /// 11)
            CTL11: u2,
            /// Port x mode bits (x =
            /// 12)
            MD12: u2,
            /// Port x configuration bits (x =
            /// 12)
            CTL12: u2,
            /// Port x mode bits (x =
            /// 13)
            MD13: u2,
            /// Port x configuration bits (x =
            /// 13)
            CTL13: u2,
            /// Port x mode bits (x =
            /// 14)
            MD14: u2,
            /// Port x configuration bits (x =
            /// 14)
            CTL14: u2,
            /// Port x mode bits (x =
            /// 15)
            MD15: u2,
            /// Port x configuration bits (x =
            /// 15)
            CTL15: u2,
        }), base_address + 0x4);

        /// address: 0x40010808
        /// Port input status register
        pub const ISTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input status
            ISTAT0: u1,
            /// Port input status
            ISTAT1: u1,
            /// Port input status
            ISTAT2: u1,
            /// Port input status
            ISTAT3: u1,
            /// Port input status
            ISTAT4: u1,
            /// Port input status
            ISTAT5: u1,
            /// Port input status
            ISTAT6: u1,
            /// Port input status
            ISTAT7: u1,
            /// Port input status
            ISTAT8: u1,
            /// Port input status
            ISTAT9: u1,
            /// Port input status
            ISTAT10: u1,
            /// Port input status
            ISTAT11: u1,
            /// Port input status
            ISTAT12: u1,
            /// Port input status
            ISTAT13: u1,
            /// Port input status
            ISTAT14: u1,
            /// Port input status
            ISTAT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001080c
        /// Port output control register
        pub const OCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output control
            OCTL0: u1,
            /// Port output control
            OCTL1: u1,
            /// Port output control
            OCTL2: u1,
            /// Port output control
            OCTL3: u1,
            /// Port output control
            OCTL4: u1,
            /// Port output control
            OCTL5: u1,
            /// Port output control
            OCTL6: u1,
            /// Port output control
            OCTL7: u1,
            /// Port output control
            OCTL8: u1,
            /// Port output control
            OCTL9: u1,
            /// Port output control
            OCTL10: u1,
            /// Port output control
            OCTL11: u1,
            /// Port output control
            OCTL12: u1,
            /// Port output control
            OCTL13: u1,
            /// Port output control
            OCTL14: u1,
            /// Port output control
            OCTL15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40010810
        /// Port bit operate register
        pub const BOP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 0 Set bit
            BOP0: u1,
            /// Port 1 Set bit
            BOP1: u1,
            /// Port 2 Set bit
            BOP2: u1,
            /// Port 3 Set bit
            BOP3: u1,
            /// Port 4 Set bit
            BOP4: u1,
            /// Port 5 Set bit
            BOP5: u1,
            /// Port 6 Set bit
            BOP6: u1,
            /// Port 7 Set bit
            BOP7: u1,
            /// Port 8 Set bit
            BOP8: u1,
            /// Port 9 Set bit
            BOP9: u1,
            /// Port 10 Set bit
            BOP10: u1,
            /// Port 11 Set bit
            BOP11: u1,
            /// Port 12 Set bit
            BOP12: u1,
            /// Port 13 Set bit
            BOP13: u1,
            /// Port 14 Set bit
            BOP14: u1,
            /// Port 15 Set bit
            BOP15: u1,
            /// Port 0 Clear bit
            CR0: u1,
            /// Port 1 Clear bit
            CR1: u1,
            /// Port 2 Clear bit
            CR2: u1,
            /// Port 3 Clear bit
            CR3: u1,
            /// Port 4 Clear bit
            CR4: u1,
            /// Port 5 Clear bit
            CR5: u1,
            /// Port 6 Clear bit
            CR6: u1,
            /// Port 7 Clear bit
            CR7: u1,
            /// Port 8 Clear bit
            CR8: u1,
            /// Port 9 Clear bit
            CR9: u1,
            /// Port 10 Clear bit
            CR10: u1,
            /// Port 11 Clear bit
            CR11: u1,
            /// Port 12 Clear bit
            CR12: u1,
            /// Port 13 Clear bit
            CR13: u1,
            /// Port 14 Clear bit
            CR14: u1,
            /// Port 15 Clear bit
            CR15: u1,
        }), base_address + 0x10);

        /// address: 0x40010814
        /// Port bit clear register
        pub const BC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 0 Clear bit
            CR0: u1,
            /// Port 1 Clear bit
            CR1: u1,
            /// Port 2 Clear bit
            CR2: u1,
            /// Port 3 Clear bit
            CR3: u1,
            /// Port 4 Clear bit
            CR4: u1,
            /// Port 5 Clear bit
            CR5: u1,
            /// Port 6 Clear bit
            CR6: u1,
            /// Port 7 Clear bit
            CR7: u1,
            /// Port 8 Clear bit
            CR8: u1,
            /// Port 9 Clear bit
            CR9: u1,
            /// Port 10 Clear bit
            CR10: u1,
            /// Port 11 Clear bit
            CR11: u1,
            /// Port 12 Clear bit
            CR12: u1,
            /// Port 13 Clear bit
            CR13: u1,
            /// Port 14 Clear bit
            CR14: u1,
            /// Port 15 Clear bit
            CR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40010818
        /// GPIO port configuration lock
        /// register
        pub const LOCK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port Lock bit 0
            LK0: u1,
            /// Port Lock bit 1
            LK1: u1,
            /// Port Lock bit 2
            LK2: u1,
            /// Port Lock bit 3
            LK3: u1,
            /// Port Lock bit 4
            LK4: u1,
            /// Port Lock bit 5
            LK5: u1,
            /// Port Lock bit 6
            LK6: u1,
            /// Port Lock bit 7
            LK7: u1,
            /// Port Lock bit 8
            LK8: u1,
            /// Port Lock bit 9
            LK9: u1,
            /// Port Lock bit 10
            LK10: u1,
            /// Port Lock bit 11
            LK11: u1,
            /// Port Lock bit 12
            LK12: u1,
            /// Port Lock bit 13
            LK13: u1,
            /// Port Lock bit 14
            LK14: u1,
            /// Port Lock bit 15
            LK15: u1,
            /// Lock sequence key
            LKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);
    };
    pub const GPIOB = struct {
        pub const base_address = 0x40010c00;

        /// address: 0x40010c00
        /// port control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x mode bits (x =
            /// 0)
            MD0: u2,
            /// Port x configuration bits (x =
            /// 0)
            CTL0: u2,
            /// Port x mode bits (x =
            /// 1)
            MD1: u2,
            /// Port x configuration bits (x =
            /// 1)
            CTL1: u2,
            /// Port x mode bits (x =
            /// 2 )
            MD2: u2,
            /// Port x configuration bits (x =
            /// 2)
            CTL2: u2,
            /// Port x mode bits (x =
            /// 3 )
            MD3: u2,
            /// Port x configuration bits (x =
            /// 3)
            CTL3: u2,
            /// Port x mode bits (x =
            /// 4)
            MD4: u2,
            /// Port x configuration bits (x =
            /// 4)
            CTL4: u2,
            /// Port x mode bits (x =
            /// 5)
            MD5: u2,
            /// Port x configuration bits (x =
            /// 5)
            CTL5: u2,
            /// Port x mode bits (x =
            /// 6)
            MD6: u2,
            /// Port x configuration bits (x =
            /// 6)
            CTL6: u2,
            /// Port x mode bits (x =
            /// 7)
            MD7: u2,
            /// Port x configuration bits (x =
            /// 7)
            CTL7: u2,
        }), base_address + 0x0);

        /// address: 0x40010c04
        /// port control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x mode bits (x =
            /// 8)
            MD8: u2,
            /// Port x configuration bits (x =
            /// 8)
            CTL8: u2,
            /// Port x mode bits (x =
            /// 9)
            MD9: u2,
            /// Port x configuration bits (x =
            /// 9)
            CTL9: u2,
            /// Port x mode bits (x =
            /// 10 )
            MD10: u2,
            /// Port x configuration bits (x =
            /// 10)
            CTL10: u2,
            /// Port x mode bits (x =
            /// 11 )
            MD11: u2,
            /// Port x configuration bits (x =
            /// 11)
            CTL11: u2,
            /// Port x mode bits (x =
            /// 12)
            MD12: u2,
            /// Port x configuration bits (x =
            /// 12)
            CTL12: u2,
            /// Port x mode bits (x =
            /// 13)
            MD13: u2,
            /// Port x configuration bits (x =
            /// 13)
            CTL13: u2,
            /// Port x mode bits (x =
            /// 14)
            MD14: u2,
            /// Port x configuration bits (x =
            /// 14)
            CTL14: u2,
            /// Port x mode bits (x =
            /// 15)
            MD15: u2,
            /// Port x configuration bits (x =
            /// 15)
            CTL15: u2,
        }), base_address + 0x4);

        /// address: 0x40010c08
        /// Port input status register
        pub const ISTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input status
            ISTAT0: u1,
            /// Port input status
            ISTAT1: u1,
            /// Port input status
            ISTAT2: u1,
            /// Port input status
            ISTAT3: u1,
            /// Port input status
            ISTAT4: u1,
            /// Port input status
            ISTAT5: u1,
            /// Port input status
            ISTAT6: u1,
            /// Port input status
            ISTAT7: u1,
            /// Port input status
            ISTAT8: u1,
            /// Port input status
            ISTAT9: u1,
            /// Port input status
            ISTAT10: u1,
            /// Port input status
            ISTAT11: u1,
            /// Port input status
            ISTAT12: u1,
            /// Port input status
            ISTAT13: u1,
            /// Port input status
            ISTAT14: u1,
            /// Port input status
            ISTAT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x40010c0c
        /// Port output control register
        pub const OCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output control
            OCTL0: u1,
            /// Port output control
            OCTL1: u1,
            /// Port output control
            OCTL2: u1,
            /// Port output control
            OCTL3: u1,
            /// Port output control
            OCTL4: u1,
            /// Port output control
            OCTL5: u1,
            /// Port output control
            OCTL6: u1,
            /// Port output control
            OCTL7: u1,
            /// Port output control
            OCTL8: u1,
            /// Port output control
            OCTL9: u1,
            /// Port output control
            OCTL10: u1,
            /// Port output control
            OCTL11: u1,
            /// Port output control
            OCTL12: u1,
            /// Port output control
            OCTL13: u1,
            /// Port output control
            OCTL14: u1,
            /// Port output control
            OCTL15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40010c10
        /// Port bit operate register
        pub const BOP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 0 Set bit
            BOP0: u1,
            /// Port 1 Set bit
            BOP1: u1,
            /// Port 2 Set bit
            BOP2: u1,
            /// Port 3 Set bit
            BOP3: u1,
            /// Port 4 Set bit
            BOP4: u1,
            /// Port 5 Set bit
            BOP5: u1,
            /// Port 6 Set bit
            BOP6: u1,
            /// Port 7 Set bit
            BOP7: u1,
            /// Port 8 Set bit
            BOP8: u1,
            /// Port 9 Set bit
            BOP9: u1,
            /// Port 10 Set bit
            BOP10: u1,
            /// Port 11 Set bit
            BOP11: u1,
            /// Port 12 Set bit
            BOP12: u1,
            /// Port 13 Set bit
            BOP13: u1,
            /// Port 14 Set bit
            BOP14: u1,
            /// Port 15 Set bit
            BOP15: u1,
            /// Port 0 Clear bit
            CR0: u1,
            /// Port 1 Clear bit
            CR1: u1,
            /// Port 2 Clear bit
            CR2: u1,
            /// Port 3 Clear bit
            CR3: u1,
            /// Port 4 Clear bit
            CR4: u1,
            /// Port 5 Clear bit
            CR5: u1,
            /// Port 6 Clear bit
            CR6: u1,
            /// Port 7 Clear bit
            CR7: u1,
            /// Port 8 Clear bit
            CR8: u1,
            /// Port 9 Clear bit
            CR9: u1,
            /// Port 10 Clear bit
            CR10: u1,
            /// Port 11 Clear bit
            CR11: u1,
            /// Port 12 Clear bit
            CR12: u1,
            /// Port 13 Clear bit
            CR13: u1,
            /// Port 14 Clear bit
            CR14: u1,
            /// Port 15 Clear bit
            CR15: u1,
        }), base_address + 0x10);

        /// address: 0x40010c14
        /// Port bit clear register
        pub const BC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 0 Clear bit
            CR0: u1,
            /// Port 1 Clear bit
            CR1: u1,
            /// Port 2 Clear bit
            CR2: u1,
            /// Port 3 Clear bit
            CR3: u1,
            /// Port 4 Clear bit
            CR4: u1,
            /// Port 5 Clear bit
            CR5: u1,
            /// Port 6 Clear bit
            CR6: u1,
            /// Port 7 Clear bit
            CR7: u1,
            /// Port 8 Clear bit
            CR8: u1,
            /// Port 9 Clear bit
            CR9: u1,
            /// Port 10 Clear bit
            CR10: u1,
            /// Port 11 Clear bit
            CR11: u1,
            /// Port 12 Clear bit
            CR12: u1,
            /// Port 13 Clear bit
            CR13: u1,
            /// Port 14 Clear bit
            CR14: u1,
            /// Port 15 Clear bit
            CR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40010c18
        /// GPIO port configuration lock
        /// register
        pub const LOCK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port Lock bit 0
            LK0: u1,
            /// Port Lock bit 1
            LK1: u1,
            /// Port Lock bit 2
            LK2: u1,
            /// Port Lock bit 3
            LK3: u1,
            /// Port Lock bit 4
            LK4: u1,
            /// Port Lock bit 5
            LK5: u1,
            /// Port Lock bit 6
            LK6: u1,
            /// Port Lock bit 7
            LK7: u1,
            /// Port Lock bit 8
            LK8: u1,
            /// Port Lock bit 9
            LK9: u1,
            /// Port Lock bit 10
            LK10: u1,
            /// Port Lock bit 11
            LK11: u1,
            /// Port Lock bit 12
            LK12: u1,
            /// Port Lock bit 13
            LK13: u1,
            /// Port Lock bit 14
            LK14: u1,
            /// Port Lock bit 15
            LK15: u1,
            /// Lock sequence key
            LKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);
    };
    pub const GPIOC = struct {
        pub const base_address = 0x40011000;

        /// address: 0x40011000
        /// port control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x mode bits (x =
            /// 0)
            MD0: u2,
            /// Port x configuration bits (x =
            /// 0)
            CTL0: u2,
            /// Port x mode bits (x =
            /// 1)
            MD1: u2,
            /// Port x configuration bits (x =
            /// 1)
            CTL1: u2,
            /// Port x mode bits (x =
            /// 2 )
            MD2: u2,
            /// Port x configuration bits (x =
            /// 2)
            CTL2: u2,
            /// Port x mode bits (x =
            /// 3 )
            MD3: u2,
            /// Port x configuration bits (x =
            /// 3)
            CTL3: u2,
            /// Port x mode bits (x =
            /// 4)
            MD4: u2,
            /// Port x configuration bits (x =
            /// 4)
            CTL4: u2,
            /// Port x mode bits (x =
            /// 5)
            MD5: u2,
            /// Port x configuration bits (x =
            /// 5)
            CTL5: u2,
            /// Port x mode bits (x =
            /// 6)
            MD6: u2,
            /// Port x configuration bits (x =
            /// 6)
            CTL6: u2,
            /// Port x mode bits (x =
            /// 7)
            MD7: u2,
            /// Port x configuration bits (x =
            /// 7)
            CTL7: u2,
        }), base_address + 0x0);

        /// address: 0x40011004
        /// port control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x mode bits (x =
            /// 8)
            MD8: u2,
            /// Port x configuration bits (x =
            /// 8)
            CTL8: u2,
            /// Port x mode bits (x =
            /// 9)
            MD9: u2,
            /// Port x configuration bits (x =
            /// 9)
            CTL9: u2,
            /// Port x mode bits (x =
            /// 10 )
            MD10: u2,
            /// Port x configuration bits (x =
            /// 10)
            CTL10: u2,
            /// Port x mode bits (x =
            /// 11 )
            MD11: u2,
            /// Port x configuration bits (x =
            /// 11)
            CTL11: u2,
            /// Port x mode bits (x =
            /// 12)
            MD12: u2,
            /// Port x configuration bits (x =
            /// 12)
            CTL12: u2,
            /// Port x mode bits (x =
            /// 13)
            MD13: u2,
            /// Port x configuration bits (x =
            /// 13)
            CTL13: u2,
            /// Port x mode bits (x =
            /// 14)
            MD14: u2,
            /// Port x configuration bits (x =
            /// 14)
            CTL14: u2,
            /// Port x mode bits (x =
            /// 15)
            MD15: u2,
            /// Port x configuration bits (x =
            /// 15)
            CTL15: u2,
        }), base_address + 0x4);

        /// address: 0x40011008
        /// Port input status register
        pub const ISTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input status
            ISTAT0: u1,
            /// Port input status
            ISTAT1: u1,
            /// Port input status
            ISTAT2: u1,
            /// Port input status
            ISTAT3: u1,
            /// Port input status
            ISTAT4: u1,
            /// Port input status
            ISTAT5: u1,
            /// Port input status
            ISTAT6: u1,
            /// Port input status
            ISTAT7: u1,
            /// Port input status
            ISTAT8: u1,
            /// Port input status
            ISTAT9: u1,
            /// Port input status
            ISTAT10: u1,
            /// Port input status
            ISTAT11: u1,
            /// Port input status
            ISTAT12: u1,
            /// Port input status
            ISTAT13: u1,
            /// Port input status
            ISTAT14: u1,
            /// Port input status
            ISTAT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001100c
        /// Port output control register
        pub const OCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output control
            OCTL0: u1,
            /// Port output control
            OCTL1: u1,
            /// Port output control
            OCTL2: u1,
            /// Port output control
            OCTL3: u1,
            /// Port output control
            OCTL4: u1,
            /// Port output control
            OCTL5: u1,
            /// Port output control
            OCTL6: u1,
            /// Port output control
            OCTL7: u1,
            /// Port output control
            OCTL8: u1,
            /// Port output control
            OCTL9: u1,
            /// Port output control
            OCTL10: u1,
            /// Port output control
            OCTL11: u1,
            /// Port output control
            OCTL12: u1,
            /// Port output control
            OCTL13: u1,
            /// Port output control
            OCTL14: u1,
            /// Port output control
            OCTL15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40011010
        /// Port bit operate register
        pub const BOP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 0 Set bit
            BOP0: u1,
            /// Port 1 Set bit
            BOP1: u1,
            /// Port 2 Set bit
            BOP2: u1,
            /// Port 3 Set bit
            BOP3: u1,
            /// Port 4 Set bit
            BOP4: u1,
            /// Port 5 Set bit
            BOP5: u1,
            /// Port 6 Set bit
            BOP6: u1,
            /// Port 7 Set bit
            BOP7: u1,
            /// Port 8 Set bit
            BOP8: u1,
            /// Port 9 Set bit
            BOP9: u1,
            /// Port 10 Set bit
            BOP10: u1,
            /// Port 11 Set bit
            BOP11: u1,
            /// Port 12 Set bit
            BOP12: u1,
            /// Port 13 Set bit
            BOP13: u1,
            /// Port 14 Set bit
            BOP14: u1,
            /// Port 15 Set bit
            BOP15: u1,
            /// Port 0 Clear bit
            CR0: u1,
            /// Port 1 Clear bit
            CR1: u1,
            /// Port 2 Clear bit
            CR2: u1,
            /// Port 3 Clear bit
            CR3: u1,
            /// Port 4 Clear bit
            CR4: u1,
            /// Port 5 Clear bit
            CR5: u1,
            /// Port 6 Clear bit
            CR6: u1,
            /// Port 7 Clear bit
            CR7: u1,
            /// Port 8 Clear bit
            CR8: u1,
            /// Port 9 Clear bit
            CR9: u1,
            /// Port 10 Clear bit
            CR10: u1,
            /// Port 11 Clear bit
            CR11: u1,
            /// Port 12 Clear bit
            CR12: u1,
            /// Port 13 Clear bit
            CR13: u1,
            /// Port 14 Clear bit
            CR14: u1,
            /// Port 15 Clear bit
            CR15: u1,
        }), base_address + 0x10);

        /// address: 0x40011014
        /// Port bit clear register
        pub const BC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 0 Clear bit
            CR0: u1,
            /// Port 1 Clear bit
            CR1: u1,
            /// Port 2 Clear bit
            CR2: u1,
            /// Port 3 Clear bit
            CR3: u1,
            /// Port 4 Clear bit
            CR4: u1,
            /// Port 5 Clear bit
            CR5: u1,
            /// Port 6 Clear bit
            CR6: u1,
            /// Port 7 Clear bit
            CR7: u1,
            /// Port 8 Clear bit
            CR8: u1,
            /// Port 9 Clear bit
            CR9: u1,
            /// Port 10 Clear bit
            CR10: u1,
            /// Port 11 Clear bit
            CR11: u1,
            /// Port 12 Clear bit
            CR12: u1,
            /// Port 13 Clear bit
            CR13: u1,
            /// Port 14 Clear bit
            CR14: u1,
            /// Port 15 Clear bit
            CR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40011018
        /// GPIO port configuration lock
        /// register
        pub const LOCK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port Lock bit 0
            LK0: u1,
            /// Port Lock bit 1
            LK1: u1,
            /// Port Lock bit 2
            LK2: u1,
            /// Port Lock bit 3
            LK3: u1,
            /// Port Lock bit 4
            LK4: u1,
            /// Port Lock bit 5
            LK5: u1,
            /// Port Lock bit 6
            LK6: u1,
            /// Port Lock bit 7
            LK7: u1,
            /// Port Lock bit 8
            LK8: u1,
            /// Port Lock bit 9
            LK9: u1,
            /// Port Lock bit 10
            LK10: u1,
            /// Port Lock bit 11
            LK11: u1,
            /// Port Lock bit 12
            LK12: u1,
            /// Port Lock bit 13
            LK13: u1,
            /// Port Lock bit 14
            LK14: u1,
            /// Port Lock bit 15
            LK15: u1,
            /// Lock sequence key
            LKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);
    };
    pub const GPIOD = struct {
        pub const base_address = 0x40011400;

        /// address: 0x40011400
        /// port control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x mode bits (x =
            /// 0)
            MD0: u2,
            /// Port x configuration bits (x =
            /// 0)
            CTL0: u2,
            /// Port x mode bits (x =
            /// 1)
            MD1: u2,
            /// Port x configuration bits (x =
            /// 1)
            CTL1: u2,
            /// Port x mode bits (x =
            /// 2 )
            MD2: u2,
            /// Port x configuration bits (x =
            /// 2)
            CTL2: u2,
            /// Port x mode bits (x =
            /// 3 )
            MD3: u2,
            /// Port x configuration bits (x =
            /// 3)
            CTL3: u2,
            /// Port x mode bits (x =
            /// 4)
            MD4: u2,
            /// Port x configuration bits (x =
            /// 4)
            CTL4: u2,
            /// Port x mode bits (x =
            /// 5)
            MD5: u2,
            /// Port x configuration bits (x =
            /// 5)
            CTL5: u2,
            /// Port x mode bits (x =
            /// 6)
            MD6: u2,
            /// Port x configuration bits (x =
            /// 6)
            CTL6: u2,
            /// Port x mode bits (x =
            /// 7)
            MD7: u2,
            /// Port x configuration bits (x =
            /// 7)
            CTL7: u2,
        }), base_address + 0x0);

        /// address: 0x40011404
        /// port control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x mode bits (x =
            /// 8)
            MD8: u2,
            /// Port x configuration bits (x =
            /// 8)
            CTL8: u2,
            /// Port x mode bits (x =
            /// 9)
            MD9: u2,
            /// Port x configuration bits (x =
            /// 9)
            CTL9: u2,
            /// Port x mode bits (x =
            /// 10 )
            MD10: u2,
            /// Port x configuration bits (x =
            /// 10)
            CTL10: u2,
            /// Port x mode bits (x =
            /// 11 )
            MD11: u2,
            /// Port x configuration bits (x =
            /// 11)
            CTL11: u2,
            /// Port x mode bits (x =
            /// 12)
            MD12: u2,
            /// Port x configuration bits (x =
            /// 12)
            CTL12: u2,
            /// Port x mode bits (x =
            /// 13)
            MD13: u2,
            /// Port x configuration bits (x =
            /// 13)
            CTL13: u2,
            /// Port x mode bits (x =
            /// 14)
            MD14: u2,
            /// Port x configuration bits (x =
            /// 14)
            CTL14: u2,
            /// Port x mode bits (x =
            /// 15)
            MD15: u2,
            /// Port x configuration bits (x =
            /// 15)
            CTL15: u2,
        }), base_address + 0x4);

        /// address: 0x40011408
        /// Port input status register
        pub const ISTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input status
            ISTAT0: u1,
            /// Port input status
            ISTAT1: u1,
            /// Port input status
            ISTAT2: u1,
            /// Port input status
            ISTAT3: u1,
            /// Port input status
            ISTAT4: u1,
            /// Port input status
            ISTAT5: u1,
            /// Port input status
            ISTAT6: u1,
            /// Port input status
            ISTAT7: u1,
            /// Port input status
            ISTAT8: u1,
            /// Port input status
            ISTAT9: u1,
            /// Port input status
            ISTAT10: u1,
            /// Port input status
            ISTAT11: u1,
            /// Port input status
            ISTAT12: u1,
            /// Port input status
            ISTAT13: u1,
            /// Port input status
            ISTAT14: u1,
            /// Port input status
            ISTAT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001140c
        /// Port output control register
        pub const OCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output control
            OCTL0: u1,
            /// Port output control
            OCTL1: u1,
            /// Port output control
            OCTL2: u1,
            /// Port output control
            OCTL3: u1,
            /// Port output control
            OCTL4: u1,
            /// Port output control
            OCTL5: u1,
            /// Port output control
            OCTL6: u1,
            /// Port output control
            OCTL7: u1,
            /// Port output control
            OCTL8: u1,
            /// Port output control
            OCTL9: u1,
            /// Port output control
            OCTL10: u1,
            /// Port output control
            OCTL11: u1,
            /// Port output control
            OCTL12: u1,
            /// Port output control
            OCTL13: u1,
            /// Port output control
            OCTL14: u1,
            /// Port output control
            OCTL15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40011410
        /// Port bit operate register
        pub const BOP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 0 Set bit
            BOP0: u1,
            /// Port 1 Set bit
            BOP1: u1,
            /// Port 2 Set bit
            BOP2: u1,
            /// Port 3 Set bit
            BOP3: u1,
            /// Port 4 Set bit
            BOP4: u1,
            /// Port 5 Set bit
            BOP5: u1,
            /// Port 6 Set bit
            BOP6: u1,
            /// Port 7 Set bit
            BOP7: u1,
            /// Port 8 Set bit
            BOP8: u1,
            /// Port 9 Set bit
            BOP9: u1,
            /// Port 10 Set bit
            BOP10: u1,
            /// Port 11 Set bit
            BOP11: u1,
            /// Port 12 Set bit
            BOP12: u1,
            /// Port 13 Set bit
            BOP13: u1,
            /// Port 14 Set bit
            BOP14: u1,
            /// Port 15 Set bit
            BOP15: u1,
            /// Port 0 Clear bit
            CR0: u1,
            /// Port 1 Clear bit
            CR1: u1,
            /// Port 2 Clear bit
            CR2: u1,
            /// Port 3 Clear bit
            CR3: u1,
            /// Port 4 Clear bit
            CR4: u1,
            /// Port 5 Clear bit
            CR5: u1,
            /// Port 6 Clear bit
            CR6: u1,
            /// Port 7 Clear bit
            CR7: u1,
            /// Port 8 Clear bit
            CR8: u1,
            /// Port 9 Clear bit
            CR9: u1,
            /// Port 10 Clear bit
            CR10: u1,
            /// Port 11 Clear bit
            CR11: u1,
            /// Port 12 Clear bit
            CR12: u1,
            /// Port 13 Clear bit
            CR13: u1,
            /// Port 14 Clear bit
            CR14: u1,
            /// Port 15 Clear bit
            CR15: u1,
        }), base_address + 0x10);

        /// address: 0x40011414
        /// Port bit clear register
        pub const BC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 0 Clear bit
            CR0: u1,
            /// Port 1 Clear bit
            CR1: u1,
            /// Port 2 Clear bit
            CR2: u1,
            /// Port 3 Clear bit
            CR3: u1,
            /// Port 4 Clear bit
            CR4: u1,
            /// Port 5 Clear bit
            CR5: u1,
            /// Port 6 Clear bit
            CR6: u1,
            /// Port 7 Clear bit
            CR7: u1,
            /// Port 8 Clear bit
            CR8: u1,
            /// Port 9 Clear bit
            CR9: u1,
            /// Port 10 Clear bit
            CR10: u1,
            /// Port 11 Clear bit
            CR11: u1,
            /// Port 12 Clear bit
            CR12: u1,
            /// Port 13 Clear bit
            CR13: u1,
            /// Port 14 Clear bit
            CR14: u1,
            /// Port 15 Clear bit
            CR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40011418
        /// GPIO port configuration lock
        /// register
        pub const LOCK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port Lock bit 0
            LK0: u1,
            /// Port Lock bit 1
            LK1: u1,
            /// Port Lock bit 2
            LK2: u1,
            /// Port Lock bit 3
            LK3: u1,
            /// Port Lock bit 4
            LK4: u1,
            /// Port Lock bit 5
            LK5: u1,
            /// Port Lock bit 6
            LK6: u1,
            /// Port Lock bit 7
            LK7: u1,
            /// Port Lock bit 8
            LK8: u1,
            /// Port Lock bit 9
            LK9: u1,
            /// Port Lock bit 10
            LK10: u1,
            /// Port Lock bit 11
            LK11: u1,
            /// Port Lock bit 12
            LK12: u1,
            /// Port Lock bit 13
            LK13: u1,
            /// Port Lock bit 14
            LK14: u1,
            /// Port Lock bit 15
            LK15: u1,
            /// Lock sequence key
            LKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);
    };
    pub const GPIOE = struct {
        pub const base_address = 0x40011800;

        /// address: 0x40011800
        /// port control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x mode bits (x =
            /// 0)
            MD0: u2,
            /// Port x configuration bits (x =
            /// 0)
            CTL0: u2,
            /// Port x mode bits (x =
            /// 1)
            MD1: u2,
            /// Port x configuration bits (x =
            /// 1)
            CTL1: u2,
            /// Port x mode bits (x =
            /// 2 )
            MD2: u2,
            /// Port x configuration bits (x =
            /// 2)
            CTL2: u2,
            /// Port x mode bits (x =
            /// 3 )
            MD3: u2,
            /// Port x configuration bits (x =
            /// 3)
            CTL3: u2,
            /// Port x mode bits (x =
            /// 4)
            MD4: u2,
            /// Port x configuration bits (x =
            /// 4)
            CTL4: u2,
            /// Port x mode bits (x =
            /// 5)
            MD5: u2,
            /// Port x configuration bits (x =
            /// 5)
            CTL5: u2,
            /// Port x mode bits (x =
            /// 6)
            MD6: u2,
            /// Port x configuration bits (x =
            /// 6)
            CTL6: u2,
            /// Port x mode bits (x =
            /// 7)
            MD7: u2,
            /// Port x configuration bits (x =
            /// 7)
            CTL7: u2,
        }), base_address + 0x0);

        /// address: 0x40011804
        /// port control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x mode bits (x =
            /// 8)
            MD8: u2,
            /// Port x configuration bits (x =
            /// 8)
            CTL8: u2,
            /// Port x mode bits (x =
            /// 9)
            MD9: u2,
            /// Port x configuration bits (x =
            /// 9)
            CTL9: u2,
            /// Port x mode bits (x =
            /// 10 )
            MD10: u2,
            /// Port x configuration bits (x =
            /// 10)
            CTL10: u2,
            /// Port x mode bits (x =
            /// 11 )
            MD11: u2,
            /// Port x configuration bits (x =
            /// 11)
            CTL11: u2,
            /// Port x mode bits (x =
            /// 12)
            MD12: u2,
            /// Port x configuration bits (x =
            /// 12)
            CTL12: u2,
            /// Port x mode bits (x =
            /// 13)
            MD13: u2,
            /// Port x configuration bits (x =
            /// 13)
            CTL13: u2,
            /// Port x mode bits (x =
            /// 14)
            MD14: u2,
            /// Port x configuration bits (x =
            /// 14)
            CTL14: u2,
            /// Port x mode bits (x =
            /// 15)
            MD15: u2,
            /// Port x configuration bits (x =
            /// 15)
            CTL15: u2,
        }), base_address + 0x4);

        /// address: 0x40011808
        /// Port input status register
        pub const ISTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input status
            ISTAT0: u1,
            /// Port input status
            ISTAT1: u1,
            /// Port input status
            ISTAT2: u1,
            /// Port input status
            ISTAT3: u1,
            /// Port input status
            ISTAT4: u1,
            /// Port input status
            ISTAT5: u1,
            /// Port input status
            ISTAT6: u1,
            /// Port input status
            ISTAT7: u1,
            /// Port input status
            ISTAT8: u1,
            /// Port input status
            ISTAT9: u1,
            /// Port input status
            ISTAT10: u1,
            /// Port input status
            ISTAT11: u1,
            /// Port input status
            ISTAT12: u1,
            /// Port input status
            ISTAT13: u1,
            /// Port input status
            ISTAT14: u1,
            /// Port input status
            ISTAT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001180c
        /// Port output control register
        pub const OCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output control
            OCTL0: u1,
            /// Port output control
            OCTL1: u1,
            /// Port output control
            OCTL2: u1,
            /// Port output control
            OCTL3: u1,
            /// Port output control
            OCTL4: u1,
            /// Port output control
            OCTL5: u1,
            /// Port output control
            OCTL6: u1,
            /// Port output control
            OCTL7: u1,
            /// Port output control
            OCTL8: u1,
            /// Port output control
            OCTL9: u1,
            /// Port output control
            OCTL10: u1,
            /// Port output control
            OCTL11: u1,
            /// Port output control
            OCTL12: u1,
            /// Port output control
            OCTL13: u1,
            /// Port output control
            OCTL14: u1,
            /// Port output control
            OCTL15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40011810
        /// Port bit operate register
        pub const BOP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 0 Set bit
            BOP0: u1,
            /// Port 1 Set bit
            BOP1: u1,
            /// Port 2 Set bit
            BOP2: u1,
            /// Port 3 Set bit
            BOP3: u1,
            /// Port 4 Set bit
            BOP4: u1,
            /// Port 5 Set bit
            BOP5: u1,
            /// Port 6 Set bit
            BOP6: u1,
            /// Port 7 Set bit
            BOP7: u1,
            /// Port 8 Set bit
            BOP8: u1,
            /// Port 9 Set bit
            BOP9: u1,
            /// Port 10 Set bit
            BOP10: u1,
            /// Port 11 Set bit
            BOP11: u1,
            /// Port 12 Set bit
            BOP12: u1,
            /// Port 13 Set bit
            BOP13: u1,
            /// Port 14 Set bit
            BOP14: u1,
            /// Port 15 Set bit
            BOP15: u1,
            /// Port 0 Clear bit
            CR0: u1,
            /// Port 1 Clear bit
            CR1: u1,
            /// Port 2 Clear bit
            CR2: u1,
            /// Port 3 Clear bit
            CR3: u1,
            /// Port 4 Clear bit
            CR4: u1,
            /// Port 5 Clear bit
            CR5: u1,
            /// Port 6 Clear bit
            CR6: u1,
            /// Port 7 Clear bit
            CR7: u1,
            /// Port 8 Clear bit
            CR8: u1,
            /// Port 9 Clear bit
            CR9: u1,
            /// Port 10 Clear bit
            CR10: u1,
            /// Port 11 Clear bit
            CR11: u1,
            /// Port 12 Clear bit
            CR12: u1,
            /// Port 13 Clear bit
            CR13: u1,
            /// Port 14 Clear bit
            CR14: u1,
            /// Port 15 Clear bit
            CR15: u1,
        }), base_address + 0x10);

        /// address: 0x40011814
        /// Port bit clear register
        pub const BC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port 0 Clear bit
            CR0: u1,
            /// Port 1 Clear bit
            CR1: u1,
            /// Port 2 Clear bit
            CR2: u1,
            /// Port 3 Clear bit
            CR3: u1,
            /// Port 4 Clear bit
            CR4: u1,
            /// Port 5 Clear bit
            CR5: u1,
            /// Port 6 Clear bit
            CR6: u1,
            /// Port 7 Clear bit
            CR7: u1,
            /// Port 8 Clear bit
            CR8: u1,
            /// Port 9 Clear bit
            CR9: u1,
            /// Port 10 Clear bit
            CR10: u1,
            /// Port 11 Clear bit
            CR11: u1,
            /// Port 12 Clear bit
            CR12: u1,
            /// Port 13 Clear bit
            CR13: u1,
            /// Port 14 Clear bit
            CR14: u1,
            /// Port 15 Clear bit
            CR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40011818
        /// GPIO port configuration lock
        /// register
        pub const LOCK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port Lock bit 0
            LK0: u1,
            /// Port Lock bit 1
            LK1: u1,
            /// Port Lock bit 2
            LK2: u1,
            /// Port Lock bit 3
            LK3: u1,
            /// Port Lock bit 4
            LK4: u1,
            /// Port Lock bit 5
            LK5: u1,
            /// Port Lock bit 6
            LK6: u1,
            /// Port Lock bit 7
            LK7: u1,
            /// Port Lock bit 8
            LK8: u1,
            /// Port Lock bit 9
            LK9: u1,
            /// Port Lock bit 10
            LK10: u1,
            /// Port Lock bit 11
            LK11: u1,
            /// Port Lock bit 12
            LK12: u1,
            /// Port Lock bit 13
            LK13: u1,
            /// Port Lock bit 14
            LK14: u1,
            /// Port Lock bit 15
            LK15: u1,
            /// Lock sequence key
            LKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);
    };

    /// Inter integrated circuit
    pub const I2C0 = struct {
        pub const base_address = 0x40005400;

        /// address: 0x40005400
        /// Control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(16, packed struct {
            /// I2C peripheral enable
            I2CEN: u1,
            /// SMBus/I2C mode switch
            SMBEN: u1,
            reserved0: u1,
            /// SMBusType Selection
            SMBSEL: u1,
            /// ARP protocol in SMBus switch
            ARPEN: u1,
            /// PEC Calculation Switch
            PECEN: u1,
            /// Whether or not to response to a General Call (0x00)
            GCEN: u1,
            /// Whether to stretch SCL low when data is not ready in slave mode
            SS: u1,
            /// Generate a START condition on I2C bus
            START: u1,
            /// Generate a STOP condition on I2C bus
            STOP: u1,
            /// Whether or not to send an ACK
            ACKEN: u1,
            /// Position of ACK and PEC when receiving
            POAP: u1,
            /// PEC Transfer
            PECTRANS: u1,
            /// SMBus alert
            SALT: u1,
            reserved1: u1,
            /// Software reset
            SRESET: u1,
        }), base_address + 0x0);

        /// address: 0x40005404
        /// Control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(16, packed struct {
            /// I2C Peripheral clock frequency
            I2CCLK: u6,
            reserved0: u1,
            reserved1: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// Event interrupt enable
            EVIE: u1,
            /// Buffer interrupt enable
            BUFIE: u1,
            /// DMA mode switch
            DMAON: u1,
            /// Flag indicating DMA last transfer
            DMALST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x4);

        /// address: 0x40005408
        /// Slave address register 0
        pub const SADDR0 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Bit 0 of a 10-bit address
            ADDRESS0: u1,
            /// 7-bit address or bits 7:1 of a 10-bit address
            ADDRESS7_1: u7,
            /// Highest two bits of a 10-bit address
            ADDRESS9_8: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Address mode for the I2C slave
            ADDFORMAT: u1,
        }), base_address + 0x8);

        /// address: 0x4000540c
        /// Slave address register 1
        pub const SADDR1 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Dual-Address mode switch
            DUADEN: u1,
            /// Second I2C address for the slave in Dual-Address mode
            ADDRESS2: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xc);

        /// address: 0x40005410
        /// Transfer buffer register
        pub const DATA = @intToPtr(*volatile Mmio(16, packed struct {
            /// Transmission or reception data buffer register
            TRB: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x10);

        /// address: 0x40005414
        /// Transfer status register 0
        pub const STAT0 = @intToPtr(*volatile Mmio(16, packed struct {
            /// START condition sent out in master mode
            SBSEND: u1,
            /// Address is sent in master mode or received and matches in slave mode
            ADDSEND: u1,
            /// Byte transmission completed
            BTC: u1,
            /// Header of 10-bit address is sent in master mode
            ADD10SEND: u1,
            /// STOP condition detected in slave mode
            STPDET: u1,
            reserved0: u1,
            /// I2C_DATA is not Empty during receiving
            RBNE: u1,
            /// I2C_DATA is Empty during transmitting
            TBE: u1,
            /// A bus error occurs indication a unexpected START or STOP condition on I2C bus
            BERR: u1,
            /// Arbitration Lost in master mode
            LOSTARB: u1,
            /// Acknowledge error
            AERR: u1,
            /// Over-run or under-run situation occurs in slave mode
            OUERR: u1,
            /// PEC error when receiving data
            PECERR: u1,
            reserved1: u1,
            /// Timeout signal in SMBus mode
            SMBTO: u1,
            /// SMBus Alert status
            SMBALT: u1,
        }), base_address + 0x14);

        /// address: 0x40005418
        /// Transfer status register 1
        pub const STAT1 = @intToPtr(*volatile Mmio(16, packed struct {
            /// A flag indicating whether I2C block is in master or slave mode
            MASTER: u1,
            /// Busy flag
            I2CBSY: u1,
            /// Whether the I2C is a transmitter or a receiver
            TR: u1,
            reserved0: u1,
            /// General call address (00h) received
            RXGC: u1,
            /// Default address of SMBusDevice
            DEFSMB: u1,
            /// SMBus Host Header detected in slave mode
            HSTSMB: u1,
            /// Dual Flag in slave mode
            DUMODF: u1,
            /// Packet Error Checking Value that calculated by hardware when PEC is enabled
            PECV: u8,
        }), base_address + 0x18);

        /// address: 0x4000541c
        /// Clock configure register
        pub const CKCFG = @intToPtr(*volatile Mmio(16, packed struct {
            /// I2C Clock control in master mode
            CLKC: u12,
            reserved0: u1,
            reserved1: u1,
            /// Duty cycle in fast mode
            DTCY: u1,
            /// I2C speed selection in master mode
            FAST: u1,
        }), base_address + 0x1c);

        /// address: 0x40005420
        /// Rise time register
        pub const RT = @intToPtr(*volatile Mmio(16, packed struct {
            /// Maximum rise time in master mode
            RISETIME: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x20);

        /// address: 0x40005490
        /// Fast mode plus configure register
        pub const FMPCFG = @intToPtr(*volatile Mmio(16, packed struct {
            /// Fast mode plus enable
            FMPEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x90);
    };
    pub const I2C1 = struct {
        pub const base_address = 0x40005800;

        /// address: 0x40005800
        /// Control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(16, packed struct {
            /// I2C peripheral enable
            I2CEN: u1,
            /// SMBus/I2C mode switch
            SMBEN: u1,
            reserved0: u1,
            /// SMBusType Selection
            SMBSEL: u1,
            /// ARP protocol in SMBus switch
            ARPEN: u1,
            /// PEC Calculation Switch
            PECEN: u1,
            /// Whether or not to response to a General Call (0x00)
            GCEN: u1,
            /// Whether to stretch SCL low when data is not ready in slave mode
            SS: u1,
            /// Generate a START condition on I2C bus
            START: u1,
            /// Generate a STOP condition on I2C bus
            STOP: u1,
            /// Whether or not to send an ACK
            ACKEN: u1,
            /// Position of ACK and PEC when receiving
            POAP: u1,
            /// PEC Transfer
            PECTRANS: u1,
            /// SMBus alert
            SALT: u1,
            reserved1: u1,
            /// Software reset
            SRESET: u1,
        }), base_address + 0x0);

        /// address: 0x40005804
        /// Control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(16, packed struct {
            /// I2C Peripheral clock frequency
            I2CCLK: u6,
            reserved0: u1,
            reserved1: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// Event interrupt enable
            EVIE: u1,
            /// Buffer interrupt enable
            BUFIE: u1,
            /// DMA mode switch
            DMAON: u1,
            /// Flag indicating DMA last transfer
            DMALST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x4);

        /// address: 0x40005808
        /// Slave address register 0
        pub const SADDR0 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Bit 0 of a 10-bit address
            ADDRESS0: u1,
            /// 7-bit address or bits 7:1 of a 10-bit address
            ADDRESS7_1: u7,
            /// Highest two bits of a 10-bit address
            ADDRESS9_8: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Address mode for the I2C slave
            ADDFORMAT: u1,
        }), base_address + 0x8);

        /// address: 0x4000580c
        /// Slave address register 1
        pub const SADDR1 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Dual-Address mode switch
            DUADEN: u1,
            /// Second I2C address for the slave in Dual-Address mode
            ADDRESS2: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xc);

        /// address: 0x40005810
        /// Transfer buffer register
        pub const DATA = @intToPtr(*volatile Mmio(16, packed struct {
            /// Transmission or reception data buffer register
            TRB: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x10);

        /// address: 0x40005814
        /// Transfer status register 0
        pub const STAT0 = @intToPtr(*volatile Mmio(16, packed struct {
            /// START condition sent out in master mode
            SBSEND: u1,
            /// Address is sent in master mode or received and matches in slave mode
            ADDSEND: u1,
            /// Byte transmission completed
            BTC: u1,
            /// Header of 10-bit address is sent in master mode
            ADD10SEND: u1,
            /// STOP condition detected in slave mode
            STPDET: u1,
            reserved0: u1,
            /// I2C_DATA is not Empty during receiving
            RBNE: u1,
            /// I2C_DATA is Empty during transmitting
            TBE: u1,
            /// A bus error occurs indication a unexpected START or STOP condition on I2C bus
            BERR: u1,
            /// Arbitration Lost in master mode
            LOSTARB: u1,
            /// Acknowledge error
            AERR: u1,
            /// Over-run or under-run situation occurs in slave mode
            OUERR: u1,
            /// PEC error when receiving data
            PECERR: u1,
            reserved1: u1,
            /// Timeout signal in SMBus mode
            SMBTO: u1,
            /// SMBus Alert status
            SMBALT: u1,
        }), base_address + 0x14);

        /// address: 0x40005818
        /// Transfer status register 1
        pub const STAT1 = @intToPtr(*volatile Mmio(16, packed struct {
            /// A flag indicating whether I2C block is in master or slave mode
            MASTER: u1,
            /// Busy flag
            I2CBSY: u1,
            /// Whether the I2C is a transmitter or a receiver
            TR: u1,
            reserved0: u1,
            /// General call address (00h) received
            RXGC: u1,
            /// Default address of SMBusDevice
            DEFSMB: u1,
            /// SMBus Host Header detected in slave mode
            HSTSMB: u1,
            /// Dual Flag in slave mode
            DUMODF: u1,
            /// Packet Error Checking Value that calculated by hardware when PEC is enabled
            PECV: u8,
        }), base_address + 0x18);

        /// address: 0x4000581c
        /// Clock configure register
        pub const CKCFG = @intToPtr(*volatile Mmio(16, packed struct {
            /// I2C Clock control in master mode
            CLKC: u12,
            reserved0: u1,
            reserved1: u1,
            /// Duty cycle in fast mode
            DTCY: u1,
            /// I2C speed selection in master mode
            FAST: u1,
        }), base_address + 0x1c);

        /// address: 0x40005820
        /// Rise time register
        pub const RT = @intToPtr(*volatile Mmio(16, packed struct {
            /// Maximum rise time in master mode
            RISETIME: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x20);

        /// address: 0x40005890
        /// Fast mode plus configure register
        pub const FMPCFG = @intToPtr(*volatile Mmio(16, packed struct {
            /// Fast mode plus enable
            FMPEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x90);
    };

    /// Enhanced Core Local Interrupt Controller
    pub const ECLIC = struct {
        pub const base_address = 0xd2000000;

        /// address: 0xd2000000
        /// cliccfg Register
        pub const CLICCFG = @intToPtr(*volatile Mmio(8, packed struct {
            reserved0: u1,
            /// NLBITS
            NLBITS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0xd2000004
        /// clicinfo Register
        pub const CLICINFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// NUM_INTERRUPT
            NUM_INTERRUPT: u13,
            /// VERSION
            VERSION: u8,
            /// CLICINTCTLBITS
            CLICINTCTLBITS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x4);

        /// address: 0xd200000b
        /// MTH Register
        pub const MTH = @intToPtr(*volatile u8, base_address + 0xb);
    };

    /// Power management unit
    pub const PMU = struct {
        pub const base_address = 0x40007000;

        /// address: 0x40007000
        /// power control register
        pub const CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// LDO Low Power Mode
            LDOLP: u1,
            /// Standby Mode
            STBMOD: u1,
            /// Wakeup Flag Reset
            WURST: u1,
            /// Standby Flag Reset
            STBRST: u1,
            /// Low Voltage Detector Enable
            LVDEN: u1,
            /// Low Voltage Detector Threshold
            LVDT: u3,
            /// Backup Domain Write Enable
            BKPWEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x0);

        /// address: 0x40007004
        /// power control/status register
        pub const CS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup flag
            WUF: u1,
            /// Standby flag
            STBF: u1,
            /// Low Voltage Detector Status Flag
            LVDF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Enable WKUP pin
            WUPEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x4);
    };

    /// Reset and clock unit
    pub const RCU = struct {
        pub const base_address = 0x40021000;

        /// address: 0x40021000
        /// Control register
        pub const CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Internal 8MHz RC oscillator Enable
            IRC8MEN: u1,
            /// IRC8M Internal 8MHz RC Oscillator stabilization Flag
            IRC8MSTB: u1,
            reserved0: u1,
            /// Internal 8MHz RC Oscillator clock trim adjust value
            IRC8MADJ: u5,
            /// Internal 8MHz RC Oscillator calibration value register
            IRC8MCALIB: u8,
            /// External High Speed oscillator Enable
            HXTALEN: u1,
            /// External crystal oscillator (HXTAL) clock stabilization flag
            HXTALSTB: u1,
            /// External crystal oscillator (HXTAL) clock bypass mode enable
            HXTALBPS: u1,
            /// HXTAL Clock Monitor Enable
            CKMEN: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// PLL enable
            PLLEN: u1,
            /// PLL Clock Stabilization Flag
            PLLSTB: u1,
            /// PLL1 enable
            PLL1EN: u1,
            /// PLL1 Clock Stabilization Flag
            PLL1STB: u1,
            /// PLL2 enable
            PLL2EN: u1,
            /// PLL2 Clock Stabilization Flag
            PLL2STB: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x0);

        /// address: 0x40021004
        /// Clock configuration register 0
        /// (RCU_CFG0)
        pub const CFG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// System clock switch
            SCS: u2,
            /// System clock switch status
            SCSS: u2,
            /// AHB prescaler selection
            AHBPSC: u4,
            /// APB1 prescaler selection
            APB1PSC: u3,
            /// APB2 prescaler selection
            APB2PSC: u3,
            /// ADC clock prescaler selection
            ADCPSC_1_0: u2,
            /// PLL Clock Source Selection
            PLLSEL: u1,
            /// The LSB of PREDV0 division factor
            PREDV0_LSB: u1,
            /// The PLL clock multiplication factor
            PLLMF_3_0: u4,
            /// USBFS clock prescaler selection
            USBFSPSC: u2,
            /// CKOUT0 Clock Source Selection
            CKOUT0SEL: u4,
            /// Bit 2 of ADCPSC
            ADCPSC_2: u1,
            /// Bit 4 of PLLMF
            PLLMF_4: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x4);

        /// address: 0x40021008
        /// Clock interrupt register
        /// (RCU_INT)
        pub const INT = @intToPtr(*volatile Mmio(32, packed struct {
            /// IRC40K stabilization interrupt flag
            IRC40KSTBIF: u1,
            /// LXTAL stabilization interrupt flag
            LXTALSTBIF: u1,
            /// IRC8M stabilization interrupt flag
            IRC8MSTBIF: u1,
            /// HXTAL stabilization interrupt flag
            HXTALSTBIF: u1,
            /// PLL stabilization interrupt flag
            PLLSTBIF: u1,
            /// PLL1 stabilization interrupt flag
            PLL1STBIF: u1,
            /// PLL2 stabilization interrupt flag
            PLL2STBIF: u1,
            /// HXTAL Clock Stuck Interrupt Flag
            CKMIF: u1,
            /// IRC40K Stabilization interrupt enable
            IRC40KSTBIE: u1,
            /// LXTAL Stabilization Interrupt Enable
            LXTALSTBIE: u1,
            /// IRC8M Stabilization Interrupt Enable
            IRC8MSTBIE: u1,
            /// HXTAL Stabilization Interrupt Enable
            HXTALSTBIE: u1,
            /// PLL Stabilization Interrupt Enable
            PLLSTBIE: u1,
            /// PLL1 Stabilization Interrupt Enable
            PLL1STBIE: u1,
            /// PLL2 Stabilization Interrupt Enable
            PLL2STBIE: u1,
            reserved0: u1,
            /// IRC40K Stabilization Interrupt Clear
            IRC40KSTBIC: u1,
            /// LXTAL Stabilization Interrupt Clear
            LXTALSTBIC: u1,
            /// IRC8M Stabilization Interrupt Clear
            IRC8MSTBIC: u1,
            /// HXTAL Stabilization Interrupt Clear
            HXTALSTBIC: u1,
            /// PLL stabilization Interrupt Clear
            PLLSTBIC: u1,
            /// PLL1 stabilization Interrupt Clear
            PLL1STBIC: u1,
            /// PLL2 stabilization Interrupt Clear
            PLL2STBIC: u1,
            /// HXTAL Clock Stuck Interrupt Clear
            CKMIC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x8);

        /// address: 0x4002100c
        /// APB2 reset register
        /// (RCU_APB2RST)
        pub const APB2RST = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function I/O reset
            AFRST: u1,
            reserved0: u1,
            /// GPIO port A reset
            PARST: u1,
            /// GPIO port B reset
            PBRST: u1,
            /// GPIO port C reset
            PCRST: u1,
            /// GPIO port D reset
            PDRST: u1,
            /// GPIO port E reset
            PERST: u1,
            reserved1: u1,
            reserved2: u1,
            /// ADC0 reset
            ADC0RST: u1,
            /// ADC1 reset
            ADC1RST: u1,
            /// Timer 0 reset
            TIMER0RST: u1,
            /// SPI0 reset
            SPI0RST: u1,
            reserved3: u1,
            /// USART0 Reset
            USART0RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40021010
        /// APB1 reset register
        /// (RCU_APB1RST)
        pub const APB1RST = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIMER1 timer reset
            TIMER1RST: u1,
            /// TIMER2 timer reset
            TIMER2RST: u1,
            /// TIMER3 timer reset
            TIMER3RST: u1,
            /// TIMER4 timer reset
            TIMER4RST: u1,
            /// TIMER5 timer reset
            TIMER5RST: u1,
            /// TIMER6 timer reset
            TIMER6RST: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Window watchdog timer reset
            WWDGTRST: u1,
            reserved5: u1,
            reserved6: u1,
            /// SPI1 reset
            SPI1RST: u1,
            /// SPI2 reset
            SPI2RST: u1,
            reserved7: u1,
            /// USART1 reset
            USART1RST: u1,
            /// USART2 reset
            USART2RST: u1,
            /// UART3 reset
            UART3RST: u1,
            /// UART4 reset
            UART4RST: u1,
            /// I2C0 reset
            I2C0RST: u1,
            /// I2C1 reset
            I2C1RST: u1,
            reserved8: u1,
            reserved9: u1,
            /// CAN0 reset
            CAN0RST: u1,
            /// CAN1 reset
            CAN1RST: u1,
            /// Backup interface reset
            BKPIRST: u1,
            /// Power control reset
            PMURST: u1,
            /// DAC reset
            DACRST: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x10);

        /// address: 0x40021014
        /// AHB enable register
        pub const AHBEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA0 clock enable
            DMA0EN: u1,
            /// DMA1 clock enable
            DMA1EN: u1,
            /// SRAM interface clock enable when sleep mode
            SRAMSPEN: u1,
            reserved0: u1,
            /// FMC clock enable when sleep mode
            FMCSPEN: u1,
            reserved1: u1,
            /// CRC clock enable
            CRCEN: u1,
            reserved2: u1,
            /// EXMC clock enable
            EXMCEN: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// USBFS clock enable
            USBFSEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x14);

        /// address: 0x40021018
        /// APB2 clock enable register
        /// (RCU_APB2EN)
        pub const APB2EN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function IO clock enable
            AFEN: u1,
            reserved0: u1,
            /// GPIO port A clock enable
            PAEN: u1,
            /// GPIO port B clock enable
            PBEN: u1,
            /// GPIO port C clock enable
            PCEN: u1,
            /// GPIO port D clock enable
            PDEN: u1,
            /// GPIO port E clock enable
            PEEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// ADC0 clock enable
            ADC0EN: u1,
            /// ADC1 clock enable
            ADC1EN: u1,
            /// TIMER0 clock enable
            TIMER0EN: u1,
            /// SPI0 clock enable
            SPI0EN: u1,
            reserved3: u1,
            /// USART0 clock enable
            USART0EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x18);

        /// address: 0x4002101c
        /// APB1 clock enable register
        /// (RCU_APB1EN)
        pub const APB1EN = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIMER1 timer clock enable
            TIMER1EN: u1,
            /// TIMER2 timer clock enable
            TIMER2EN: u1,
            /// TIMER3 timer clock enable
            TIMER3EN: u1,
            /// TIMER4 timer clock enable
            TIMER4EN: u1,
            /// TIMER5 timer clock enable
            TIMER5EN: u1,
            /// TIMER6 timer clock enable
            TIMER6EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Window watchdog timer clock enable
            WWDGTEN: u1,
            reserved5: u1,
            reserved6: u1,
            /// SPI1 clock enable
            SPI1EN: u1,
            /// SPI2 clock enable
            SPI2EN: u1,
            reserved7: u1,
            /// USART1 clock enable
            USART1EN: u1,
            /// USART2 clock enable
            USART2EN: u1,
            /// UART3 clock enable
            UART3EN: u1,
            /// UART4 clock enable
            UART4EN: u1,
            /// I2C0 clock enable
            I2C0EN: u1,
            /// I2C1 clock enable
            I2C1EN: u1,
            reserved8: u1,
            reserved9: u1,
            /// CAN0 clock enable
            CAN0EN: u1,
            /// CAN1 clock enable
            CAN1EN: u1,
            /// Backup interface clock enable
            BKPIEN: u1,
            /// Power control clock enable
            PMUEN: u1,
            /// DAC clock enable
            DACEN: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x1c);

        /// address: 0x40021020
        /// Backup domain control register
        /// (RCU_BDCTL)
        pub const BDCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// LXTAL enable
            LXTALEN: u1,
            /// External low-speed oscillator stabilization
            LXTALSTB: u1,
            /// LXTAL bypass mode enable
            LXTALBPS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// RTC clock entry selection
            RTCSRC: u2,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// RTC clock enable
            RTCEN: u1,
            /// Backup domain reset
            BKPRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x20);

        /// address: 0x40021024
        /// Reset source /clock register
        /// (RCU_RSTSCK)
        pub const RSTSCK = @intToPtr(*volatile Mmio(32, packed struct {
            /// IRC40K enable
            IRC40KEN: u1,
            /// IRC40K stabilization
            IRC40KSTB: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// Reset flag clear
            RSTFC: u1,
            reserved22: u1,
            /// External PIN reset flag
            EPRSTF: u1,
            /// Power reset flag
            PORRSTF: u1,
            /// Software reset flag
            SWRSTF: u1,
            /// Free Watchdog timer reset flag
            FWDGTRSTF: u1,
            /// Window watchdog timer reset flag
            WWDGTRSTF: u1,
            /// Low-power reset flag
            LPRSTF: u1,
        }), base_address + 0x24);

        /// address: 0x40021028
        /// AHB reset register
        pub const AHBRST = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// USBFS reset
            USBFSRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x28);

        /// address: 0x4002102c
        /// Clock Configuration register 1
        pub const CFG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PREDV0 division factor
            PREDV0: u4,
            /// PREDV1 division factor
            PREDV1: u4,
            /// The PLL1 clock multiplication factor
            PLL1MF: u4,
            /// The PLL2 clock multiplication factor
            PLL2MF: u4,
            /// PREDV0 input Clock Source Selection
            PREDV0SEL: u1,
            /// I2S1 Clock Source Selection
            I2S1SEL: u1,
            /// I2S2 Clock Source Selection
            I2S2SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x2c);

        /// address: 0x40021034
        /// Deep sleep mode Voltage register
        pub const DSV = @intToPtr(*volatile Mmio(32, packed struct {
            /// Deep-sleep mode voltage select
            DSLPVS: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x34);
    };

    /// Real-time clock
    pub const RTC = struct {
        pub const base_address = 0x40002800;

        /// address: 0x40002800
        /// RTC interrupt enable register
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second interrupt
            SCIE: u1,
            /// Alarm interrupt enable
            ALRMIE: u1,
            /// Overflow interrupt enable
            OVIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x0);

        /// address: 0x40002804
        /// control register
        pub const CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sencond interrupt flag
            SCIF: u1,
            /// Alarm interrupt flag
            ALRMIF: u1,
            /// Overflow interrupt flag
            OVIF: u1,
            /// Registers synchronized flag
            RSYNF: u1,
            /// Configuration mode flag
            CMF: u1,
            /// Last write operation finished flag
            LWOFF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x4);

        /// address: 0x40002808
        /// RTC prescaler high register
        pub const PSCH = @intToPtr(*volatile Mmio(32, packed struct {
            /// RTC prescaler value high
            PSC: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x8);

        /// address: 0x4000280c
        /// RTC prescaler low
        /// register
        pub const PSCL = @intToPtr(*volatile Mmio(32, packed struct {
            /// RTC prescaler value low
            PSC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40002810
        /// RTC divider high register
        pub const DIVH = @intToPtr(*volatile Mmio(32, packed struct {
            /// RTC divider value high
            DIV: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x10);

        /// address: 0x40002814
        /// RTC divider low register
        pub const DIVL = @intToPtr(*volatile Mmio(32, packed struct {
            /// RTC divider value low
            DIV: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40002818
        /// RTC counter high register
        pub const CNTH = @intToPtr(*volatile Mmio(32, packed struct {
            /// RTC counter value high
            CNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000281c
        /// RTC counter low register
        pub const CNTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// RTC counter value low
            CNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40002820
        /// Alarm high register
        pub const ALRMH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alarm value high
            ALRM: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40002824
        /// RTC alarm low register
        pub const ALRML = @intToPtr(*volatile Mmio(32, packed struct {
            /// alarm value low
            ALRM: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x24);
    };

    /// Serial peripheral interface
    pub const SPI0 = struct {
        pub const base_address = 0x40013000;

        /// address: 0x40013000
        /// control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Clock Phase Selection
            CKPH: u1,
            /// Clock polarity Selection
            CKPL: u1,
            /// Master Mode Enable
            MSTMOD: u1,
            /// Master Clock Prescaler Selection
            PSC: u3,
            /// SPI enable
            SPIEN: u1,
            /// LSB First Mode
            LF: u1,
            /// NSS Pin Selection In NSS Software Mode
            SWNSS: u1,
            /// NSS Software Mode Selection
            SWNSSEN: u1,
            /// Receive only
            RO: u1,
            /// Data frame format
            FF16: u1,
            /// CRC Next Transfer
            CRCNT: u1,
            /// CRC Calculation Enable
            CRCEN: u1,
            /// Bidirectional Transmit output enable
            BDOEN: u1,
            /// Bidirectional
            /// enable
            BDEN: u1,
        }), base_address + 0x0);

        /// address: 0x40013004
        /// control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Rx buffer DMA enable
            DMAREN: u1,
            /// Transmit Buffer DMA Enable
            DMATEN: u1,
            /// Drive NSS Output
            NSSDRV: u1,
            /// SPI NSS pulse mode enable
            NSSP: u1,
            /// SPI TI mode enable
            TMOD: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RBNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TBEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40013008
        /// status register
        pub const STAT = @intToPtr(*volatile Mmio(16, packed struct {
            /// Receive Buffer Not Empty
            RBNE: u1,
            /// Transmit Buffer Empty
            TBE: u1,
            /// I2S channel side
            I2SCH: u1,
            /// Transmission underrun error bit
            TXURERR: u1,
            /// SPI CRC Error Bit
            CRCERR: u1,
            /// SPI Configuration error
            CONFERR: u1,
            /// Reception Overrun Error Bit
            RXORERR: u1,
            /// Transmitting On-going Bit
            TRANS: u1,
            /// Format error
            FERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x8);

        /// address: 0x4001300c
        /// data register
        pub const DATA = @intToPtr(*volatile Mmio(16, packed struct {
            /// Data transfer register
            SPI_DATA: u16,
        }), base_address + 0xc);

        /// address: 0x40013010
        /// CRC polynomial register
        pub const CRCPOLY = @intToPtr(*volatile u16, base_address + 0x10);

        /// address: 0x40013014
        /// RX CRC register
        pub const RCRC = @intToPtr(*volatile u16, base_address + 0x14);

        /// address: 0x40013018
        /// TX CRC register
        pub const TCRC = @intToPtr(*volatile u16, base_address + 0x18);

        /// address: 0x4001301c
        /// I2S control register
        pub const I2SCTL = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length
            DTLEN: u2,
            /// Idle state clock polarity
            CKPL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization mode
            PCMSMOD: u1,
            /// I2S operation mode
            I2SOPMOD: u2,
            /// I2S Enable
            I2SEN: u1,
            /// I2S mode selection
            I2SSEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x1c);

        /// address: 0x40013020
        /// I2S prescaler register
        pub const I2SPSC = @intToPtr(*volatile Mmio(16, packed struct {
            /// Dividing factor for the prescaler
            DIV: u8,
            /// Odd factor for the
            /// prescaler
            OF: u1,
            /// I2S_MCK output enable
            MCKOEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x20);
    };
    pub const SPI1 = struct {
        pub const base_address = 0x40003800;

        /// address: 0x40003800
        /// control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Clock Phase Selection
            CKPH: u1,
            /// Clock polarity Selection
            CKPL: u1,
            /// Master Mode Enable
            MSTMOD: u1,
            /// Master Clock Prescaler Selection
            PSC: u3,
            /// SPI enable
            SPIEN: u1,
            /// LSB First Mode
            LF: u1,
            /// NSS Pin Selection In NSS Software Mode
            SWNSS: u1,
            /// NSS Software Mode Selection
            SWNSSEN: u1,
            /// Receive only
            RO: u1,
            /// Data frame format
            FF16: u1,
            /// CRC Next Transfer
            CRCNT: u1,
            /// CRC Calculation Enable
            CRCEN: u1,
            /// Bidirectional Transmit output enable
            BDOEN: u1,
            /// Bidirectional
            /// enable
            BDEN: u1,
        }), base_address + 0x0);

        /// address: 0x40003804
        /// control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Rx buffer DMA enable
            DMAREN: u1,
            /// Transmit Buffer DMA Enable
            DMATEN: u1,
            /// Drive NSS Output
            NSSDRV: u1,
            /// SPI NSS pulse mode enable
            NSSP: u1,
            /// SPI TI mode enable
            TMOD: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RBNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TBEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40003808
        /// status register
        pub const STAT = @intToPtr(*volatile Mmio(16, packed struct {
            /// Receive Buffer Not Empty
            RBNE: u1,
            /// Transmit Buffer Empty
            TBE: u1,
            /// I2S channel side
            I2SCH: u1,
            /// Transmission underrun error bit
            TXURERR: u1,
            /// SPI CRC Error Bit
            CRCERR: u1,
            /// SPI Configuration error
            CONFERR: u1,
            /// Reception Overrun Error Bit
            RXORERR: u1,
            /// Transmitting On-going Bit
            TRANS: u1,
            /// Format error
            FERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x8);

        /// address: 0x4000380c
        /// data register
        pub const DATA = @intToPtr(*volatile Mmio(16, packed struct {
            /// Data transfer register
            SPI_DATA: u16,
        }), base_address + 0xc);

        /// address: 0x40003810
        /// CRC polynomial register
        pub const CRCPOLY = @intToPtr(*volatile u16, base_address + 0x10);

        /// address: 0x40003814
        /// RX CRC register
        pub const RCRC = @intToPtr(*volatile u16, base_address + 0x14);

        /// address: 0x40003818
        /// TX CRC register
        pub const TCRC = @intToPtr(*volatile u16, base_address + 0x18);

        /// address: 0x4000381c
        /// I2S control register
        pub const I2SCTL = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length
            DTLEN: u2,
            /// Idle state clock polarity
            CKPL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization mode
            PCMSMOD: u1,
            /// I2S operation mode
            I2SOPMOD: u2,
            /// I2S Enable
            I2SEN: u1,
            /// I2S mode selection
            I2SSEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x1c);

        /// address: 0x40003820
        /// I2S prescaler register
        pub const I2SPSC = @intToPtr(*volatile Mmio(16, packed struct {
            /// Dividing factor for the prescaler
            DIV: u8,
            /// Odd factor for the
            /// prescaler
            OF: u1,
            /// I2S_MCK output enable
            MCKOEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x20);
    };
    pub const SPI2 = struct {
        pub const base_address = 0x40003c00;

        /// address: 0x40003c00
        /// control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Clock Phase Selection
            CKPH: u1,
            /// Clock polarity Selection
            CKPL: u1,
            /// Master Mode Enable
            MSTMOD: u1,
            /// Master Clock Prescaler Selection
            PSC: u3,
            /// SPI enable
            SPIEN: u1,
            /// LSB First Mode
            LF: u1,
            /// NSS Pin Selection In NSS Software Mode
            SWNSS: u1,
            /// NSS Software Mode Selection
            SWNSSEN: u1,
            /// Receive only
            RO: u1,
            /// Data frame format
            FF16: u1,
            /// CRC Next Transfer
            CRCNT: u1,
            /// CRC Calculation Enable
            CRCEN: u1,
            /// Bidirectional Transmit output enable
            BDOEN: u1,
            /// Bidirectional
            /// enable
            BDEN: u1,
        }), base_address + 0x0);

        /// address: 0x40003c04
        /// control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Rx buffer DMA enable
            DMAREN: u1,
            /// Transmit Buffer DMA Enable
            DMATEN: u1,
            /// Drive NSS Output
            NSSDRV: u1,
            /// SPI NSS pulse mode enable
            NSSP: u1,
            /// SPI TI mode enable
            TMOD: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RBNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TBEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40003c08
        /// status register
        pub const STAT = @intToPtr(*volatile Mmio(16, packed struct {
            /// Receive Buffer Not Empty
            RBNE: u1,
            /// Transmit Buffer Empty
            TBE: u1,
            /// I2S channel side
            I2SCH: u1,
            /// Transmission underrun error bit
            TXURERR: u1,
            /// SPI CRC Error Bit
            CRCERR: u1,
            /// SPI Configuration error
            CONFERR: u1,
            /// Reception Overrun Error Bit
            RXORERR: u1,
            /// Transmitting On-going Bit
            TRANS: u1,
            /// Format error
            FERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x8);

        /// address: 0x40003c0c
        /// data register
        pub const DATA = @intToPtr(*volatile Mmio(16, packed struct {
            /// Data transfer register
            SPI_DATA: u16,
        }), base_address + 0xc);

        /// address: 0x40003c10
        /// CRC polynomial register
        pub const CRCPOLY = @intToPtr(*volatile u16, base_address + 0x10);

        /// address: 0x40003c14
        /// RX CRC register
        pub const RCRC = @intToPtr(*volatile u16, base_address + 0x14);

        /// address: 0x40003c18
        /// TX CRC register
        pub const TCRC = @intToPtr(*volatile u16, base_address + 0x18);

        /// address: 0x40003c1c
        /// I2S control register
        pub const I2SCTL = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length
            DTLEN: u2,
            /// Idle state clock polarity
            CKPL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization mode
            PCMSMOD: u1,
            /// I2S operation mode
            I2SOPMOD: u2,
            /// I2S Enable
            I2SEN: u1,
            /// I2S mode selection
            I2SSEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x1c);

        /// address: 0x40003c20
        /// I2S prescaler register
        pub const I2SPSC = @intToPtr(*volatile Mmio(16, packed struct {
            /// Dividing factor for the prescaler
            DIV: u8,
            /// Odd factor for the
            /// prescaler
            OF: u1,
            /// I2S_MCK output enable
            MCKOEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x20);
    };

    /// Advanced-timers
    pub const TIMER0 = struct {
        pub const base_address = 0x40012c00;

        /// address: 0x40012c00
        /// control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UPDIS: u1,
            /// Update source
            UPS: u1,
            /// Single pulse mode
            SPM: u1,
            /// Direction
            DIR: u1,
            /// Counter aligns mode
            /// selection
            CAM: u2,
            /// Auto-reload shadow enable
            ARSE: u1,
            /// Clock division
            CKDIV: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x0);

        /// address: 0x40012c04
        /// control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Commutation control shadow enable
            CCSE: u1,
            reserved0: u1,
            /// Commutation control shadow register update control
            CCUC: u1,
            /// DMA request source selection
            DMAS: u1,
            /// Master mode control
            MMC: u3,
            /// Channel 0 trigger input selection
            TI0S: u1,
            /// Idle state of channel 0 output
            ISO0: u1,
            /// Idle state of channel 0 complementary output
            ISO0N: u1,
            /// Idle state of channel 1 output
            ISO1: u1,
            /// Idle state of channel 1 complementary output
            ISO1N: u1,
            /// Idle state of channel 2 output
            ISO2: u1,
            /// Idle state of channel 2 complementary output
            ISO2N: u1,
            /// Idle state of channel 3 output
            ISO3: u1,
            padding0: u1,
        }), base_address + 0x4);

        /// address: 0x40012c08
        /// slave mode configuration register
        pub const SMCFG = @intToPtr(*volatile Mmio(16, packed struct {
            /// Slave mode selection
            SMC: u3,
            reserved0: u1,
            /// Trigger selection
            TRGS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter control
            ETFC: u4,
            /// External trigger prescaler
            ETPSC: u2,
            /// Part of SMC for enable External clock mode1
            SMC1: u1,
            /// External trigger polarity
            ETP: u1,
        }), base_address + 0x8);

        /// address: 0x40012c0c
        /// DMA/Interrupt enable register
        pub const DMAINTEN = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update interrupt enable
            UPIE: u1,
            /// Channel 0 capture/compare interrupt enable
            CH0IE: u1,
            /// Channel 1 capture/compare interrupt enable
            CH1IE: u1,
            /// Channel 2 capture/compare interrupt enable
            CH2IE: u1,
            /// Channel 3 capture/compare interrupt enable
            CH3IE: u1,
            /// commutation interrupt enable
            CMTIE: u1,
            /// Trigger interrupt enable
            TRGIE: u1,
            /// Break interrupt enable
            BRKIE: u1,
            /// Update DMA request enable
            UPDEN: u1,
            /// Channel 0 capture/compare DMA request enable
            CH0DEN: u1,
            /// Channel 1 capture/compare DMA request enable
            CH1DEN: u1,
            /// Channel 2 capture/compare DMA request enable
            CH2DEN: u1,
            /// Channel 3 capture/compare DMA request enable
            CH3DEN: u1,
            /// Commutation DMA request enable
            CMTDEN: u1,
            /// Trigger DMA request enable
            TRGDEN: u1,
            padding0: u1,
        }), base_address + 0xc);

        /// address: 0x40012c10
        /// Interrupt flag register
        pub const INTF = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update interrupt flag
            UPIF: u1,
            /// Channel 0 capture/compare interrupt flag
            CH0IF: u1,
            /// Channel 1 capture/compare interrupt flag
            CH1IF: u1,
            /// Channel 2 capture/compare interrupt flag
            CH2IF: u1,
            /// Channel 3 capture/compare interrupt flag
            CH3IF: u1,
            /// Channel commutation interrupt flag
            CMTIF: u1,
            /// Trigger interrupt flag
            TRGIF: u1,
            /// Break interrupt flag
            BRKIF: u1,
            reserved0: u1,
            /// Channel 0 over capture flag
            CH0OF: u1,
            /// Channel 1 over capture flag
            CH1OF: u1,
            /// Channel 2 over capture flag
            CH2OF: u1,
            /// Channel 3 over capture flag
            CH3OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x10);

        /// address: 0x40012c14
        /// Software event generation register
        pub const SWEVG = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update event generation
            UPG: u1,
            /// Channel 0 capture or compare event generation
            CH0G: u1,
            /// Channel 1 capture or compare event generation
            CH1G: u1,
            /// Channel 2 capture or compare event generation
            CH2G: u1,
            /// Channel 3 capture or compare event generation
            CH3G: u1,
            /// Channel commutation event generation
            CMTG: u1,
            /// Trigger event generation
            TRGG: u1,
            /// Break event generation
            BRKG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x14);

        /// address: 0x40012c18
        /// Channel control register 0 (output
        /// mode)
        pub const CHCTL0_Output = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 0 I/O mode selection
            CH0MS: u2,
            /// Channel 0 output compare fast enable
            CH0COMFEN: u1,
            /// Channel 0 compare output shadow enable
            CH0COMSEN: u1,
            /// Channel 0 compare output control
            CH0COMCTL: u3,
            /// Channel 0 output compare clear enable
            CH0COMCEN: u1,
            /// Channel 1 mode selection
            CH1MS: u2,
            /// Channel 1 output compare fast enable
            CH1COMFEN: u1,
            /// Channel 1 output compare shadow enable
            CH1COMSEN: u1,
            /// Channel 1 compare output control
            CH1COMCTL: u3,
            /// Channel 1 output compare clear enable
            CH1COMCEN: u1,
        }), base_address + 0x18);

        /// address: 0x40012c18
        /// Channel control register 0 (input
        /// mode)
        pub const CHCTL0_Input = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 0 mode selection
            CH0MS: u2,
            /// Channel 0 input capture prescaler
            CH0CAPPSC: u2,
            /// Channel 0 input capture filter control
            CH0CAPFLT: u4,
            /// Channel 1 mode selection
            CH1MS: u2,
            /// Channel 1 input capture prescaler
            CH1CAPPSC: u2,
            /// Channel 1 input capture filter control
            CH1CAPFLT: u4,
        }), base_address + 0x18);

        /// address: 0x40012c1c
        /// Channel control register 1 (output
        /// mode)
        pub const CHCTL1_Output = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 2 I/O mode selection
            CH2MS: u2,
            /// Channel 2 output compare fast enable
            CH2COMFEN: u1,
            /// Channel 2 compare output shadow enable
            CH2COMSEN: u1,
            /// Channel 2 compare output control
            CH2COMCTL: u3,
            /// Channel 2 output compare clear enable
            CH2COMCEN: u1,
            /// Channel 3 mode selection
            CH3MS: u2,
            /// Channel 3 output compare fast enable
            CH3COMFEN: u1,
            /// Channel 3 output compare shadow enable
            CH3COMSEN: u1,
            /// Channel 3 compare output control
            CH3COMCTL: u3,
            /// Channel 3 output compare clear enable
            CH3COMCEN: u1,
        }), base_address + 0x1c);

        /// address: 0x40012c1c
        /// Channel control register 1 (input
        /// mode)
        pub const CHCTL1_Input = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 2 mode selection
            CH2MS: u2,
            /// Channel 2 input capture prescaler
            CH2CAPPSC: u2,
            /// Channel 2 input capture filter control
            CH2CAPFLT: u4,
            /// Channel 3 mode selection
            CH3MS: u2,
            /// Channel 3 input capture prescaler
            CH3CAPPSC: u2,
            /// Channel 3 input capture filter control
            CH3CAPFLT: u4,
        }), base_address + 0x1c);

        /// address: 0x40012c20
        /// Channel control register 2
        pub const CHCTL2 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 0 capture/compare function enable
            CH0EN: u1,
            /// Channel 0 capture/compare function polarity
            CH0P: u1,
            /// Channel 0 complementary output enable
            CH0NEN: u1,
            /// Channel 0 complementary output polarity
            CH0NP: u1,
            /// Channel 1 capture/compare function enable
            CH1EN: u1,
            /// Channel 1 capture/compare function polarity
            CH1P: u1,
            /// Channel 1 complementary output enable
            CH1NEN: u1,
            /// Channel 1 complementary output polarity
            CH1NP: u1,
            /// Channel 2 capture/compare function enable
            CH2EN: u1,
            /// Channel 2 capture/compare function polarity
            CH2P: u1,
            /// Channel 2 complementary output enable
            CH2NEN: u1,
            /// Channel 2 complementary output polarity
            CH2NP: u1,
            /// Channel 3 capture/compare function enable
            CH3EN: u1,
            /// Channel 3 capture/compare function polarity
            CH3P: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x20);

        /// address: 0x40012c24
        /// counter
        pub const CNT = @intToPtr(*volatile u16, base_address + 0x24);

        /// address: 0x40012c28
        /// prescaler
        pub const PSC = @intToPtr(*volatile u16, base_address + 0x28);

        /// address: 0x40012c2c
        /// Counter auto reload register
        pub const CAR = @intToPtr(*volatile Mmio(16, packed struct {
            /// Counter auto reload value
            CARL: u16,
        }), base_address + 0x2c);

        /// address: 0x40012c30
        /// Counter repetition register
        pub const CREP = @intToPtr(*volatile MmioInt(16, u8), base_address + 0x30);

        /// address: 0x40012c34
        /// Channel 0 capture/compare value register
        pub const CH0CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel0
            CH0VAL: u16,
        }), base_address + 0x34);

        /// address: 0x40012c38
        /// Channel 1 capture/compare value register
        pub const CH1CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel1
            CH1VAL: u16,
        }), base_address + 0x38);

        /// address: 0x40012c3c
        /// Channel 2 capture/compare value register
        pub const CH2CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel 2
            CH2VAL: u16,
        }), base_address + 0x3c);

        /// address: 0x40012c40
        /// Channel 3 capture/compare value register
        pub const CH3CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel 3
            CH3VAL: u16,
        }), base_address + 0x40);

        /// address: 0x40012c44
        /// channel complementary protection register
        pub const CCHP = @intToPtr(*volatile Mmio(16, packed struct {
            /// Dead time configure
            DTCFG: u8,
            /// Complementary register protect control
            PROT: u2,
            /// Idle mode off-state configure
            IOS: u1,
            /// Run mode off-state configure
            ROS: u1,
            /// Break enable
            BRKEN: u1,
            /// Break polarity
            BRKP: u1,
            /// Output automatic enable
            OAEN: u1,
            /// Primary output enable
            POEN: u1,
        }), base_address + 0x44);

        /// address: 0x40012c48
        /// DMA configuration register
        pub const DMACFG = @intToPtr(*volatile Mmio(16, packed struct {
            /// DMA transfer access start address
            DMATA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA transfer count
            DMATC: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x48);

        /// address: 0x40012c4c
        /// DMA transfer buffer register
        pub const DMATB = @intToPtr(*volatile u16, base_address + 0x4c);
    };

    /// General-purpose-timers
    pub const TIMER1 = struct {
        pub const base_address = 0x40000000;

        /// address: 0x40000000
        /// control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UPDIS: u1,
            /// Update source
            UPS: u1,
            /// Single pulse mode
            SPM: u1,
            /// Direction
            DIR: u1,
            /// Counter aligns mode selection
            CAM: u2,
            /// Auto-reload shadow enable
            ARSE: u1,
            /// Clock division
            CKDIV: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x0);

        /// address: 0x40000004
        /// control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(16, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA request source selection
            DMAS: u1,
            /// Master mode control
            MMC: u3,
            /// Channel 0 trigger input selection
            TI0S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40000008
        /// slave mode control register
        pub const SMCFG = @intToPtr(*volatile Mmio(16, packed struct {
            /// Slave mode control
            SMC: u3,
            reserved0: u1,
            /// Trigger selection
            TRGS: u3,
            /// Master-slave mode
            MSM: u1,
            /// External trigger filter control
            ETFC: u4,
            /// External trigger prescaler
            ETPSC: u2,
            /// Part of SMC for enable External clock mode1
            SMC1: u1,
            /// External trigger polarity
            ETP: u1,
        }), base_address + 0x8);

        /// address: 0x4000000c
        /// DMA/Interrupt enable register
        pub const DMAINTEN = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update interrupt enable
            UPIE: u1,
            /// Channel 0 capture/compare interrupt enable
            CH0IE: u1,
            /// Channel 1 capture/compare interrupt enable
            CH1IE: u1,
            /// Channel 2 capture/compare interrupt enable
            CH2IE: u1,
            /// Channel 3 capture/compare interrupt enable
            CH3IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TRGIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UPDEN: u1,
            /// Channel 0 capture/compare DMA request enable
            CH0DEN: u1,
            /// Channel 1 capture/compare DMA request enable
            CH1DEN: u1,
            /// Channel 2 capture/compare DMA request enable
            CH2DEN: u1,
            /// Channel 3 capture/compare DMA request enable
            CH3DEN: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TRGDEN: u1,
            padding0: u1,
        }), base_address + 0xc);

        /// address: 0x40000010
        /// interrupt flag register
        pub const INTF = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update interrupt flag
            UPIF: u1,
            /// Channel 0 capture/compare interrupt flag
            CH0IF: u1,
            /// Channel 1 capture/compare interrupt flag
            CH1IF: u1,
            /// Channel 2 capture/compare interrupt enable
            CH2IF: u1,
            /// Channel 3 capture/compare interrupt enable
            CH3IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TRGIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Channel 0 over capture flag
            CH0OF: u1,
            /// Channel 1 over capture flag
            CH1OF: u1,
            /// Channel 2 over capture flag
            CH2OF: u1,
            /// Channel 3 over capture flag
            CH3OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x10);

        /// address: 0x40000014
        /// event generation register
        pub const SWEVG = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update generation
            UPG: u1,
            /// Channel 0 capture or compare event generation
            CH0G: u1,
            /// Channel 1 capture or compare event generation
            CH1G: u1,
            /// Channel 2 capture or compare event generation
            CH2G: u1,
            /// Channel 3 capture or compare event generation
            CH3G: u1,
            reserved0: u1,
            /// Trigger event generation
            TRGG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x14);

        /// address: 0x40000018
        /// Channel control register 0 (output
        /// mode)
        pub const CHCTL0_Output = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 0 I/O mode selection
            CH0MS: u2,
            /// Channel 0 output compare fast enable
            CH0COMFEN: u1,
            /// Channel 0 compare output shadow enable
            CH0COMSEN: u1,
            /// Channel 0 compare output control
            CH0COMCTL: u3,
            /// Channel 0 output compare clear enable
            CH0COMCEN: u1,
            /// Channel 1 mode selection
            CH1MS: u2,
            /// Channel 1 output compare fast enable
            CH1COMFEN: u1,
            /// Channel 1 output compare shadow enable
            CH1COMSEN: u1,
            /// Channel 1 compare output control
            CH1COMCTL: u3,
            /// Channel 1 output compare clear enable
            CH1COMCEN: u1,
        }), base_address + 0x18);

        /// address: 0x40000018
        /// Channel control register 0 (input
        /// mode)
        pub const CHCTL0_Input = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 0 mode selection
            CH0MS: u2,
            /// Channel 0 input capture prescaler
            CH0CAPPSC: u2,
            /// Channel 0 input capture filter control
            CH0CAPFLT: u4,
            /// Channel 1 mode selection
            CH1MS: u2,
            /// Channel 1 input capture prescaler
            CH1CAPPSC: u2,
            /// Channel 1 input capture filter control
            CH1CAPFLT: u4,
        }), base_address + 0x18);

        /// address: 0x4000001c
        /// Channel control register 1 (output mode)
        pub const CHCTL1_Output = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 2 I/O mode selection
            CH2MS: u2,
            /// Channel 2 output compare fast enable
            CH2COMFEN: u1,
            /// Channel 2 compare output shadow enable
            CH2COMSEN: u1,
            /// Channel 2 compare output control
            CH2COMCTL: u3,
            /// Channel 2 output compare clear enable
            CH2COMCEN: u1,
            /// Channel 3 mode selection
            CH3MS: u2,
            /// Channel 3 output compare fast enable
            CH3COMFEN: u1,
            /// Channel 3 output compare shadow enable
            CH3COMSEN: u1,
            /// Channel 3 compare output control
            CH3COMCTL: u3,
            /// Channel 3 output compare clear enable
            CH3COMCEN: u1,
        }), base_address + 0x1c);

        /// address: 0x4000001c
        /// Channel control register 1 (input
        /// mode)
        pub const CHCTL1_Input = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 2 mode selection
            CH2MS: u2,
            /// Channel 2 input capture prescaler
            CH2CAPPSC: u2,
            /// Channel 2 input capture filter control
            CH2CAPFLT: u4,
            /// Channel 3 mode selection
            CH3MS: u2,
            /// Channel 3 input capture prescaler
            CH3CAPPSC: u2,
            /// Channel 3 input capture filter control
            CH3CAPFLT: u4,
        }), base_address + 0x1c);

        /// address: 0x40000020
        /// Channel control register 2
        pub const CHCTL2 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 0 capture/compare function enable
            CH0EN: u1,
            /// Channel 0 capture/compare function polarity
            CH0P: u1,
            reserved0: u1,
            reserved1: u1,
            /// Channel 1 capture/compare function enable
            CH1EN: u1,
            /// Channel 1 capture/compare function polarity
            CH1P: u1,
            reserved2: u1,
            reserved3: u1,
            /// Channel 2 capture/compare function enable
            CH2EN: u1,
            /// Channel 2 capture/compare function polarity
            CH2P: u1,
            reserved4: u1,
            reserved5: u1,
            /// Channel 3 capture/compare function enable
            CH3EN: u1,
            /// Channel 3 capture/compare function polarity
            CH3P: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x20);

        /// address: 0x40000024
        /// Counter register
        pub const CNT = @intToPtr(*volatile u16, base_address + 0x24);

        /// address: 0x40000028
        /// Prescaler register
        pub const PSC = @intToPtr(*volatile u16, base_address + 0x28);

        /// address: 0x4000002c
        /// Counter auto reload register
        pub const CAR = @intToPtr(*volatile Mmio(16, packed struct {
            /// Counter auto reload value
            CARL: u16,
        }), base_address + 0x2c);

        /// address: 0x40000034
        /// Channel 0 capture/compare value register
        pub const CH0CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel 0
            CH0VAL: u16,
        }), base_address + 0x34);

        /// address: 0x40000038
        /// Channel 1 capture/compare value register
        pub const CH1CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel1
            CH1VAL: u16,
        }), base_address + 0x38);

        /// address: 0x4000003c
        /// Channel 2 capture/compare value register
        pub const CH2CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel 2
            CH2VAL: u16,
        }), base_address + 0x3c);

        /// address: 0x40000040
        /// Channel 3 capture/compare value register
        pub const CH3CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel 3
            CH3VAL: u16,
        }), base_address + 0x40);

        /// address: 0x40000048
        /// DMA configuration register
        pub const DMACFG = @intToPtr(*volatile Mmio(16, packed struct {
            /// DMA transfer access start address
            DMATA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA transfer count
            DMATC: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x48);

        /// address: 0x4000004c
        /// DMA transfer buffer register
        pub const DMATB = @intToPtr(*volatile u16, base_address + 0x4c);
    };
    pub const TIMER2 = struct {
        pub const base_address = 0x40000400;

        /// address: 0x40000400
        /// control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UPDIS: u1,
            /// Update source
            UPS: u1,
            /// Single pulse mode
            SPM: u1,
            /// Direction
            DIR: u1,
            /// Counter aligns mode selection
            CAM: u2,
            /// Auto-reload shadow enable
            ARSE: u1,
            /// Clock division
            CKDIV: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x0);

        /// address: 0x40000404
        /// control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(16, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA request source selection
            DMAS: u1,
            /// Master mode control
            MMC: u3,
            /// Channel 0 trigger input selection
            TI0S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40000408
        /// slave mode control register
        pub const SMCFG = @intToPtr(*volatile Mmio(16, packed struct {
            /// Slave mode control
            SMC: u3,
            reserved0: u1,
            /// Trigger selection
            TRGS: u3,
            /// Master-slave mode
            MSM: u1,
            /// External trigger filter control
            ETFC: u4,
            /// External trigger prescaler
            ETPSC: u2,
            /// Part of SMC for enable External clock mode1
            SMC1: u1,
            /// External trigger polarity
            ETP: u1,
        }), base_address + 0x8);

        /// address: 0x4000040c
        /// DMA/Interrupt enable register
        pub const DMAINTEN = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update interrupt enable
            UPIE: u1,
            /// Channel 0 capture/compare interrupt enable
            CH0IE: u1,
            /// Channel 1 capture/compare interrupt enable
            CH1IE: u1,
            /// Channel 2 capture/compare interrupt enable
            CH2IE: u1,
            /// Channel 3 capture/compare interrupt enable
            CH3IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TRGIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UPDEN: u1,
            /// Channel 0 capture/compare DMA request enable
            CH0DEN: u1,
            /// Channel 1 capture/compare DMA request enable
            CH1DEN: u1,
            /// Channel 2 capture/compare DMA request enable
            CH2DEN: u1,
            /// Channel 3 capture/compare DMA request enable
            CH3DEN: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TRGDEN: u1,
            padding0: u1,
        }), base_address + 0xc);

        /// address: 0x40000410
        /// interrupt flag register
        pub const INTF = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update interrupt flag
            UPIF: u1,
            /// Channel 0 capture/compare interrupt flag
            CH0IF: u1,
            /// Channel 1 capture/compare interrupt flag
            CH1IF: u1,
            /// Channel 2 capture/compare interrupt enable
            CH2IF: u1,
            /// Channel 3 capture/compare interrupt enable
            CH3IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TRGIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Channel 0 over capture flag
            CH0OF: u1,
            /// Channel 1 over capture flag
            CH1OF: u1,
            /// Channel 2 over capture flag
            CH2OF: u1,
            /// Channel 3 over capture flag
            CH3OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x10);

        /// address: 0x40000414
        /// event generation register
        pub const SWEVG = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update generation
            UPG: u1,
            /// Channel 0 capture or compare event generation
            CH0G: u1,
            /// Channel 1 capture or compare event generation
            CH1G: u1,
            /// Channel 2 capture or compare event generation
            CH2G: u1,
            /// Channel 3 capture or compare event generation
            CH3G: u1,
            reserved0: u1,
            /// Trigger event generation
            TRGG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x14);

        /// address: 0x40000418
        /// Channel control register 0 (output
        /// mode)
        pub const CHCTL0_Output = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 0 I/O mode selection
            CH0MS: u2,
            /// Channel 0 output compare fast enable
            CH0COMFEN: u1,
            /// Channel 0 compare output shadow enable
            CH0COMSEN: u1,
            /// Channel 0 compare output control
            CH0COMCTL: u3,
            /// Channel 0 output compare clear enable
            CH0COMCEN: u1,
            /// Channel 1 mode selection
            CH1MS: u2,
            /// Channel 1 output compare fast enable
            CH1COMFEN: u1,
            /// Channel 1 output compare shadow enable
            CH1COMSEN: u1,
            /// Channel 1 compare output control
            CH1COMCTL: u3,
            /// Channel 1 output compare clear enable
            CH1COMCEN: u1,
        }), base_address + 0x18);

        /// address: 0x40000418
        /// Channel control register 0 (input
        /// mode)
        pub const CHCTL0_Input = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 0 mode selection
            CH0MS: u2,
            /// Channel 0 input capture prescaler
            CH0CAPPSC: u2,
            /// Channel 0 input capture filter control
            CH0CAPFLT: u4,
            /// Channel 1 mode selection
            CH1MS: u2,
            /// Channel 1 input capture prescaler
            CH1CAPPSC: u2,
            /// Channel 1 input capture filter control
            CH1CAPFLT: u4,
        }), base_address + 0x18);

        /// address: 0x4000041c
        /// Channel control register 1 (output mode)
        pub const CHCTL1_Output = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 2 I/O mode selection
            CH2MS: u2,
            /// Channel 2 output compare fast enable
            CH2COMFEN: u1,
            /// Channel 2 compare output shadow enable
            CH2COMSEN: u1,
            /// Channel 2 compare output control
            CH2COMCTL: u3,
            /// Channel 2 output compare clear enable
            CH2COMCEN: u1,
            /// Channel 3 mode selection
            CH3MS: u2,
            /// Channel 3 output compare fast enable
            CH3COMFEN: u1,
            /// Channel 3 output compare shadow enable
            CH3COMSEN: u1,
            /// Channel 3 compare output control
            CH3COMCTL: u3,
            /// Channel 3 output compare clear enable
            CH3COMCEN: u1,
        }), base_address + 0x1c);

        /// address: 0x4000041c
        /// Channel control register 1 (input
        /// mode)
        pub const CHCTL1_Input = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 2 mode selection
            CH2MS: u2,
            /// Channel 2 input capture prescaler
            CH2CAPPSC: u2,
            /// Channel 2 input capture filter control
            CH2CAPFLT: u4,
            /// Channel 3 mode selection
            CH3MS: u2,
            /// Channel 3 input capture prescaler
            CH3CAPPSC: u2,
            /// Channel 3 input capture filter control
            CH3CAPFLT: u4,
        }), base_address + 0x1c);

        /// address: 0x40000420
        /// Channel control register 2
        pub const CHCTL2 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 0 capture/compare function enable
            CH0EN: u1,
            /// Channel 0 capture/compare function polarity
            CH0P: u1,
            reserved0: u1,
            reserved1: u1,
            /// Channel 1 capture/compare function enable
            CH1EN: u1,
            /// Channel 1 capture/compare function polarity
            CH1P: u1,
            reserved2: u1,
            reserved3: u1,
            /// Channel 2 capture/compare function enable
            CH2EN: u1,
            /// Channel 2 capture/compare function polarity
            CH2P: u1,
            reserved4: u1,
            reserved5: u1,
            /// Channel 3 capture/compare function enable
            CH3EN: u1,
            /// Channel 3 capture/compare function polarity
            CH3P: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x20);

        /// address: 0x40000424
        /// Counter register
        pub const CNT = @intToPtr(*volatile u16, base_address + 0x24);

        /// address: 0x40000428
        /// Prescaler register
        pub const PSC = @intToPtr(*volatile u16, base_address + 0x28);

        /// address: 0x4000042c
        /// Counter auto reload register
        pub const CAR = @intToPtr(*volatile Mmio(16, packed struct {
            /// Counter auto reload value
            CARL: u16,
        }), base_address + 0x2c);

        /// address: 0x40000434
        /// Channel 0 capture/compare value register
        pub const CH0CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel 0
            CH0VAL: u16,
        }), base_address + 0x34);

        /// address: 0x40000438
        /// Channel 1 capture/compare value register
        pub const CH1CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel1
            CH1VAL: u16,
        }), base_address + 0x38);

        /// address: 0x4000043c
        /// Channel 2 capture/compare value register
        pub const CH2CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel 2
            CH2VAL: u16,
        }), base_address + 0x3c);

        /// address: 0x40000440
        /// Channel 3 capture/compare value register
        pub const CH3CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel 3
            CH3VAL: u16,
        }), base_address + 0x40);

        /// address: 0x40000448
        /// DMA configuration register
        pub const DMACFG = @intToPtr(*volatile Mmio(16, packed struct {
            /// DMA transfer access start address
            DMATA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA transfer count
            DMATC: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x48);

        /// address: 0x4000044c
        /// DMA transfer buffer register
        pub const DMATB = @intToPtr(*volatile u16, base_address + 0x4c);
    };
    pub const TIMER3 = struct {
        pub const base_address = 0x40000800;

        /// address: 0x40000800
        /// control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UPDIS: u1,
            /// Update source
            UPS: u1,
            /// Single pulse mode
            SPM: u1,
            /// Direction
            DIR: u1,
            /// Counter aligns mode selection
            CAM: u2,
            /// Auto-reload shadow enable
            ARSE: u1,
            /// Clock division
            CKDIV: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x0);

        /// address: 0x40000804
        /// control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(16, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA request source selection
            DMAS: u1,
            /// Master mode control
            MMC: u3,
            /// Channel 0 trigger input selection
            TI0S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40000808
        /// slave mode control register
        pub const SMCFG = @intToPtr(*volatile Mmio(16, packed struct {
            /// Slave mode control
            SMC: u3,
            reserved0: u1,
            /// Trigger selection
            TRGS: u3,
            /// Master-slave mode
            MSM: u1,
            /// External trigger filter control
            ETFC: u4,
            /// External trigger prescaler
            ETPSC: u2,
            /// Part of SMC for enable External clock mode1
            SMC1: u1,
            /// External trigger polarity
            ETP: u1,
        }), base_address + 0x8);

        /// address: 0x4000080c
        /// DMA/Interrupt enable register
        pub const DMAINTEN = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update interrupt enable
            UPIE: u1,
            /// Channel 0 capture/compare interrupt enable
            CH0IE: u1,
            /// Channel 1 capture/compare interrupt enable
            CH1IE: u1,
            /// Channel 2 capture/compare interrupt enable
            CH2IE: u1,
            /// Channel 3 capture/compare interrupt enable
            CH3IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TRGIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UPDEN: u1,
            /// Channel 0 capture/compare DMA request enable
            CH0DEN: u1,
            /// Channel 1 capture/compare DMA request enable
            CH1DEN: u1,
            /// Channel 2 capture/compare DMA request enable
            CH2DEN: u1,
            /// Channel 3 capture/compare DMA request enable
            CH3DEN: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TRGDEN: u1,
            padding0: u1,
        }), base_address + 0xc);

        /// address: 0x40000810
        /// interrupt flag register
        pub const INTF = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update interrupt flag
            UPIF: u1,
            /// Channel 0 capture/compare interrupt flag
            CH0IF: u1,
            /// Channel 1 capture/compare interrupt flag
            CH1IF: u1,
            /// Channel 2 capture/compare interrupt enable
            CH2IF: u1,
            /// Channel 3 capture/compare interrupt enable
            CH3IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TRGIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Channel 0 over capture flag
            CH0OF: u1,
            /// Channel 1 over capture flag
            CH1OF: u1,
            /// Channel 2 over capture flag
            CH2OF: u1,
            /// Channel 3 over capture flag
            CH3OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x10);

        /// address: 0x40000814
        /// event generation register
        pub const SWEVG = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update generation
            UPG: u1,
            /// Channel 0 capture or compare event generation
            CH0G: u1,
            /// Channel 1 capture or compare event generation
            CH1G: u1,
            /// Channel 2 capture or compare event generation
            CH2G: u1,
            /// Channel 3 capture or compare event generation
            CH3G: u1,
            reserved0: u1,
            /// Trigger event generation
            TRGG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x14);

        /// address: 0x40000818
        /// Channel control register 0 (output
        /// mode)
        pub const CHCTL0_Output = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 0 I/O mode selection
            CH0MS: u2,
            /// Channel 0 output compare fast enable
            CH0COMFEN: u1,
            /// Channel 0 compare output shadow enable
            CH0COMSEN: u1,
            /// Channel 0 compare output control
            CH0COMCTL: u3,
            /// Channel 0 output compare clear enable
            CH0COMCEN: u1,
            /// Channel 1 mode selection
            CH1MS: u2,
            /// Channel 1 output compare fast enable
            CH1COMFEN: u1,
            /// Channel 1 output compare shadow enable
            CH1COMSEN: u1,
            /// Channel 1 compare output control
            CH1COMCTL: u3,
            /// Channel 1 output compare clear enable
            CH1COMCEN: u1,
        }), base_address + 0x18);

        /// address: 0x40000818
        /// Channel control register 0 (input
        /// mode)
        pub const CHCTL0_Input = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 0 mode selection
            CH0MS: u2,
            /// Channel 0 input capture prescaler
            CH0CAPPSC: u2,
            /// Channel 0 input capture filter control
            CH0CAPFLT: u4,
            /// Channel 1 mode selection
            CH1MS: u2,
            /// Channel 1 input capture prescaler
            CH1CAPPSC: u2,
            /// Channel 1 input capture filter control
            CH1CAPFLT: u4,
        }), base_address + 0x18);

        /// address: 0x4000081c
        /// Channel control register 1 (output mode)
        pub const CHCTL1_Output = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 2 I/O mode selection
            CH2MS: u2,
            /// Channel 2 output compare fast enable
            CH2COMFEN: u1,
            /// Channel 2 compare output shadow enable
            CH2COMSEN: u1,
            /// Channel 2 compare output control
            CH2COMCTL: u3,
            /// Channel 2 output compare clear enable
            CH2COMCEN: u1,
            /// Channel 3 mode selection
            CH3MS: u2,
            /// Channel 3 output compare fast enable
            CH3COMFEN: u1,
            /// Channel 3 output compare shadow enable
            CH3COMSEN: u1,
            /// Channel 3 compare output control
            CH3COMCTL: u3,
            /// Channel 3 output compare clear enable
            CH3COMCEN: u1,
        }), base_address + 0x1c);

        /// address: 0x4000081c
        /// Channel control register 1 (input
        /// mode)
        pub const CHCTL1_Input = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 2 mode selection
            CH2MS: u2,
            /// Channel 2 input capture prescaler
            CH2CAPPSC: u2,
            /// Channel 2 input capture filter control
            CH2CAPFLT: u4,
            /// Channel 3 mode selection
            CH3MS: u2,
            /// Channel 3 input capture prescaler
            CH3CAPPSC: u2,
            /// Channel 3 input capture filter control
            CH3CAPFLT: u4,
        }), base_address + 0x1c);

        /// address: 0x40000820
        /// Channel control register 2
        pub const CHCTL2 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 0 capture/compare function enable
            CH0EN: u1,
            /// Channel 0 capture/compare function polarity
            CH0P: u1,
            reserved0: u1,
            reserved1: u1,
            /// Channel 1 capture/compare function enable
            CH1EN: u1,
            /// Channel 1 capture/compare function polarity
            CH1P: u1,
            reserved2: u1,
            reserved3: u1,
            /// Channel 2 capture/compare function enable
            CH2EN: u1,
            /// Channel 2 capture/compare function polarity
            CH2P: u1,
            reserved4: u1,
            reserved5: u1,
            /// Channel 3 capture/compare function enable
            CH3EN: u1,
            /// Channel 3 capture/compare function polarity
            CH3P: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x20);

        /// address: 0x40000824
        /// Counter register
        pub const CNT = @intToPtr(*volatile u16, base_address + 0x24);

        /// address: 0x40000828
        /// Prescaler register
        pub const PSC = @intToPtr(*volatile u16, base_address + 0x28);

        /// address: 0x4000082c
        /// Counter auto reload register
        pub const CAR = @intToPtr(*volatile Mmio(16, packed struct {
            /// Counter auto reload value
            CARL: u16,
        }), base_address + 0x2c);

        /// address: 0x40000834
        /// Channel 0 capture/compare value register
        pub const CH0CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel 0
            CH0VAL: u16,
        }), base_address + 0x34);

        /// address: 0x40000838
        /// Channel 1 capture/compare value register
        pub const CH1CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel1
            CH1VAL: u16,
        }), base_address + 0x38);

        /// address: 0x4000083c
        /// Channel 2 capture/compare value register
        pub const CH2CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel 2
            CH2VAL: u16,
        }), base_address + 0x3c);

        /// address: 0x40000840
        /// Channel 3 capture/compare value register
        pub const CH3CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel 3
            CH3VAL: u16,
        }), base_address + 0x40);

        /// address: 0x40000848
        /// DMA configuration register
        pub const DMACFG = @intToPtr(*volatile Mmio(16, packed struct {
            /// DMA transfer access start address
            DMATA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA transfer count
            DMATC: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x48);

        /// address: 0x4000084c
        /// DMA transfer buffer register
        pub const DMATB = @intToPtr(*volatile u16, base_address + 0x4c);
    };
    pub const TIMER4 = struct {
        pub const base_address = 0x40000c00;

        /// address: 0x40000c00
        /// control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UPDIS: u1,
            /// Update source
            UPS: u1,
            /// Single pulse mode
            SPM: u1,
            /// Direction
            DIR: u1,
            /// Counter aligns mode selection
            CAM: u2,
            /// Auto-reload shadow enable
            ARSE: u1,
            /// Clock division
            CKDIV: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x0);

        /// address: 0x40000c04
        /// control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(16, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA request source selection
            DMAS: u1,
            /// Master mode control
            MMC: u3,
            /// Channel 0 trigger input selection
            TI0S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40000c08
        /// slave mode control register
        pub const SMCFG = @intToPtr(*volatile Mmio(16, packed struct {
            /// Slave mode control
            SMC: u3,
            reserved0: u1,
            /// Trigger selection
            TRGS: u3,
            /// Master-slave mode
            MSM: u1,
            /// External trigger filter control
            ETFC: u4,
            /// External trigger prescaler
            ETPSC: u2,
            /// Part of SMC for enable External clock mode1
            SMC1: u1,
            /// External trigger polarity
            ETP: u1,
        }), base_address + 0x8);

        /// address: 0x40000c0c
        /// DMA/Interrupt enable register
        pub const DMAINTEN = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update interrupt enable
            UPIE: u1,
            /// Channel 0 capture/compare interrupt enable
            CH0IE: u1,
            /// Channel 1 capture/compare interrupt enable
            CH1IE: u1,
            /// Channel 2 capture/compare interrupt enable
            CH2IE: u1,
            /// Channel 3 capture/compare interrupt enable
            CH3IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TRGIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UPDEN: u1,
            /// Channel 0 capture/compare DMA request enable
            CH0DEN: u1,
            /// Channel 1 capture/compare DMA request enable
            CH1DEN: u1,
            /// Channel 2 capture/compare DMA request enable
            CH2DEN: u1,
            /// Channel 3 capture/compare DMA request enable
            CH3DEN: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TRGDEN: u1,
            padding0: u1,
        }), base_address + 0xc);

        /// address: 0x40000c10
        /// interrupt flag register
        pub const INTF = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update interrupt flag
            UPIF: u1,
            /// Channel 0 capture/compare interrupt flag
            CH0IF: u1,
            /// Channel 1 capture/compare interrupt flag
            CH1IF: u1,
            /// Channel 2 capture/compare interrupt enable
            CH2IF: u1,
            /// Channel 3 capture/compare interrupt enable
            CH3IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TRGIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Channel 0 over capture flag
            CH0OF: u1,
            /// Channel 1 over capture flag
            CH1OF: u1,
            /// Channel 2 over capture flag
            CH2OF: u1,
            /// Channel 3 over capture flag
            CH3OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x10);

        /// address: 0x40000c14
        /// event generation register
        pub const SWEVG = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update generation
            UPG: u1,
            /// Channel 0 capture or compare event generation
            CH0G: u1,
            /// Channel 1 capture or compare event generation
            CH1G: u1,
            /// Channel 2 capture or compare event generation
            CH2G: u1,
            /// Channel 3 capture or compare event generation
            CH3G: u1,
            reserved0: u1,
            /// Trigger event generation
            TRGG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x14);

        /// address: 0x40000c18
        /// Channel control register 0 (output
        /// mode)
        pub const CHCTL0_Output = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 0 I/O mode selection
            CH0MS: u2,
            /// Channel 0 output compare fast enable
            CH0COMFEN: u1,
            /// Channel 0 compare output shadow enable
            CH0COMSEN: u1,
            /// Channel 0 compare output control
            CH0COMCTL: u3,
            /// Channel 0 output compare clear enable
            CH0COMCEN: u1,
            /// Channel 1 mode selection
            CH1MS: u2,
            /// Channel 1 output compare fast enable
            CH1COMFEN: u1,
            /// Channel 1 output compare shadow enable
            CH1COMSEN: u1,
            /// Channel 1 compare output control
            CH1COMCTL: u3,
            /// Channel 1 output compare clear enable
            CH1COMCEN: u1,
        }), base_address + 0x18);

        /// address: 0x40000c18
        /// Channel control register 0 (input
        /// mode)
        pub const CHCTL0_Input = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 0 mode selection
            CH0MS: u2,
            /// Channel 0 input capture prescaler
            CH0CAPPSC: u2,
            /// Channel 0 input capture filter control
            CH0CAPFLT: u4,
            /// Channel 1 mode selection
            CH1MS: u2,
            /// Channel 1 input capture prescaler
            CH1CAPPSC: u2,
            /// Channel 1 input capture filter control
            CH1CAPFLT: u4,
        }), base_address + 0x18);

        /// address: 0x40000c1c
        /// Channel control register 1 (output mode)
        pub const CHCTL1_Output = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 2 I/O mode selection
            CH2MS: u2,
            /// Channel 2 output compare fast enable
            CH2COMFEN: u1,
            /// Channel 2 compare output shadow enable
            CH2COMSEN: u1,
            /// Channel 2 compare output control
            CH2COMCTL: u3,
            /// Channel 2 output compare clear enable
            CH2COMCEN: u1,
            /// Channel 3 mode selection
            CH3MS: u2,
            /// Channel 3 output compare fast enable
            CH3COMFEN: u1,
            /// Channel 3 output compare shadow enable
            CH3COMSEN: u1,
            /// Channel 3 compare output control
            CH3COMCTL: u3,
            /// Channel 3 output compare clear enable
            CH3COMCEN: u1,
        }), base_address + 0x1c);

        /// address: 0x40000c1c
        /// Channel control register 1 (input
        /// mode)
        pub const CHCTL1_Input = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 2 mode selection
            CH2MS: u2,
            /// Channel 2 input capture prescaler
            CH2CAPPSC: u2,
            /// Channel 2 input capture filter control
            CH2CAPFLT: u4,
            /// Channel 3 mode selection
            CH3MS: u2,
            /// Channel 3 input capture prescaler
            CH3CAPPSC: u2,
            /// Channel 3 input capture filter control
            CH3CAPFLT: u4,
        }), base_address + 0x1c);

        /// address: 0x40000c20
        /// Channel control register 2
        pub const CHCTL2 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel 0 capture/compare function enable
            CH0EN: u1,
            /// Channel 0 capture/compare function polarity
            CH0P: u1,
            reserved0: u1,
            reserved1: u1,
            /// Channel 1 capture/compare function enable
            CH1EN: u1,
            /// Channel 1 capture/compare function polarity
            CH1P: u1,
            reserved2: u1,
            reserved3: u1,
            /// Channel 2 capture/compare function enable
            CH2EN: u1,
            /// Channel 2 capture/compare function polarity
            CH2P: u1,
            reserved4: u1,
            reserved5: u1,
            /// Channel 3 capture/compare function enable
            CH3EN: u1,
            /// Channel 3 capture/compare function polarity
            CH3P: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x20);

        /// address: 0x40000c24
        /// Counter register
        pub const CNT = @intToPtr(*volatile u16, base_address + 0x24);

        /// address: 0x40000c28
        /// Prescaler register
        pub const PSC = @intToPtr(*volatile u16, base_address + 0x28);

        /// address: 0x40000c2c
        /// Counter auto reload register
        pub const CAR = @intToPtr(*volatile Mmio(16, packed struct {
            /// Counter auto reload value
            CARL: u16,
        }), base_address + 0x2c);

        /// address: 0x40000c34
        /// Channel 0 capture/compare value register
        pub const CH0CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel 0
            CH0VAL: u16,
        }), base_address + 0x34);

        /// address: 0x40000c38
        /// Channel 1 capture/compare value register
        pub const CH1CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel1
            CH1VAL: u16,
        }), base_address + 0x38);

        /// address: 0x40000c3c
        /// Channel 2 capture/compare value register
        pub const CH2CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel 2
            CH2VAL: u16,
        }), base_address + 0x3c);

        /// address: 0x40000c40
        /// Channel 3 capture/compare value register
        pub const CH3CV = @intToPtr(*volatile Mmio(16, packed struct {
            /// Capture or compare value of channel 3
            CH3VAL: u16,
        }), base_address + 0x40);

        /// address: 0x40000c48
        /// DMA configuration register
        pub const DMACFG = @intToPtr(*volatile Mmio(16, packed struct {
            /// DMA transfer access start address
            DMATA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA transfer count
            DMATC: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x48);

        /// address: 0x40000c4c
        /// DMA transfer buffer register
        pub const DMATB = @intToPtr(*volatile u16, base_address + 0x4c);
    };

    /// Basic-timers
    pub const TIMER5 = struct {
        pub const base_address = 0x40001000;

        /// address: 0x40001000
        /// control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UPDIS: u1,
            /// Update source
            UPS: u1,
            /// Single pulse mode
            SPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload shadow enable
            ARSE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40001004
        /// control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(16, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode control
            MMC: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x4);

        /// address: 0x4000100c
        /// DMA/Interrupt enable register
        pub const DMAINTEN = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update interrupt enable
            UPIE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Update DMA request enable
            UPDEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0xc);

        /// address: 0x40001010
        /// Interrupt flag register
        pub const INTF = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update interrupt flag
            UPIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x10);

        /// address: 0x40001014
        /// event generation register
        pub const SWEVG = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update generation
            UPG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x14);

        /// address: 0x40001024
        /// Counter register
        pub const CNT = @intToPtr(*volatile u16, base_address + 0x24);

        /// address: 0x40001028
        /// Prescaler register
        pub const PSC = @intToPtr(*volatile u16, base_address + 0x28);

        /// address: 0x4000102c
        /// Counter auto reload register
        pub const CAR = @intToPtr(*volatile Mmio(16, packed struct {
            /// Counter auto reload value
            CARL: u16,
        }), base_address + 0x2c);
    };
    pub const TIMER6 = struct {
        pub const base_address = 0x40001400;

        /// address: 0x40001400
        /// control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(16, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UPDIS: u1,
            /// Update source
            UPS: u1,
            /// Single pulse mode
            SPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload shadow enable
            ARSE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40001404
        /// control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(16, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode control
            MMC: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x4);

        /// address: 0x4000140c
        /// DMA/Interrupt enable register
        pub const DMAINTEN = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update interrupt enable
            UPIE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Update DMA request enable
            UPDEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0xc);

        /// address: 0x40001410
        /// Interrupt flag register
        pub const INTF = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update interrupt flag
            UPIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x10);

        /// address: 0x40001414
        /// event generation register
        pub const SWEVG = @intToPtr(*volatile Mmio(16, packed struct {
            /// Update generation
            UPG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x14);

        /// address: 0x40001424
        /// Counter register
        pub const CNT = @intToPtr(*volatile u16, base_address + 0x24);

        /// address: 0x40001428
        /// Prescaler register
        pub const PSC = @intToPtr(*volatile u16, base_address + 0x28);

        /// address: 0x4000142c
        /// Counter auto reload register
        pub const CAR = @intToPtr(*volatile Mmio(16, packed struct {
            /// Counter auto reload value
            CARL: u16,
        }), base_address + 0x2c);
    };

    /// Universal synchronous asynchronous receiver
    /// transmitter
    pub const USART0 = struct {
        pub const base_address = 0x40013800;

        /// address: 0x40013800
        /// Status register
        pub const STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error flag
            PERR: u1,
            /// Frame error flag
            FERR: u1,
            /// Noise error flag
            NERR: u1,
            /// Overrun error
            ORERR: u1,
            /// IDLE frame detected flag
            IDLEF: u1,
            /// Read data buffer not empty
            RBNE: u1,
            /// Transmission complete
            TC: u1,
            /// Transmit data buffer empty
            TBE: u1,
            /// LIN break detection flag
            LBDF: u1,
            /// CTS change flag
            CTSF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40013804
        /// Data register
        pub const DATA = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x4);

        /// address: 0x40013808
        /// Baud rate register
        pub const BAUD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fraction part of baud-rate divider
            FRADIV: u4,
            /// Integer part of baud-rate divider
            INTDIV: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001380c
        /// Control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Send break command
            SBKCMD: u1,
            /// Receiver wakeup from mute mode
            RWU: u1,
            /// Receiver enable
            REN: u1,
            /// Transmitter enable
            TEN: u1,
            /// IDLE line detected interrupt enable
            IDLEIE: u1,
            /// Read data buffer not empty interrupt and overrun error interrupt enable
            RBNEIE: u1,
            /// Transmission complete interrupt enable
            TCIE: u1,
            /// Transmitter buffer empty interrupt enable
            TBEIE: u1,
            /// Parity error interrupt enable
            PERRIE: u1,
            /// Parity mode
            PM: u1,
            /// Parity check function enable
            PCEN: u1,
            /// Wakeup method in mute mode
            WM: u1,
            /// Word length
            WL: u1,
            /// USART enable
            UEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xc);

        /// address: 0x40013810
        /// Control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address of the USART
            ADDR: u4,
            reserved0: u1,
            /// LIN break frame length
            LBLEN: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved1: u1,
            /// CK Length
            CLEN: u1,
            /// Clock phase
            CPH: u1,
            /// Clock polarity
            CPL: u1,
            /// CK pin enable
            CKEN: u1,
            /// STOP bits length
            STB: u2,
            /// LIN mode enable
            LMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x10);

        /// address: 0x40013814
        /// Control register 2
        pub const CTL2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            ERRIE: u1,
            /// IrDA mode enable
            IREN: u1,
            /// IrDA low-power
            IRLP: u1,
            /// Half-duplex selection
            HDEN: u1,
            /// Smartcard NACK enable
            NKEN: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA request enable for reception
            DENR: u1,
            /// DMA request enable for transmission
            DENT: u1,
            /// RTS enable
            RTSEN: u1,
            /// CTS enable
            CTSEN: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x14);

        /// address: 0x40013818
        /// Guard time and prescaler
        /// register
        pub const GP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value in Smartcard mode
            GUAT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);
    };
    pub const USART1 = struct {
        pub const base_address = 0x40004400;

        /// address: 0x40004400
        /// Status register
        pub const STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error flag
            PERR: u1,
            /// Frame error flag
            FERR: u1,
            /// Noise error flag
            NERR: u1,
            /// Overrun error
            ORERR: u1,
            /// IDLE frame detected flag
            IDLEF: u1,
            /// Read data buffer not empty
            RBNE: u1,
            /// Transmission complete
            TC: u1,
            /// Transmit data buffer empty
            TBE: u1,
            /// LIN break detection flag
            LBDF: u1,
            /// CTS change flag
            CTSF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40004404
        /// Data register
        pub const DATA = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x4);

        /// address: 0x40004408
        /// Baud rate register
        pub const BAUD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fraction part of baud-rate divider
            FRADIV: u4,
            /// Integer part of baud-rate divider
            INTDIV: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000440c
        /// Control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Send break command
            SBKCMD: u1,
            /// Receiver wakeup from mute mode
            RWU: u1,
            /// Receiver enable
            REN: u1,
            /// Transmitter enable
            TEN: u1,
            /// IDLE line detected interrupt enable
            IDLEIE: u1,
            /// Read data buffer not empty interrupt and overrun error interrupt enable
            RBNEIE: u1,
            /// Transmission complete interrupt enable
            TCIE: u1,
            /// Transmitter buffer empty interrupt enable
            TBEIE: u1,
            /// Parity error interrupt enable
            PERRIE: u1,
            /// Parity mode
            PM: u1,
            /// Parity check function enable
            PCEN: u1,
            /// Wakeup method in mute mode
            WM: u1,
            /// Word length
            WL: u1,
            /// USART enable
            UEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xc);

        /// address: 0x40004410
        /// Control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address of the USART
            ADDR: u4,
            reserved0: u1,
            /// LIN break frame length
            LBLEN: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved1: u1,
            /// CK Length
            CLEN: u1,
            /// Clock phase
            CPH: u1,
            /// Clock polarity
            CPL: u1,
            /// CK pin enable
            CKEN: u1,
            /// STOP bits length
            STB: u2,
            /// LIN mode enable
            LMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x10);

        /// address: 0x40004414
        /// Control register 2
        pub const CTL2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            ERRIE: u1,
            /// IrDA mode enable
            IREN: u1,
            /// IrDA low-power
            IRLP: u1,
            /// Half-duplex selection
            HDEN: u1,
            /// Smartcard NACK enable
            NKEN: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA request enable for reception
            DENR: u1,
            /// DMA request enable for transmission
            DENT: u1,
            /// RTS enable
            RTSEN: u1,
            /// CTS enable
            CTSEN: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x14);

        /// address: 0x40004418
        /// Guard time and prescaler
        /// register
        pub const GP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value in Smartcard mode
            GUAT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);
    };
    pub const USART2 = struct {
        pub const base_address = 0x40004800;

        /// address: 0x40004800
        /// Status register
        pub const STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error flag
            PERR: u1,
            /// Frame error flag
            FERR: u1,
            /// Noise error flag
            NERR: u1,
            /// Overrun error
            ORERR: u1,
            /// IDLE frame detected flag
            IDLEF: u1,
            /// Read data buffer not empty
            RBNE: u1,
            /// Transmission complete
            TC: u1,
            /// Transmit data buffer empty
            TBE: u1,
            /// LIN break detection flag
            LBDF: u1,
            /// CTS change flag
            CTSF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40004804
        /// Data register
        pub const DATA = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x4);

        /// address: 0x40004808
        /// Baud rate register
        pub const BAUD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fraction part of baud-rate divider
            FRADIV: u4,
            /// Integer part of baud-rate divider
            INTDIV: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000480c
        /// Control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Send break command
            SBKCMD: u1,
            /// Receiver wakeup from mute mode
            RWU: u1,
            /// Receiver enable
            REN: u1,
            /// Transmitter enable
            TEN: u1,
            /// IDLE line detected interrupt enable
            IDLEIE: u1,
            /// Read data buffer not empty interrupt and overrun error interrupt enable
            RBNEIE: u1,
            /// Transmission complete interrupt enable
            TCIE: u1,
            /// Transmitter buffer empty interrupt enable
            TBEIE: u1,
            /// Parity error interrupt enable
            PERRIE: u1,
            /// Parity mode
            PM: u1,
            /// Parity check function enable
            PCEN: u1,
            /// Wakeup method in mute mode
            WM: u1,
            /// Word length
            WL: u1,
            /// USART enable
            UEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xc);

        /// address: 0x40004810
        /// Control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address of the USART
            ADDR: u4,
            reserved0: u1,
            /// LIN break frame length
            LBLEN: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved1: u1,
            /// CK Length
            CLEN: u1,
            /// Clock phase
            CPH: u1,
            /// Clock polarity
            CPL: u1,
            /// CK pin enable
            CKEN: u1,
            /// STOP bits length
            STB: u2,
            /// LIN mode enable
            LMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x10);

        /// address: 0x40004814
        /// Control register 2
        pub const CTL2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            ERRIE: u1,
            /// IrDA mode enable
            IREN: u1,
            /// IrDA low-power
            IRLP: u1,
            /// Half-duplex selection
            HDEN: u1,
            /// Smartcard NACK enable
            NKEN: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA request enable for reception
            DENR: u1,
            /// DMA request enable for transmission
            DENT: u1,
            /// RTS enable
            RTSEN: u1,
            /// CTS enable
            CTSEN: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x14);

        /// address: 0x40004818
        /// Guard time and prescaler
        /// register
        pub const GP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value in Smartcard mode
            GUAT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);
    };

    /// Universal asynchronous receiver
    /// transmitter
    pub const UART3 = struct {
        pub const base_address = 0x40004c00;

        /// address: 0x40004c00
        /// Status register
        pub const STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error flag
            PERR: u1,
            /// Frame error flag
            FERR: u1,
            /// Noise error flag
            NERR: u1,
            /// Overrun error
            ORERR: u1,
            /// IDLE frame detected flag
            IDLEF: u1,
            /// Read data buffer not empty
            RBNE: u1,
            /// Transmission complete
            TC: u1,
            /// Transmit data buffer empty
            TBE: u1,
            /// LIN break detection flag
            LBDF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x0);

        /// address: 0x40004c04
        /// Data register
        pub const DATA = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x4);

        /// address: 0x40004c08
        /// Baud rate register
        pub const BAUD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fraction part of baud-rate divider
            FRADIV: u4,
            /// Integer part of baud-rate divider
            INTDIV: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x40004c0c
        /// Control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Send break command
            SBKCMD: u1,
            /// Receiver wakeup from mute mode
            RWU: u1,
            /// Receiver enable
            REN: u1,
            /// Transmitter enable
            TEN: u1,
            /// IDLE line detected interrupt enable
            IDLEIE: u1,
            /// Read data buffer not empty interrupt and overrun error interrupt enable
            RBNEIE: u1,
            /// Transmission complete interrupt enable
            TCIE: u1,
            /// Transmitter buffer empty interrupt enable
            TBEIE: u1,
            /// Parity error interrupt enable
            PERRIE: u1,
            /// Parity mode
            PM: u1,
            /// Parity check function enable
            PCEN: u1,
            /// Wakeup method in mute mode
            WM: u1,
            /// Word length
            WL: u1,
            /// USART enable
            UEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xc);

        /// address: 0x40004c10
        /// Control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address of the USART
            ADDR: u4,
            reserved0: u1,
            /// LIN break frame length
            LBLEN: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// STOP bits length
            STB: u2,
            /// LIN mode enable
            LMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x10);

        /// address: 0x40004c14
        /// Control register 2
        pub const CTL2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            ERRIE: u1,
            /// IrDA mode enable
            IREN: u1,
            /// IrDA low-power
            IRLP: u1,
            /// Half-duplex selection
            HDEN: u1,
            reserved0: u1,
            reserved1: u1,
            /// DMA request enable for reception
            DENR: u1,
            /// DMA request enable for transmission
            DENT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x40004c18
        /// Guard time and prescaler
        /// register
        pub const GP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);
    };
    pub const UART4 = struct {
        pub const base_address = 0x40005000;

        /// address: 0x40005000
        /// Status register
        pub const STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error flag
            PERR: u1,
            /// Frame error flag
            FERR: u1,
            /// Noise error flag
            NERR: u1,
            /// Overrun error
            ORERR: u1,
            /// IDLE frame detected flag
            IDLEF: u1,
            /// Read data buffer not empty
            RBNE: u1,
            /// Transmission complete
            TC: u1,
            /// Transmit data buffer empty
            TBE: u1,
            /// LIN break detection flag
            LBDF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x0);

        /// address: 0x40005004
        /// Data register
        pub const DATA = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x4);

        /// address: 0x40005008
        /// Baud rate register
        pub const BAUD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fraction part of baud-rate divider
            FRADIV: u4,
            /// Integer part of baud-rate divider
            INTDIV: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000500c
        /// Control register 0
        pub const CTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Send break command
            SBKCMD: u1,
            /// Receiver wakeup from mute mode
            RWU: u1,
            /// Receiver enable
            REN: u1,
            /// Transmitter enable
            TEN: u1,
            /// IDLE line detected interrupt enable
            IDLEIE: u1,
            /// Read data buffer not empty interrupt and overrun error interrupt enable
            RBNEIE: u1,
            /// Transmission complete interrupt enable
            TCIE: u1,
            /// Transmitter buffer empty interrupt enable
            TBEIE: u1,
            /// Parity error interrupt enable
            PERRIE: u1,
            /// Parity mode
            PM: u1,
            /// Parity check function enable
            PCEN: u1,
            /// Wakeup method in mute mode
            WM: u1,
            /// Word length
            WL: u1,
            /// USART enable
            UEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xc);

        /// address: 0x40005010
        /// Control register 1
        pub const CTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address of the USART
            ADDR: u4,
            reserved0: u1,
            /// LIN break frame length
            LBLEN: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// STOP bits length
            STB: u2,
            /// LIN mode enable
            LMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x10);

        /// address: 0x40005014
        /// Control register 2
        pub const CTL2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            ERRIE: u1,
            /// IrDA mode enable
            IREN: u1,
            /// IrDA low-power
            IRLP: u1,
            /// Half-duplex selection
            HDEN: u1,
            reserved0: u1,
            reserved1: u1,
            /// DMA request enable for reception
            DENR: u1,
            /// DMA request enable for transmission
            DENT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x40005018
        /// Guard time and prescaler
        /// register
        pub const GP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);
    };

    /// USB full speed global registers
    pub const USBFS_GLOBAL = struct {
        pub const base_address = 0x50000000;

        /// address: 0x50000000
        /// Global OTG control and status register
        /// (USBFS_GOTGCS)
        pub const GOTGCS = @intToPtr(*volatile Mmio(32, packed struct {
            /// SRP success
            SRPS: u1,
            /// SRP request
            SRPREQ: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Host success
            HNPS: u1,
            /// HNP request
            HNPREQ: u1,
            /// Host HNP enable
            HHNPEN: u1,
            /// Device HNP enabled
            DHNPEN: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// ID pin status
            IDPS: u1,
            /// Debounce interval
            DI: u1,
            /// A-session valid
            ASV: u1,
            /// B-session valid
            BSV: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x0);

        /// address: 0x50000004
        /// Global OTG interrupt flag register
        /// (USBFS_GOTGINTF)
        pub const GOTGINTF = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Session end
            SESEND: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Session request success status
            /// change
            SRPEND: u1,
            /// HNP end
            HNPEND: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Host negotiation request detected
            HNPDET: u1,
            /// A-device timeout
            ADTO: u1,
            /// Debounce finish
            DF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x4);

        /// address: 0x50000008
        /// Global AHB control and status register
        /// (USBFS_GAHBCS)
        pub const GAHBCS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Global interrupt enable
            GINTEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Tx FIFO threshold
            TXFTH: u1,
            /// Periodic Tx FIFO threshold
            PTXFTH: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x8);

        /// address: 0x5000000c
        /// Global USB control and status register
        /// (USBFS_GUSBCSR)
        pub const GUSBCS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timeout calibration
            TOC: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// SRP capability enable
            SRPCEN: u1,
            /// HNP capability enable
            HNPCEN: u1,
            /// USB turnaround time
            UTT: u4,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// Force host mode
            FHM: u1,
            /// Force device mode
            FDM: u1,
            padding0: u1,
        }), base_address + 0xc);

        /// address: 0x50000010
        /// Global reset control register (USBFS_GRSTCTL)
        pub const GRSTCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Core soft reset
            CSRST: u1,
            /// HCLK soft reset
            HCSRST: u1,
            /// Host frame counter reset
            HFCRST: u1,
            reserved0: u1,
            /// RxFIFO flush
            RXFF: u1,
            /// TxFIFO flush
            TXFF: u1,
            /// TxFIFO number
            TXFNUM: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x10);

        /// address: 0x50000014
        /// Global interrupt flag register (USBFS_GINTF)
        pub const GINTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current operation mode
            COPM: u1,
            /// Mode fault interrupt flag
            MFIF: u1,
            /// OTG interrupt flag
            OTGIF: u1,
            /// Start of frame
            SOF: u1,
            /// RxFIFO non-empty interrupt flag
            RXFNEIF: u1,
            /// Non-periodic TxFIFO empty interrupt flag
            NPTXFEIF: u1,
            /// Global Non-Periodic IN NAK effective
            GNPINAK: u1,
            /// Global OUT NAK effective
            GONAK: u1,
            reserved0: u1,
            reserved1: u1,
            /// Early suspend
            ESP: u1,
            /// USB suspend
            SP: u1,
            /// USB reset
            RST: u1,
            /// Enumeration finished
            ENUMF: u1,
            /// Isochronous OUT packet dropped
            /// interrupt
            ISOOPDIF: u1,
            /// End of periodic frame
            /// interrupt flag
            EOPFIF: u1,
            reserved2: u1,
            reserved3: u1,
            /// IN endpoint interrupt flag
            IEPIF: u1,
            /// OUT endpoint interrupt flag
            OEPIF: u1,
            /// Isochronous IN transfer Not Complete Interrupt Flag
            ISOINCIF: u1,
            /// periodic transfer not complete interrupt flag(Host
            /// mode)/isochronous OUT transfer not complete interrupt flag(Device
            /// mode)
            PXNCIF_ISOONCIF: u1,
            reserved4: u1,
            reserved5: u1,
            /// Host port interrupt flag
            HPIF: u1,
            /// Host channels interrupt flag
            HCIF: u1,
            /// Periodic TxFIFO empty interrupt flag
            PTXFEIF: u1,
            reserved6: u1,
            /// ID pin status change
            IDPSC: u1,
            /// Disconnect interrupt flag
            DISCIF: u1,
            /// Session interrupt flag
            SESIF: u1,
            /// Wakeup interrupt flag
            WKUPIF: u1,
        }), base_address + 0x14);

        /// address: 0x50000018
        /// Global interrupt enable register
        /// (USBFS_GINTEN)
        pub const GINTEN = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Mode fault interrupt
            /// enable
            MFIE: u1,
            /// OTG interrupt enable
            OTGIE: u1,
            /// Start of frame interrupt enable
            SOFIE: u1,
            /// Receive FIFO non-empty
            /// interrupt enable
            RXFNEIE: u1,
            /// Non-periodic TxFIFO empty
            /// interrupt enable
            NPTXFEIE: u1,
            /// Global non-periodic IN NAK effective interrupt enable
            GNPINAKIE: u1,
            /// Global OUT NAK effective
            /// interrupt enable
            GONAKIE: u1,
            reserved1: u1,
            reserved2: u1,
            /// Early suspend interrupt enable
            ESPIE: u1,
            /// USB suspend interrupt enable
            SPIE: u1,
            /// USB reset interrupt enable
            RSTIE: u1,
            /// Enumeration finish interrupt enable
            ENUMFIE: u1,
            /// Isochronous OUT packet dropped interrupt enable
            ISOOPDIE: u1,
            /// End of periodic frame interrupt enable
            EOPFIE: u1,
            reserved3: u1,
            reserved4: u1,
            /// IN endpoints interrupt enable
            IEPIE: u1,
            /// OUT endpoints interrupt enable
            OEPIE: u1,
            /// isochronous IN transfer not complete
            /// interrupt enable
            ISOINCIE: u1,
            /// periodic transfer not compelete Interrupt enable(Host
            /// mode)/isochronous OUT transfer not complete interrupt enable(Device
            /// mode)
            PXNCIE_ISOONCIE: u1,
            reserved5: u1,
            reserved6: u1,
            /// Host port interrupt enable
            HPIE: u1,
            /// Host channels interrupt enable
            HCIE: u1,
            /// Periodic TxFIFO empty interrupt enable
            PTXFEIE: u1,
            reserved7: u1,
            /// ID pin status change interrupt enable
            IDPSCIE: u1,
            /// Disconnect interrupt enable
            DISCIE: u1,
            /// Session interrupt enable
            SESIE: u1,
            /// Wakeup interrupt enable
            WKUPIE: u1,
        }), base_address + 0x18);

        /// address: 0x5000001c
        /// Global Receive status read(Device
        /// mode)
        pub const GRSTATR_Device = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint number
            EPNUM: u4,
            /// Byte count
            BCOUNT: u11,
            /// Data PID
            DPID: u2,
            /// Recieve packet status
            RPCKST: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x1c);

        /// address: 0x5000001c
        /// Global Receive status read(Host
        /// mode)
        pub const GRSTATR_Host = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel number
            CNUM: u4,
            /// Byte count
            BCOUNT: u11,
            /// Data PID
            DPID: u2,
            /// Reivece packet status
            RPCKST: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x1c);

        /// address: 0x50000020
        /// Global Receive status pop(Device
        /// mode)
        pub const GRSTATP_Device = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint number
            EPNUM: u4,
            /// Byte count
            BCOUNT: u11,
            /// Data PID
            DPID: u2,
            /// Recieve packet status
            RPCKST: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x50000020
        /// Global Receive status pop(Host
        /// mode)
        pub const GRSTATP_Host = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel number
            CNUM: u4,
            /// Byte count
            BCOUNT: u11,
            /// Data PID
            DPID: u2,
            /// Reivece packet status
            RPCKST: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x50000024
        /// Global Receive FIFO size register
        /// (USBFS_GRFLEN)
        pub const GRFLEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO depth
            RXFD: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x24);

        /// address: 0x50000028
        /// Host non-periodic transmit FIFO length register
        /// (Host mode)
        pub const HNPTFLEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// host non-periodic transmit Tx RAM start
            /// address
            HNPTXRSAR: u16,
            /// host non-periodic TxFIFO depth
            HNPTXFD: u16,
        }), base_address + 0x28);

        /// address: 0x50000028
        /// Device IN endpoint 0 transmit FIFO length
        /// (Device mode)
        pub const DIEP0TFLEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// in endpoint 0 Tx RAM start address
            IEP0TXRSAR: u16,
            /// in endpoint 0 Tx FIFO depth
            IEP0TXFD: u16,
        }), base_address + 0x28);

        /// address: 0x5000002c
        /// Host non-periodic transmit FIFO/queue
        /// status register (HNPTFQSTAT)
        pub const HNPTFQSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Non-periodic TxFIFO space
            NPTXFS: u16,
            /// Non-periodic transmit request queue
            /// space
            NPTXRQS: u8,
            /// Top of the non-periodic transmit request
            /// queue
            NPTXRQTOP: u7,
            padding0: u1,
        }), base_address + 0x2c);

        /// address: 0x50000038
        /// Global core configuration register (USBFS_GCCFG)
        pub const GCCFG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Power on
            PWRON: u1,
            reserved16: u1,
            /// The VBUS A-device Comparer enable
            VBUSACEN: u1,
            /// The VBUS B-device Comparer enable
            VBUSBCEN: u1,
            /// SOF output enable
            SOFOEN: u1,
            /// VBUS ignored
            VBUSIG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x38);

        /// address: 0x5000003c
        /// core ID register
        pub const CID = @intToPtr(*volatile u32, base_address + 0x3c);

        /// address: 0x50000100
        /// Host periodic transmit FIFO length register (HPTFLEN)
        pub const HPTFLEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Host periodic TxFIFO start
            /// address
            HPTXFSAR: u16,
            /// Host periodic TxFIFO depth
            HPTXFD: u16,
        }), base_address + 0x100);

        /// address: 0x50000104
        /// device IN endpoint transmit FIFO size
        /// register (DIEP1TFLEN)
        pub const DIEP1TFLEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint FIFO transmit RAM start
            /// address
            IEPTXRSAR: u16,
            /// IN endpoint TxFIFO depth
            IEPTXFD: u16,
        }), base_address + 0x104);

        /// address: 0x50000108
        /// device IN endpoint transmit FIFO size
        /// register (DIEP2TFLEN)
        pub const DIEP2TFLEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint FIFO transmit RAM start
            /// address
            IEPTXRSAR: u16,
            /// IN endpoint TxFIFO depth
            IEPTXFD: u16,
        }), base_address + 0x108);

        /// address: 0x5000010c
        /// device IN endpoint transmit FIFO size
        /// register (FS_DIEP3TXFLEN)
        pub const DIEP3TFLEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint FIFO4 transmit RAM start
            /// address
            IEPTXRSAR: u16,
            /// IN endpoint TxFIFO depth
            IEPTXFD: u16,
        }), base_address + 0x10c);
    };

    /// USB on the go full speed host
    pub const USBFS_HOST = struct {
        pub const base_address = 0x50000400;

        /// address: 0x50000400
        /// host configuration register
        /// (HCTL)
        pub const HCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// clock select for USB clock
            CLKSEL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x0);

        /// address: 0x50000404
        /// Host frame interval
        /// register
        pub const HFT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame interval
            FRI: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x50000408
        /// FS host frame number/frame time
        /// remaining register (HFINFR)
        pub const HFINFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame number
            FRNUM: u16,
            /// Frame remaining time
            FRT: u16,
        }), base_address + 0x8);

        /// address: 0x50000410
        /// Host periodic transmit FIFO/queue
        /// status register (HPTFQSTAT)
        pub const HPTFQSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Periodic transmit data FIFO space
            /// available
            PTXFS: u16,
            /// Periodic transmit request queue space
            /// available
            PTXREQS: u8,
            /// Top of the periodic transmit request
            /// queue
            PTXREQT: u8,
        }), base_address + 0x10);

        /// address: 0x50000414
        /// Host all channels interrupt
        /// register
        pub const HACHINT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x14);

        /// address: 0x50000418
        /// host all channels interrupt mask
        /// register
        pub const HACHINTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel interrupt enable
            CINTEN: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x50000440
        /// Host port control and status register (USBFS_HPCS)
        pub const HPCS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port connect status
            PCST: u1,
            /// Port connect detected
            PCD: u1,
            /// Port enable
            PE: u1,
            /// Port enable/disable change
            PEDC: u1,
            reserved0: u1,
            reserved1: u1,
            /// Port resume
            PREM: u1,
            /// Port suspend
            PSP: u1,
            /// Port reset
            PRST: u1,
            reserved2: u1,
            /// Port line status
            PLST: u2,
            /// Port power
            PP: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Port speed
            PS: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x40);

        /// address: 0x50000500
        /// host channel-0 characteristics
        /// register (HCH0CTL)
        pub const HCH0CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPL: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSD: u1,
            /// Endpoint type
            EPTYPE: u2,
            reserved1: u1,
            reserved2: u1,
            /// Device address
            DAR: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CDIS: u1,
            /// Channel enable
            CEN: u1,
        }), base_address + 0x100);

        /// address: 0x50000520
        /// host channel-1 characteristics
        /// register (HCH1CTL)
        pub const HCH1CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPL: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSD: u1,
            /// Endpoint type
            EPTYPE: u2,
            reserved1: u1,
            reserved2: u1,
            /// Device address
            DAR: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CDIS: u1,
            /// Channel enable
            CEN: u1,
        }), base_address + 0x120);

        /// address: 0x50000540
        /// host channel-2 characteristics
        /// register (HCH2CTL)
        pub const HCH2CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPL: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSD: u1,
            /// Endpoint type
            EPTYPE: u2,
            reserved1: u1,
            reserved2: u1,
            /// Device address
            DAR: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CDIS: u1,
            /// Channel enable
            CEN: u1,
        }), base_address + 0x140);

        /// address: 0x50000560
        /// host channel-3 characteristics
        /// register (HCH3CTL)
        pub const HCH3CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPL: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSD: u1,
            /// Endpoint type
            EPTYPE: u2,
            reserved1: u1,
            reserved2: u1,
            /// Device address
            DAR: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CDIS: u1,
            /// Channel enable
            CEN: u1,
        }), base_address + 0x160);

        /// address: 0x50000580
        /// host channel-4 characteristics
        /// register (HCH4CTL)
        pub const HCH4CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPL: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSD: u1,
            /// Endpoint type
            EPTYPE: u2,
            reserved1: u1,
            reserved2: u1,
            /// Device address
            DAR: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CDIS: u1,
            /// Channel enable
            CEN: u1,
        }), base_address + 0x180);

        /// address: 0x500005a0
        /// host channel-5 characteristics
        /// register (HCH5CTL)
        pub const HCH5CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPL: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSD: u1,
            /// Endpoint type
            EPTYPE: u2,
            reserved1: u1,
            reserved2: u1,
            /// Device address
            DAR: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CDIS: u1,
            /// Channel enable
            CEN: u1,
        }), base_address + 0x1a0);

        /// address: 0x500005c0
        /// host channel-6 characteristics
        /// register (HCH6CTL)
        pub const HCH6CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPL: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSD: u1,
            /// Endpoint type
            EPTYPE: u2,
            reserved1: u1,
            reserved2: u1,
            /// Device address
            DAR: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CDIS: u1,
            /// Channel enable
            CEN: u1,
        }), base_address + 0x1c0);

        /// address: 0x500005e0
        /// host channel-7 characteristics
        /// register (HCH7CTL)
        pub const HCH7CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet size
            MPL: u11,
            /// Endpoint number
            EPNUM: u4,
            /// Endpoint direction
            EPDIR: u1,
            reserved0: u1,
            /// Low-speed device
            LSD: u1,
            /// Endpoint type
            EPTYPE: u2,
            reserved1: u1,
            reserved2: u1,
            /// Device address
            DAR: u7,
            /// Odd frame
            ODDFRM: u1,
            /// Channel disable
            CDIS: u1,
            /// Channel enable
            CEN: u1,
        }), base_address + 0x1e0);

        /// address: 0x50000508
        /// host channel-0 interrupt register
        /// (USBFS_HCHxINTF)
        pub const HCH0INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer finished
            TF: u1,
            /// Channel halted
            CH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// USB bus error
            USBER: u1,
            /// Babble error
            BBER: u1,
            /// Request queue overrun
            REQOVR: u1,
            /// Data toggle error
            DTER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x108);

        /// address: 0x50000528
        /// host channel-1 interrupt register
        /// (HCH1INTF)
        pub const HCH1INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer finished
            TF: u1,
            /// Channel halted
            CH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// USB bus error
            USBER: u1,
            /// Babble error
            BBER: u1,
            /// Request queue overrun
            REQOVR: u1,
            /// Data toggle error
            DTER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x128);

        /// address: 0x50000548
        /// host channel-2 interrupt register
        /// (HCH2INTF)
        pub const HCH2INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer finished
            TF: u1,
            /// Channel halted
            CH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// USB bus error
            USBER: u1,
            /// Babble error
            BBER: u1,
            /// Request queue overrun
            REQOVR: u1,
            /// Data toggle error
            DTER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x148);

        /// address: 0x50000568
        /// host channel-3 interrupt register
        /// (HCH3INTF)
        pub const HCH3INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer finished
            TF: u1,
            /// Channel halted
            CH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// USB bus error
            USBER: u1,
            /// Babble error
            BBER: u1,
            /// Request queue overrun
            REQOVR: u1,
            /// Data toggle error
            DTER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x168);

        /// address: 0x50000588
        /// host channel-4 interrupt register
        /// (HCH4INTF)
        pub const HCH4INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer finished
            TF: u1,
            /// Channel halted
            CH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// USB bus error
            USBER: u1,
            /// Babble error
            BBER: u1,
            /// Request queue overrun
            REQOVR: u1,
            /// Data toggle error
            DTER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x188);

        /// address: 0x500005a8
        /// host channel-5 interrupt register
        /// (HCH5INTF)
        pub const HCH5INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer finished
            TF: u1,
            /// Channel halted
            CH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// USB bus error
            USBER: u1,
            /// Babble error
            BBER: u1,
            /// Request queue overrun
            REQOVR: u1,
            /// Data toggle error
            DTER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1a8);

        /// address: 0x500005c8
        /// host channel-6 interrupt register
        /// (HCH6INTF)
        pub const HCH6INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer finished
            TF: u1,
            /// Channel halted
            CH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// USB bus error
            USBER: u1,
            /// Babble error
            BBER: u1,
            /// Request queue overrun
            REQOVR: u1,
            /// Data toggle error
            DTER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1c8);

        /// address: 0x500005e8
        /// host channel-7 interrupt register
        /// (HCH7INTF)
        pub const HCH7INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer finished
            TF: u1,
            /// Channel halted
            CH: u1,
            reserved0: u1,
            /// STALL response received
            /// interrupt
            STALL: u1,
            /// NAK response received
            /// interrupt
            NAK: u1,
            /// ACK response received/transmitted
            /// interrupt
            ACK: u1,
            reserved1: u1,
            /// USB bus error
            USBER: u1,
            /// Babble error
            BBER: u1,
            /// Request queue overrun
            REQOVR: u1,
            /// Data toggle error
            DTER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1e8);

        /// address: 0x5000050c
        /// host channel-0 interrupt enable register
        /// (HCH0INTEN)
        pub const HCH0INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed interrupt enable
            TFIE: u1,
            /// Channel halted interrupt enable
            CHIE: u1,
            reserved0: u1,
            /// STALL interrupt enable
            STALLIE: u1,
            /// NAK interrupt enable
            NAKIE: u1,
            /// ACK interrupt enable
            ACKIE: u1,
            reserved1: u1,
            /// USB bus error interrupt enable
            USBERIE: u1,
            /// Babble error interrupt enable
            BBERIE: u1,
            /// request queue overrun interrupt enable
            REQOVRIE: u1,
            /// Data toggle error interrupt enable
            DTERIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x10c);

        /// address: 0x5000052c
        /// host channel-1 interrupt enable register
        /// (HCH1INTEN)
        pub const HCH1INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed interrupt enable
            TFIE: u1,
            /// Channel halted interrupt enable
            CHIE: u1,
            reserved0: u1,
            /// STALL interrupt enable
            STALLIE: u1,
            /// NAK interrupt enable
            NAKIE: u1,
            /// ACK interrupt enable
            ACKIE: u1,
            reserved1: u1,
            /// USB bus error interrupt enable
            USBERIE: u1,
            /// Babble error interrupt enable
            BBERIE: u1,
            /// request queue overrun interrupt enable
            REQOVRIE: u1,
            /// Data toggle error interrupt enable
            DTERIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x12c);

        /// address: 0x5000054c
        /// host channel-2 interrupt enable register
        /// (HCH2INTEN)
        pub const HCH2INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed interrupt enable
            TFIE: u1,
            /// Channel halted interrupt enable
            CHIE: u1,
            reserved0: u1,
            /// STALL interrupt enable
            STALLIE: u1,
            /// NAK interrupt enable
            NAKIE: u1,
            /// ACK interrupt enable
            ACKIE: u1,
            reserved1: u1,
            /// USB bus error interrupt enable
            USBERIE: u1,
            /// Babble error interrupt enable
            BBERIE: u1,
            /// request queue overrun interrupt enable
            REQOVRIE: u1,
            /// Data toggle error interrupt enable
            DTERIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x14c);

        /// address: 0x5000056c
        /// host channel-3 interrupt enable register
        /// (HCH3INTEN)
        pub const HCH3INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed interrupt enable
            TFIE: u1,
            /// Channel halted interrupt enable
            CHIE: u1,
            reserved0: u1,
            /// STALL interrupt enable
            STALLIE: u1,
            /// NAK interrupt enable
            NAKIE: u1,
            /// ACK interrupt enable
            ACKIE: u1,
            reserved1: u1,
            /// USB bus error interrupt enable
            USBERIE: u1,
            /// Babble error interrupt enable
            BBERIE: u1,
            /// request queue overrun interrupt enable
            REQOVRIE: u1,
            /// Data toggle error interrupt enable
            DTERIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x16c);

        /// address: 0x5000058c
        /// host channel-4 interrupt enable register
        /// (HCH4INTEN)
        pub const HCH4INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed interrupt enable
            TFIE: u1,
            /// Channel halted interrupt enable
            CHIE: u1,
            reserved0: u1,
            /// STALL interrupt enable
            STALLIE: u1,
            /// NAK interrupt enable
            NAKIE: u1,
            /// ACK interrupt enable
            ACKIE: u1,
            reserved1: u1,
            /// USB bus error interrupt enable
            USBERIE: u1,
            /// Babble error interrupt enable
            BBERIE: u1,
            /// request queue overrun interrupt enable
            REQOVRIE: u1,
            /// Data toggle error interrupt enable
            DTERIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x18c);

        /// address: 0x500005ac
        /// host channel-5 interrupt enable register
        /// (HCH5INTEN)
        pub const HCH5INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed interrupt enable
            TFIE: u1,
            /// Channel halted interrupt enable
            CHIE: u1,
            reserved0: u1,
            /// STALL interrupt enable
            STALLIE: u1,
            /// NAK interrupt enable
            NAKIE: u1,
            /// ACK interrupt enable
            ACKIE: u1,
            reserved1: u1,
            /// USB bus error interrupt enable
            USBERIE: u1,
            /// Babble error interrupt enable
            BBERIE: u1,
            /// request queue overrun interrupt enable
            REQOVRIE: u1,
            /// Data toggle error interrupt enable
            DTERIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1ac);

        /// address: 0x500005cc
        /// host channel-6 interrupt enable register
        /// (HCH6INTEN)
        pub const HCH6INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed interrupt enable
            TFIE: u1,
            /// Channel halted interrupt enable
            CHIE: u1,
            reserved0: u1,
            /// STALL interrupt enable
            STALLIE: u1,
            /// NAK interrupt enable
            NAKIE: u1,
            /// ACK interrupt enable
            ACKIE: u1,
            reserved1: u1,
            /// USB bus error interrupt enable
            USBERIE: u1,
            /// Babble error interrupt enable
            BBERIE: u1,
            /// request queue overrun interrupt enable
            REQOVRIE: u1,
            /// Data toggle error interrupt enable
            DTERIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1cc);

        /// address: 0x500005ec
        /// host channel-7 interrupt enable register
        /// (HCH7INTEN)
        pub const HCH7INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer completed interrupt enable
            TFIE: u1,
            /// Channel halted interrupt enable
            CHIE: u1,
            reserved0: u1,
            /// STALL interrupt enable
            STALLIE: u1,
            /// NAK interrupt enable
            NAKIE: u1,
            /// ACK interrupt enable
            ACKIE: u1,
            reserved1: u1,
            /// USB bus error interrupt enable
            USBERIE: u1,
            /// Babble error interrupt enable
            BBERIE: u1,
            /// request queue overrun interrupt enable
            REQOVRIE: u1,
            /// Data toggle error interrupt enable
            DTERIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1ec);

        /// address: 0x50000510
        /// host channel-0 transfer length
        /// register
        pub const HCH0LEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer length
            TLEN: u19,
            /// Packet count
            PCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x110);

        /// address: 0x50000530
        /// host channel-1 transfer length
        /// register
        pub const HCH1LEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer length
            TLEN: u19,
            /// Packet count
            PCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x130);

        /// address: 0x50000550
        /// host channel-2 transfer length
        /// register
        pub const HCH2LEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer length
            TLEN: u19,
            /// Packet count
            PCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x150);

        /// address: 0x50000570
        /// host channel-3 transfer length
        /// register
        pub const HCH3LEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer length
            TLEN: u19,
            /// Packet count
            PCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x170);

        /// address: 0x50000590
        /// host channel-4 transfer length
        /// register
        pub const HCH4LEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer length
            TLEN: u19,
            /// Packet count
            PCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x190);

        /// address: 0x500005b0
        /// host channel-5 transfer length
        /// register
        pub const HCH5LEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer length
            TLEN: u19,
            /// Packet count
            PCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x1b0);

        /// address: 0x500005d0
        /// host channel-6 transfer length
        /// register
        pub const HCH6LEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer length
            TLEN: u19,
            /// Packet count
            PCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x1d0);

        /// address: 0x500005f0
        /// host channel-7 transfer length
        /// register
        pub const HCH7LEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer length
            TLEN: u19,
            /// Packet count
            PCNT: u10,
            /// Data PID
            DPID: u2,
            padding0: u1,
        }), base_address + 0x1f0);
    };

    /// USB on the go full speed device
    pub const USBFS_DEVICE = struct {
        pub const base_address = 0x50000800;

        /// address: 0x50000800
        /// device configuration register
        /// (DCFG)
        pub const DCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device speed
            DS: u2,
            /// Non-zero-length status OUT
            /// handshake
            NZLSOH: u1,
            reserved0: u1,
            /// Device address
            DAR: u7,
            /// end of periodic frame time
            EOPFT: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x0);

        /// address: 0x50000804
        /// device control register
        /// (DCTL)
        pub const DCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Remote wakeup
            RWKUP: u1,
            /// Soft disconnect
            SD: u1,
            /// Global IN NAK status
            GINS: u1,
            /// Global OUT NAK status
            GONS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Set global IN NAK
            SGINAK: u1,
            /// Clear global IN NAK
            CGINAK: u1,
            /// Set global OUT NAK
            SGONAK: u1,
            /// Clear global OUT NAK
            CGONAK: u1,
            /// Power-on initialization flag
            POIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x4);

        /// address: 0x50000808
        /// device status register
        /// (DSTAT)
        pub const DSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Suspend status
            SPST: u1,
            /// Enumerated speed
            ES: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Frame number of the received
            /// SOF
            FNRSOF: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x8);

        /// address: 0x50000810
        /// device IN endpoint common interrupt
        /// mask register (DIEPINTEN)
        pub const DIEPINTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer finished interrupt
            /// enable
            TFEN: u1,
            /// Endpoint disabled interrupt
            /// enable
            EPDISEN: u1,
            reserved0: u1,
            /// Control IN timeout condition interrupt enable (Non-isochronous
            /// endpoints)
            CITOEN: u1,
            /// Endpoint Tx FIFO underrun interrupt enable bit
            EPTXFUDEN: u1,
            reserved1: u1,
            /// IN endpoint NAK effective
            /// interrupt enable
            IEPNEEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x10);

        /// address: 0x50000814
        /// device OUT endpoint common interrupt
        /// enable register (DOEPINTEN)
        pub const DOEPINTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer finished interrupt
            /// enable
            TFEN: u1,
            /// Endpoint disabled interrupt
            /// enable
            EPDISEN: u1,
            reserved0: u1,
            /// SETUP phase finished interrupt enable
            STPFEN: u1,
            /// Endpoint Rx FIFO overrun interrupt enable
            EPRXFOVREN: u1,
            reserved1: u1,
            /// Back-to-back SETUP packets
            /// interrupt enable
            BTBSTPEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x50000818
        /// device all endpoints interrupt
        /// register (DAEPINT)
        pub const DAEPINT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device all IN endpoint interrupt bits
            IEPITB: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Device all OUT endpoint interrupt bits
            OEPITB: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x18);

        /// address: 0x5000081c
        /// Device all endpoints interrupt enable register
        /// (DAEPINTEN)
        pub const DAEPINTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN EP interrupt interrupt enable bits
            IEPIE: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// OUT endpoint interrupt enable bits
            OEPIE: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x1c);

        /// address: 0x50000828
        /// device VBUS discharge time
        /// register
        pub const DVBUSDT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x5000082c
        /// device VBUS pulsing time
        /// register
        pub const DVBUSPT = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x2c);

        /// address: 0x50000834
        /// device IN endpoint FIFO empty
        /// interrupt enable register
        pub const DIEPFEINTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN EP Tx FIFO empty interrupt enable
            /// bits
            IEPTXFEIE: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x34);

        /// address: 0x50000900
        /// device IN endpoint 0 control
        /// register (DIEP0CTL)
        pub const DIEP0CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet length
            MPL: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// endpoint active
            EPACT: u1,
            reserved13: u1,
            /// NAK status
            NAKS: u1,
            /// Endpoint type
            EPTYPE: u2,
            reserved14: u1,
            /// STALL handshake
            STALL: u1,
            /// TxFIFO number
            TXFNUM: u4,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            reserved15: u1,
            reserved16: u1,
            /// Endpoint disable
            EPD: u1,
            /// Endpoint enable
            EPEN: u1,
        }), base_address + 0x100);

        /// address: 0x50000920
        /// device in endpoint-1 control
        /// register
        pub const DIEP1CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// maximum packet length
            MPL: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Endpoint active
            EPACT: u1,
            /// EOFRM/DPID
            EOFRM_DPID: u1,
            /// NAK status
            NAKS: u1,
            /// Endpoint type
            EPTYPE: u2,
            reserved4: u1,
            /// STALL handshake
            STALL: u1,
            /// Tx FIFO number
            TXFNUM: u4,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// SD0PID/SEVNFRM
            SD0PID_SEVENFRM: u1,
            /// Set DATA1 PID/Set odd frame
            SD1PID_SODDFRM: u1,
            /// Endpoint disable
            EPD: u1,
            /// Endpoint enable
            EPEN: u1,
        }), base_address + 0x120);

        /// address: 0x50000940
        /// device endpoint-2 control
        /// register
        pub const DIEP2CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// maximum packet length
            MPL: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Endpoint active
            EPACT: u1,
            /// EOFRM/DPID
            EOFRM_DPID: u1,
            /// NAK status
            NAKS: u1,
            /// Endpoint type
            EPTYPE: u2,
            reserved4: u1,
            /// STALL handshake
            STALL: u1,
            /// Tx FIFO number
            TXFNUM: u4,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// SD0PID/SEVNFRM
            SD0PID_SEVENFRM: u1,
            /// Set DATA1 PID/Set odd frame
            SD1PID_SODDFRM: u1,
            /// Endpoint disable
            EPD: u1,
            /// Endpoint enable
            EPEN: u1,
        }), base_address + 0x140);

        /// address: 0x50000960
        /// device endpoint-3 control
        /// register
        pub const DIEP3CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// maximum packet length
            MPL: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Endpoint active
            EPACT: u1,
            /// EOFRM/DPID
            EOFRM_DPID: u1,
            /// NAK status
            NAKS: u1,
            /// Endpoint type
            EPTYPE: u2,
            reserved4: u1,
            /// STALL handshake
            STALL: u1,
            /// Tx FIFO number
            TXFNUM: u4,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// SD0PID/SEVNFRM
            SD0PID_SEVENFRM: u1,
            /// Set DATA1 PID/Set odd frame
            SD1PID_SODDFRM: u1,
            /// Endpoint disable
            EPD: u1,
            /// Endpoint enable
            EPEN: u1,
        }), base_address + 0x160);

        /// address: 0x50000b00
        /// device endpoint-0 control
        /// register
        pub const DOEP0CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum packet length
            MPL: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Endpoint active
            EPACT: u1,
            reserved13: u1,
            /// NAK status
            NAKS: u1,
            /// Endpoint type
            EPTYPE: u2,
            /// Snoop mode
            SNOOP: u1,
            /// STALL handshake
            STALL: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            reserved18: u1,
            reserved19: u1,
            /// Endpoint disable
            EPD: u1,
            /// Endpoint enable
            EPEN: u1,
        }), base_address + 0x300);

        /// address: 0x50000b20
        /// device endpoint-1 control
        /// register
        pub const DOEP1CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// maximum packet length
            MPL: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Endpoint active
            EPACT: u1,
            /// EOFRM/DPID
            EOFRM_DPID: u1,
            /// NAK status
            NAKS: u1,
            /// Endpoint type
            EPTYPE: u2,
            /// Snoop mode
            SNOOP: u1,
            /// STALL handshake
            STALL: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// SD0PID/SEVENFRM
            SD0PID_SEVENFRM: u1,
            /// SD1PID/SODDFRM
            SD1PID_SODDFRM: u1,
            /// Endpoint disable
            EPD: u1,
            /// Endpoint enable
            EPEN: u1,
        }), base_address + 0x320);

        /// address: 0x50000b40
        /// device endpoint-2 control
        /// register
        pub const DOEP2CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// maximum packet length
            MPL: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Endpoint active
            EPACT: u1,
            /// EOFRM/DPID
            EOFRM_DPID: u1,
            /// NAK status
            NAKS: u1,
            /// Endpoint type
            EPTYPE: u2,
            /// Snoop mode
            SNOOP: u1,
            /// STALL handshake
            STALL: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// SD0PID/SEVENFRM
            SD0PID_SEVENFRM: u1,
            /// SD1PID/SODDFRM
            SD1PID_SODDFRM: u1,
            /// Endpoint disable
            EPD: u1,
            /// Endpoint enable
            EPEN: u1,
        }), base_address + 0x340);

        /// address: 0x50000b60
        /// device endpoint-3 control
        /// register
        pub const DOEP3CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// maximum packet length
            MPL: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Endpoint active
            EPACT: u1,
            /// EOFRM/DPID
            EOFRM_DPID: u1,
            /// NAK status
            NAKS: u1,
            /// Endpoint type
            EPTYPE: u2,
            /// Snoop mode
            SNOOP: u1,
            /// STALL handshake
            STALL: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Clear NAK
            CNAK: u1,
            /// Set NAK
            SNAK: u1,
            /// SD0PID/SEVENFRM
            SD0PID_SEVENFRM: u1,
            /// SD1PID/SODDFRM
            SD1PID_SODDFRM: u1,
            /// Endpoint disable
            EPD: u1,
            /// Endpoint enable
            EPEN: u1,
        }), base_address + 0x360);

        /// address: 0x50000908
        /// device endpoint-0 interrupt
        /// register
        pub const DIEP0INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer finished
            TF: u1,
            /// Endpoint finished
            EPDIS: u1,
            reserved0: u1,
            /// Control in timeout interrupt
            CITO: u1,
            /// Endpoint Tx FIFO underrun
            EPTXFUD: u1,
            reserved1: u1,
            /// IN endpoint NAK effective
            IEPNE: u1,
            /// Transmit FIFO empty
            TXFE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x108);

        /// address: 0x50000928
        /// device endpoint-1 interrupt
        /// register
        pub const DIEP1INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer finished
            TF: u1,
            /// Endpoint finished
            EPDIS: u1,
            reserved0: u1,
            /// Control in timeout interrupt
            CITO: u1,
            /// Endpoint Tx FIFO underrun
            EPTXFUD: u1,
            reserved1: u1,
            /// IN endpoint NAK effective
            IEPNE: u1,
            /// Transmit FIFO empty
            TXFE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x128);

        /// address: 0x50000948
        /// device endpoint-2 interrupt
        /// register
        pub const DIEP2INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer finished
            TF: u1,
            /// Endpoint finished
            EPDIS: u1,
            reserved0: u1,
            /// Control in timeout interrupt
            CITO: u1,
            /// Endpoint Tx FIFO underrun
            EPTXFUD: u1,
            reserved1: u1,
            /// IN endpoint NAK effective
            IEPNE: u1,
            /// Transmit FIFO empty
            TXFE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x148);

        /// address: 0x50000968
        /// device endpoint-3 interrupt
        /// register
        pub const DIEP3INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer finished
            TF: u1,
            /// Endpoint finished
            EPDIS: u1,
            reserved0: u1,
            /// Control in timeout interrupt
            CITO: u1,
            /// Endpoint Tx FIFO underrun
            EPTXFUD: u1,
            reserved1: u1,
            /// IN endpoint NAK effective
            IEPNE: u1,
            /// Transmit FIFO empty
            TXFE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x168);

        /// address: 0x50000b08
        /// device out endpoint-0 interrupt flag
        /// register
        pub const DOEP0INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer finished
            TF: u1,
            /// Endpoint disabled
            EPDIS: u1,
            reserved0: u1,
            /// Setup phase finished
            STPF: u1,
            /// Endpoint Rx FIFO overrun
            EPRXFOVR: u1,
            reserved1: u1,
            /// Back-to-back SETUP packets
            BTBSTP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x308);

        /// address: 0x50000b28
        /// device out endpoint-1 interrupt flag
        /// register
        pub const DOEP1INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer finished
            TF: u1,
            /// Endpoint disabled
            EPDIS: u1,
            reserved0: u1,
            /// Setup phase finished
            STPF: u1,
            /// Endpoint Rx FIFO overrun
            EPRXFOVR: u1,
            reserved1: u1,
            /// Back-to-back SETUP packets
            BTBSTP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x328);

        /// address: 0x50000b48
        /// device out endpoint-2 interrupt flag
        /// register
        pub const DOEP2INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer finished
            TF: u1,
            /// Endpoint disabled
            EPDIS: u1,
            reserved0: u1,
            /// Setup phase finished
            STPF: u1,
            /// Endpoint Rx FIFO overrun
            EPRXFOVR: u1,
            reserved1: u1,
            /// Back-to-back SETUP packets
            BTBSTP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x348);

        /// address: 0x50000b68
        /// device out endpoint-3 interrupt flag
        /// register
        pub const DOEP3INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer finished
            TF: u1,
            /// Endpoint disabled
            EPDIS: u1,
            reserved0: u1,
            /// Setup phase finished
            STPF: u1,
            /// Endpoint Rx FIFO overrun
            EPRXFOVR: u1,
            reserved1: u1,
            /// Back-to-back SETUP packets
            BTBSTP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x368);

        /// address: 0x50000910
        /// device IN endpoint-0 transfer length
        /// register
        pub const DIEP0LEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer length
            TLEN: u7,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Packet count
            PCNT: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x110);

        /// address: 0x50000b10
        /// device OUT endpoint-0 transfer length
        /// register
        pub const DOEP0LEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer length
            TLEN: u7,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Packet count
            PCNT: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// SETUP packet count
            STPCNT: u2,
            padding0: u1,
        }), base_address + 0x310);

        /// address: 0x50000930
        /// device IN endpoint-1 transfer length
        /// register
        pub const DIEP1LEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer length
            TLEN: u19,
            /// Packet count
            PCNT: u10,
            /// Multi packet count per frame
            MCPF: u2,
            padding0: u1,
        }), base_address + 0x130);

        /// address: 0x50000950
        /// device IN endpoint-2 transfer length
        /// register
        pub const DIEP2LEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer length
            TLEN: u19,
            /// Packet count
            PCNT: u10,
            /// Multi packet count per frame
            MCPF: u2,
            padding0: u1,
        }), base_address + 0x150);

        /// address: 0x50000970
        /// device IN endpoint-3 transfer length
        /// register
        pub const DIEP3LEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer length
            TLEN: u19,
            /// Packet count
            PCNT: u10,
            /// Multi packet count per frame
            MCPF: u2,
            padding0: u1,
        }), base_address + 0x170);

        /// address: 0x50000b30
        /// device OUT endpoint-1 transfer length
        /// register
        pub const DOEP1LEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer length
            TLEN: u19,
            /// Packet count
            PCNT: u10,
            /// SETUP packet count/Received data PID
            STPCNT_RXDPID: u2,
            padding0: u1,
        }), base_address + 0x330);

        /// address: 0x50000b50
        /// device OUT endpoint-2 transfer length
        /// register
        pub const DOEP2LEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer length
            TLEN: u19,
            /// Packet count
            PCNT: u10,
            /// SETUP packet count/Received data PID
            STPCNT_RXDPID: u2,
            padding0: u1,
        }), base_address + 0x350);

        /// address: 0x50000b70
        /// device OUT endpoint-3 transfer length
        /// register
        pub const DOEP3LEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer length
            TLEN: u19,
            /// Packet count
            PCNT: u10,
            /// SETUP packet count/Received data PID
            STPCNT_RXDPID: u2,
            padding0: u1,
        }), base_address + 0x370);

        /// address: 0x50000918
        /// device IN endpoint 0 transmit FIFO
        /// status register
        pub const DIEP0TFSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint TxFIFO space
            /// remaining
            IEPTFS: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x118);

        /// address: 0x50000938
        /// device IN endpoint 1 transmit FIFO
        /// status register
        pub const DIEP1TFSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint TxFIFO space
            /// remaining
            IEPTFS: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x138);

        /// address: 0x50000958
        /// device IN endpoint 2 transmit FIFO
        /// status register
        pub const DIEP2TFSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint TxFIFO space
            /// remaining
            IEPTFS: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x158);

        /// address: 0x50000978
        /// device IN endpoint 3 transmit FIFO
        /// status register
        pub const DIEP3TFSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// IN endpoint TxFIFO space
            /// remaining
            IEPTFS: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x178);
    };

    /// USB on the go full speed
    pub const USBFS_PWRCLK = struct {
        pub const base_address = 0x50000e00;

        /// address: 0x50000e00
        /// power and clock gating control
        /// register (PWRCLKCTL)
        pub const PWRCLKCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stop the USB clock
            SUCLK: u1,
            /// Stop HCLK
            SHCLK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x0);
    };

    /// Window watchdog timer
    pub const WWDGT = struct {
        pub const base_address = 0x40002c00;

        /// address: 0x40002c00
        /// Control register
        pub const CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7-bit counter
            CNT: u7,
            /// Activation bit
            WDGTEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40002c04
        /// Configuration register
        pub const CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7-bit window value
            WIN: u7,
            /// Prescaler
            PSC: u2,
            /// Early wakeup interrupt
            EWIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x4);

        /// address: 0x40002c08
        /// Status register
        pub const STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Early wakeup interrupt
            /// flag
            EWIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x8);
    };

    /// Core timer
    pub const CTIMER = struct {
        pub const base_address = 0xd1000000;

        /// address: 0xd1000000
        /// Timer value (lower half)
        pub const mtime_lo = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0xd1000004
        /// Timer value (upper half)
        pub const mtime_hi = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0xd1000008
        /// Timer comparison value (lower half)
        pub const mtimecmp_lo = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0xd100000c
        /// Timer comparison value (upper half)
        pub const mtimecmp_hi = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0xd1000ff8
        /// Timer control register
        pub const mstop = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pause (1) or run (0) the timer
            TIMESTOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xff8);

        /// address: 0xd1000ffc
        /// Software interrupt register
        pub const msip = @intToPtr(*volatile Mmio(32, packed struct {
            /// Generate software interrupts
            MSIP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xffc);
    };
};

const std = @import("std");

pub fn mmio(addr: usize, comptime size: u8, comptime PackedT: type) *volatile Mmio(size, PackedT) {
    return @intToPtr(*volatile Mmio(size, PackedT), addr);
}

pub fn Mmio(comptime size: u8, comptime PackedT: type) type {
    if ((size % 8) != 0)
        @compileError("size must be divisible by 8!");

    if (!std.math.isPowerOfTwo(size / 8))
        @compileError("size must encode a power of two number of bytes!");

    const IntT = std.meta.Int(.unsigned, size);

    if (@sizeOf(PackedT) != (size / 8))
        @compileError(std.fmt.comptimePrint("IntT and PackedT must have the same size!, they are {} and {} bytes respectively", .{ size / 8, @sizeOf(PackedT) }));

    return extern struct {
        const Self = @This();

        raw: IntT,

        pub const underlying_type = PackedT;

        pub inline fn read(addr: *volatile Self) PackedT {
            return @bitCast(PackedT, addr.raw);
        }

        pub inline fn write(addr: *volatile Self, val: PackedT) void {
            // This is a workaround for a compiler bug related to miscompilation
            // If the tmp var is not used, result location will fuck things up
            var tmp = @bitCast(IntT, val);
            addr.raw = tmp;
        }

        pub inline fn modify(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, field.name) = @field(fields, field.name);
            }
            write(addr, val);
        }

        pub inline fn toggle(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, @tagName(field.default_value.?)) = !@field(val, @tagName(field.default_value.?));
            }
            write(addr, val);
        }
    };
}

pub fn MmioInt(comptime size: u8, comptime T: type) type {
    return extern struct {
        const Self = @This();

        raw: std.meta.Int(.unsigned, size),

        pub inline fn read(addr: *volatile Self) T {
            return @truncate(T, addr.raw);
        }

        pub inline fn modify(addr: *volatile Self, val: T) void {
            const Int = std.meta.Int(.unsigned, size);
            const mask = ~@as(Int, (1 << @bitSizeOf(T)) - 1);

            var tmp = addr.raw;
            addr.raw = (tmp & mask) | val;
        }
    };
}

pub fn mmioInt(addr: usize, comptime size: usize, comptime T: type) *volatile MmioInt(size, T) {
    return @intToPtr(*volatile MmioInt(size, T), addr);
}

pub const InterruptVector = extern union {
    C: fn () callconv(.C) void,
    Naked: fn () callconv(.Naked) void,
    // Interrupt is not supported on arm
};

const unhandled = InterruptVector{
    .C = struct {
        fn tmp() callconv(.C) noreturn {
            @panic("unhandled interrupt");
        }
    }.tmp,
};
