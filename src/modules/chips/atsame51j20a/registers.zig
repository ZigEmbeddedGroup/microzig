// this file was generated by regz: https://github.com/ZigEmbeddedGroup/regz
// commit: 4b04e50cf14a3df87662dc79863e9b7e3dfc6591
//
// vendor: Microchip Technology
// device: ATSAME51J20A
// cpu: CM4

pub const VectorTable = extern struct {
    initial_stack_pointer: u32,
    Reset: InterruptVector = unhandled,
    NMI: InterruptVector = unhandled,
    HardFault: InterruptVector = unhandled,
    MemManage: InterruptVector = unhandled,
    BusFault: InterruptVector = unhandled,
    UsageFault: InterruptVector = unhandled,
    reserved0: [4]u32 = undefined,
    SVCall: InterruptVector = unhandled,
    reserved1: [2]u32 = undefined,
    PendSV: InterruptVector = unhandled,
    SysTick: InterruptVector = unhandled,
    PM: InterruptVector = unhandled,
    MCLK: InterruptVector = unhandled,
    OSCCTRL_XOSC0: InterruptVector = unhandled,
    OSCCTRL_XOSC1: InterruptVector = unhandled,
    OSCCTRL_DFLL: InterruptVector = unhandled,
    OSCCTRL_DPLL0: InterruptVector = unhandled,
    OSCCTRL_DPLL1: InterruptVector = unhandled,
    OSC32KCTRL: InterruptVector = unhandled,
    SUPC_OTHER: InterruptVector = unhandled,
    SUPC_BODDET: InterruptVector = unhandled,
    WDT: InterruptVector = unhandled,
    RTC: InterruptVector = unhandled,
    EIC_EXTINT_0: InterruptVector = unhandled,
    EIC_EXTINT_1: InterruptVector = unhandled,
    EIC_EXTINT_2: InterruptVector = unhandled,
    EIC_EXTINT_3: InterruptVector = unhandled,
    EIC_EXTINT_4: InterruptVector = unhandled,
    EIC_EXTINT_5: InterruptVector = unhandled,
    EIC_EXTINT_6: InterruptVector = unhandled,
    EIC_EXTINT_7: InterruptVector = unhandled,
    EIC_EXTINT_8: InterruptVector = unhandled,
    EIC_EXTINT_9: InterruptVector = unhandled,
    EIC_EXTINT_10: InterruptVector = unhandled,
    EIC_EXTINT_11: InterruptVector = unhandled,
    EIC_EXTINT_12: InterruptVector = unhandled,
    EIC_EXTINT_13: InterruptVector = unhandled,
    EIC_EXTINT_14: InterruptVector = unhandled,
    EIC_EXTINT_15: InterruptVector = unhandled,
    FREQM: InterruptVector = unhandled,
    NVMCTRL_0: InterruptVector = unhandled,
    NVMCTRL_1: InterruptVector = unhandled,
    DMAC_0: InterruptVector = unhandled,
    DMAC_1: InterruptVector = unhandled,
    DMAC_2: InterruptVector = unhandled,
    DMAC_3: InterruptVector = unhandled,
    DMAC_OTHER: InterruptVector = unhandled,
    EVSYS_0: InterruptVector = unhandled,
    EVSYS_1: InterruptVector = unhandled,
    EVSYS_2: InterruptVector = unhandled,
    EVSYS_3: InterruptVector = unhandled,
    EVSYS_OTHER: InterruptVector = unhandled,
    PAC: InterruptVector = unhandled,
    reserved2: u32 = undefined,
    reserved3: u32 = undefined,
    reserved4: u32 = undefined,
    RAMECC: InterruptVector = unhandled,
    SERCOM0_0: InterruptVector = unhandled,
    SERCOM0_1: InterruptVector = unhandled,
    SERCOM0_2: InterruptVector = unhandled,
    SERCOM0_OTHER: InterruptVector = unhandled,
    SERCOM1_0: InterruptVector = unhandled,
    SERCOM1_1: InterruptVector = unhandled,
    SERCOM1_2: InterruptVector = unhandled,
    SERCOM1_OTHER: InterruptVector = unhandled,
    SERCOM2_0: InterruptVector = unhandled,
    SERCOM2_1: InterruptVector = unhandled,
    SERCOM2_2: InterruptVector = unhandled,
    SERCOM2_OTHER: InterruptVector = unhandled,
    SERCOM3_0: InterruptVector = unhandled,
    SERCOM3_1: InterruptVector = unhandled,
    SERCOM3_2: InterruptVector = unhandled,
    SERCOM3_OTHER: InterruptVector = unhandled,
    SERCOM4_0: InterruptVector = unhandled,
    SERCOM4_1: InterruptVector = unhandled,
    SERCOM4_2: InterruptVector = unhandled,
    SERCOM4_OTHER: InterruptVector = unhandled,
    SERCOM5_0: InterruptVector = unhandled,
    SERCOM5_1: InterruptVector = unhandled,
    SERCOM5_2: InterruptVector = unhandled,
    SERCOM5_OTHER: InterruptVector = unhandled,
    reserved5: u32 = undefined,
    reserved6: u32 = undefined,
    reserved7: u32 = undefined,
    reserved8: u32 = undefined,
    reserved9: u32 = undefined,
    reserved10: u32 = undefined,
    reserved11: u32 = undefined,
    reserved12: u32 = undefined,
    CAN0: InterruptVector = unhandled,
    CAN1: InterruptVector = unhandled,
    USB_OTHER: InterruptVector = unhandled,
    USB_SOF_HSOF: InterruptVector = unhandled,
    USB_TRCPT0: InterruptVector = unhandled,
    USB_TRCPT1: InterruptVector = unhandled,
    reserved13: u32 = undefined,
    TCC0_OTHER: InterruptVector = unhandled,
    TCC0_MC0: InterruptVector = unhandled,
    TCC0_MC1: InterruptVector = unhandled,
    TCC0_MC2: InterruptVector = unhandled,
    TCC0_MC3: InterruptVector = unhandled,
    TCC0_MC4: InterruptVector = unhandled,
    TCC0_MC5: InterruptVector = unhandled,
    TCC1_OTHER: InterruptVector = unhandled,
    TCC1_MC0: InterruptVector = unhandled,
    TCC1_MC1: InterruptVector = unhandled,
    TCC1_MC2: InterruptVector = unhandled,
    TCC1_MC3: InterruptVector = unhandled,
    TCC2_OTHER: InterruptVector = unhandled,
    TCC2_MC0: InterruptVector = unhandled,
    TCC2_MC1: InterruptVector = unhandled,
    TCC2_MC2: InterruptVector = unhandled,
    TCC3_OTHER: InterruptVector = unhandled,
    TCC3_MC0: InterruptVector = unhandled,
    TCC3_MC1: InterruptVector = unhandled,
    TCC4_OTHER: InterruptVector = unhandled,
    TCC4_MC0: InterruptVector = unhandled,
    TCC4_MC1: InterruptVector = unhandled,
    TC0: InterruptVector = unhandled,
    TC1: InterruptVector = unhandled,
    TC2: InterruptVector = unhandled,
    TC3: InterruptVector = unhandled,
    TC4: InterruptVector = unhandled,
    TC5: InterruptVector = unhandled,
    reserved14: u32 = undefined,
    reserved15: u32 = undefined,
    PDEC_OTHER: InterruptVector = unhandled,
    PDEC_MC0: InterruptVector = unhandled,
    PDEC_MC1: InterruptVector = unhandled,
    ADC0_OTHER: InterruptVector = unhandled,
    ADC0_RESRDY: InterruptVector = unhandled,
    ADC1_OTHER: InterruptVector = unhandled,
    ADC1_RESRDY: InterruptVector = unhandled,
    AC: InterruptVector = unhandled,
    DAC_OTHER: InterruptVector = unhandled,
    DAC_EMPTY_0: InterruptVector = unhandled,
    DAC_EMPTY_1: InterruptVector = unhandled,
    DAC_RESRDY_0: InterruptVector = unhandled,
    DAC_RESRDY_1: InterruptVector = unhandled,
    I2S: InterruptVector = unhandled,
    PCC: InterruptVector = unhandled,
    AES: InterruptVector = unhandled,
    TRNG: InterruptVector = unhandled,
    ICM: InterruptVector = unhandled,
    reserved16: u32 = undefined,
    QSPI: InterruptVector = unhandled,
    SDHC0: InterruptVector = unhandled,
};

pub const registers = struct {
    /// System Control Space
    pub const SCS = struct {
        pub const base_address = 0xe000e000;

        /// System Tick Timer
        pub const SysTick = struct {
            /// address: 0xe000e010
            /// SysTick Control and Status Register
            pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
                ENABLE: u1,
                TICKINT: u1,
                CLKSOURCE: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                COUNTFLAG: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
            }), base_address + 0x10);

            /// address: 0xe000e014
            /// SysTick Reload Value Register
            pub const LOAD = @intToPtr(*volatile Mmio(32, packed struct {
                RELOAD: u24,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x14);

            /// address: 0xe000e018
            /// SysTick Current Value Register
            pub const VAL = @intToPtr(*volatile Mmio(32, packed struct {
                CURRENT: u24,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x18);

            /// address: 0xe000e01c
            /// SysTick Calibration Register
            pub const CALIB = @intToPtr(*volatile Mmio(32, packed struct {
                TENMS: u24,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                SKEW: u1,
                NOREF: u1,
            }), base_address + 0x1c);
        };
    };

    /// Analog Comparators
    pub const AC = struct {
        pub const base_address = 0x42002000;
        pub const version = "U25011.0.0";

        /// address: 0x42002000
        /// Control A
        pub const CTRLA = @intToPtr(*volatile Mmio(8, packed struct {
            /// Software Reset
            SWRST: u1,
            /// Enable
            ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x0);

        /// address: 0x42002001
        /// Control B
        pub const CTRLB = @intToPtr(*volatile Mmio(8, packed struct {
            /// Comparator 0 Start Comparison
            START0: u1,
            /// Comparator 1 Start Comparison
            START1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x1);

        /// address: 0x42002002
        /// Event Control
        pub const EVCTRL = @intToPtr(*volatile Mmio(16, packed struct {
            /// Comparator 0 Event Output Enable
            COMPEO0: u1,
            /// Comparator 1 Event Output Enable
            COMPEO1: u1,
            reserved0: u1,
            reserved1: u1,
            /// Window 0 Event Output Enable
            WINEO0: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Comparator 0 Event Input Enable
            COMPEI0: u1,
            /// Comparator 1 Event Input Enable
            COMPEI1: u1,
            reserved5: u1,
            reserved6: u1,
            /// Comparator 0 Input Event Invert Enable
            INVEI0: u1,
            /// Comparator 1 Input Event Invert Enable
            INVEI1: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x2);

        /// address: 0x42002004
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Comparator 0 Interrupt Enable
            COMP0: u1,
            /// Comparator 1 Interrupt Enable
            COMP1: u1,
            reserved0: u1,
            reserved1: u1,
            /// Window 0 Interrupt Enable
            WIN0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x4);

        /// address: 0x42002005
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
            /// Comparator 0 Interrupt Enable
            COMP0: u1,
            /// Comparator 1 Interrupt Enable
            COMP1: u1,
            reserved0: u1,
            reserved1: u1,
            /// Window 0 Interrupt Enable
            WIN0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x5);

        /// address: 0x42002006
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
            /// Comparator 0
            COMP0: u1,
            /// Comparator 1
            COMP1: u1,
            reserved0: u1,
            reserved1: u1,
            /// Window 0
            WIN0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x6);

        /// address: 0x42002007
        /// Status A
        pub const STATUSA = @intToPtr(*volatile Mmio(8, packed struct {
            /// Comparator 0 Current State
            STATE0: u1,
            /// Comparator 1 Current State
            STATE1: u1,
            reserved0: u1,
            reserved1: u1,
            /// Window 0 Current State
            WSTATE0: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x7);

        /// address: 0x42002008
        /// Status B
        pub const STATUSB = @intToPtr(*volatile Mmio(8, packed struct {
            /// Comparator 0 Ready
            READY0: u1,
            /// Comparator 1 Ready
            READY1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x8);

        /// address: 0x42002009
        /// Debug Control
        pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Debug Run
            DBGRUN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x9);

        /// address: 0x4200200a
        /// Window Control
        pub const WINCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Window 0 Mode Enable
            WEN0: u1,
            /// Window 0 Interrupt Selection
            WINTSEL0: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0xa);

        /// address: 0x4200200c
        /// Scaler n
        pub const SCALER = @intToPtr(*volatile [2]Mmio(8, packed struct {
            /// Scaler Value
            VALUE: u6,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xc);

        /// address: 0x42002010
        /// Comparator Control n
        pub const COMPCTRL = @intToPtr(*volatile [2]Mmio(32, packed struct {
            reserved0: u1,
            /// Enable
            ENABLE: u1,
            /// Single-Shot Mode
            SINGLE: u1,
            /// Interrupt Selection
            INTSEL: u2,
            reserved1: u1,
            /// Run in Standby
            RUNSTDBY: u1,
            reserved2: u1,
            /// Negative Input Mux Selection
            MUXNEG: u3,
            reserved3: u1,
            /// Positive Input Mux Selection
            MUXPOS: u3,
            /// Swap Inputs and Invert
            SWAP: u1,
            /// Speed Selection
            SPEED: u2,
            reserved4: u1,
            /// Hysteresis Enable
            HYSTEN: u1,
            /// Hysteresis Level
            HYST: u2,
            reserved5: u1,
            reserved6: u1,
            /// Filter Length
            FLEN: u3,
            reserved7: u1,
            /// Output
            OUT: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x10);

        /// address: 0x42002020
        /// Synchronization Busy
        pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Reset Synchronization Busy
            SWRST: u1,
            /// Enable Synchronization Busy
            ENABLE: u1,
            /// WINCTRL Synchronization Busy
            WINCTRL: u1,
            /// COMPCTRL 0 Synchronization Busy
            COMPCTRL0: u1,
            /// COMPCTRL 1 Synchronization Busy
            COMPCTRL1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x20);

        /// address: 0x42002024
        /// Calibration
        pub const CALIB = @intToPtr(*volatile Mmio(16, packed struct {
            /// COMP0/1 Bias Scaling
            BIAS0: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x24);
    };

    /// Analog Digital Converter
    pub const ADC0 = struct {
        pub const base_address = 0x43001c00;
        pub const version = "U25001.0.0";

        /// address: 0x43001c00
        /// Control A
        pub const CTRLA = @intToPtr(*volatile Mmio(16, packed struct {
            /// Software Reset
            SWRST: u1,
            /// Enable
            ENABLE: u1,
            reserved0: u1,
            /// Dual Mode Trigger Selection
            DUALSEL: u2,
            /// Slave Enable
            SLAVEEN: u1,
            /// Run in Standby
            RUNSTDBY: u1,
            /// On Demand Control
            ONDEMAND: u1,
            /// Prescaler Configuration
            PRESCALER: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Rail to Rail Operation Enable
            R2R: u1,
        }), base_address + 0x0);

        /// address: 0x43001c02
        /// Event Control
        pub const EVCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Flush Event Input Enable
            FLUSHEI: u1,
            /// Start Conversion Event Input Enable
            STARTEI: u1,
            /// Flush Event Invert Enable
            FLUSHINV: u1,
            /// Start Conversion Event Invert Enable
            STARTINV: u1,
            /// Result Ready Event Out
            RESRDYEO: u1,
            /// Window Monitor Event Out
            WINMONEO: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x2);

        /// address: 0x43001c03
        /// Debug Control
        pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Debug Run
            DBGRUN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x3);

        /// address: 0x43001c04
        /// Input Control
        pub const INPUTCTRL = @intToPtr(*volatile Mmio(16, packed struct {
            /// Positive Mux Input Selection
            MUXPOS: u5,
            reserved0: u1,
            reserved1: u1,
            /// Differential Mode
            DIFFMODE: u1,
            /// Negative Mux Input Selection
            MUXNEG: u5,
            reserved2: u1,
            reserved3: u1,
            /// Stop DMA Sequencing
            DSEQSTOP: u1,
        }), base_address + 0x4);

        /// address: 0x43001c06
        /// Control B
        pub const CTRLB = @intToPtr(*volatile Mmio(16, packed struct {
            /// Left-Adjusted Result
            LEFTADJ: u1,
            /// Free Running Mode
            FREERUN: u1,
            /// Digital Correction Logic Enable
            CORREN: u1,
            /// Conversion Result Resolution
            RESSEL: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Window Monitor Mode
            WINMODE: u3,
            /// Window Single Sample
            WINSS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x6);

        /// address: 0x43001c08
        /// Reference Control
        pub const REFCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Reference Selection
            REFSEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Reference Buffer Offset Compensation Enable
            REFCOMP: u1,
        }), base_address + 0x8);

        /// address: 0x43001c0a
        /// Average Control
        pub const AVGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Number of Samples to be Collected
            SAMPLENUM: u4,
            /// Adjusting Result / Division Coefficient
            ADJRES: u3,
            padding0: u1,
        }), base_address + 0xa);

        /// address: 0x43001c0b
        /// Sample Time Control
        pub const SAMPCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Sampling Time Length
            SAMPLEN: u6,
            reserved0: u1,
            /// Comparator Offset Compensation Enable
            OFFCOMP: u1,
        }), base_address + 0xb);

        /// address: 0x43001c0c
        /// Window Monitor Lower Threshold
        pub const WINLT = @intToPtr(*volatile u16, base_address + 0xc);

        /// address: 0x43001c0e
        /// Window Monitor Upper Threshold
        pub const WINUT = @intToPtr(*volatile u16, base_address + 0xe);

        /// address: 0x43001c10
        /// Gain Correction
        pub const GAINCORR = @intToPtr(*volatile MmioInt(16, u12), base_address + 0x10);

        /// address: 0x43001c12
        /// Offset Correction
        pub const OFFSETCORR = @intToPtr(*volatile MmioInt(16, u12), base_address + 0x12);

        /// address: 0x43001c14
        /// Software Trigger
        pub const SWTRIG = @intToPtr(*volatile Mmio(8, packed struct {
            /// ADC Conversion Flush
            FLUSH: u1,
            /// Start ADC Conversion
            START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x14);

        /// address: 0x43001c2c
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Result Ready Interrupt Disable
            RESRDY: u1,
            /// Overrun Interrupt Disable
            OVERRUN: u1,
            /// Window Monitor Interrupt Disable
            WINMON: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x2c);

        /// address: 0x43001c2d
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
            /// Result Ready Interrupt Enable
            RESRDY: u1,
            /// Overrun Interrupt Enable
            OVERRUN: u1,
            /// Window Monitor Interrupt Enable
            WINMON: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x2d);

        /// address: 0x43001c2e
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
            /// Result Ready Interrupt Flag
            RESRDY: u1,
            /// Overrun Interrupt Flag
            OVERRUN: u1,
            /// Window Monitor Interrupt Flag
            WINMON: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x2e);

        /// address: 0x43001c2f
        /// Status
        pub const STATUS = @intToPtr(*volatile Mmio(8, packed struct {
            /// ADC Busy Status
            ADCBUSY: u1,
            reserved0: u1,
            /// Window Comparator Counter
            WCC: u6,
        }), base_address + 0x2f);

        /// address: 0x43001c30
        /// Synchronization Busy
        pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
            /// SWRST Synchronization Busy
            SWRST: u1,
            /// ENABLE Synchronization Busy
            ENABLE: u1,
            /// Input Control Synchronization Busy
            INPUTCTRL: u1,
            /// Control B Synchronization Busy
            CTRLB: u1,
            /// Reference Control Synchronization Busy
            REFCTRL: u1,
            /// Average Control Synchronization Busy
            AVGCTRL: u1,
            /// Sampling Time Control Synchronization Busy
            SAMPCTRL: u1,
            /// Window Monitor Lower Threshold Synchronization Busy
            WINLT: u1,
            /// Window Monitor Upper Threshold Synchronization Busy
            WINUT: u1,
            /// Gain Correction Synchronization Busy
            GAINCORR: u1,
            /// Offset Correction Synchronization Busy
            OFFSETCORR: u1,
            /// Software Trigger Synchronization Busy
            SWTRIG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x30);

        /// address: 0x43001c34
        /// DMA Sequencial Data
        pub const DSEQDATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Sequential Data
            DATA: u32,
        }), base_address + 0x34);

        /// address: 0x43001c38
        /// DMA Sequential Control
        pub const DSEQCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input Control
            INPUTCTRL: u1,
            /// Control B
            CTRLB: u1,
            /// Reference Control
            REFCTRL: u1,
            /// Average Control
            AVGCTRL: u1,
            /// Sampling Time Control
            SAMPCTRL: u1,
            /// Window Monitor Lower Threshold
            WINLT: u1,
            /// Window Monitor Upper Threshold
            WINUT: u1,
            /// Gain Correction
            GAINCORR: u1,
            /// Offset Correction
            OFFSETCORR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// ADC Auto-Start Conversion
            AUTOSTART: u1,
        }), base_address + 0x38);

        /// address: 0x43001c3c
        /// DMA Sequencial Status
        pub const DSEQSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input Control
            INPUTCTRL: u1,
            /// Control B
            CTRLB: u1,
            /// Reference Control
            REFCTRL: u1,
            /// Average Control
            AVGCTRL: u1,
            /// Sampling Time Control
            SAMPCTRL: u1,
            /// Window Monitor Lower Threshold
            WINLT: u1,
            /// Window Monitor Upper Threshold
            WINUT: u1,
            /// Gain Correction
            GAINCORR: u1,
            /// Offset Correction
            OFFSETCORR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// DMA Sequencing Busy
            BUSY: u1,
        }), base_address + 0x3c);

        /// address: 0x43001c40
        /// Result Conversion Value
        pub const RESULT = @intToPtr(*volatile u16, base_address + 0x40);

        /// address: 0x43001c44
        /// Last Sample Result
        pub const RESS = @intToPtr(*volatile u16, base_address + 0x44);

        /// address: 0x43001c48
        /// Calibration
        pub const CALIB = @intToPtr(*volatile Mmio(16, packed struct {
            /// Bias Comparator Scaling
            BIASCOMP: u3,
            reserved0: u1,
            /// Bias R2R Ampli scaling
            BIASR2R: u3,
            reserved1: u1,
            /// Bias Reference Buffer Scaling
            BIASREFBUF: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x48);
    };
    pub const ADC1 = struct {
        pub const base_address = 0x43002000;

        /// address: 0x43002000
        /// Control A
        pub const CTRLA = @intToPtr(*volatile Mmio(16, packed struct {
            /// Software Reset
            SWRST: u1,
            /// Enable
            ENABLE: u1,
            reserved0: u1,
            /// Dual Mode Trigger Selection
            DUALSEL: u2,
            /// Slave Enable
            SLAVEEN: u1,
            /// Run in Standby
            RUNSTDBY: u1,
            /// On Demand Control
            ONDEMAND: u1,
            /// Prescaler Configuration
            PRESCALER: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Rail to Rail Operation Enable
            R2R: u1,
        }), base_address + 0x0);

        /// address: 0x43002002
        /// Event Control
        pub const EVCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Flush Event Input Enable
            FLUSHEI: u1,
            /// Start Conversion Event Input Enable
            STARTEI: u1,
            /// Flush Event Invert Enable
            FLUSHINV: u1,
            /// Start Conversion Event Invert Enable
            STARTINV: u1,
            /// Result Ready Event Out
            RESRDYEO: u1,
            /// Window Monitor Event Out
            WINMONEO: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x2);

        /// address: 0x43002003
        /// Debug Control
        pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Debug Run
            DBGRUN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x3);

        /// address: 0x43002004
        /// Input Control
        pub const INPUTCTRL = @intToPtr(*volatile Mmio(16, packed struct {
            /// Positive Mux Input Selection
            MUXPOS: u5,
            reserved0: u1,
            reserved1: u1,
            /// Differential Mode
            DIFFMODE: u1,
            /// Negative Mux Input Selection
            MUXNEG: u5,
            reserved2: u1,
            reserved3: u1,
            /// Stop DMA Sequencing
            DSEQSTOP: u1,
        }), base_address + 0x4);

        /// address: 0x43002006
        /// Control B
        pub const CTRLB = @intToPtr(*volatile Mmio(16, packed struct {
            /// Left-Adjusted Result
            LEFTADJ: u1,
            /// Free Running Mode
            FREERUN: u1,
            /// Digital Correction Logic Enable
            CORREN: u1,
            /// Conversion Result Resolution
            RESSEL: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Window Monitor Mode
            WINMODE: u3,
            /// Window Single Sample
            WINSS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x6);

        /// address: 0x43002008
        /// Reference Control
        pub const REFCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Reference Selection
            REFSEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Reference Buffer Offset Compensation Enable
            REFCOMP: u1,
        }), base_address + 0x8);

        /// address: 0x4300200a
        /// Average Control
        pub const AVGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Number of Samples to be Collected
            SAMPLENUM: u4,
            /// Adjusting Result / Division Coefficient
            ADJRES: u3,
            padding0: u1,
        }), base_address + 0xa);

        /// address: 0x4300200b
        /// Sample Time Control
        pub const SAMPCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Sampling Time Length
            SAMPLEN: u6,
            reserved0: u1,
            /// Comparator Offset Compensation Enable
            OFFCOMP: u1,
        }), base_address + 0xb);

        /// address: 0x4300200c
        /// Window Monitor Lower Threshold
        pub const WINLT = @intToPtr(*volatile u16, base_address + 0xc);

        /// address: 0x4300200e
        /// Window Monitor Upper Threshold
        pub const WINUT = @intToPtr(*volatile u16, base_address + 0xe);

        /// address: 0x43002010
        /// Gain Correction
        pub const GAINCORR = @intToPtr(*volatile MmioInt(16, u12), base_address + 0x10);

        /// address: 0x43002012
        /// Offset Correction
        pub const OFFSETCORR = @intToPtr(*volatile MmioInt(16, u12), base_address + 0x12);

        /// address: 0x43002014
        /// Software Trigger
        pub const SWTRIG = @intToPtr(*volatile Mmio(8, packed struct {
            /// ADC Conversion Flush
            FLUSH: u1,
            /// Start ADC Conversion
            START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x14);

        /// address: 0x4300202c
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Result Ready Interrupt Disable
            RESRDY: u1,
            /// Overrun Interrupt Disable
            OVERRUN: u1,
            /// Window Monitor Interrupt Disable
            WINMON: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x2c);

        /// address: 0x4300202d
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
            /// Result Ready Interrupt Enable
            RESRDY: u1,
            /// Overrun Interrupt Enable
            OVERRUN: u1,
            /// Window Monitor Interrupt Enable
            WINMON: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x2d);

        /// address: 0x4300202e
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
            /// Result Ready Interrupt Flag
            RESRDY: u1,
            /// Overrun Interrupt Flag
            OVERRUN: u1,
            /// Window Monitor Interrupt Flag
            WINMON: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x2e);

        /// address: 0x4300202f
        /// Status
        pub const STATUS = @intToPtr(*volatile Mmio(8, packed struct {
            /// ADC Busy Status
            ADCBUSY: u1,
            reserved0: u1,
            /// Window Comparator Counter
            WCC: u6,
        }), base_address + 0x2f);

        /// address: 0x43002030
        /// Synchronization Busy
        pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
            /// SWRST Synchronization Busy
            SWRST: u1,
            /// ENABLE Synchronization Busy
            ENABLE: u1,
            /// Input Control Synchronization Busy
            INPUTCTRL: u1,
            /// Control B Synchronization Busy
            CTRLB: u1,
            /// Reference Control Synchronization Busy
            REFCTRL: u1,
            /// Average Control Synchronization Busy
            AVGCTRL: u1,
            /// Sampling Time Control Synchronization Busy
            SAMPCTRL: u1,
            /// Window Monitor Lower Threshold Synchronization Busy
            WINLT: u1,
            /// Window Monitor Upper Threshold Synchronization Busy
            WINUT: u1,
            /// Gain Correction Synchronization Busy
            GAINCORR: u1,
            /// Offset Correction Synchronization Busy
            OFFSETCORR: u1,
            /// Software Trigger Synchronization Busy
            SWTRIG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x30);

        /// address: 0x43002034
        /// DMA Sequencial Data
        pub const DSEQDATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Sequential Data
            DATA: u32,
        }), base_address + 0x34);

        /// address: 0x43002038
        /// DMA Sequential Control
        pub const DSEQCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input Control
            INPUTCTRL: u1,
            /// Control B
            CTRLB: u1,
            /// Reference Control
            REFCTRL: u1,
            /// Average Control
            AVGCTRL: u1,
            /// Sampling Time Control
            SAMPCTRL: u1,
            /// Window Monitor Lower Threshold
            WINLT: u1,
            /// Window Monitor Upper Threshold
            WINUT: u1,
            /// Gain Correction
            GAINCORR: u1,
            /// Offset Correction
            OFFSETCORR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// ADC Auto-Start Conversion
            AUTOSTART: u1,
        }), base_address + 0x38);

        /// address: 0x4300203c
        /// DMA Sequencial Status
        pub const DSEQSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input Control
            INPUTCTRL: u1,
            /// Control B
            CTRLB: u1,
            /// Reference Control
            REFCTRL: u1,
            /// Average Control
            AVGCTRL: u1,
            /// Sampling Time Control
            SAMPCTRL: u1,
            /// Window Monitor Lower Threshold
            WINLT: u1,
            /// Window Monitor Upper Threshold
            WINUT: u1,
            /// Gain Correction
            GAINCORR: u1,
            /// Offset Correction
            OFFSETCORR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// DMA Sequencing Busy
            BUSY: u1,
        }), base_address + 0x3c);

        /// address: 0x43002040
        /// Result Conversion Value
        pub const RESULT = @intToPtr(*volatile u16, base_address + 0x40);

        /// address: 0x43002044
        /// Last Sample Result
        pub const RESS = @intToPtr(*volatile u16, base_address + 0x44);

        /// address: 0x43002048
        /// Calibration
        pub const CALIB = @intToPtr(*volatile Mmio(16, packed struct {
            /// Bias Comparator Scaling
            BIASCOMP: u3,
            reserved0: u1,
            /// Bias R2R Ampli scaling
            BIASR2R: u3,
            reserved1: u1,
            /// Bias Reference Buffer Scaling
            BIASREFBUF: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x48);
    };

    /// Advanced Encryption Standard
    pub const AES = struct {
        pub const base_address = 0x42002400;
        pub const version = "U22382.2.0";

        /// address: 0x42002400
        /// Control A
        pub const CTRLA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Reset
            SWRST: u1,
            /// Enable
            ENABLE: u1,
            /// AES Modes of operation
            AESMODE: u3,
            /// Cipher Feedback Block Size
            CFBS: u3,
            /// Encryption Key Size
            KEYSIZE: u2,
            /// Cipher Mode
            CIPHER: u1,
            /// Start Mode Select
            STARTMODE: u1,
            /// Last Output Data Mode
            LOD: u1,
            /// Last Key Generation
            KEYGEN: u1,
            /// XOR Key Operation
            XORKEY: u1,
            reserved0: u1,
            /// Counter Measure Type
            CTYPE: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x0);

        /// address: 0x42002404
        /// Control B
        pub const CTRLB = @intToPtr(*volatile Mmio(8, packed struct {
            /// Start Encryption/Decryption
            START: u1,
            /// New message
            NEWMSG: u1,
            /// End of message
            EOM: u1,
            /// GF Multiplication
            GFMUL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x4);

        /// address: 0x42002405
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Encryption Complete Interrupt Enable
            ENCCMP: u1,
            /// GF Multiplication Complete Interrupt Enable
            GFMCMP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x5);

        /// address: 0x42002406
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
            /// Encryption Complete Interrupt Enable
            ENCCMP: u1,
            /// GF Multiplication Complete Interrupt Enable
            GFMCMP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x6);

        /// address: 0x42002407
        /// Interrupt Flag Status
        pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
            /// Encryption Complete
            ENCCMP: u1,
            /// GF Multiplication Complete
            GFMCMP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x7);

        /// address: 0x42002408
        /// Data buffer pointer
        pub const DATABUFPTR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Input Data Pointer
            INDATAPTR: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x8);

        /// address: 0x42002409
        /// Debug control
        pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Debug Run
            DBGRUN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x9);

        /// address: 0x4200240c
        /// Keyword n
        pub const KEYWORD = @intToPtr(*volatile [8]u32, base_address + 0xc);

        /// address: 0x42002438
        /// Indata
        pub const INDATA = @intToPtr(*volatile u32, base_address + 0x38);

        /// address: 0x4200243c
        /// Initialisation Vector n
        pub const INTVECTV = @intToPtr(*volatile [4]u32, base_address + 0x3c);

        /// address: 0x4200245c
        /// Hash key n
        pub const HASHKEY = @intToPtr(*volatile [4]u32, base_address + 0x5c);

        /// address: 0x4200246c
        /// Galois Hash n
        pub const GHASH = @intToPtr(*volatile [4]u32, base_address + 0x6c);

        /// address: 0x42002480
        /// Cipher Length
        pub const CIPLEN = @intToPtr(*volatile u32, base_address + 0x80);

        /// address: 0x42002484
        /// Random Seed
        pub const RANDSEED = @intToPtr(*volatile u32, base_address + 0x84);
    };

    /// Control Area Network
    pub const CAN0 = struct {
        pub const base_address = 0x42000000;
        pub const version = "U20033.2.1";

        /// address: 0x42000000
        /// Core Release
        pub const CREL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// Sub-step of Core Release
            SUBSTEP: u4,
            /// Step of Core Release
            STEP: u4,
            /// Core Release
            REL: u4,
        }), base_address + 0x0);

        /// address: 0x42000004
        /// Endian
        pub const ENDN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endianness Test Value
            ETV: u32,
        }), base_address + 0x4);

        /// address: 0x42000008
        /// Message RAM Configuration
        pub const MRCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Quality of Service
            QOS: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x8);

        /// address: 0x4200000c
        /// Fast Bit Timing and Prescaler
        pub const DBTP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data (Re)Synchronization Jump Width
            DSJW: u4,
            /// Data time segment after sample point
            DTSEG2: u4,
            /// Data time segment before sample point
            DTSEG1: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Data Baud Rate Prescaler
            DBRP: u5,
            reserved3: u1,
            reserved4: u1,
            /// Tranceiver Delay Compensation
            TDC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xc);

        /// address: 0x42000010
        /// Test
        pub const TEST = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Loop Back Mode
            LBCK: u1,
            /// Control of Transmit Pin
            TX: u2,
            /// Receive Pin
            RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x42000014
        /// RAM Watchdog
        pub const RWD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog Configuration
            WDC: u8,
            /// Watchdog Value
            WDV: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x42000018
        /// CC Control
        pub const CCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Initialization
            INIT: u1,
            /// Configuration Change Enable
            CCE: u1,
            /// ASM Restricted Operation Mode
            ASM: u1,
            /// Clock Stop Acknowledge
            CSA: u1,
            /// Clock Stop Request
            CSR: u1,
            /// Bus Monitoring Mode
            MON: u1,
            /// Disable Automatic Retransmission
            DAR: u1,
            /// Test Mode Enable
            TEST: u1,
            /// FD Operation Enable
            FDOE: u1,
            /// Bit Rate Switch Enable
            BRSE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Protocol Exception Handling Disable
            PXHD: u1,
            /// Edge Filtering during Bus Integration
            EFBI: u1,
            /// Transmit Pause
            TXP: u1,
            /// Non ISO Operation
            NISO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4200001c
        /// Nominal Bit Timing and Prescaler
        pub const NBTP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Nominal Time segment after sample point
            NTSEG2: u7,
            reserved0: u1,
            /// Nominal Time segment before sample point
            NTSEG1: u8,
            /// Nominal Baud Rate Prescaler
            NBRP: u9,
            /// Nominal (Re)Synchronization Jump Width
            NSJW: u7,
        }), base_address + 0x1c);

        /// address: 0x42000020
        /// Timestamp Counter Configuration
        pub const TSCC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timestamp Select
            TSS: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Timestamp Counter Prescaler
            TCP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x20);

        /// address: 0x42000024
        /// Timestamp Counter Value
        pub const TSCV = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timestamp Counter
            TSC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x24);

        /// address: 0x42000028
        /// Timeout Counter Configuration
        pub const TOCC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable Timeout Counter
            ETOC: u1,
            /// Timeout Select
            TOS: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Timeout Period
            TOP: u16,
        }), base_address + 0x28);

        /// address: 0x4200002c
        /// Timeout Counter Value
        pub const TOCV = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timeout Counter
            TOC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2c);

        /// address: 0x42000040
        /// Error Counter
        pub const ECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Error Counter
            TEC: u8,
            /// Receive Error Counter
            REC: u7,
            /// Receive Error Passive
            RP: u1,
            /// CAN Error Logging
            CEL: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x42000044
        /// Protocol Status
        pub const PSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Last Error Code
            LEC: u3,
            /// Activity
            ACT: u2,
            /// Error Passive
            EP: u1,
            /// Warning Status
            EW: u1,
            /// Bus_Off Status
            BO: u1,
            /// Data Phase Last Error Code
            DLEC: u3,
            /// ESI flag of last received CAN FD Message
            RESI: u1,
            /// BRS flag of last received CAN FD Message
            RBRS: u1,
            /// Received a CAN FD Message
            RFDF: u1,
            /// Protocol Exception Event
            PXE: u1,
            reserved0: u1,
            /// Transmitter Delay Compensation Value
            TDCV: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x44);

        /// address: 0x42000048
        /// Extended ID Filter Configuration
        pub const TDCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmitter Delay Compensation Filter Length
            TDCF: u7,
            reserved0: u1,
            /// Transmitter Delay Compensation Offset
            TDCO: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x48);

        /// address: 0x42000050
        /// Interrupt
        pub const IR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 0 New Message
            RF0N: u1,
            /// Rx FIFO 0 Watermark Reached
            RF0W: u1,
            /// Rx FIFO 0 Full
            RF0F: u1,
            /// Rx FIFO 0 Message Lost
            RF0L: u1,
            /// Rx FIFO 1 New Message
            RF1N: u1,
            /// Rx FIFO 1 Watermark Reached
            RF1W: u1,
            /// Rx FIFO 1 FIFO Full
            RF1F: u1,
            /// Rx FIFO 1 Message Lost
            RF1L: u1,
            /// High Priority Message
            HPM: u1,
            /// Timestamp Completed
            TC: u1,
            /// Transmission Cancellation Finished
            TCF: u1,
            /// Tx FIFO Empty
            TFE: u1,
            /// Tx Event FIFO New Entry
            TEFN: u1,
            /// Tx Event FIFO Watermark Reached
            TEFW: u1,
            /// Tx Event FIFO Full
            TEFF: u1,
            /// Tx Event FIFO Element Lost
            TEFL: u1,
            /// Timestamp Wraparound
            TSW: u1,
            /// Message RAM Access Failure
            MRAF: u1,
            /// Timeout Occurred
            TOO: u1,
            /// Message stored to Dedicated Rx Buffer
            DRX: u1,
            /// Bit Error Corrected
            BEC: u1,
            /// Bit Error Uncorrected
            BEU: u1,
            /// Error Logging Overflow
            ELO: u1,
            /// Error Passive
            EP: u1,
            /// Warning Status
            EW: u1,
            /// Bus_Off Status
            BO: u1,
            /// Watchdog Interrupt
            WDI: u1,
            /// Protocol Error in Arbitration Phase
            PEA: u1,
            /// Protocol Error in Data Phase
            PED: u1,
            /// Access to Reserved Address
            ARA: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x50);

        /// address: 0x42000054
        /// Interrupt Enable
        pub const IE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 0 New Message Interrupt Enable
            RF0NE: u1,
            /// Rx FIFO 0 Watermark Reached Interrupt Enable
            RF0WE: u1,
            /// Rx FIFO 0 Full Interrupt Enable
            RF0FE: u1,
            /// Rx FIFO 0 Message Lost Interrupt Enable
            RF0LE: u1,
            /// Rx FIFO 1 New Message Interrupt Enable
            RF1NE: u1,
            /// Rx FIFO 1 Watermark Reached Interrupt Enable
            RF1WE: u1,
            /// Rx FIFO 1 FIFO Full Interrupt Enable
            RF1FE: u1,
            /// Rx FIFO 1 Message Lost Interrupt Enable
            RF1LE: u1,
            /// High Priority Message Interrupt Enable
            HPME: u1,
            /// Timestamp Completed Interrupt Enable
            TCE: u1,
            /// Transmission Cancellation Finished Interrupt Enable
            TCFE: u1,
            /// Tx FIFO Empty Interrupt Enable
            TFEE: u1,
            /// Tx Event FIFO New Entry Interrupt Enable
            TEFNE: u1,
            /// Tx Event FIFO Watermark Reached Interrupt Enable
            TEFWE: u1,
            /// Tx Event FIFO Full Interrupt Enable
            TEFFE: u1,
            /// Tx Event FIFO Element Lost Interrupt Enable
            TEFLE: u1,
            /// Timestamp Wraparound Interrupt Enable
            TSWE: u1,
            /// Message RAM Access Failure Interrupt Enable
            MRAFE: u1,
            /// Timeout Occurred Interrupt Enable
            TOOE: u1,
            /// Message stored to Dedicated Rx Buffer Interrupt Enable
            DRXE: u1,
            /// Bit Error Corrected Interrupt Enable
            BECE: u1,
            /// Bit Error Uncorrected Interrupt Enable
            BEUE: u1,
            /// Error Logging Overflow Interrupt Enable
            ELOE: u1,
            /// Error Passive Interrupt Enable
            EPE: u1,
            /// Warning Status Interrupt Enable
            EWE: u1,
            /// Bus_Off Status Interrupt Enable
            BOE: u1,
            /// Watchdog Interrupt Interrupt Enable
            WDIE: u1,
            /// Protocol Error in Arbitration Phase Enable
            PEAE: u1,
            /// Protocol Error in Data Phase Enable
            PEDE: u1,
            /// Access to Reserved Address Enable
            ARAE: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x54);

        /// address: 0x42000058
        /// Interrupt Line Select
        pub const ILS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 0 New Message Interrupt Line
            RF0NL: u1,
            /// Rx FIFO 0 Watermark Reached Interrupt Line
            RF0WL: u1,
            /// Rx FIFO 0 Full Interrupt Line
            RF0FL: u1,
            /// Rx FIFO 0 Message Lost Interrupt Line
            RF0LL: u1,
            /// Rx FIFO 1 New Message Interrupt Line
            RF1NL: u1,
            /// Rx FIFO 1 Watermark Reached Interrupt Line
            RF1WL: u1,
            /// Rx FIFO 1 FIFO Full Interrupt Line
            RF1FL: u1,
            /// Rx FIFO 1 Message Lost Interrupt Line
            RF1LL: u1,
            /// High Priority Message Interrupt Line
            HPML: u1,
            /// Timestamp Completed Interrupt Line
            TCL: u1,
            /// Transmission Cancellation Finished Interrupt Line
            TCFL: u1,
            /// Tx FIFO Empty Interrupt Line
            TFEL: u1,
            /// Tx Event FIFO New Entry Interrupt Line
            TEFNL: u1,
            /// Tx Event FIFO Watermark Reached Interrupt Line
            TEFWL: u1,
            /// Tx Event FIFO Full Interrupt Line
            TEFFL: u1,
            /// Tx Event FIFO Element Lost Interrupt Line
            TEFLL: u1,
            /// Timestamp Wraparound Interrupt Line
            TSWL: u1,
            /// Message RAM Access Failure Interrupt Line
            MRAFL: u1,
            /// Timeout Occurred Interrupt Line
            TOOL: u1,
            /// Message stored to Dedicated Rx Buffer Interrupt Line
            DRXL: u1,
            /// Bit Error Corrected Interrupt Line
            BECL: u1,
            /// Bit Error Uncorrected Interrupt Line
            BEUL: u1,
            /// Error Logging Overflow Interrupt Line
            ELOL: u1,
            /// Error Passive Interrupt Line
            EPL: u1,
            /// Warning Status Interrupt Line
            EWL: u1,
            /// Bus_Off Status Interrupt Line
            BOL: u1,
            /// Watchdog Interrupt Interrupt Line
            WDIL: u1,
            /// Protocol Error in Arbitration Phase Line
            PEAL: u1,
            /// Protocol Error in Data Phase Line
            PEDL: u1,
            /// Access to Reserved Address Line
            ARAL: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x58);

        /// address: 0x4200005c
        /// Interrupt Line Enable
        pub const ILE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable Interrupt Line 0
            EINT0: u1,
            /// Enable Interrupt Line 1
            EINT1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x5c);

        /// address: 0x42000080
        /// Global Filter Configuration
        pub const GFC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reject Remote Frames Extended
            RRFE: u1,
            /// Reject Remote Frames Standard
            RRFS: u1,
            /// Accept Non-matching Frames Extended
            ANFE: u2,
            /// Accept Non-matching Frames Standard
            ANFS: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x80);

        /// address: 0x42000084
        /// Standard ID Filter Configuration
        pub const SIDFC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter List Standard Start Address
            FLSSA: u16,
            /// List Size Standard
            LSS: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x84);

        /// address: 0x42000088
        /// Extended ID Filter Configuration
        pub const XIDFC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter List Extended Start Address
            FLESA: u16,
            /// List Size Extended
            LSE: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x88);

        /// address: 0x42000090
        /// Extended ID AND Mask
        pub const XIDAM = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extended ID Mask
            EIDM: u29,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x90);

        /// address: 0x42000094
        /// High Priority Message Status
        pub const HPMS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Index
            BIDX: u6,
            /// Message Storage Indicator
            MSI: u2,
            /// Filter Index
            FIDX: u7,
            /// Filter List
            FLST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x94);

        /// address: 0x42000098
        /// New Data 1
        pub const NDAT1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// New Data 0
            ND0: u1,
            /// New Data 1
            ND1: u1,
            /// New Data 2
            ND2: u1,
            /// New Data 3
            ND3: u1,
            /// New Data 4
            ND4: u1,
            /// New Data 5
            ND5: u1,
            /// New Data 6
            ND6: u1,
            /// New Data 7
            ND7: u1,
            /// New Data 8
            ND8: u1,
            /// New Data 9
            ND9: u1,
            /// New Data 10
            ND10: u1,
            /// New Data 11
            ND11: u1,
            /// New Data 12
            ND12: u1,
            /// New Data 13
            ND13: u1,
            /// New Data 14
            ND14: u1,
            /// New Data 15
            ND15: u1,
            /// New Data 16
            ND16: u1,
            /// New Data 17
            ND17: u1,
            /// New Data 18
            ND18: u1,
            /// New Data 19
            ND19: u1,
            /// New Data 20
            ND20: u1,
            /// New Data 21
            ND21: u1,
            /// New Data 22
            ND22: u1,
            /// New Data 23
            ND23: u1,
            /// New Data 24
            ND24: u1,
            /// New Data 25
            ND25: u1,
            /// New Data 26
            ND26: u1,
            /// New Data 27
            ND27: u1,
            /// New Data 28
            ND28: u1,
            /// New Data 29
            ND29: u1,
            /// New Data 30
            ND30: u1,
            /// New Data 31
            ND31: u1,
        }), base_address + 0x98);

        /// address: 0x4200009c
        /// New Data 2
        pub const NDAT2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// New Data 32
            ND32: u1,
            /// New Data 33
            ND33: u1,
            /// New Data 34
            ND34: u1,
            /// New Data 35
            ND35: u1,
            /// New Data 36
            ND36: u1,
            /// New Data 37
            ND37: u1,
            /// New Data 38
            ND38: u1,
            /// New Data 39
            ND39: u1,
            /// New Data 40
            ND40: u1,
            /// New Data 41
            ND41: u1,
            /// New Data 42
            ND42: u1,
            /// New Data 43
            ND43: u1,
            /// New Data 44
            ND44: u1,
            /// New Data 45
            ND45: u1,
            /// New Data 46
            ND46: u1,
            /// New Data 47
            ND47: u1,
            /// New Data 48
            ND48: u1,
            /// New Data 49
            ND49: u1,
            /// New Data 50
            ND50: u1,
            /// New Data 51
            ND51: u1,
            /// New Data 52
            ND52: u1,
            /// New Data 53
            ND53: u1,
            /// New Data 54
            ND54: u1,
            /// New Data 55
            ND55: u1,
            /// New Data 56
            ND56: u1,
            /// New Data 57
            ND57: u1,
            /// New Data 58
            ND58: u1,
            /// New Data 59
            ND59: u1,
            /// New Data 60
            ND60: u1,
            /// New Data 61
            ND61: u1,
            /// New Data 62
            ND62: u1,
            /// New Data 63
            ND63: u1,
        }), base_address + 0x9c);

        /// address: 0x420000a0
        /// Rx FIFO 0 Configuration
        pub const RXF0C = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 0 Start Address
            F0SA: u16,
            /// Rx FIFO 0 Size
            F0S: u7,
            reserved0: u1,
            /// Rx FIFO 0 Watermark
            F0WM: u7,
            /// FIFO 0 Operation Mode
            F0OM: u1,
        }), base_address + 0xa0);

        /// address: 0x420000a4
        /// Rx FIFO 0 Status
        pub const RXF0S = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 0 Fill Level
            F0FL: u7,
            reserved0: u1,
            /// Rx FIFO 0 Get Index
            F0GI: u6,
            reserved1: u1,
            reserved2: u1,
            /// Rx FIFO 0 Put Index
            F0PI: u6,
            reserved3: u1,
            reserved4: u1,
            /// Rx FIFO 0 Full
            F0F: u1,
            /// Rx FIFO 0 Message Lost
            RF0L: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0xa4);

        /// address: 0x420000a8
        /// Rx FIFO 0 Acknowledge
        pub const RXF0A = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 0 Acknowledge Index
            F0AI: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xa8);

        /// address: 0x420000ac
        /// Rx Buffer Configuration
        pub const RXBC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx Buffer Start Address
            RBSA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xac);

        /// address: 0x420000b0
        /// Rx FIFO 1 Configuration
        pub const RXF1C = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 1 Start Address
            F1SA: u16,
            /// Rx FIFO 1 Size
            F1S: u7,
            reserved0: u1,
            /// Rx FIFO 1 Watermark
            F1WM: u7,
            /// FIFO 1 Operation Mode
            F1OM: u1,
        }), base_address + 0xb0);

        /// address: 0x420000b4
        /// Rx FIFO 1 Status
        pub const RXF1S = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 1 Fill Level
            F1FL: u7,
            reserved0: u1,
            /// Rx FIFO 1 Get Index
            F1GI: u6,
            reserved1: u1,
            reserved2: u1,
            /// Rx FIFO 1 Put Index
            F1PI: u6,
            reserved3: u1,
            reserved4: u1,
            /// Rx FIFO 1 Full
            F1F: u1,
            /// Rx FIFO 1 Message Lost
            RF1L: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Debug Message Status
            DMS: u2,
        }), base_address + 0xb4);

        /// address: 0x420000b8
        /// Rx FIFO 1 Acknowledge
        pub const RXF1A = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 1 Acknowledge Index
            F1AI: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xb8);

        /// address: 0x420000bc
        /// Rx Buffer / FIFO Element Size Configuration
        pub const RXESC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 0 Data Field Size
            F0DS: u3,
            reserved0: u1,
            /// Rx FIFO 1 Data Field Size
            F1DS: u3,
            reserved1: u1,
            /// Rx Buffer Data Field Size
            RBDS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0xbc);

        /// address: 0x420000c0
        /// Tx Buffer Configuration
        pub const TXBC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx Buffers Start Address
            TBSA: u16,
            /// Number of Dedicated Transmit Buffers
            NDTB: u6,
            reserved0: u1,
            reserved1: u1,
            /// Transmit FIFO/Queue Size
            TFQS: u6,
            /// Tx FIFO/Queue Mode
            TFQM: u1,
            padding0: u1,
        }), base_address + 0xc0);

        /// address: 0x420000c4
        /// Tx FIFO / Queue Status
        pub const TXFQS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx FIFO Free Level
            TFFL: u6,
            reserved0: u1,
            reserved1: u1,
            /// Tx FIFO Get Index
            TFGI: u5,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Tx FIFO/Queue Put Index
            TFQPI: u5,
            /// Tx FIFO/Queue Full
            TFQF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0xc4);

        /// address: 0x420000c8
        /// Tx Buffer Element Size Configuration
        pub const TXESC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx Buffer Data Field Size
            TBDS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xc8);

        /// address: 0x420000cc
        /// Tx Buffer Request Pending
        pub const TXBRP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmission Request Pending 0
            TRP0: u1,
            /// Transmission Request Pending 1
            TRP1: u1,
            /// Transmission Request Pending 2
            TRP2: u1,
            /// Transmission Request Pending 3
            TRP3: u1,
            /// Transmission Request Pending 4
            TRP4: u1,
            /// Transmission Request Pending 5
            TRP5: u1,
            /// Transmission Request Pending 6
            TRP6: u1,
            /// Transmission Request Pending 7
            TRP7: u1,
            /// Transmission Request Pending 8
            TRP8: u1,
            /// Transmission Request Pending 9
            TRP9: u1,
            /// Transmission Request Pending 10
            TRP10: u1,
            /// Transmission Request Pending 11
            TRP11: u1,
            /// Transmission Request Pending 12
            TRP12: u1,
            /// Transmission Request Pending 13
            TRP13: u1,
            /// Transmission Request Pending 14
            TRP14: u1,
            /// Transmission Request Pending 15
            TRP15: u1,
            /// Transmission Request Pending 16
            TRP16: u1,
            /// Transmission Request Pending 17
            TRP17: u1,
            /// Transmission Request Pending 18
            TRP18: u1,
            /// Transmission Request Pending 19
            TRP19: u1,
            /// Transmission Request Pending 20
            TRP20: u1,
            /// Transmission Request Pending 21
            TRP21: u1,
            /// Transmission Request Pending 22
            TRP22: u1,
            /// Transmission Request Pending 23
            TRP23: u1,
            /// Transmission Request Pending 24
            TRP24: u1,
            /// Transmission Request Pending 25
            TRP25: u1,
            /// Transmission Request Pending 26
            TRP26: u1,
            /// Transmission Request Pending 27
            TRP27: u1,
            /// Transmission Request Pending 28
            TRP28: u1,
            /// Transmission Request Pending 29
            TRP29: u1,
            /// Transmission Request Pending 30
            TRP30: u1,
            /// Transmission Request Pending 31
            TRP31: u1,
        }), base_address + 0xcc);

        /// address: 0x420000d0
        /// Tx Buffer Add Request
        pub const TXBAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Add Request 0
            AR0: u1,
            /// Add Request 1
            AR1: u1,
            /// Add Request 2
            AR2: u1,
            /// Add Request 3
            AR3: u1,
            /// Add Request 4
            AR4: u1,
            /// Add Request 5
            AR5: u1,
            /// Add Request 6
            AR6: u1,
            /// Add Request 7
            AR7: u1,
            /// Add Request 8
            AR8: u1,
            /// Add Request 9
            AR9: u1,
            /// Add Request 10
            AR10: u1,
            /// Add Request 11
            AR11: u1,
            /// Add Request 12
            AR12: u1,
            /// Add Request 13
            AR13: u1,
            /// Add Request 14
            AR14: u1,
            /// Add Request 15
            AR15: u1,
            /// Add Request 16
            AR16: u1,
            /// Add Request 17
            AR17: u1,
            /// Add Request 18
            AR18: u1,
            /// Add Request 19
            AR19: u1,
            /// Add Request 20
            AR20: u1,
            /// Add Request 21
            AR21: u1,
            /// Add Request 22
            AR22: u1,
            /// Add Request 23
            AR23: u1,
            /// Add Request 24
            AR24: u1,
            /// Add Request 25
            AR25: u1,
            /// Add Request 26
            AR26: u1,
            /// Add Request 27
            AR27: u1,
            /// Add Request 28
            AR28: u1,
            /// Add Request 29
            AR29: u1,
            /// Add Request 30
            AR30: u1,
            /// Add Request 31
            AR31: u1,
        }), base_address + 0xd0);

        /// address: 0x420000d4
        /// Tx Buffer Cancellation Request
        pub const TXBCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Cancellation Request 0
            CR0: u1,
            /// Cancellation Request 1
            CR1: u1,
            /// Cancellation Request 2
            CR2: u1,
            /// Cancellation Request 3
            CR3: u1,
            /// Cancellation Request 4
            CR4: u1,
            /// Cancellation Request 5
            CR5: u1,
            /// Cancellation Request 6
            CR6: u1,
            /// Cancellation Request 7
            CR7: u1,
            /// Cancellation Request 8
            CR8: u1,
            /// Cancellation Request 9
            CR9: u1,
            /// Cancellation Request 10
            CR10: u1,
            /// Cancellation Request 11
            CR11: u1,
            /// Cancellation Request 12
            CR12: u1,
            /// Cancellation Request 13
            CR13: u1,
            /// Cancellation Request 14
            CR14: u1,
            /// Cancellation Request 15
            CR15: u1,
            /// Cancellation Request 16
            CR16: u1,
            /// Cancellation Request 17
            CR17: u1,
            /// Cancellation Request 18
            CR18: u1,
            /// Cancellation Request 19
            CR19: u1,
            /// Cancellation Request 20
            CR20: u1,
            /// Cancellation Request 21
            CR21: u1,
            /// Cancellation Request 22
            CR22: u1,
            /// Cancellation Request 23
            CR23: u1,
            /// Cancellation Request 24
            CR24: u1,
            /// Cancellation Request 25
            CR25: u1,
            /// Cancellation Request 26
            CR26: u1,
            /// Cancellation Request 27
            CR27: u1,
            /// Cancellation Request 28
            CR28: u1,
            /// Cancellation Request 29
            CR29: u1,
            /// Cancellation Request 30
            CR30: u1,
            /// Cancellation Request 31
            CR31: u1,
        }), base_address + 0xd4);

        /// address: 0x420000d8
        /// Tx Buffer Transmission Occurred
        pub const TXBTO = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmission Occurred 0
            TO0: u1,
            /// Transmission Occurred 1
            TO1: u1,
            /// Transmission Occurred 2
            TO2: u1,
            /// Transmission Occurred 3
            TO3: u1,
            /// Transmission Occurred 4
            TO4: u1,
            /// Transmission Occurred 5
            TO5: u1,
            /// Transmission Occurred 6
            TO6: u1,
            /// Transmission Occurred 7
            TO7: u1,
            /// Transmission Occurred 8
            TO8: u1,
            /// Transmission Occurred 9
            TO9: u1,
            /// Transmission Occurred 10
            TO10: u1,
            /// Transmission Occurred 11
            TO11: u1,
            /// Transmission Occurred 12
            TO12: u1,
            /// Transmission Occurred 13
            TO13: u1,
            /// Transmission Occurred 14
            TO14: u1,
            /// Transmission Occurred 15
            TO15: u1,
            /// Transmission Occurred 16
            TO16: u1,
            /// Transmission Occurred 17
            TO17: u1,
            /// Transmission Occurred 18
            TO18: u1,
            /// Transmission Occurred 19
            TO19: u1,
            /// Transmission Occurred 20
            TO20: u1,
            /// Transmission Occurred 21
            TO21: u1,
            /// Transmission Occurred 22
            TO22: u1,
            /// Transmission Occurred 23
            TO23: u1,
            /// Transmission Occurred 24
            TO24: u1,
            /// Transmission Occurred 25
            TO25: u1,
            /// Transmission Occurred 26
            TO26: u1,
            /// Transmission Occurred 27
            TO27: u1,
            /// Transmission Occurred 28
            TO28: u1,
            /// Transmission Occurred 29
            TO29: u1,
            /// Transmission Occurred 30
            TO30: u1,
            /// Transmission Occurred 31
            TO31: u1,
        }), base_address + 0xd8);

        /// address: 0x420000dc
        /// Tx Buffer Cancellation Finished
        pub const TXBCF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx Buffer Cancellation Finished 0
            CF0: u1,
            /// Tx Buffer Cancellation Finished 1
            CF1: u1,
            /// Tx Buffer Cancellation Finished 2
            CF2: u1,
            /// Tx Buffer Cancellation Finished 3
            CF3: u1,
            /// Tx Buffer Cancellation Finished 4
            CF4: u1,
            /// Tx Buffer Cancellation Finished 5
            CF5: u1,
            /// Tx Buffer Cancellation Finished 6
            CF6: u1,
            /// Tx Buffer Cancellation Finished 7
            CF7: u1,
            /// Tx Buffer Cancellation Finished 8
            CF8: u1,
            /// Tx Buffer Cancellation Finished 9
            CF9: u1,
            /// Tx Buffer Cancellation Finished 10
            CF10: u1,
            /// Tx Buffer Cancellation Finished 11
            CF11: u1,
            /// Tx Buffer Cancellation Finished 12
            CF12: u1,
            /// Tx Buffer Cancellation Finished 13
            CF13: u1,
            /// Tx Buffer Cancellation Finished 14
            CF14: u1,
            /// Tx Buffer Cancellation Finished 15
            CF15: u1,
            /// Tx Buffer Cancellation Finished 16
            CF16: u1,
            /// Tx Buffer Cancellation Finished 17
            CF17: u1,
            /// Tx Buffer Cancellation Finished 18
            CF18: u1,
            /// Tx Buffer Cancellation Finished 19
            CF19: u1,
            /// Tx Buffer Cancellation Finished 20
            CF20: u1,
            /// Tx Buffer Cancellation Finished 21
            CF21: u1,
            /// Tx Buffer Cancellation Finished 22
            CF22: u1,
            /// Tx Buffer Cancellation Finished 23
            CF23: u1,
            /// Tx Buffer Cancellation Finished 24
            CF24: u1,
            /// Tx Buffer Cancellation Finished 25
            CF25: u1,
            /// Tx Buffer Cancellation Finished 26
            CF26: u1,
            /// Tx Buffer Cancellation Finished 27
            CF27: u1,
            /// Tx Buffer Cancellation Finished 28
            CF28: u1,
            /// Tx Buffer Cancellation Finished 29
            CF29: u1,
            /// Tx Buffer Cancellation Finished 30
            CF30: u1,
            /// Tx Buffer Cancellation Finished 31
            CF31: u1,
        }), base_address + 0xdc);

        /// address: 0x420000e0
        /// Tx Buffer Transmission Interrupt Enable
        pub const TXBTIE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmission Interrupt Enable 0
            TIE0: u1,
            /// Transmission Interrupt Enable 1
            TIE1: u1,
            /// Transmission Interrupt Enable 2
            TIE2: u1,
            /// Transmission Interrupt Enable 3
            TIE3: u1,
            /// Transmission Interrupt Enable 4
            TIE4: u1,
            /// Transmission Interrupt Enable 5
            TIE5: u1,
            /// Transmission Interrupt Enable 6
            TIE6: u1,
            /// Transmission Interrupt Enable 7
            TIE7: u1,
            /// Transmission Interrupt Enable 8
            TIE8: u1,
            /// Transmission Interrupt Enable 9
            TIE9: u1,
            /// Transmission Interrupt Enable 10
            TIE10: u1,
            /// Transmission Interrupt Enable 11
            TIE11: u1,
            /// Transmission Interrupt Enable 12
            TIE12: u1,
            /// Transmission Interrupt Enable 13
            TIE13: u1,
            /// Transmission Interrupt Enable 14
            TIE14: u1,
            /// Transmission Interrupt Enable 15
            TIE15: u1,
            /// Transmission Interrupt Enable 16
            TIE16: u1,
            /// Transmission Interrupt Enable 17
            TIE17: u1,
            /// Transmission Interrupt Enable 18
            TIE18: u1,
            /// Transmission Interrupt Enable 19
            TIE19: u1,
            /// Transmission Interrupt Enable 20
            TIE20: u1,
            /// Transmission Interrupt Enable 21
            TIE21: u1,
            /// Transmission Interrupt Enable 22
            TIE22: u1,
            /// Transmission Interrupt Enable 23
            TIE23: u1,
            /// Transmission Interrupt Enable 24
            TIE24: u1,
            /// Transmission Interrupt Enable 25
            TIE25: u1,
            /// Transmission Interrupt Enable 26
            TIE26: u1,
            /// Transmission Interrupt Enable 27
            TIE27: u1,
            /// Transmission Interrupt Enable 28
            TIE28: u1,
            /// Transmission Interrupt Enable 29
            TIE29: u1,
            /// Transmission Interrupt Enable 30
            TIE30: u1,
            /// Transmission Interrupt Enable 31
            TIE31: u1,
        }), base_address + 0xe0);

        /// address: 0x420000e4
        /// Tx Buffer Cancellation Finished Interrupt Enable
        pub const TXBCIE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Cancellation Finished Interrupt Enable 0
            CFIE0: u1,
            /// Cancellation Finished Interrupt Enable 1
            CFIE1: u1,
            /// Cancellation Finished Interrupt Enable 2
            CFIE2: u1,
            /// Cancellation Finished Interrupt Enable 3
            CFIE3: u1,
            /// Cancellation Finished Interrupt Enable 4
            CFIE4: u1,
            /// Cancellation Finished Interrupt Enable 5
            CFIE5: u1,
            /// Cancellation Finished Interrupt Enable 6
            CFIE6: u1,
            /// Cancellation Finished Interrupt Enable 7
            CFIE7: u1,
            /// Cancellation Finished Interrupt Enable 8
            CFIE8: u1,
            /// Cancellation Finished Interrupt Enable 9
            CFIE9: u1,
            /// Cancellation Finished Interrupt Enable 10
            CFIE10: u1,
            /// Cancellation Finished Interrupt Enable 11
            CFIE11: u1,
            /// Cancellation Finished Interrupt Enable 12
            CFIE12: u1,
            /// Cancellation Finished Interrupt Enable 13
            CFIE13: u1,
            /// Cancellation Finished Interrupt Enable 14
            CFIE14: u1,
            /// Cancellation Finished Interrupt Enable 15
            CFIE15: u1,
            /// Cancellation Finished Interrupt Enable 16
            CFIE16: u1,
            /// Cancellation Finished Interrupt Enable 17
            CFIE17: u1,
            /// Cancellation Finished Interrupt Enable 18
            CFIE18: u1,
            /// Cancellation Finished Interrupt Enable 19
            CFIE19: u1,
            /// Cancellation Finished Interrupt Enable 20
            CFIE20: u1,
            /// Cancellation Finished Interrupt Enable 21
            CFIE21: u1,
            /// Cancellation Finished Interrupt Enable 22
            CFIE22: u1,
            /// Cancellation Finished Interrupt Enable 23
            CFIE23: u1,
            /// Cancellation Finished Interrupt Enable 24
            CFIE24: u1,
            /// Cancellation Finished Interrupt Enable 25
            CFIE25: u1,
            /// Cancellation Finished Interrupt Enable 26
            CFIE26: u1,
            /// Cancellation Finished Interrupt Enable 27
            CFIE27: u1,
            /// Cancellation Finished Interrupt Enable 28
            CFIE28: u1,
            /// Cancellation Finished Interrupt Enable 29
            CFIE29: u1,
            /// Cancellation Finished Interrupt Enable 30
            CFIE30: u1,
            /// Cancellation Finished Interrupt Enable 31
            CFIE31: u1,
        }), base_address + 0xe4);

        /// address: 0x420000f0
        /// Tx Event FIFO Configuration
        pub const TXEFC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Event FIFO Start Address
            EFSA: u16,
            /// Event FIFO Size
            EFS: u6,
            reserved0: u1,
            reserved1: u1,
            /// Event FIFO Watermark
            EFWM: u6,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xf0);

        /// address: 0x420000f4
        /// Tx Event FIFO Status
        pub const TXEFS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Event FIFO Fill Level
            EFFL: u6,
            reserved0: u1,
            reserved1: u1,
            /// Event FIFO Get Index
            EFGI: u5,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Event FIFO Put Index
            EFPI: u5,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Event FIFO Full
            EFF: u1,
            /// Tx Event FIFO Element Lost
            TEFL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0xf4);

        /// address: 0x420000f8
        /// Tx Event FIFO Acknowledge
        pub const TXEFA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Event FIFO Acknowledge Index
            EFAI: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0xf8);
    };
    pub const CAN1 = struct {
        pub const base_address = 0x42000400;

        /// address: 0x42000400
        /// Core Release
        pub const CREL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// Sub-step of Core Release
            SUBSTEP: u4,
            /// Step of Core Release
            STEP: u4,
            /// Core Release
            REL: u4,
        }), base_address + 0x0);

        /// address: 0x42000404
        /// Endian
        pub const ENDN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endianness Test Value
            ETV: u32,
        }), base_address + 0x4);

        /// address: 0x42000408
        /// Message RAM Configuration
        pub const MRCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Quality of Service
            QOS: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x8);

        /// address: 0x4200040c
        /// Fast Bit Timing and Prescaler
        pub const DBTP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data (Re)Synchronization Jump Width
            DSJW: u4,
            /// Data time segment after sample point
            DTSEG2: u4,
            /// Data time segment before sample point
            DTSEG1: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Data Baud Rate Prescaler
            DBRP: u5,
            reserved3: u1,
            reserved4: u1,
            /// Tranceiver Delay Compensation
            TDC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xc);

        /// address: 0x42000410
        /// Test
        pub const TEST = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Loop Back Mode
            LBCK: u1,
            /// Control of Transmit Pin
            TX: u2,
            /// Receive Pin
            RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x42000414
        /// RAM Watchdog
        pub const RWD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog Configuration
            WDC: u8,
            /// Watchdog Value
            WDV: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x42000418
        /// CC Control
        pub const CCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Initialization
            INIT: u1,
            /// Configuration Change Enable
            CCE: u1,
            /// ASM Restricted Operation Mode
            ASM: u1,
            /// Clock Stop Acknowledge
            CSA: u1,
            /// Clock Stop Request
            CSR: u1,
            /// Bus Monitoring Mode
            MON: u1,
            /// Disable Automatic Retransmission
            DAR: u1,
            /// Test Mode Enable
            TEST: u1,
            /// FD Operation Enable
            FDOE: u1,
            /// Bit Rate Switch Enable
            BRSE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Protocol Exception Handling Disable
            PXHD: u1,
            /// Edge Filtering during Bus Integration
            EFBI: u1,
            /// Transmit Pause
            TXP: u1,
            /// Non ISO Operation
            NISO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4200041c
        /// Nominal Bit Timing and Prescaler
        pub const NBTP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Nominal Time segment after sample point
            NTSEG2: u7,
            reserved0: u1,
            /// Nominal Time segment before sample point
            NTSEG1: u8,
            /// Nominal Baud Rate Prescaler
            NBRP: u9,
            /// Nominal (Re)Synchronization Jump Width
            NSJW: u7,
        }), base_address + 0x1c);

        /// address: 0x42000420
        /// Timestamp Counter Configuration
        pub const TSCC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timestamp Select
            TSS: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Timestamp Counter Prescaler
            TCP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x20);

        /// address: 0x42000424
        /// Timestamp Counter Value
        pub const TSCV = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timestamp Counter
            TSC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x24);

        /// address: 0x42000428
        /// Timeout Counter Configuration
        pub const TOCC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable Timeout Counter
            ETOC: u1,
            /// Timeout Select
            TOS: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Timeout Period
            TOP: u16,
        }), base_address + 0x28);

        /// address: 0x4200042c
        /// Timeout Counter Value
        pub const TOCV = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timeout Counter
            TOC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2c);

        /// address: 0x42000440
        /// Error Counter
        pub const ECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Error Counter
            TEC: u8,
            /// Receive Error Counter
            REC: u7,
            /// Receive Error Passive
            RP: u1,
            /// CAN Error Logging
            CEL: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x42000444
        /// Protocol Status
        pub const PSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Last Error Code
            LEC: u3,
            /// Activity
            ACT: u2,
            /// Error Passive
            EP: u1,
            /// Warning Status
            EW: u1,
            /// Bus_Off Status
            BO: u1,
            /// Data Phase Last Error Code
            DLEC: u3,
            /// ESI flag of last received CAN FD Message
            RESI: u1,
            /// BRS flag of last received CAN FD Message
            RBRS: u1,
            /// Received a CAN FD Message
            RFDF: u1,
            /// Protocol Exception Event
            PXE: u1,
            reserved0: u1,
            /// Transmitter Delay Compensation Value
            TDCV: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x44);

        /// address: 0x42000448
        /// Extended ID Filter Configuration
        pub const TDCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmitter Delay Compensation Filter Length
            TDCF: u7,
            reserved0: u1,
            /// Transmitter Delay Compensation Offset
            TDCO: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x48);

        /// address: 0x42000450
        /// Interrupt
        pub const IR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 0 New Message
            RF0N: u1,
            /// Rx FIFO 0 Watermark Reached
            RF0W: u1,
            /// Rx FIFO 0 Full
            RF0F: u1,
            /// Rx FIFO 0 Message Lost
            RF0L: u1,
            /// Rx FIFO 1 New Message
            RF1N: u1,
            /// Rx FIFO 1 Watermark Reached
            RF1W: u1,
            /// Rx FIFO 1 FIFO Full
            RF1F: u1,
            /// Rx FIFO 1 Message Lost
            RF1L: u1,
            /// High Priority Message
            HPM: u1,
            /// Timestamp Completed
            TC: u1,
            /// Transmission Cancellation Finished
            TCF: u1,
            /// Tx FIFO Empty
            TFE: u1,
            /// Tx Event FIFO New Entry
            TEFN: u1,
            /// Tx Event FIFO Watermark Reached
            TEFW: u1,
            /// Tx Event FIFO Full
            TEFF: u1,
            /// Tx Event FIFO Element Lost
            TEFL: u1,
            /// Timestamp Wraparound
            TSW: u1,
            /// Message RAM Access Failure
            MRAF: u1,
            /// Timeout Occurred
            TOO: u1,
            /// Message stored to Dedicated Rx Buffer
            DRX: u1,
            /// Bit Error Corrected
            BEC: u1,
            /// Bit Error Uncorrected
            BEU: u1,
            /// Error Logging Overflow
            ELO: u1,
            /// Error Passive
            EP: u1,
            /// Warning Status
            EW: u1,
            /// Bus_Off Status
            BO: u1,
            /// Watchdog Interrupt
            WDI: u1,
            /// Protocol Error in Arbitration Phase
            PEA: u1,
            /// Protocol Error in Data Phase
            PED: u1,
            /// Access to Reserved Address
            ARA: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x50);

        /// address: 0x42000454
        /// Interrupt Enable
        pub const IE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 0 New Message Interrupt Enable
            RF0NE: u1,
            /// Rx FIFO 0 Watermark Reached Interrupt Enable
            RF0WE: u1,
            /// Rx FIFO 0 Full Interrupt Enable
            RF0FE: u1,
            /// Rx FIFO 0 Message Lost Interrupt Enable
            RF0LE: u1,
            /// Rx FIFO 1 New Message Interrupt Enable
            RF1NE: u1,
            /// Rx FIFO 1 Watermark Reached Interrupt Enable
            RF1WE: u1,
            /// Rx FIFO 1 FIFO Full Interrupt Enable
            RF1FE: u1,
            /// Rx FIFO 1 Message Lost Interrupt Enable
            RF1LE: u1,
            /// High Priority Message Interrupt Enable
            HPME: u1,
            /// Timestamp Completed Interrupt Enable
            TCE: u1,
            /// Transmission Cancellation Finished Interrupt Enable
            TCFE: u1,
            /// Tx FIFO Empty Interrupt Enable
            TFEE: u1,
            /// Tx Event FIFO New Entry Interrupt Enable
            TEFNE: u1,
            /// Tx Event FIFO Watermark Reached Interrupt Enable
            TEFWE: u1,
            /// Tx Event FIFO Full Interrupt Enable
            TEFFE: u1,
            /// Tx Event FIFO Element Lost Interrupt Enable
            TEFLE: u1,
            /// Timestamp Wraparound Interrupt Enable
            TSWE: u1,
            /// Message RAM Access Failure Interrupt Enable
            MRAFE: u1,
            /// Timeout Occurred Interrupt Enable
            TOOE: u1,
            /// Message stored to Dedicated Rx Buffer Interrupt Enable
            DRXE: u1,
            /// Bit Error Corrected Interrupt Enable
            BECE: u1,
            /// Bit Error Uncorrected Interrupt Enable
            BEUE: u1,
            /// Error Logging Overflow Interrupt Enable
            ELOE: u1,
            /// Error Passive Interrupt Enable
            EPE: u1,
            /// Warning Status Interrupt Enable
            EWE: u1,
            /// Bus_Off Status Interrupt Enable
            BOE: u1,
            /// Watchdog Interrupt Interrupt Enable
            WDIE: u1,
            /// Protocol Error in Arbitration Phase Enable
            PEAE: u1,
            /// Protocol Error in Data Phase Enable
            PEDE: u1,
            /// Access to Reserved Address Enable
            ARAE: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x54);

        /// address: 0x42000458
        /// Interrupt Line Select
        pub const ILS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 0 New Message Interrupt Line
            RF0NL: u1,
            /// Rx FIFO 0 Watermark Reached Interrupt Line
            RF0WL: u1,
            /// Rx FIFO 0 Full Interrupt Line
            RF0FL: u1,
            /// Rx FIFO 0 Message Lost Interrupt Line
            RF0LL: u1,
            /// Rx FIFO 1 New Message Interrupt Line
            RF1NL: u1,
            /// Rx FIFO 1 Watermark Reached Interrupt Line
            RF1WL: u1,
            /// Rx FIFO 1 FIFO Full Interrupt Line
            RF1FL: u1,
            /// Rx FIFO 1 Message Lost Interrupt Line
            RF1LL: u1,
            /// High Priority Message Interrupt Line
            HPML: u1,
            /// Timestamp Completed Interrupt Line
            TCL: u1,
            /// Transmission Cancellation Finished Interrupt Line
            TCFL: u1,
            /// Tx FIFO Empty Interrupt Line
            TFEL: u1,
            /// Tx Event FIFO New Entry Interrupt Line
            TEFNL: u1,
            /// Tx Event FIFO Watermark Reached Interrupt Line
            TEFWL: u1,
            /// Tx Event FIFO Full Interrupt Line
            TEFFL: u1,
            /// Tx Event FIFO Element Lost Interrupt Line
            TEFLL: u1,
            /// Timestamp Wraparound Interrupt Line
            TSWL: u1,
            /// Message RAM Access Failure Interrupt Line
            MRAFL: u1,
            /// Timeout Occurred Interrupt Line
            TOOL: u1,
            /// Message stored to Dedicated Rx Buffer Interrupt Line
            DRXL: u1,
            /// Bit Error Corrected Interrupt Line
            BECL: u1,
            /// Bit Error Uncorrected Interrupt Line
            BEUL: u1,
            /// Error Logging Overflow Interrupt Line
            ELOL: u1,
            /// Error Passive Interrupt Line
            EPL: u1,
            /// Warning Status Interrupt Line
            EWL: u1,
            /// Bus_Off Status Interrupt Line
            BOL: u1,
            /// Watchdog Interrupt Interrupt Line
            WDIL: u1,
            /// Protocol Error in Arbitration Phase Line
            PEAL: u1,
            /// Protocol Error in Data Phase Line
            PEDL: u1,
            /// Access to Reserved Address Line
            ARAL: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x58);

        /// address: 0x4200045c
        /// Interrupt Line Enable
        pub const ILE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable Interrupt Line 0
            EINT0: u1,
            /// Enable Interrupt Line 1
            EINT1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x5c);

        /// address: 0x42000480
        /// Global Filter Configuration
        pub const GFC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reject Remote Frames Extended
            RRFE: u1,
            /// Reject Remote Frames Standard
            RRFS: u1,
            /// Accept Non-matching Frames Extended
            ANFE: u2,
            /// Accept Non-matching Frames Standard
            ANFS: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x80);

        /// address: 0x42000484
        /// Standard ID Filter Configuration
        pub const SIDFC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter List Standard Start Address
            FLSSA: u16,
            /// List Size Standard
            LSS: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x84);

        /// address: 0x42000488
        /// Extended ID Filter Configuration
        pub const XIDFC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter List Extended Start Address
            FLESA: u16,
            /// List Size Extended
            LSE: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x88);

        /// address: 0x42000490
        /// Extended ID AND Mask
        pub const XIDAM = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extended ID Mask
            EIDM: u29,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x90);

        /// address: 0x42000494
        /// High Priority Message Status
        pub const HPMS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Index
            BIDX: u6,
            /// Message Storage Indicator
            MSI: u2,
            /// Filter Index
            FIDX: u7,
            /// Filter List
            FLST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x94);

        /// address: 0x42000498
        /// New Data 1
        pub const NDAT1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// New Data 0
            ND0: u1,
            /// New Data 1
            ND1: u1,
            /// New Data 2
            ND2: u1,
            /// New Data 3
            ND3: u1,
            /// New Data 4
            ND4: u1,
            /// New Data 5
            ND5: u1,
            /// New Data 6
            ND6: u1,
            /// New Data 7
            ND7: u1,
            /// New Data 8
            ND8: u1,
            /// New Data 9
            ND9: u1,
            /// New Data 10
            ND10: u1,
            /// New Data 11
            ND11: u1,
            /// New Data 12
            ND12: u1,
            /// New Data 13
            ND13: u1,
            /// New Data 14
            ND14: u1,
            /// New Data 15
            ND15: u1,
            /// New Data 16
            ND16: u1,
            /// New Data 17
            ND17: u1,
            /// New Data 18
            ND18: u1,
            /// New Data 19
            ND19: u1,
            /// New Data 20
            ND20: u1,
            /// New Data 21
            ND21: u1,
            /// New Data 22
            ND22: u1,
            /// New Data 23
            ND23: u1,
            /// New Data 24
            ND24: u1,
            /// New Data 25
            ND25: u1,
            /// New Data 26
            ND26: u1,
            /// New Data 27
            ND27: u1,
            /// New Data 28
            ND28: u1,
            /// New Data 29
            ND29: u1,
            /// New Data 30
            ND30: u1,
            /// New Data 31
            ND31: u1,
        }), base_address + 0x98);

        /// address: 0x4200049c
        /// New Data 2
        pub const NDAT2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// New Data 32
            ND32: u1,
            /// New Data 33
            ND33: u1,
            /// New Data 34
            ND34: u1,
            /// New Data 35
            ND35: u1,
            /// New Data 36
            ND36: u1,
            /// New Data 37
            ND37: u1,
            /// New Data 38
            ND38: u1,
            /// New Data 39
            ND39: u1,
            /// New Data 40
            ND40: u1,
            /// New Data 41
            ND41: u1,
            /// New Data 42
            ND42: u1,
            /// New Data 43
            ND43: u1,
            /// New Data 44
            ND44: u1,
            /// New Data 45
            ND45: u1,
            /// New Data 46
            ND46: u1,
            /// New Data 47
            ND47: u1,
            /// New Data 48
            ND48: u1,
            /// New Data 49
            ND49: u1,
            /// New Data 50
            ND50: u1,
            /// New Data 51
            ND51: u1,
            /// New Data 52
            ND52: u1,
            /// New Data 53
            ND53: u1,
            /// New Data 54
            ND54: u1,
            /// New Data 55
            ND55: u1,
            /// New Data 56
            ND56: u1,
            /// New Data 57
            ND57: u1,
            /// New Data 58
            ND58: u1,
            /// New Data 59
            ND59: u1,
            /// New Data 60
            ND60: u1,
            /// New Data 61
            ND61: u1,
            /// New Data 62
            ND62: u1,
            /// New Data 63
            ND63: u1,
        }), base_address + 0x9c);

        /// address: 0x420004a0
        /// Rx FIFO 0 Configuration
        pub const RXF0C = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 0 Start Address
            F0SA: u16,
            /// Rx FIFO 0 Size
            F0S: u7,
            reserved0: u1,
            /// Rx FIFO 0 Watermark
            F0WM: u7,
            /// FIFO 0 Operation Mode
            F0OM: u1,
        }), base_address + 0xa0);

        /// address: 0x420004a4
        /// Rx FIFO 0 Status
        pub const RXF0S = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 0 Fill Level
            F0FL: u7,
            reserved0: u1,
            /// Rx FIFO 0 Get Index
            F0GI: u6,
            reserved1: u1,
            reserved2: u1,
            /// Rx FIFO 0 Put Index
            F0PI: u6,
            reserved3: u1,
            reserved4: u1,
            /// Rx FIFO 0 Full
            F0F: u1,
            /// Rx FIFO 0 Message Lost
            RF0L: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0xa4);

        /// address: 0x420004a8
        /// Rx FIFO 0 Acknowledge
        pub const RXF0A = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 0 Acknowledge Index
            F0AI: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xa8);

        /// address: 0x420004ac
        /// Rx Buffer Configuration
        pub const RXBC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx Buffer Start Address
            RBSA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xac);

        /// address: 0x420004b0
        /// Rx FIFO 1 Configuration
        pub const RXF1C = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 1 Start Address
            F1SA: u16,
            /// Rx FIFO 1 Size
            F1S: u7,
            reserved0: u1,
            /// Rx FIFO 1 Watermark
            F1WM: u7,
            /// FIFO 1 Operation Mode
            F1OM: u1,
        }), base_address + 0xb0);

        /// address: 0x420004b4
        /// Rx FIFO 1 Status
        pub const RXF1S = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 1 Fill Level
            F1FL: u7,
            reserved0: u1,
            /// Rx FIFO 1 Get Index
            F1GI: u6,
            reserved1: u1,
            reserved2: u1,
            /// Rx FIFO 1 Put Index
            F1PI: u6,
            reserved3: u1,
            reserved4: u1,
            /// Rx FIFO 1 Full
            F1F: u1,
            /// Rx FIFO 1 Message Lost
            RF1L: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Debug Message Status
            DMS: u2,
        }), base_address + 0xb4);

        /// address: 0x420004b8
        /// Rx FIFO 1 Acknowledge
        pub const RXF1A = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 1 Acknowledge Index
            F1AI: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xb8);

        /// address: 0x420004bc
        /// Rx Buffer / FIFO Element Size Configuration
        pub const RXESC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx FIFO 0 Data Field Size
            F0DS: u3,
            reserved0: u1,
            /// Rx FIFO 1 Data Field Size
            F1DS: u3,
            reserved1: u1,
            /// Rx Buffer Data Field Size
            RBDS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0xbc);

        /// address: 0x420004c0
        /// Tx Buffer Configuration
        pub const TXBC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx Buffers Start Address
            TBSA: u16,
            /// Number of Dedicated Transmit Buffers
            NDTB: u6,
            reserved0: u1,
            reserved1: u1,
            /// Transmit FIFO/Queue Size
            TFQS: u6,
            /// Tx FIFO/Queue Mode
            TFQM: u1,
            padding0: u1,
        }), base_address + 0xc0);

        /// address: 0x420004c4
        /// Tx FIFO / Queue Status
        pub const TXFQS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx FIFO Free Level
            TFFL: u6,
            reserved0: u1,
            reserved1: u1,
            /// Tx FIFO Get Index
            TFGI: u5,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Tx FIFO/Queue Put Index
            TFQPI: u5,
            /// Tx FIFO/Queue Full
            TFQF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0xc4);

        /// address: 0x420004c8
        /// Tx Buffer Element Size Configuration
        pub const TXESC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx Buffer Data Field Size
            TBDS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xc8);

        /// address: 0x420004cc
        /// Tx Buffer Request Pending
        pub const TXBRP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmission Request Pending 0
            TRP0: u1,
            /// Transmission Request Pending 1
            TRP1: u1,
            /// Transmission Request Pending 2
            TRP2: u1,
            /// Transmission Request Pending 3
            TRP3: u1,
            /// Transmission Request Pending 4
            TRP4: u1,
            /// Transmission Request Pending 5
            TRP5: u1,
            /// Transmission Request Pending 6
            TRP6: u1,
            /// Transmission Request Pending 7
            TRP7: u1,
            /// Transmission Request Pending 8
            TRP8: u1,
            /// Transmission Request Pending 9
            TRP9: u1,
            /// Transmission Request Pending 10
            TRP10: u1,
            /// Transmission Request Pending 11
            TRP11: u1,
            /// Transmission Request Pending 12
            TRP12: u1,
            /// Transmission Request Pending 13
            TRP13: u1,
            /// Transmission Request Pending 14
            TRP14: u1,
            /// Transmission Request Pending 15
            TRP15: u1,
            /// Transmission Request Pending 16
            TRP16: u1,
            /// Transmission Request Pending 17
            TRP17: u1,
            /// Transmission Request Pending 18
            TRP18: u1,
            /// Transmission Request Pending 19
            TRP19: u1,
            /// Transmission Request Pending 20
            TRP20: u1,
            /// Transmission Request Pending 21
            TRP21: u1,
            /// Transmission Request Pending 22
            TRP22: u1,
            /// Transmission Request Pending 23
            TRP23: u1,
            /// Transmission Request Pending 24
            TRP24: u1,
            /// Transmission Request Pending 25
            TRP25: u1,
            /// Transmission Request Pending 26
            TRP26: u1,
            /// Transmission Request Pending 27
            TRP27: u1,
            /// Transmission Request Pending 28
            TRP28: u1,
            /// Transmission Request Pending 29
            TRP29: u1,
            /// Transmission Request Pending 30
            TRP30: u1,
            /// Transmission Request Pending 31
            TRP31: u1,
        }), base_address + 0xcc);

        /// address: 0x420004d0
        /// Tx Buffer Add Request
        pub const TXBAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Add Request 0
            AR0: u1,
            /// Add Request 1
            AR1: u1,
            /// Add Request 2
            AR2: u1,
            /// Add Request 3
            AR3: u1,
            /// Add Request 4
            AR4: u1,
            /// Add Request 5
            AR5: u1,
            /// Add Request 6
            AR6: u1,
            /// Add Request 7
            AR7: u1,
            /// Add Request 8
            AR8: u1,
            /// Add Request 9
            AR9: u1,
            /// Add Request 10
            AR10: u1,
            /// Add Request 11
            AR11: u1,
            /// Add Request 12
            AR12: u1,
            /// Add Request 13
            AR13: u1,
            /// Add Request 14
            AR14: u1,
            /// Add Request 15
            AR15: u1,
            /// Add Request 16
            AR16: u1,
            /// Add Request 17
            AR17: u1,
            /// Add Request 18
            AR18: u1,
            /// Add Request 19
            AR19: u1,
            /// Add Request 20
            AR20: u1,
            /// Add Request 21
            AR21: u1,
            /// Add Request 22
            AR22: u1,
            /// Add Request 23
            AR23: u1,
            /// Add Request 24
            AR24: u1,
            /// Add Request 25
            AR25: u1,
            /// Add Request 26
            AR26: u1,
            /// Add Request 27
            AR27: u1,
            /// Add Request 28
            AR28: u1,
            /// Add Request 29
            AR29: u1,
            /// Add Request 30
            AR30: u1,
            /// Add Request 31
            AR31: u1,
        }), base_address + 0xd0);

        /// address: 0x420004d4
        /// Tx Buffer Cancellation Request
        pub const TXBCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Cancellation Request 0
            CR0: u1,
            /// Cancellation Request 1
            CR1: u1,
            /// Cancellation Request 2
            CR2: u1,
            /// Cancellation Request 3
            CR3: u1,
            /// Cancellation Request 4
            CR4: u1,
            /// Cancellation Request 5
            CR5: u1,
            /// Cancellation Request 6
            CR6: u1,
            /// Cancellation Request 7
            CR7: u1,
            /// Cancellation Request 8
            CR8: u1,
            /// Cancellation Request 9
            CR9: u1,
            /// Cancellation Request 10
            CR10: u1,
            /// Cancellation Request 11
            CR11: u1,
            /// Cancellation Request 12
            CR12: u1,
            /// Cancellation Request 13
            CR13: u1,
            /// Cancellation Request 14
            CR14: u1,
            /// Cancellation Request 15
            CR15: u1,
            /// Cancellation Request 16
            CR16: u1,
            /// Cancellation Request 17
            CR17: u1,
            /// Cancellation Request 18
            CR18: u1,
            /// Cancellation Request 19
            CR19: u1,
            /// Cancellation Request 20
            CR20: u1,
            /// Cancellation Request 21
            CR21: u1,
            /// Cancellation Request 22
            CR22: u1,
            /// Cancellation Request 23
            CR23: u1,
            /// Cancellation Request 24
            CR24: u1,
            /// Cancellation Request 25
            CR25: u1,
            /// Cancellation Request 26
            CR26: u1,
            /// Cancellation Request 27
            CR27: u1,
            /// Cancellation Request 28
            CR28: u1,
            /// Cancellation Request 29
            CR29: u1,
            /// Cancellation Request 30
            CR30: u1,
            /// Cancellation Request 31
            CR31: u1,
        }), base_address + 0xd4);

        /// address: 0x420004d8
        /// Tx Buffer Transmission Occurred
        pub const TXBTO = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmission Occurred 0
            TO0: u1,
            /// Transmission Occurred 1
            TO1: u1,
            /// Transmission Occurred 2
            TO2: u1,
            /// Transmission Occurred 3
            TO3: u1,
            /// Transmission Occurred 4
            TO4: u1,
            /// Transmission Occurred 5
            TO5: u1,
            /// Transmission Occurred 6
            TO6: u1,
            /// Transmission Occurred 7
            TO7: u1,
            /// Transmission Occurred 8
            TO8: u1,
            /// Transmission Occurred 9
            TO9: u1,
            /// Transmission Occurred 10
            TO10: u1,
            /// Transmission Occurred 11
            TO11: u1,
            /// Transmission Occurred 12
            TO12: u1,
            /// Transmission Occurred 13
            TO13: u1,
            /// Transmission Occurred 14
            TO14: u1,
            /// Transmission Occurred 15
            TO15: u1,
            /// Transmission Occurred 16
            TO16: u1,
            /// Transmission Occurred 17
            TO17: u1,
            /// Transmission Occurred 18
            TO18: u1,
            /// Transmission Occurred 19
            TO19: u1,
            /// Transmission Occurred 20
            TO20: u1,
            /// Transmission Occurred 21
            TO21: u1,
            /// Transmission Occurred 22
            TO22: u1,
            /// Transmission Occurred 23
            TO23: u1,
            /// Transmission Occurred 24
            TO24: u1,
            /// Transmission Occurred 25
            TO25: u1,
            /// Transmission Occurred 26
            TO26: u1,
            /// Transmission Occurred 27
            TO27: u1,
            /// Transmission Occurred 28
            TO28: u1,
            /// Transmission Occurred 29
            TO29: u1,
            /// Transmission Occurred 30
            TO30: u1,
            /// Transmission Occurred 31
            TO31: u1,
        }), base_address + 0xd8);

        /// address: 0x420004dc
        /// Tx Buffer Cancellation Finished
        pub const TXBCF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx Buffer Cancellation Finished 0
            CF0: u1,
            /// Tx Buffer Cancellation Finished 1
            CF1: u1,
            /// Tx Buffer Cancellation Finished 2
            CF2: u1,
            /// Tx Buffer Cancellation Finished 3
            CF3: u1,
            /// Tx Buffer Cancellation Finished 4
            CF4: u1,
            /// Tx Buffer Cancellation Finished 5
            CF5: u1,
            /// Tx Buffer Cancellation Finished 6
            CF6: u1,
            /// Tx Buffer Cancellation Finished 7
            CF7: u1,
            /// Tx Buffer Cancellation Finished 8
            CF8: u1,
            /// Tx Buffer Cancellation Finished 9
            CF9: u1,
            /// Tx Buffer Cancellation Finished 10
            CF10: u1,
            /// Tx Buffer Cancellation Finished 11
            CF11: u1,
            /// Tx Buffer Cancellation Finished 12
            CF12: u1,
            /// Tx Buffer Cancellation Finished 13
            CF13: u1,
            /// Tx Buffer Cancellation Finished 14
            CF14: u1,
            /// Tx Buffer Cancellation Finished 15
            CF15: u1,
            /// Tx Buffer Cancellation Finished 16
            CF16: u1,
            /// Tx Buffer Cancellation Finished 17
            CF17: u1,
            /// Tx Buffer Cancellation Finished 18
            CF18: u1,
            /// Tx Buffer Cancellation Finished 19
            CF19: u1,
            /// Tx Buffer Cancellation Finished 20
            CF20: u1,
            /// Tx Buffer Cancellation Finished 21
            CF21: u1,
            /// Tx Buffer Cancellation Finished 22
            CF22: u1,
            /// Tx Buffer Cancellation Finished 23
            CF23: u1,
            /// Tx Buffer Cancellation Finished 24
            CF24: u1,
            /// Tx Buffer Cancellation Finished 25
            CF25: u1,
            /// Tx Buffer Cancellation Finished 26
            CF26: u1,
            /// Tx Buffer Cancellation Finished 27
            CF27: u1,
            /// Tx Buffer Cancellation Finished 28
            CF28: u1,
            /// Tx Buffer Cancellation Finished 29
            CF29: u1,
            /// Tx Buffer Cancellation Finished 30
            CF30: u1,
            /// Tx Buffer Cancellation Finished 31
            CF31: u1,
        }), base_address + 0xdc);

        /// address: 0x420004e0
        /// Tx Buffer Transmission Interrupt Enable
        pub const TXBTIE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmission Interrupt Enable 0
            TIE0: u1,
            /// Transmission Interrupt Enable 1
            TIE1: u1,
            /// Transmission Interrupt Enable 2
            TIE2: u1,
            /// Transmission Interrupt Enable 3
            TIE3: u1,
            /// Transmission Interrupt Enable 4
            TIE4: u1,
            /// Transmission Interrupt Enable 5
            TIE5: u1,
            /// Transmission Interrupt Enable 6
            TIE6: u1,
            /// Transmission Interrupt Enable 7
            TIE7: u1,
            /// Transmission Interrupt Enable 8
            TIE8: u1,
            /// Transmission Interrupt Enable 9
            TIE9: u1,
            /// Transmission Interrupt Enable 10
            TIE10: u1,
            /// Transmission Interrupt Enable 11
            TIE11: u1,
            /// Transmission Interrupt Enable 12
            TIE12: u1,
            /// Transmission Interrupt Enable 13
            TIE13: u1,
            /// Transmission Interrupt Enable 14
            TIE14: u1,
            /// Transmission Interrupt Enable 15
            TIE15: u1,
            /// Transmission Interrupt Enable 16
            TIE16: u1,
            /// Transmission Interrupt Enable 17
            TIE17: u1,
            /// Transmission Interrupt Enable 18
            TIE18: u1,
            /// Transmission Interrupt Enable 19
            TIE19: u1,
            /// Transmission Interrupt Enable 20
            TIE20: u1,
            /// Transmission Interrupt Enable 21
            TIE21: u1,
            /// Transmission Interrupt Enable 22
            TIE22: u1,
            /// Transmission Interrupt Enable 23
            TIE23: u1,
            /// Transmission Interrupt Enable 24
            TIE24: u1,
            /// Transmission Interrupt Enable 25
            TIE25: u1,
            /// Transmission Interrupt Enable 26
            TIE26: u1,
            /// Transmission Interrupt Enable 27
            TIE27: u1,
            /// Transmission Interrupt Enable 28
            TIE28: u1,
            /// Transmission Interrupt Enable 29
            TIE29: u1,
            /// Transmission Interrupt Enable 30
            TIE30: u1,
            /// Transmission Interrupt Enable 31
            TIE31: u1,
        }), base_address + 0xe0);

        /// address: 0x420004e4
        /// Tx Buffer Cancellation Finished Interrupt Enable
        pub const TXBCIE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Cancellation Finished Interrupt Enable 0
            CFIE0: u1,
            /// Cancellation Finished Interrupt Enable 1
            CFIE1: u1,
            /// Cancellation Finished Interrupt Enable 2
            CFIE2: u1,
            /// Cancellation Finished Interrupt Enable 3
            CFIE3: u1,
            /// Cancellation Finished Interrupt Enable 4
            CFIE4: u1,
            /// Cancellation Finished Interrupt Enable 5
            CFIE5: u1,
            /// Cancellation Finished Interrupt Enable 6
            CFIE6: u1,
            /// Cancellation Finished Interrupt Enable 7
            CFIE7: u1,
            /// Cancellation Finished Interrupt Enable 8
            CFIE8: u1,
            /// Cancellation Finished Interrupt Enable 9
            CFIE9: u1,
            /// Cancellation Finished Interrupt Enable 10
            CFIE10: u1,
            /// Cancellation Finished Interrupt Enable 11
            CFIE11: u1,
            /// Cancellation Finished Interrupt Enable 12
            CFIE12: u1,
            /// Cancellation Finished Interrupt Enable 13
            CFIE13: u1,
            /// Cancellation Finished Interrupt Enable 14
            CFIE14: u1,
            /// Cancellation Finished Interrupt Enable 15
            CFIE15: u1,
            /// Cancellation Finished Interrupt Enable 16
            CFIE16: u1,
            /// Cancellation Finished Interrupt Enable 17
            CFIE17: u1,
            /// Cancellation Finished Interrupt Enable 18
            CFIE18: u1,
            /// Cancellation Finished Interrupt Enable 19
            CFIE19: u1,
            /// Cancellation Finished Interrupt Enable 20
            CFIE20: u1,
            /// Cancellation Finished Interrupt Enable 21
            CFIE21: u1,
            /// Cancellation Finished Interrupt Enable 22
            CFIE22: u1,
            /// Cancellation Finished Interrupt Enable 23
            CFIE23: u1,
            /// Cancellation Finished Interrupt Enable 24
            CFIE24: u1,
            /// Cancellation Finished Interrupt Enable 25
            CFIE25: u1,
            /// Cancellation Finished Interrupt Enable 26
            CFIE26: u1,
            /// Cancellation Finished Interrupt Enable 27
            CFIE27: u1,
            /// Cancellation Finished Interrupt Enable 28
            CFIE28: u1,
            /// Cancellation Finished Interrupt Enable 29
            CFIE29: u1,
            /// Cancellation Finished Interrupt Enable 30
            CFIE30: u1,
            /// Cancellation Finished Interrupt Enable 31
            CFIE31: u1,
        }), base_address + 0xe4);

        /// address: 0x420004f0
        /// Tx Event FIFO Configuration
        pub const TXEFC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Event FIFO Start Address
            EFSA: u16,
            /// Event FIFO Size
            EFS: u6,
            reserved0: u1,
            reserved1: u1,
            /// Event FIFO Watermark
            EFWM: u6,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xf0);

        /// address: 0x420004f4
        /// Tx Event FIFO Status
        pub const TXEFS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Event FIFO Fill Level
            EFFL: u6,
            reserved0: u1,
            reserved1: u1,
            /// Event FIFO Get Index
            EFGI: u5,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Event FIFO Put Index
            EFPI: u5,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Event FIFO Full
            EFF: u1,
            /// Tx Event FIFO Element Lost
            TEFL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0xf4);

        /// address: 0x420004f8
        /// Tx Event FIFO Acknowledge
        pub const TXEFA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Event FIFO Acknowledge Index
            EFAI: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0xf8);
    };

    /// Configurable Custom Logic
    pub const CCL = struct {
        pub const base_address = 0x42003800;
        pub const version = "U22251.1.0";

        /// address: 0x42003800
        /// Control
        pub const CTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Software Reset
            SWRST: u1,
            /// Enable
            ENABLE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Run in Standby
            RUNSTDBY: u1,
            padding0: u1,
        }), base_address + 0x0);

        /// address: 0x42003804
        /// SEQ Control x
        pub const SEQCTRL = @intToPtr(*volatile [2]Mmio(8, packed struct {
            /// Sequential Selection
            SEQSEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x4);

        /// address: 0x42003808
        /// LUT Control x
        pub const LUTCTRL = @intToPtr(*volatile [4]Mmio(32, packed struct {
            reserved0: u1,
            /// LUT Enable
            ENABLE: u1,
            reserved1: u1,
            reserved2: u1,
            /// Filter Selection
            FILTSEL: u2,
            reserved3: u1,
            /// Edge Selection
            EDGESEL: u1,
            /// Input Selection 0
            INSEL0: u4,
            /// Input Selection 1
            INSEL1: u4,
            /// Input Selection 2
            INSEL2: u4,
            /// Inverted Event Input Enable
            INVEI: u1,
            /// LUT Event Input Enable
            LUTEI: u1,
            /// LUT Event Output Enable
            LUTEO: u1,
            reserved4: u1,
            /// Truth Value
            TRUTH: u8,
        }), base_address + 0x8);
    };

    /// Cortex M Cache Controller
    pub const CMCC = struct {
        pub const base_address = 0x41006000;
        pub const version = "U20156.0.0";

        /// address: 0x41006000
        /// Cache Type Register
        pub const TYPE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// dynamic Clock Gating supported
            GCLK: u1,
            reserved1: u1,
            reserved2: u1,
            /// Round Robin Policy supported
            RRP: u1,
            /// Number of Way
            WAYNUM: u2,
            /// Lock Down supported
            LCKDOWN: u1,
            /// Cache Size
            CSIZE: u3,
            /// Cache Line Size
            CLSIZE: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x0);

        /// address: 0x41006004
        /// Cache Configuration Register
        pub const CFG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Instruction Cache Disable
            ICDIS: u1,
            /// Data Cache Disable
            DCDIS: u1,
            reserved1: u1,
            /// Cache size configured by software
            CSIZESW: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x41006008
        /// Cache Control Register
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Cache Controller Enable
            CEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x8);

        /// address: 0x4100600c
        /// Cache Status Register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Cache Controller Status
            CSTS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xc);

        /// address: 0x41006010
        /// Cache Lock per Way Register
        pub const LCKWAY = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x10);

        /// address: 0x41006020
        /// Cache Maintenance Register 0
        pub const MAINT0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Cache Controller invalidate All
            INVALL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x20);

        /// address: 0x41006024
        /// Cache Maintenance Register 1
        pub const MAINT1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Invalidate Index
            INDEX: u8,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// Invalidate Way
            WAY: u4,
        }), base_address + 0x24);

        /// address: 0x41006028
        /// Cache Monitor Configuration Register
        pub const MCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Cache Controller Monitor Counter Mode
            MODE: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x28);

        /// address: 0x4100602c
        /// Cache Monitor Enable Register
        pub const MEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Cache Controller Monitor Enable
            MENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2c);

        /// address: 0x41006030
        /// Cache Monitor Control Register
        pub const MCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Cache Controller Software Reset
            SWRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x30);

        /// address: 0x41006034
        /// Cache Monitor Status Register
        pub const MSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Monitor Event Counter
            EVENT_CNT: u32,
        }), base_address + 0x34);
    };

    /// Digital-to-Analog Converter
    pub const DAC = struct {
        pub const base_address = 0x43002400;
        pub const version = "U25021.0.0";

        /// address: 0x43002400
        /// Control A
        pub const CTRLA = @intToPtr(*volatile Mmio(8, packed struct {
            /// Software Reset
            SWRST: u1,
            /// Enable DAC Controller
            ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x0);

        /// address: 0x43002401
        /// Control B
        pub const CTRLB = @intToPtr(*volatile Mmio(8, packed struct {
            /// Differential mode enable
            DIFF: u1,
            /// Reference Selection for DAC0/1
            REFSEL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x1);

        /// address: 0x43002402
        /// Event Control
        pub const EVCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Start Conversion Event Input DAC 0
            STARTEI0: u1,
            /// Start Conversion Event Input DAC 1
            STARTEI1: u1,
            /// Data Buffer Empty Event Output DAC 0
            EMPTYEO0: u1,
            /// Data Buffer Empty Event Output DAC 1
            EMPTYEO1: u1,
            /// Enable Invertion of DAC 0 input event
            INVEI0: u1,
            /// Enable Invertion of DAC 1 input event
            INVEI1: u1,
            /// Result Ready Event Output 0
            RESRDYEO0: u1,
            /// Result Ready Event Output 1
            RESRDYEO1: u1,
        }), base_address + 0x2);

        /// address: 0x43002404
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Underrun 0 Interrupt Enable
            UNDERRUN0: u1,
            /// Underrun 1 Interrupt Enable
            UNDERRUN1: u1,
            /// Data Buffer 0 Empty Interrupt Enable
            EMPTY0: u1,
            /// Data Buffer 1 Empty Interrupt Enable
            EMPTY1: u1,
            /// Result 0 Ready Interrupt Enable
            RESRDY0: u1,
            /// Result 1 Ready Interrupt Enable
            RESRDY1: u1,
            /// Overrun 0 Interrupt Enable
            OVERRUN0: u1,
            /// Overrun 1 Interrupt Enable
            OVERRUN1: u1,
        }), base_address + 0x4);

        /// address: 0x43002405
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
            /// Underrun 0 Interrupt Enable
            UNDERRUN0: u1,
            /// Underrun 1 Interrupt Enable
            UNDERRUN1: u1,
            /// Data Buffer 0 Empty Interrupt Enable
            EMPTY0: u1,
            /// Data Buffer 1 Empty Interrupt Enable
            EMPTY1: u1,
            /// Result 0 Ready Interrupt Enable
            RESRDY0: u1,
            /// Result 1 Ready Interrupt Enable
            RESRDY1: u1,
            /// Overrun 0 Interrupt Enable
            OVERRUN0: u1,
            /// Overrun 1 Interrupt Enable
            OVERRUN1: u1,
        }), base_address + 0x5);

        /// address: 0x43002406
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
            /// Result 0 Underrun
            UNDERRUN0: u1,
            /// Result 1 Underrun
            UNDERRUN1: u1,
            /// Data Buffer 0 Empty
            EMPTY0: u1,
            /// Data Buffer 1 Empty
            EMPTY1: u1,
            /// Result 0 Ready
            RESRDY0: u1,
            /// Result 1 Ready
            RESRDY1: u1,
            /// Result 0 Overrun
            OVERRUN0: u1,
            /// Result 1 Overrun
            OVERRUN1: u1,
        }), base_address + 0x6);

        /// address: 0x43002407
        /// Status
        pub const STATUS = @intToPtr(*volatile Mmio(8, packed struct {
            /// DAC 0 Startup Ready
            READY0: u1,
            /// DAC 1 Startup Ready
            READY1: u1,
            /// DAC 0 End of Conversion
            EOC0: u1,
            /// DAC 1 End of Conversion
            EOC1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x7);

        /// address: 0x43002408
        /// Synchronization Busy
        pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Reset
            SWRST: u1,
            /// DAC Enable Status
            ENABLE: u1,
            /// Data DAC 0
            DATA0: u1,
            /// Data DAC 1
            DATA1: u1,
            /// Data Buffer DAC 0
            DATABUF0: u1,
            /// Data Buffer DAC 1
            DATABUF1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x8);

        /// address: 0x4300240c
        /// DAC n Control
        pub const DACCTRL = @intToPtr(*volatile [2]Mmio(16, packed struct {
            /// Left Adjusted Data
            LEFTADJ: u1,
            /// Enable DAC0
            ENABLE: u1,
            /// Current Control
            CCTRL: u2,
            reserved0: u1,
            /// Standalone Filter
            FEXT: u1,
            /// Run in Standby
            RUNSTDBY: u1,
            /// Dithering Mode
            DITHER: u1,
            /// Refresh period
            REFRESH: u4,
            reserved1: u1,
            /// Sampling Rate
            OSR: u3,
        }), base_address + 0xc);

        /// address: 0x43002410
        /// DAC n Data
        pub const DATA = @intToPtr(*volatile [2]u16, base_address + 0x10);

        /// address: 0x43002414
        /// DAC n Data Buffer
        pub const DATABUF = @intToPtr(*volatile [2]u16, base_address + 0x14);

        /// address: 0x43002418
        /// Debug Control
        pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Debug Run
            DBGRUN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x18);

        /// address: 0x4300241c
        /// Filter Result
        pub const RESULT = @intToPtr(*volatile [2]u16, base_address + 0x1c);
    };

    /// Direct Memory Access Controller
    pub const DMAC = struct {
        pub const base_address = 0x4100a000;
        pub const version = "U25031.0.1";

        /// address: 0x4100a000
        /// Control
        pub const CTRL = @intToPtr(*volatile Mmio(16, packed struct {
            /// Software Reset
            SWRST: u1,
            /// DMA Enable
            DMAENABLE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Priority Level 0 Enable
            LVLEN0: u1,
            /// Priority Level 1 Enable
            LVLEN1: u1,
            /// Priority Level 2 Enable
            LVLEN2: u1,
            /// Priority Level 3 Enable
            LVLEN3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x4100a002
        /// CRC Control
        pub const CRCCTRL = @intToPtr(*volatile Mmio(16, packed struct {
            /// CRC Beat Size
            CRCBEATSIZE: u2,
            /// CRC Polynomial Type
            CRCPOLY: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// CRC Input Source
            CRCSRC: u6,
            /// CRC Operating Mode
            CRCMODE: u2,
        }), base_address + 0x2);

        /// address: 0x4100a004
        /// CRC Data Input
        pub const CRCDATAIN = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x4100a008
        /// CRC Checksum
        pub const CRCCHKSUM = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4100a00c
        /// CRC Status
        pub const CRCSTATUS = @intToPtr(*volatile Mmio(8, packed struct {
            /// CRC Module Busy
            CRCBUSY: u1,
            /// CRC Zero
            CRCZERO: u1,
            /// CRC Error
            CRCERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0xc);

        /// address: 0x4100a00d
        /// Debug Control
        pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Debug Run
            DBGRUN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0xd);

        /// address: 0x4100a010
        /// Software Trigger Control
        pub const SWTRIGCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 0 Software Trigger
            SWTRIG0: u1,
            /// Channel 1 Software Trigger
            SWTRIG1: u1,
            /// Channel 2 Software Trigger
            SWTRIG2: u1,
            /// Channel 3 Software Trigger
            SWTRIG3: u1,
            /// Channel 4 Software Trigger
            SWTRIG4: u1,
            /// Channel 5 Software Trigger
            SWTRIG5: u1,
            /// Channel 6 Software Trigger
            SWTRIG6: u1,
            /// Channel 7 Software Trigger
            SWTRIG7: u1,
            /// Channel 8 Software Trigger
            SWTRIG8: u1,
            /// Channel 9 Software Trigger
            SWTRIG9: u1,
            /// Channel 10 Software Trigger
            SWTRIG10: u1,
            /// Channel 11 Software Trigger
            SWTRIG11: u1,
            /// Channel 12 Software Trigger
            SWTRIG12: u1,
            /// Channel 13 Software Trigger
            SWTRIG13: u1,
            /// Channel 14 Software Trigger
            SWTRIG14: u1,
            /// Channel 15 Software Trigger
            SWTRIG15: u1,
            /// Channel 16 Software Trigger
            SWTRIG16: u1,
            /// Channel 17 Software Trigger
            SWTRIG17: u1,
            /// Channel 18 Software Trigger
            SWTRIG18: u1,
            /// Channel 19 Software Trigger
            SWTRIG19: u1,
            /// Channel 20 Software Trigger
            SWTRIG20: u1,
            /// Channel 21 Software Trigger
            SWTRIG21: u1,
            /// Channel 22 Software Trigger
            SWTRIG22: u1,
            /// Channel 23 Software Trigger
            SWTRIG23: u1,
            /// Channel 24 Software Trigger
            SWTRIG24: u1,
            /// Channel 25 Software Trigger
            SWTRIG25: u1,
            /// Channel 26 Software Trigger
            SWTRIG26: u1,
            /// Channel 27 Software Trigger
            SWTRIG27: u1,
            /// Channel 28 Software Trigger
            SWTRIG28: u1,
            /// Channel 29 Software Trigger
            SWTRIG29: u1,
            /// Channel 30 Software Trigger
            SWTRIG30: u1,
            /// Channel 31 Software Trigger
            SWTRIG31: u1,
        }), base_address + 0x10);

        /// address: 0x4100a014
        /// Priority Control 0
        pub const PRICTRL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Level 0 Channel Priority Number
            LVLPRI0: u5,
            /// Level 0 Quality of Service
            QOS0: u2,
            /// Level 0 Round-Robin Scheduling Enable
            RRLVLEN0: u1,
            /// Level 1 Channel Priority Number
            LVLPRI1: u5,
            /// Level 1 Quality of Service
            QOS1: u2,
            /// Level 1 Round-Robin Scheduling Enable
            RRLVLEN1: u1,
            /// Level 2 Channel Priority Number
            LVLPRI2: u5,
            /// Level 2 Quality of Service
            QOS2: u2,
            /// Level 2 Round-Robin Scheduling Enable
            RRLVLEN2: u1,
            /// Level 3 Channel Priority Number
            LVLPRI3: u5,
            /// Level 3 Quality of Service
            QOS3: u2,
            /// Level 3 Round-Robin Scheduling Enable
            RRLVLEN3: u1,
        }), base_address + 0x14);

        /// address: 0x4100a020
        /// Interrupt Pending
        pub const INTPEND = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel ID
            ID: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Transfer Error
            TERR: u1,
            /// Transfer Complete
            TCMPL: u1,
            /// Channel Suspend
            SUSP: u1,
            reserved3: u1,
            /// CRC Error
            CRCERR: u1,
            /// Fetch Error
            FERR: u1,
            /// Busy
            BUSY: u1,
            /// Pending
            PEND: u1,
        }), base_address + 0x20);

        /// address: 0x4100a024
        /// Interrupt Status
        pub const INTSTATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 0 Pending Interrupt
            CHINT0: u1,
            /// Channel 1 Pending Interrupt
            CHINT1: u1,
            /// Channel 2 Pending Interrupt
            CHINT2: u1,
            /// Channel 3 Pending Interrupt
            CHINT3: u1,
            /// Channel 4 Pending Interrupt
            CHINT4: u1,
            /// Channel 5 Pending Interrupt
            CHINT5: u1,
            /// Channel 6 Pending Interrupt
            CHINT6: u1,
            /// Channel 7 Pending Interrupt
            CHINT7: u1,
            /// Channel 8 Pending Interrupt
            CHINT8: u1,
            /// Channel 9 Pending Interrupt
            CHINT9: u1,
            /// Channel 10 Pending Interrupt
            CHINT10: u1,
            /// Channel 11 Pending Interrupt
            CHINT11: u1,
            /// Channel 12 Pending Interrupt
            CHINT12: u1,
            /// Channel 13 Pending Interrupt
            CHINT13: u1,
            /// Channel 14 Pending Interrupt
            CHINT14: u1,
            /// Channel 15 Pending Interrupt
            CHINT15: u1,
            /// Channel 16 Pending Interrupt
            CHINT16: u1,
            /// Channel 17 Pending Interrupt
            CHINT17: u1,
            /// Channel 18 Pending Interrupt
            CHINT18: u1,
            /// Channel 19 Pending Interrupt
            CHINT19: u1,
            /// Channel 20 Pending Interrupt
            CHINT20: u1,
            /// Channel 21 Pending Interrupt
            CHINT21: u1,
            /// Channel 22 Pending Interrupt
            CHINT22: u1,
            /// Channel 23 Pending Interrupt
            CHINT23: u1,
            /// Channel 24 Pending Interrupt
            CHINT24: u1,
            /// Channel 25 Pending Interrupt
            CHINT25: u1,
            /// Channel 26 Pending Interrupt
            CHINT26: u1,
            /// Channel 27 Pending Interrupt
            CHINT27: u1,
            /// Channel 28 Pending Interrupt
            CHINT28: u1,
            /// Channel 29 Pending Interrupt
            CHINT29: u1,
            /// Channel 30 Pending Interrupt
            CHINT30: u1,
            /// Channel 31 Pending Interrupt
            CHINT31: u1,
        }), base_address + 0x24);

        /// address: 0x4100a028
        /// Busy Channels
        pub const BUSYCH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Busy Channel 0
            BUSYCH0: u1,
            /// Busy Channel 1
            BUSYCH1: u1,
            /// Busy Channel 2
            BUSYCH2: u1,
            /// Busy Channel 3
            BUSYCH3: u1,
            /// Busy Channel 4
            BUSYCH4: u1,
            /// Busy Channel 5
            BUSYCH5: u1,
            /// Busy Channel 6
            BUSYCH6: u1,
            /// Busy Channel 7
            BUSYCH7: u1,
            /// Busy Channel 8
            BUSYCH8: u1,
            /// Busy Channel 9
            BUSYCH9: u1,
            /// Busy Channel 10
            BUSYCH10: u1,
            /// Busy Channel 11
            BUSYCH11: u1,
            /// Busy Channel 12
            BUSYCH12: u1,
            /// Busy Channel 13
            BUSYCH13: u1,
            /// Busy Channel 14
            BUSYCH14: u1,
            /// Busy Channel 15
            BUSYCH15: u1,
            /// Busy Channel 16
            BUSYCH16: u1,
            /// Busy Channel 17
            BUSYCH17: u1,
            /// Busy Channel 18
            BUSYCH18: u1,
            /// Busy Channel 19
            BUSYCH19: u1,
            /// Busy Channel 20
            BUSYCH20: u1,
            /// Busy Channel 21
            BUSYCH21: u1,
            /// Busy Channel 22
            BUSYCH22: u1,
            /// Busy Channel 23
            BUSYCH23: u1,
            /// Busy Channel 24
            BUSYCH24: u1,
            /// Busy Channel 25
            BUSYCH25: u1,
            /// Busy Channel 26
            BUSYCH26: u1,
            /// Busy Channel 27
            BUSYCH27: u1,
            /// Busy Channel 28
            BUSYCH28: u1,
            /// Busy Channel 29
            BUSYCH29: u1,
            /// Busy Channel 30
            BUSYCH30: u1,
            /// Busy Channel 31
            BUSYCH31: u1,
        }), base_address + 0x28);

        /// address: 0x4100a02c
        /// Pending Channels
        pub const PENDCH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pending Channel 0
            PENDCH0: u1,
            /// Pending Channel 1
            PENDCH1: u1,
            /// Pending Channel 2
            PENDCH2: u1,
            /// Pending Channel 3
            PENDCH3: u1,
            /// Pending Channel 4
            PENDCH4: u1,
            /// Pending Channel 5
            PENDCH5: u1,
            /// Pending Channel 6
            PENDCH6: u1,
            /// Pending Channel 7
            PENDCH7: u1,
            /// Pending Channel 8
            PENDCH8: u1,
            /// Pending Channel 9
            PENDCH9: u1,
            /// Pending Channel 10
            PENDCH10: u1,
            /// Pending Channel 11
            PENDCH11: u1,
            /// Pending Channel 12
            PENDCH12: u1,
            /// Pending Channel 13
            PENDCH13: u1,
            /// Pending Channel 14
            PENDCH14: u1,
            /// Pending Channel 15
            PENDCH15: u1,
            /// Pending Channel 16
            PENDCH16: u1,
            /// Pending Channel 17
            PENDCH17: u1,
            /// Pending Channel 18
            PENDCH18: u1,
            /// Pending Channel 19
            PENDCH19: u1,
            /// Pending Channel 20
            PENDCH20: u1,
            /// Pending Channel 21
            PENDCH21: u1,
            /// Pending Channel 22
            PENDCH22: u1,
            /// Pending Channel 23
            PENDCH23: u1,
            /// Pending Channel 24
            PENDCH24: u1,
            /// Pending Channel 25
            PENDCH25: u1,
            /// Pending Channel 26
            PENDCH26: u1,
            /// Pending Channel 27
            PENDCH27: u1,
            /// Pending Channel 28
            PENDCH28: u1,
            /// Pending Channel 29
            PENDCH29: u1,
            /// Pending Channel 30
            PENDCH30: u1,
            /// Pending Channel 31
            PENDCH31: u1,
        }), base_address + 0x2c);

        /// address: 0x4100a030
        /// Active Channel and Levels
        pub const ACTIVE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Level 0 Channel Trigger Request Executing
            LVLEX0: u1,
            /// Level 1 Channel Trigger Request Executing
            LVLEX1: u1,
            /// Level 2 Channel Trigger Request Executing
            LVLEX2: u1,
            /// Level 3 Channel Trigger Request Executing
            LVLEX3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Active Channel ID
            ID: u5,
            reserved4: u1,
            reserved5: u1,
            /// Active Channel Busy
            ABUSY: u1,
            /// Active Channel Block Transfer Count
            BTCNT: u16,
        }), base_address + 0x30);

        /// address: 0x4100a034
        /// Descriptor Memory Section Base Address
        pub const BASEADDR = @intToPtr(*volatile u32, base_address + 0x34);

        /// address: 0x4100a038
        /// Write-Back Memory Section Base Address
        pub const WRBADDR = @intToPtr(*volatile u32, base_address + 0x38);

        pub const CHANNEL = @ptrCast(*volatile [32]packed struct {
            /// Channel n Control A
            CHCTRLA: Mmio(32, packed struct {
                /// Channel Software Reset
                SWRST: u1,
                /// Channel Enable
                ENABLE: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Channel Run in Standby
                RUNSTDBY: u1,
                reserved4: u1,
                /// Trigger Source
                TRIGSRC: u7,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                /// Trigger Action
                TRIGACT: u2,
                reserved10: u1,
                reserved11: u1,
                /// Burst Length
                BURSTLEN: u4,
                /// FIFO Threshold
                THRESHOLD: u2,
                padding0: u1,
                padding1: u1,
            }),

            /// Channel n Control B
            CHCTRLB: Mmio(8, packed struct {
                /// Software Command
                CMD: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }),

            /// Channel n Priority Level
            CHPRILVL: Mmio(8, packed struct {
                /// Channel Priority Level
                PRILVL: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }),

            /// Channel n Event Control
            CHEVCTRL: Mmio(8, packed struct {
                /// Channel Event Input Action
                EVACT: u3,
                reserved0: u1,
                /// Channel Event Output Mode
                EVOMODE: u2,
                /// Channel Event Input Enable
                EVIE: u1,
                /// Channel Event Output Enable
                EVOE: u1,
            }),

            /// Channel n Interrupt Enable Clear
            CHINTENCLR: Mmio(8, packed struct {
                /// Channel Transfer Error Interrupt Enable
                TERR: u1,
                /// Channel Transfer Complete Interrupt Enable
                TCMPL: u1,
                /// Channel Suspend Interrupt Enable
                SUSP: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
            }),

            /// Channel n Interrupt Enable Set
            CHINTENSET: Mmio(8, packed struct {
                /// Channel Transfer Error Interrupt Enable
                TERR: u1,
                /// Channel Transfer Complete Interrupt Enable
                TCMPL: u1,
                /// Channel Suspend Interrupt Enable
                SUSP: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
            }),

            /// Channel n Interrupt Flag Status and Clear
            CHINTFLAG: Mmio(8, packed struct {
                /// Channel Transfer Error
                TERR: u1,
                /// Channel Transfer Complete
                TCMPL: u1,
                /// Channel Suspend
                SUSP: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
            }),

            /// Channel n Status
            CHSTATUS: Mmio(8, packed struct {
                /// Channel Pending
                PEND: u1,
                /// Channel Busy
                BUSY: u1,
                /// Channel Fetch Error
                FERR: u1,
                /// Channel CRC Error
                CRCERR: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
            }),
            padding0: u32,
        }, base_address + 0x40);
    };

    /// Device Service Unit
    pub const DSU = struct {
        pub const base_address = 0x41002000;
        pub const version = "U24101.0.0";

        /// address: 0x41002000
        /// Control
        pub const CTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Software Reset
            SWRST: u1,
            reserved0: u1,
            /// 32-bit Cyclic Redundancy Code
            CRC: u1,
            /// Memory built-in self-test
            MBIST: u1,
            /// Chip-Erase
            CE: u1,
            reserved1: u1,
            /// Auxiliary Row Read
            ARR: u1,
            /// Start Memory Stream Access
            SMSA: u1,
        }), base_address + 0x0);

        /// address: 0x41002001
        /// Status A
        pub const STATUSA = @intToPtr(*volatile Mmio(8, packed struct {
            /// Done
            DONE: u1,
            /// CPU Reset Phase Extension
            CRSTEXT: u1,
            /// Bus Error
            BERR: u1,
            /// Failure
            FAIL: u1,
            /// Protection Error
            PERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x1);

        /// address: 0x41002002
        /// Status B
        pub const STATUSB = @intToPtr(*volatile Mmio(8, packed struct {
            /// Protected
            PROT: u1,
            /// Debugger Present
            DBGPRES: u1,
            /// Debug Communication Channel 0 Dirty
            DCCD0: u1,
            /// Debug Communication Channel 1 Dirty
            DCCD1: u1,
            /// Hot-Plugging Enable
            HPE: u1,
            /// Chip Erase Locked
            CELCK: u1,
            /// Test Debug Communication Channel 0 Dirty
            TDCCD0: u1,
            /// Test Debug Communication Channel 1 Dirty
            TDCCD1: u1,
        }), base_address + 0x2);

        /// address: 0x41002004
        /// Address
        pub const ADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Access Mode
            AMOD: u2,
            /// Address
            ADDR: u30,
        }), base_address + 0x4);

        /// address: 0x41002008
        /// Length
        pub const LENGTH = @intToPtr(*volatile MmioInt(32, u30), base_address + 0x8);

        /// address: 0x4100200c
        /// Data
        pub const DATA = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x41002010
        /// Debug Communication Channel n
        pub const DCC = @intToPtr(*volatile [2]Mmio(32, packed struct {
            /// Data
            DATA: u32,
        }), base_address + 0x10);

        /// address: 0x41002018
        /// Device Identification
        pub const DID = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device Select
            DEVSEL: u8,
            /// Revision Number
            REVISION: u4,
            /// Die Number
            DIE: u4,
            /// Series
            SERIES: u6,
            reserved0: u1,
            /// Family
            FAMILY: u5,
            /// Processor
            PROCESSOR: u4,
        }), base_address + 0x18);

        /// address: 0x4100201c
        /// Configuration
        pub const CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Latency Quality Of Service
            LQOS: u2,
            /// DMA Trigger Level
            DCCDMALEVEL: u2,
            /// Trace Control
            ETBRAMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x1c);

        /// address: 0x410020f0
        /// Device Configuration
        pub const DCFG = @intToPtr(*volatile [2]u32, base_address + 0xf0);

        /// address: 0x41003000
        /// CoreSight ROM Table Entry 0
        pub const ENTRY0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Entry Present
            EPRES: u1,
            /// Format
            FMT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Address Offset
            ADDOFF: u20,
        }), base_address + 0x1000);

        /// address: 0x41003004
        /// CoreSight ROM Table Entry 1
        pub const ENTRY1 = @intToPtr(*volatile u32, base_address + 0x1004);

        /// address: 0x41003008
        /// CoreSight ROM Table End
        pub const END = @intToPtr(*volatile u32, base_address + 0x1008);

        /// address: 0x41003fcc
        /// CoreSight ROM Table Memory Type
        pub const MEMTYPE = @intToPtr(*volatile Mmio(32, packed struct {
            /// System Memory Present
            SMEMP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1fcc);

        /// address: 0x41003fd0
        /// Peripheral Identification 4
        pub const PID4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JEP-106 Continuation Code
            JEPCC: u4,
            /// 4KB count
            FKBC: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1fd0);

        /// address: 0x41003fd4
        /// Peripheral Identification 5
        pub const PID5 = @intToPtr(*volatile u32, base_address + 0x1fd4);

        /// address: 0x41003fd8
        /// Peripheral Identification 6
        pub const PID6 = @intToPtr(*volatile u32, base_address + 0x1fd8);

        /// address: 0x41003fdc
        /// Peripheral Identification 7
        pub const PID7 = @intToPtr(*volatile u32, base_address + 0x1fdc);

        /// address: 0x41003fe0
        /// Peripheral Identification 0
        pub const PID0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Part Number Low
            PARTNBL: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1fe0);

        /// address: 0x41003fe4
        /// Peripheral Identification 1
        pub const PID1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Part Number High
            PARTNBH: u4,
            /// Low part of the JEP-106 Identity Code
            JEPIDCL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1fe4);

        /// address: 0x41003fe8
        /// Peripheral Identification 2
        pub const PID2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JEP-106 Identity Code High
            JEPIDCH: u3,
            /// JEP-106 Identity Code is used
            JEPU: u1,
            /// Revision Number
            REVISION: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1fe8);

        /// address: 0x41003fec
        /// Peripheral Identification 3
        pub const PID3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ARM CUSMOD
            CUSMOD: u4,
            /// Revision Number
            REVAND: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1fec);

        /// address: 0x41003ff0
        /// Component Identification 0
        pub const CID0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Preamble Byte 0
            PREAMBLEB0: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1ff0);

        /// address: 0x41003ff4
        /// Component Identification 1
        pub const CID1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Preamble
            PREAMBLE: u4,
            /// Component Class
            CCLASS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1ff4);

        /// address: 0x41003ff8
        /// Component Identification 2
        pub const CID2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Preamble Byte 2
            PREAMBLEB2: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1ff8);

        /// address: 0x41003ffc
        /// Component Identification 3
        pub const CID3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Preamble Byte 3
            PREAMBLEB3: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1ffc);
    };

    /// External Interrupt Controller
    pub const EIC = struct {
        pub const base_address = 0x40002800;
        pub const version = "U22543.0.0";

        /// address: 0x40002800
        /// Control A
        pub const CTRLA = @intToPtr(*volatile Mmio(8, packed struct {
            /// Software Reset
            SWRST: u1,
            /// Enable
            ENABLE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock Selection
            CKSEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40002801
        /// Non-Maskable Interrupt Control
        pub const NMICTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Non-Maskable Interrupt Sense Configuration
            NMISENSE: u3,
            /// Non-Maskable Interrupt Filter Enable
            NMIFILTEN: u1,
            /// Asynchronous Edge Detection Mode
            NMIASYNCH: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x1);

        /// address: 0x40002802
        /// Non-Maskable Interrupt Flag Status and Clear
        pub const NMIFLAG = @intToPtr(*volatile Mmio(16, packed struct {
            /// Non-Maskable Interrupt
            NMI: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x2);

        /// address: 0x40002804
        /// Synchronization Busy
        pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Reset Synchronization Busy Status
            SWRST: u1,
            /// Enable Synchronization Busy Status
            ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x4);

        /// address: 0x40002808
        /// Event Control
        pub const EVCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// External Interrupt Event Output Enable
            EXTINTEO: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000280c
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// External Interrupt Enable
            EXTINT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40002810
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// External Interrupt Enable
            EXTINT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40002814
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(32, packed struct {
            /// External Interrupt
            EXTINT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40002818
        /// External Interrupt Asynchronous Mode
        pub const ASYNCH = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x18);

        /// address: 0x4000281c
        /// External Interrupt Sense Configuration
        pub const CONFIG = @intToPtr(*volatile [2]Mmio(32, packed struct {
            /// Input Sense Configuration 0
            SENSE0: u3,
            /// Filter Enable 0
            FILTEN0: u1,
            /// Input Sense Configuration 1
            SENSE1: u3,
            /// Filter Enable 1
            FILTEN1: u1,
            /// Input Sense Configuration 2
            SENSE2: u3,
            /// Filter Enable 2
            FILTEN2: u1,
            /// Input Sense Configuration 3
            SENSE3: u3,
            /// Filter Enable 3
            FILTEN3: u1,
            /// Input Sense Configuration 4
            SENSE4: u3,
            /// Filter Enable 4
            FILTEN4: u1,
            /// Input Sense Configuration 5
            SENSE5: u3,
            /// Filter Enable 5
            FILTEN5: u1,
            /// Input Sense Configuration 6
            SENSE6: u3,
            /// Filter Enable 6
            FILTEN6: u1,
            /// Input Sense Configuration 7
            SENSE7: u3,
            /// Filter Enable 7
            FILTEN7: u1,
        }), base_address + 0x1c);

        /// address: 0x40002830
        /// Debouncer Enable
        pub const DEBOUNCEN = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x30);

        /// address: 0x40002834
        /// Debouncer Prescaler
        pub const DPRESCALER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Debouncer Prescaler
            PRESCALER0: u3,
            /// Debouncer number of states
            STATES0: u1,
            /// Debouncer Prescaler
            PRESCALER1: u3,
            /// Debouncer number of states
            STATES1: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Pin Sampler frequency selection
            TICKON: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x34);

        /// address: 0x40002838
        /// Pin State
        pub const PINSTATE = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);
    };

    /// Event System Interface
    pub const EVSYS = struct {
        pub const base_address = 0x4100e000;
        pub const version = "U25041.0.0";

        /// address: 0x4100e000
        /// Control
        pub const CTRLA = @intToPtr(*volatile Mmio(8, packed struct {
            /// Software Reset
            SWRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x0);

        /// address: 0x4100e004
        /// Software Event
        pub const SWEVT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 0 Software Selection
            CHANNEL0: u1,
            /// Channel 1 Software Selection
            CHANNEL1: u1,
            /// Channel 2 Software Selection
            CHANNEL2: u1,
            /// Channel 3 Software Selection
            CHANNEL3: u1,
            /// Channel 4 Software Selection
            CHANNEL4: u1,
            /// Channel 5 Software Selection
            CHANNEL5: u1,
            /// Channel 6 Software Selection
            CHANNEL6: u1,
            /// Channel 7 Software Selection
            CHANNEL7: u1,
            /// Channel 8 Software Selection
            CHANNEL8: u1,
            /// Channel 9 Software Selection
            CHANNEL9: u1,
            /// Channel 10 Software Selection
            CHANNEL10: u1,
            /// Channel 11 Software Selection
            CHANNEL11: u1,
            /// Channel 12 Software Selection
            CHANNEL12: u1,
            /// Channel 13 Software Selection
            CHANNEL13: u1,
            /// Channel 14 Software Selection
            CHANNEL14: u1,
            /// Channel 15 Software Selection
            CHANNEL15: u1,
            /// Channel 16 Software Selection
            CHANNEL16: u1,
            /// Channel 17 Software Selection
            CHANNEL17: u1,
            /// Channel 18 Software Selection
            CHANNEL18: u1,
            /// Channel 19 Software Selection
            CHANNEL19: u1,
            /// Channel 20 Software Selection
            CHANNEL20: u1,
            /// Channel 21 Software Selection
            CHANNEL21: u1,
            /// Channel 22 Software Selection
            CHANNEL22: u1,
            /// Channel 23 Software Selection
            CHANNEL23: u1,
            /// Channel 24 Software Selection
            CHANNEL24: u1,
            /// Channel 25 Software Selection
            CHANNEL25: u1,
            /// Channel 26 Software Selection
            CHANNEL26: u1,
            /// Channel 27 Software Selection
            CHANNEL27: u1,
            /// Channel 28 Software Selection
            CHANNEL28: u1,
            /// Channel 29 Software Selection
            CHANNEL29: u1,
            /// Channel 30 Software Selection
            CHANNEL30: u1,
            /// Channel 31 Software Selection
            CHANNEL31: u1,
        }), base_address + 0x4);

        /// address: 0x4100e008
        /// Priority Control
        pub const PRICTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Channel Priority Number
            PRI: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Round-Robin Scheduling Enable
            RREN: u1,
        }), base_address + 0x8);

        /// address: 0x4100e010
        /// Channel Pending Interrupt
        pub const INTPEND = @intToPtr(*volatile Mmio(16, packed struct {
            /// Channel ID
            ID: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Channel Overrun
            OVR: u1,
            /// Channel Event Detected
            EVD: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Ready
            READY: u1,
            /// Busy
            BUSY: u1,
        }), base_address + 0x10);

        /// address: 0x4100e014
        /// Interrupt Status
        pub const INTSTATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 0 Pending Interrupt
            CHINT0: u1,
            /// Channel 1 Pending Interrupt
            CHINT1: u1,
            /// Channel 2 Pending Interrupt
            CHINT2: u1,
            /// Channel 3 Pending Interrupt
            CHINT3: u1,
            /// Channel 4 Pending Interrupt
            CHINT4: u1,
            /// Channel 5 Pending Interrupt
            CHINT5: u1,
            /// Channel 6 Pending Interrupt
            CHINT6: u1,
            /// Channel 7 Pending Interrupt
            CHINT7: u1,
            /// Channel 8 Pending Interrupt
            CHINT8: u1,
            /// Channel 9 Pending Interrupt
            CHINT9: u1,
            /// Channel 10 Pending Interrupt
            CHINT10: u1,
            /// Channel 11 Pending Interrupt
            CHINT11: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x14);

        /// address: 0x4100e018
        /// Busy Channels
        pub const BUSYCH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Busy Channel 0
            BUSYCH0: u1,
            /// Busy Channel 1
            BUSYCH1: u1,
            /// Busy Channel 2
            BUSYCH2: u1,
            /// Busy Channel 3
            BUSYCH3: u1,
            /// Busy Channel 4
            BUSYCH4: u1,
            /// Busy Channel 5
            BUSYCH5: u1,
            /// Busy Channel 6
            BUSYCH6: u1,
            /// Busy Channel 7
            BUSYCH7: u1,
            /// Busy Channel 8
            BUSYCH8: u1,
            /// Busy Channel 9
            BUSYCH9: u1,
            /// Busy Channel 10
            BUSYCH10: u1,
            /// Busy Channel 11
            BUSYCH11: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x18);

        /// address: 0x4100e01c
        /// Ready Users
        pub const READYUSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Ready User for Channel 0
            READYUSR0: u1,
            /// Ready User for Channel 1
            READYUSR1: u1,
            /// Ready User for Channel 2
            READYUSR2: u1,
            /// Ready User for Channel 3
            READYUSR3: u1,
            /// Ready User for Channel 4
            READYUSR4: u1,
            /// Ready User for Channel 5
            READYUSR5: u1,
            /// Ready User for Channel 6
            READYUSR6: u1,
            /// Ready User for Channel 7
            READYUSR7: u1,
            /// Ready User for Channel 8
            READYUSR8: u1,
            /// Ready User for Channel 9
            READYUSR9: u1,
            /// Ready User for Channel 10
            READYUSR10: u1,
            /// Ready User for Channel 11
            READYUSR11: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x4100e120
        /// User Multiplexer n
        pub const USER = @intToPtr(*volatile [67]Mmio(32, packed struct {
            /// Channel Event Selection
            CHANNEL: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x120);

        pub const CHANNEL = @ptrCast(*volatile [32]packed struct {
            /// Channel n Control
            CHANNEL: Mmio(32, packed struct {
                /// Event Generator Selection
                EVGEN: u7,
                reserved0: u1,
                /// Path Selection
                PATH: u2,
                /// Edge Detection Selection
                EDGSEL: u2,
                reserved1: u1,
                reserved2: u1,
                /// Run in standby
                RUNSTDBY: u1,
                /// Generic Clock On Demand
                ONDEMAND: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }),

            /// Channel n Interrupt Enable Clear
            CHINTENCLR: Mmio(8, packed struct {
                /// Channel Overrun Interrupt Disable
                OVR: u1,
                /// Channel Event Detected Interrupt Disable
                EVD: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }),

            /// Channel n Interrupt Enable Set
            CHINTENSET: Mmio(8, packed struct {
                /// Channel Overrun Interrupt Enable
                OVR: u1,
                /// Channel Event Detected Interrupt Enable
                EVD: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }),

            /// Channel n Interrupt Flag Status and Clear
            CHINTFLAG: Mmio(8, packed struct {
                /// Channel Overrun
                OVR: u1,
                /// Channel Event Detected
                EVD: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }),

            /// Channel n Status
            CHSTATUS: Mmio(8, packed struct {
                /// Ready User
                RDYUSR: u1,
                /// Busy Channel
                BUSYCH: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }),
        }, base_address + 0x20);
    };

    /// Frequency Meter
    pub const FREQM = struct {
        pub const base_address = 0x40002c00;
        pub const version = "U22571.1.0";

        /// address: 0x40002c00
        /// Control A Register
        pub const CTRLA = @intToPtr(*volatile Mmio(8, packed struct {
            /// Software Reset
            SWRST: u1,
            /// Enable
            ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x0);

        /// address: 0x40002c01
        /// Control B Register
        pub const CTRLB = @intToPtr(*volatile Mmio(8, packed struct {
            /// Start Measurement
            START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1);

        /// address: 0x40002c02
        /// Config A register
        pub const CFGA = @intToPtr(*volatile Mmio(16, packed struct {
            /// Number of Reference Clock Cycles
            REFNUM: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x2);

        /// address: 0x40002c08
        /// Interrupt Enable Clear Register
        pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Measurement Done Interrupt Enable
            DONE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x8);

        /// address: 0x40002c09
        /// Interrupt Enable Set Register
        pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
            /// Measurement Done Interrupt Enable
            DONE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x9);

        /// address: 0x40002c0a
        /// Interrupt Flag Register
        pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
            /// Measurement Done
            DONE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0xa);

        /// address: 0x40002c0b
        /// Status Register
        pub const STATUS = @intToPtr(*volatile Mmio(8, packed struct {
            /// FREQM Status
            BUSY: u1,
            /// Sticky Count Value Overflow
            OVF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0xb);

        /// address: 0x40002c0c
        /// Synchronization Busy Register
        pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Reset
            SWRST: u1,
            /// Enable
            ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x40002c10
        /// Count Value Register
        pub const VALUE = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x10);
    };

    /// Generic Clock Generator
    pub const GCLK = struct {
        pub const base_address = 0x40001c00;
        pub const version = "U21221.2.0";

        /// address: 0x40001c00
        /// Control
        pub const CTRLA = @intToPtr(*volatile Mmio(8, packed struct {
            /// Software Reset
            SWRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x0);

        /// address: 0x40001c04
        /// Synchronization Busy
        pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Reset Synchroniation Busy bit
            SWRST: u1,
            reserved0: u1,
            /// Generic Clock Generator Control n Synchronization Busy bits
            GENCTRL: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x4);

        /// address: 0x40001c20
        /// Generic Clock Generator Control
        pub const GENCTRL = @intToPtr(*volatile [12]Mmio(32, packed struct {
            /// Source Select
            SRC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Generic Clock Generator Enable
            GENEN: u1,
            /// Improve Duty Cycle
            IDC: u1,
            /// Output Off Value
            OOV: u1,
            /// Output Enable
            OE: u1,
            /// Divide Selection
            DIVSEL: u1,
            /// Run in Standby
            RUNSTDBY: u1,
            reserved4: u1,
            reserved5: u1,
            /// Division Factor
            DIV: u16,
        }), base_address + 0x20);

        /// address: 0x40001c80
        /// Peripheral Clock Control
        pub const PCHCTRL = @intToPtr(*volatile [48]Mmio(32, packed struct {
            /// Generic Clock Generator
            GEN: u4,
            reserved0: u1,
            reserved1: u1,
            /// Channel Enable
            CHEN: u1,
            /// Write Lock
            WRTLOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x80);
    };

    /// HSB Matrix
    pub const HMATRIX = struct {
        pub const base_address = 0x4100c000;
        pub const version = "I76382.1.4";

        pub const PRS = @ptrCast(*volatile [16]packed struct {
            /// Priority A for Slave
            PRAS: u32,

            /// Priority B for Slave
            PRBS: u32,
        }, base_address + 0x80);
    };

    /// Integrity Check Monitor
    pub const ICM = struct {
        pub const base_address = 0x42002c00;
        pub const version = "U20101.2.0";

        /// address: 0x42002c00
        /// Configuration
        pub const CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write Back Disable
            WBDIS: u1,
            /// End of Monitoring Disable
            EOMDIS: u1,
            /// Secondary List Branching Disable
            SLBDIS: u1,
            reserved0: u1,
            /// Bus Burden Control
            BBC: u4,
            /// Automatic Switch To Compare Digest
            ASCD: u1,
            /// Dual Input Buffer
            DUALBUFF: u1,
            reserved1: u1,
            reserved2: u1,
            /// User Initial Hash Value
            UIHASH: u1,
            /// User SHA Algorithm
            UALGO: u3,
            /// Region Hash Area Protection
            HAPROT: u6,
            reserved3: u1,
            reserved4: u1,
            /// Region Descriptor Area Protection
            DAPROT: u6,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x0);

        /// address: 0x42002c04
        /// Control
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// ICM Enable
            ENABLE: u1,
            /// ICM Disable Register
            DISABLE: u1,
            /// Software Reset
            SWRST: u1,
            reserved0: u1,
            /// Recompute Internal Hash
            REHASH: u4,
            /// Region Monitoring Disable
            RMDIS: u4,
            /// Region Monitoring Enable
            RMEN: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x42002c08
        /// Status
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ICM Controller Enable Register
            ENABLE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// RAW Region Monitoring Disabled Status
            RAWRMDIS: u4,
            /// Region Monitoring Disabled Status
            RMDIS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x42002c10
        /// Interrupt Enable
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Region Hash Completed Interrupt Enable
            RHC: u4,
            /// Region Digest Mismatch Interrupt Enable
            RDM: u4,
            /// Region Bus Error Interrupt Enable
            RBE: u4,
            /// Region Wrap Condition detected Interrupt Enable
            RWC: u4,
            /// Region End bit Condition Detected Interrupt Enable
            REC: u4,
            /// Region Status Updated Interrupt Disable
            RSU: u4,
            /// Undefined Register Access Detection Interrupt Enable
            URAD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x10);

        /// address: 0x42002c14
        /// Interrupt Disable
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Region Hash Completed Interrupt Disable
            RHC: u4,
            /// Region Digest Mismatch Interrupt Disable
            RDM: u4,
            /// Region Bus Error Interrupt Disable
            RBE: u4,
            /// Region Wrap Condition Detected Interrupt Disable
            RWC: u4,
            /// Region End bit Condition detected Interrupt Disable
            REC: u4,
            /// Region Status Updated Interrupt Disable
            RSU: u4,
            /// Undefined Register Access Detection Interrupt Disable
            URAD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x14);

        /// address: 0x42002c18
        /// Interrupt Mask
        pub const IMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Region Hash Completed Interrupt Mask
            RHC: u4,
            /// Region Digest Mismatch Interrupt Mask
            RDM: u4,
            /// Region Bus Error Interrupt Mask
            RBE: u4,
            /// Region Wrap Condition Detected Interrupt Mask
            RWC: u4,
            /// Region End bit Condition Detected Interrupt Mask
            REC: u4,
            /// Region Status Updated Interrupt Mask
            RSU: u4,
            /// Undefined Register Access Detection Interrupt Mask
            URAD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x18);

        /// address: 0x42002c1c
        /// Interrupt Status
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Region Hash Completed
            RHC: u4,
            /// Region Digest Mismatch
            RDM: u4,
            /// Region Bus Error
            RBE: u4,
            /// Region Wrap Condition Detected
            RWC: u4,
            /// Region End bit Condition Detected
            REC: u4,
            /// Region Status Updated Detected
            RSU: u4,
            /// Undefined Register Access Detection Status
            URAD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1c);

        /// address: 0x42002c20
        /// Undefined Access Status
        pub const UASR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Undefined Register Access Trace
            URAT: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x20);

        /// address: 0x42002c30
        /// Region Descriptor Area Start Address
        pub const DSCR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Descriptor Area Start Address
            DASA: u26,
        }), base_address + 0x30);

        /// address: 0x42002c34
        /// Region Hash Area Start Address
        pub const HASH = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Hash Area Start Address
            HASA: u25,
        }), base_address + 0x34);

        /// address: 0x42002c38
        /// User Initial Hash Value n
        pub const UIHVAL = @intToPtr(*volatile [8]Mmio(32, packed struct {
            /// Initial Hash Value
            VAL: u32,
        }), base_address + 0x38);
    };

    /// Inter-IC Sound Interface
    pub const I2S = struct {
        pub const base_address = 0x43002800;
        pub const version = "U22242.0.0";

        /// address: 0x43002800
        /// Control A
        pub const CTRLA = @intToPtr(*volatile Mmio(8, packed struct {
            /// Software Reset
            SWRST: u1,
            /// Enable
            ENABLE: u1,
            /// Clock Unit 0 Enable
            CKEN0: u1,
            /// Clock Unit 1 Enable
            CKEN1: u1,
            /// Tx Serializer Enable
            TXEN: u1,
            /// Rx Serializer Enable
            RXEN: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x0);

        /// address: 0x43002804
        /// Clock Unit n Control
        pub const CLKCTRL = @intToPtr(*volatile [2]Mmio(32, packed struct {
            /// Slot Size
            SLOTSIZE: u2,
            /// Number of Slots in Frame
            NBSLOTS: u3,
            /// Frame Sync Width
            FSWIDTH: u2,
            /// Data Delay from Frame Sync
            BITDELAY: u1,
            /// Frame Sync Select
            FSSEL: u1,
            /// Frame Sync Invert
            FSINV: u1,
            /// Frame Sync Output Invert
            FSOUTINV: u1,
            /// Serial Clock Select
            SCKSEL: u1,
            /// Serial Clock Output Invert
            SCKOUTINV: u1,
            /// Master Clock Select
            MCKSEL: u1,
            /// Master Clock Enable
            MCKEN: u1,
            /// Master Clock Output Invert
            MCKOUTINV: u1,
            /// Master Clock Division Factor
            MCKDIV: u6,
            reserved0: u1,
            reserved1: u1,
            /// Master Clock Output Division Factor
            MCKOUTDIV: u6,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x4);

        /// address: 0x4300280c
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(16, packed struct {
            /// Receive Ready 0 Interrupt Enable
            RXRDY0: u1,
            /// Receive Ready 1 Interrupt Enable
            RXRDY1: u1,
            reserved0: u1,
            reserved1: u1,
            /// Receive Overrun 0 Interrupt Enable
            RXOR0: u1,
            /// Receive Overrun 1 Interrupt Enable
            RXOR1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Transmit Ready 0 Interrupt Enable
            TXRDY0: u1,
            /// Transmit Ready 1 Interrupt Enable
            TXRDY1: u1,
            reserved4: u1,
            reserved5: u1,
            /// Transmit Underrun 0 Interrupt Enable
            TXUR0: u1,
            /// Transmit Underrun 1 Interrupt Enable
            TXUR1: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xc);

        /// address: 0x43002810
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(16, packed struct {
            /// Receive Ready 0 Interrupt Enable
            RXRDY0: u1,
            /// Receive Ready 1 Interrupt Enable
            RXRDY1: u1,
            reserved0: u1,
            reserved1: u1,
            /// Receive Overrun 0 Interrupt Enable
            RXOR0: u1,
            /// Receive Overrun 1 Interrupt Enable
            RXOR1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Transmit Ready 0 Interrupt Enable
            TXRDY0: u1,
            /// Transmit Ready 1 Interrupt Enable
            TXRDY1: u1,
            reserved4: u1,
            reserved5: u1,
            /// Transmit Underrun 0 Interrupt Enable
            TXUR0: u1,
            /// Transmit Underrun 1 Interrupt Enable
            TXUR1: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x10);

        /// address: 0x43002814
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(16, packed struct {
            /// Receive Ready 0
            RXRDY0: u1,
            /// Receive Ready 1
            RXRDY1: u1,
            reserved0: u1,
            reserved1: u1,
            /// Receive Overrun 0
            RXOR0: u1,
            /// Receive Overrun 1
            RXOR1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Transmit Ready 0
            TXRDY0: u1,
            /// Transmit Ready 1
            TXRDY1: u1,
            reserved4: u1,
            reserved5: u1,
            /// Transmit Underrun 0
            TXUR0: u1,
            /// Transmit Underrun 1
            TXUR1: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x14);

        /// address: 0x43002818
        /// Synchronization Status
        pub const SYNCBUSY = @intToPtr(*volatile Mmio(16, packed struct {
            /// Software Reset Synchronization Status
            SWRST: u1,
            /// Enable Synchronization Status
            ENABLE: u1,
            /// Clock Unit 0 Enable Synchronization Status
            CKEN0: u1,
            /// Clock Unit 1 Enable Synchronization Status
            CKEN1: u1,
            /// Tx Serializer Enable Synchronization Status
            TXEN: u1,
            /// Rx Serializer Enable Synchronization Status
            RXEN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Tx Data Synchronization Status
            TXDATA: u1,
            /// Rx Data Synchronization Status
            RXDATA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x18);

        /// address: 0x43002820
        /// Tx Serializer Control
        pub const TXCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Serializer Mode
            SERMODE: u2,
            /// Line Default Line when Slot Disabled
            TXDEFAULT: u2,
            /// Transmit Data when Underrun
            TXSAME: u1,
            /// Clock Unit Selection
            CLKSEL: u1,
            reserved0: u1,
            /// Data Slot Formatting Adjust
            SLOTADJ: u1,
            /// Data Word Size
            DATASIZE: u3,
            reserved1: u1,
            /// Data Word Formatting Adjust
            WORDADJ: u1,
            /// Data Formatting Bit Extension
            EXTEND: u2,
            /// Data Formatting Bit Reverse
            BITREV: u1,
            /// Slot 0 Disabled for this Serializer
            SLOTDIS0: u1,
            /// Slot 1 Disabled for this Serializer
            SLOTDIS1: u1,
            /// Slot 2 Disabled for this Serializer
            SLOTDIS2: u1,
            /// Slot 3 Disabled for this Serializer
            SLOTDIS3: u1,
            /// Slot 4 Disabled for this Serializer
            SLOTDIS4: u1,
            /// Slot 5 Disabled for this Serializer
            SLOTDIS5: u1,
            /// Slot 6 Disabled for this Serializer
            SLOTDIS6: u1,
            /// Slot 7 Disabled for this Serializer
            SLOTDIS7: u1,
            /// Mono Mode
            MONO: u1,
            /// Single or Multiple DMA Channels
            DMA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x20);

        /// address: 0x43002824
        /// Rx Serializer Control
        pub const RXCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Serializer Mode
            SERMODE: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Clock Unit Selection
            CLKSEL: u1,
            reserved3: u1,
            /// Data Slot Formatting Adjust
            SLOTADJ: u1,
            /// Data Word Size
            DATASIZE: u3,
            reserved4: u1,
            /// Data Word Formatting Adjust
            WORDADJ: u1,
            /// Data Formatting Bit Extension
            EXTEND: u2,
            /// Data Formatting Bit Reverse
            BITREV: u1,
            /// Slot 0 Disabled for this Serializer
            SLOTDIS0: u1,
            /// Slot 1 Disabled for this Serializer
            SLOTDIS1: u1,
            /// Slot 2 Disabled for this Serializer
            SLOTDIS2: u1,
            /// Slot 3 Disabled for this Serializer
            SLOTDIS3: u1,
            /// Slot 4 Disabled for this Serializer
            SLOTDIS4: u1,
            /// Slot 5 Disabled for this Serializer
            SLOTDIS5: u1,
            /// Slot 6 Disabled for this Serializer
            SLOTDIS6: u1,
            /// Slot 7 Disabled for this Serializer
            SLOTDIS7: u1,
            /// Mono Mode
            MONO: u1,
            /// Single or Multiple DMA Channels
            DMA: u1,
            /// Loop-back Test Mode
            RXLOOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x24);

        /// address: 0x43002830
        /// Tx Data
        pub const TXDATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sample Data
            DATA: u32,
        }), base_address + 0x30);

        /// address: 0x43002834
        /// Rx Data
        pub const RXDATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sample Data
            DATA: u32,
        }), base_address + 0x34);
    };

    /// Main Clock
    pub const MCLK = struct {
        pub const base_address: usize = 0x40000800;
        pub const version = "U24081.0.0";

        /// address: 0x40000801
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Clock Ready Interrupt Enable
            CKRDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1);

        /// address: 0x40000802
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
            /// Clock Ready Interrupt Enable
            CKRDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x2);

        /// address: 0x40000803
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
            /// Clock Ready
            CKRDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x3);

        /// address: 0x40000804
        /// HS Clock Division
        pub const HSDIV = @intToPtr(*volatile Mmio(8, packed struct {
            /// CPU Clock Division Factor
            DIV: u8,
        }), base_address + 0x4);

        /// address: 0x40000805
        /// CPU Clock Division
        pub const CPUDIV = @intToPtr(*volatile Mmio(8, packed struct {
            /// Low-Power Clock Division Factor
            DIV: u8,
        }), base_address + 0x5);

        /// address: 0x40000810
        /// AHB Mask
        pub const AHBMASK = @intToPtr(*volatile Mmio(32, packed struct {
            /// HPB0 AHB Clock Mask
            HPB0_: u1,
            /// HPB1 AHB Clock Mask
            HPB1_: u1,
            /// HPB2 AHB Clock Mask
            HPB2_: u1,
            /// HPB3 AHB Clock Mask
            HPB3_: u1,
            /// DSU AHB Clock Mask
            DSU_: u1,
            /// HMATRIX AHB Clock Mask
            HMATRIX_: u1,
            /// NVMCTRL AHB Clock Mask
            NVMCTRL_: u1,
            /// HSRAM AHB Clock Mask
            HSRAM_: u1,
            /// CMCC AHB Clock Mask
            CMCC_: u1,
            /// DMAC AHB Clock Mask
            DMAC_: u1,
            /// USB AHB Clock Mask
            USB_: u1,
            /// BKUPRAM AHB Clock Mask
            BKUPRAM_: u1,
            /// PAC AHB Clock Mask
            PAC_: u1,
            /// QSPI AHB Clock Mask
            QSPI_: u1,
            reserved0: u1,
            /// SDHC0 AHB Clock Mask
            SDHC0_: u1,
            reserved1: u1,
            /// CAN0 AHB Clock Mask
            CAN0_: u1,
            /// CAN1 AHB Clock Mask
            CAN1_: u1,
            /// ICM AHB Clock Mask
            ICM_: u1,
            /// PUKCC AHB Clock Mask
            PUKCC_: u1,
            /// QSPI_2X AHB Clock Mask
            QSPI_2X_: u1,
            /// NVMCTRL_SMEEPROM AHB Clock Mask
            NVMCTRL_SMEEPROM_: u1,
            /// NVMCTRL_CACHE AHB Clock Mask
            NVMCTRL_CACHE_: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x10);

        /// address: 0x40000814
        /// APBA Mask
        pub const APBAMASK = @intToPtr(*volatile Mmio(32, packed struct {
            /// PAC APB Clock Enable
            PAC_: u1,
            /// PM APB Clock Enable
            PM_: u1,
            /// MCLK APB Clock Enable
            MCLK_: u1,
            /// RSTC APB Clock Enable
            RSTC_: u1,
            /// OSCCTRL APB Clock Enable
            OSCCTRL_: u1,
            /// OSC32KCTRL APB Clock Enable
            OSC32KCTRL_: u1,
            /// SUPC APB Clock Enable
            SUPC_: u1,
            /// GCLK APB Clock Enable
            GCLK_: u1,
            /// WDT APB Clock Enable
            WDT_: u1,
            /// RTC APB Clock Enable
            RTC_: u1,
            /// EIC APB Clock Enable
            EIC_: u1,
            /// FREQM APB Clock Enable
            FREQM_: u1,
            /// SERCOM0 APB Clock Enable
            SERCOM0_: u1,
            /// SERCOM1 APB Clock Enable
            SERCOM1_: u1,
            /// TC0 APB Clock Enable
            TC0_: u1,
            /// TC1 APB Clock Enable
            TC1_: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40000818
        /// APBB Mask
        pub const APBBMASK = @intToPtr(*volatile Mmio(32, packed struct {
            /// USB APB Clock Enable
            USB_: u1,
            /// DSU APB Clock Enable
            DSU_: u1,
            /// NVMCTRL APB Clock Enable
            NVMCTRL_: u1,
            reserved0: u1,
            /// PORT APB Clock Enable
            PORT_: u1,
            reserved1: u1,
            /// HMATRIX APB Clock Enable
            HMATRIX_: u1,
            /// EVSYS APB Clock Enable
            EVSYS_: u1,
            reserved2: u1,
            /// SERCOM2 APB Clock Enable
            SERCOM2_: u1,
            /// SERCOM3 APB Clock Enable
            SERCOM3_: u1,
            /// TCC0 APB Clock Enable
            TCC0_: u1,
            /// TCC1 APB Clock Enable
            TCC1_: u1,
            /// TC2 APB Clock Enable
            TC2_: u1,
            /// TC3 APB Clock Enable
            TC3_: u1,
            reserved3: u1,
            /// RAMECC APB Clock Enable
            RAMECC_: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);

        /// address: 0x4000081c
        /// APBC Mask
        pub const APBCMASK = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// TCC2 APB Clock Enable
            TCC2_: u1,
            /// TCC3 APB Clock Enable
            TCC3_: u1,
            /// TC4 APB Clock Enable
            TC4_: u1,
            /// TC5 APB Clock Enable
            TC5_: u1,
            /// PDEC APB Clock Enable
            PDEC_: u1,
            /// AC APB Clock Enable
            AC_: u1,
            /// AES APB Clock Enable
            AES_: u1,
            /// TRNG APB Clock Enable
            TRNG_: u1,
            /// ICM APB Clock Enable
            ICM_: u1,
            reserved3: u1,
            /// QSPI APB Clock Enable
            QSPI_: u1,
            /// CCL APB Clock Enable
            CCL_: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x1c);

        /// address: 0x40000820
        /// APBD Mask
        pub const APBDMASK = @intToPtr(*volatile Mmio(32, packed struct {
            /// SERCOM4 APB Clock Enable
            SERCOM4_: u1,
            /// SERCOM5 APB Clock Enable
            SERCOM5_: u1,
            reserved0: u1,
            reserved1: u1,
            /// TCC4 APB Clock Enable
            TCC4_: u1,
            reserved2: u1,
            reserved3: u1,
            /// ADC0 APB Clock Enable
            ADC0_: u1,
            /// ADC1 APB Clock Enable
            ADC1_: u1,
            /// DAC APB Clock Enable
            DAC_: u1,
            /// I2S APB Clock Enable
            I2S_: u1,
            /// PCC APB Clock Enable
            PCC_: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x20);
    };

    /// Non-Volatile Memory Controller
    pub const NVMCTRL = struct {
        pub const base_address = 0x41004000;
        pub const version = "U24091.0.0";

        /// address: 0x41004000
        /// Control A
        pub const CTRLA = @intToPtr(*volatile Mmio(16, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Auto Wait State Enable
            AUTOWS: u1,
            /// Suspend Enable
            SUSPEN: u1,
            /// Write Mode
            WMODE: u2,
            /// Power Reduction Mode during Sleep
            PRM: u2,
            /// NVM Read Wait States
            RWS: u4,
            /// Force AHB0 access to NONSEQ, burst transfers are continuously rearbitrated
            AHBNS0: u1,
            /// Force AHB1 access to NONSEQ, burst transfers are continuously rearbitrated
            AHBNS1: u1,
            /// AHB0 Cache Disable
            CACHEDIS0: u1,
            /// AHB1 Cache Disable
            CACHEDIS1: u1,
        }), base_address + 0x0);

        /// address: 0x41004004
        /// Control B
        pub const CTRLB = @intToPtr(*volatile Mmio(16, packed struct {
            /// Command
            CMD: u7,
            reserved0: u1,
            /// Command Execution
            CMDEX: u8,
        }), base_address + 0x4);

        /// address: 0x41004008
        /// NVM Parameter
        pub const PARAM = @intToPtr(*volatile Mmio(32, packed struct {
            /// NVM Pages
            NVMP: u16,
            /// Page Size
            PSZ: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// SmartEEPROM Supported
            SEE: u1,
        }), base_address + 0x8);

        /// address: 0x4100400c
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(16, packed struct {
            /// Command Done Interrupt Clear
            DONE: u1,
            /// Address Error
            ADDRE: u1,
            /// Programming Error Interrupt Clear
            PROGE: u1,
            /// Lock Error Interrupt Clear
            LOCKE: u1,
            /// ECC Single Error Interrupt Clear
            ECCSE: u1,
            /// ECC Dual Error Interrupt Clear
            ECCDE: u1,
            /// NVM Error Interrupt Clear
            NVME: u1,
            /// Suspended Write Or Erase Interrupt Clear
            SUSP: u1,
            /// Active SEES Full Interrupt Clear
            SEESFULL: u1,
            /// Active SEES Overflow Interrupt Clear
            SEESOVF: u1,
            /// SEE Write Completed Interrupt Clear
            SEEWRC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0xc);

        /// address: 0x4100400e
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(16, packed struct {
            /// Command Done Interrupt Enable
            DONE: u1,
            /// Address Error Interrupt Enable
            ADDRE: u1,
            /// Programming Error Interrupt Enable
            PROGE: u1,
            /// Lock Error Interrupt Enable
            LOCKE: u1,
            /// ECC Single Error Interrupt Enable
            ECCSE: u1,
            /// ECC Dual Error Interrupt Enable
            ECCDE: u1,
            /// NVM Error Interrupt Enable
            NVME: u1,
            /// Suspended Write Or Erase Interrupt Enable
            SUSP: u1,
            /// Active SEES Full Interrupt Enable
            SEESFULL: u1,
            /// Active SEES Overflow Interrupt Enable
            SEESOVF: u1,
            /// SEE Write Completed Interrupt Enable
            SEEWRC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0xe);

        /// address: 0x41004010
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(16, packed struct {
            /// Command Done
            DONE: u1,
            /// Address Error
            ADDRE: u1,
            /// Programming Error
            PROGE: u1,
            /// Lock Error
            LOCKE: u1,
            /// ECC Single Error
            ECCSE: u1,
            /// ECC Dual Error
            ECCDE: u1,
            /// NVM Error
            NVME: u1,
            /// Suspended Write Or Erase Operation
            SUSP: u1,
            /// Active SEES Full
            SEESFULL: u1,
            /// Active SEES Overflow
            SEESOVF: u1,
            /// SEE Write Completed
            SEEWRC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x10);

        /// address: 0x41004012
        /// Status
        pub const STATUS = @intToPtr(*volatile Mmio(16, packed struct {
            /// Ready to accept a command
            READY: u1,
            /// Power Reduction Mode
            PRM: u1,
            /// NVM Page Buffer Active Loading
            LOAD: u1,
            /// NVM Write Or Erase Operation Is Suspended
            SUSP: u1,
            /// BANKA First
            AFIRST: u1,
            /// Boot Loader Protection Disable
            BPDIS: u1,
            reserved0: u1,
            reserved1: u1,
            /// Boot Loader Protection Size
            BOOTPROT: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x12);

        /// address: 0x41004014
        /// Address
        pub const ADDR = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x14);

        /// address: 0x41004018
        /// Lock Section
        pub const RUNLOCK = @intToPtr(*volatile u32, base_address + 0x18);

        /// address: 0x4100401c
        /// Page Buffer Load Data x
        pub const PBLDATA = @intToPtr(*volatile [2]Mmio(32, packed struct {
            /// Page Buffer Data
            DATA: u32,
        }), base_address + 0x1c);

        /// address: 0x41004024
        /// ECC Error Status Register
        pub const ECCERR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error Address
            ADDR: u24,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Low Double-Word Error Type
            TYPEL: u2,
            /// High Double-Word Error Type
            TYPEH: u2,
        }), base_address + 0x24);

        /// address: 0x41004028
        /// Debug Control
        pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Debugger ECC Read Disable
            ECCDIS: u1,
            /// Debugger ECC Error Tracking Mode
            ECCELOG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x28);

        /// address: 0x4100402a
        /// SmartEEPROM Configuration Register
        pub const SEECFG = @intToPtr(*volatile Mmio(8, packed struct {
            /// Write Mode
            WMODE: u1,
            /// Automatic Page Reallocation Disable
            APRDIS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x2a);

        /// address: 0x4100402c
        /// SmartEEPROM Status Register
        pub const SEESTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Active SmartEEPROM Sector
            ASEES: u1,
            /// Page Buffer Loaded
            LOAD: u1,
            /// Busy
            BUSY: u1,
            /// SmartEEPROM Write Access Is Locked
            LOCK: u1,
            /// SmartEEPROM Write Access To Register Address Space Is Locked
            RLOCK: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Blocks Number In a Sector
            SBLK: u4,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// SmartEEPROM Page Size
            PSZ: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x2c);
    };

    /// Oscillators Control
    pub const OSCCTRL = struct {
        pub const base_address = 0x40001000;
        pub const version = "U24011.0.0";

        /// address: 0x40001000
        /// Event Control
        pub const EVCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Clock 0 Failure Detector Event Output Enable
            CFDEO0: u1,
            /// Clock 1 Failure Detector Event Output Enable
            CFDEO1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x0);

        /// address: 0x40001004
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// XOSC 0 Ready Interrupt Enable
            XOSCRDY0: u1,
            /// XOSC 1 Ready Interrupt Enable
            XOSCRDY1: u1,
            /// XOSC 0 Clock Failure Detector Interrupt Enable
            XOSCFAIL0: u1,
            /// XOSC 1 Clock Failure Detector Interrupt Enable
            XOSCFAIL1: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DFLL Ready Interrupt Enable
            DFLLRDY: u1,
            /// DFLL Out Of Bounds Interrupt Enable
            DFLLOOB: u1,
            /// DFLL Lock Fine Interrupt Enable
            DFLLLCKF: u1,
            /// DFLL Lock Coarse Interrupt Enable
            DFLLLCKC: u1,
            /// DFLL Reference Clock Stopped Interrupt Enable
            DFLLRCS: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// DPLL0 Lock Rise Interrupt Enable
            DPLL0LCKR: u1,
            /// DPLL0 Lock Fall Interrupt Enable
            DPLL0LCKF: u1,
            /// DPLL0 Lock Timeout Interrupt Enable
            DPLL0LTO: u1,
            /// DPLL0 Loop Divider Ratio Update Complete Interrupt Enable
            DPLL0LDRTO: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// DPLL1 Lock Rise Interrupt Enable
            DPLL1LCKR: u1,
            /// DPLL1 Lock Fall Interrupt Enable
            DPLL1LCKF: u1,
            /// DPLL1 Lock Timeout Interrupt Enable
            DPLL1LTO: u1,
            /// DPLL1 Loop Divider Ratio Update Complete Interrupt Enable
            DPLL1LDRTO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x4);

        /// address: 0x40001008
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// XOSC 0 Ready Interrupt Enable
            XOSCRDY0: u1,
            /// XOSC 1 Ready Interrupt Enable
            XOSCRDY1: u1,
            /// XOSC 0 Clock Failure Detector Interrupt Enable
            XOSCFAIL0: u1,
            /// XOSC 1 Clock Failure Detector Interrupt Enable
            XOSCFAIL1: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DFLL Ready Interrupt Enable
            DFLLRDY: u1,
            /// DFLL Out Of Bounds Interrupt Enable
            DFLLOOB: u1,
            /// DFLL Lock Fine Interrupt Enable
            DFLLLCKF: u1,
            /// DFLL Lock Coarse Interrupt Enable
            DFLLLCKC: u1,
            /// DFLL Reference Clock Stopped Interrupt Enable
            DFLLRCS: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// DPLL0 Lock Rise Interrupt Enable
            DPLL0LCKR: u1,
            /// DPLL0 Lock Fall Interrupt Enable
            DPLL0LCKF: u1,
            /// DPLL0 Lock Timeout Interrupt Enable
            DPLL0LTO: u1,
            /// DPLL0 Loop Divider Ratio Update Complete Interrupt Enable
            DPLL0LDRTO: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// DPLL1 Lock Rise Interrupt Enable
            DPLL1LCKR: u1,
            /// DPLL1 Lock Fall Interrupt Enable
            DPLL1LCKF: u1,
            /// DPLL1 Lock Timeout Interrupt Enable
            DPLL1LTO: u1,
            /// DPLL1 Loop Divider Ratio Update Complete Interrupt Enable
            DPLL1LDRTO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x8);

        /// address: 0x4000100c
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(32, packed struct {
            /// XOSC 0 Ready
            XOSCRDY0: u1,
            /// XOSC 1 Ready
            XOSCRDY1: u1,
            /// XOSC 0 Clock Failure Detector
            XOSCFAIL0: u1,
            /// XOSC 1 Clock Failure Detector
            XOSCFAIL1: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DFLL Ready
            DFLLRDY: u1,
            /// DFLL Out Of Bounds
            DFLLOOB: u1,
            /// DFLL Lock Fine
            DFLLLCKF: u1,
            /// DFLL Lock Coarse
            DFLLLCKC: u1,
            /// DFLL Reference Clock Stopped
            DFLLRCS: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// DPLL0 Lock Rise
            DPLL0LCKR: u1,
            /// DPLL0 Lock Fall
            DPLL0LCKF: u1,
            /// DPLL0 Lock Timeout
            DPLL0LTO: u1,
            /// DPLL0 Loop Divider Ratio Update Complete
            DPLL0LDRTO: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// DPLL1 Lock Rise
            DPLL1LCKR: u1,
            /// DPLL1 Lock Fall
            DPLL1LCKF: u1,
            /// DPLL1 Lock Timeout
            DPLL1LTO: u1,
            /// DPLL1 Loop Divider Ratio Update Complete
            DPLL1LDRTO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xc);

        /// address: 0x40001010
        /// Status
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// XOSC 0 Ready
            XOSCRDY0: u1,
            /// XOSC 1 Ready
            XOSCRDY1: u1,
            /// XOSC 0 Clock Failure Detector
            XOSCFAIL0: u1,
            /// XOSC 1 Clock Failure Detector
            XOSCFAIL1: u1,
            /// XOSC 0 Clock Switch
            XOSCCKSW0: u1,
            /// XOSC 1 Clock Switch
            XOSCCKSW1: u1,
            reserved0: u1,
            reserved1: u1,
            /// DFLL Ready
            DFLLRDY: u1,
            /// DFLL Out Of Bounds
            DFLLOOB: u1,
            /// DFLL Lock Fine
            DFLLLCKF: u1,
            /// DFLL Lock Coarse
            DFLLLCKC: u1,
            /// DFLL Reference Clock Stopped
            DFLLRCS: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// DPLL0 Lock Rise
            DPLL0LCKR: u1,
            /// DPLL0 Lock Fall
            DPLL0LCKF: u1,
            /// DPLL0 Timeout
            DPLL0TO: u1,
            /// DPLL0 Loop Divider Ratio Update Complete
            DPLL0LDRTO: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// DPLL1 Lock Rise
            DPLL1LCKR: u1,
            /// DPLL1 Lock Fall
            DPLL1LCKF: u1,
            /// DPLL1 Timeout
            DPLL1TO: u1,
            /// DPLL1 Loop Divider Ratio Update Complete
            DPLL1LDRTO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x10);

        /// address: 0x40001014
        /// External Multipurpose Crystal Oscillator Control
        pub const XOSCCTRL = @intToPtr(*volatile [2]Mmio(32, packed struct {
            reserved0: u1,
            /// Oscillator Enable
            ENABLE: u1,
            /// Crystal Oscillator Enable
            XTALEN: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Run in Standby
            RUNSTDBY: u1,
            /// On Demand Control
            ONDEMAND: u1,
            /// Low Buffer Gain Enable
            LOWBUFGAIN: u1,
            /// Oscillator Current Reference
            IPTAT: u2,
            /// Oscillator Current Multiplier
            IMULT: u4,
            /// Automatic Loop Control Enable
            ENALC: u1,
            /// Clock Failure Detector Enable
            CFDEN: u1,
            /// Xosc Clock Switch Enable
            SWBEN: u1,
            reserved4: u1,
            reserved5: u1,
            /// Start-Up Time
            STARTUP: u4,
            /// Clock Failure Detector Prescaler
            CFDPRESC: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x14);

        /// address: 0x4000101c
        /// DFLL48M Control A
        pub const DFLLCTRLA = @intToPtr(*volatile Mmio(8, packed struct {
            reserved0: u1,
            /// DFLL Enable
            ENABLE: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Run in Standby
            RUNSTDBY: u1,
            /// On Demand Control
            ONDEMAND: u1,
        }), base_address + 0x1c);

        /// address: 0x40001020
        /// DFLL48M Control B
        pub const DFLLCTRLB = @intToPtr(*volatile Mmio(8, packed struct {
            /// Operating Mode Selection
            MODE: u1,
            /// Stable DFLL Frequency
            STABLE: u1,
            /// Lose Lock After Wake
            LLAW: u1,
            /// USB Clock Recovery Mode
            USBCRM: u1,
            /// Chill Cycle Disable
            CCDIS: u1,
            /// Quick Lock Disable
            QLDIS: u1,
            /// Bypass Coarse Lock
            BPLCKC: u1,
            /// Wait Lock
            WAITLOCK: u1,
        }), base_address + 0x20);

        /// address: 0x40001024
        /// DFLL48M Value
        pub const DFLLVAL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fine Value
            FINE: u8,
            reserved0: u1,
            reserved1: u1,
            /// Coarse Value
            COARSE: u6,
            /// Multiplication Ratio Difference
            DIFF: u16,
        }), base_address + 0x24);

        /// address: 0x40001028
        /// DFLL48M Multiplier
        pub const DFLLMUL = @intToPtr(*volatile Mmio(32, packed struct {
            /// DFLL Multiply Factor
            MUL: u16,
            /// Fine Maximum Step
            FSTEP: u8,
            reserved0: u1,
            reserved1: u1,
            /// Coarse Maximum Step
            CSTEP: u6,
        }), base_address + 0x28);

        /// address: 0x4000102c
        /// DFLL48M Synchronization
        pub const DFLLSYNC = @intToPtr(*volatile Mmio(8, packed struct {
            reserved0: u1,
            /// ENABLE Synchronization Busy
            ENABLE: u1,
            /// DFLLCTRLB Synchronization Busy
            DFLLCTRLB: u1,
            /// DFLLVAL Synchronization Busy
            DFLLVAL: u1,
            /// DFLLMUL Synchronization Busy
            DFLLMUL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x2c);

        pub const DPLL = @ptrCast(*volatile [2]packed struct {
            /// DPLL Control A
            DPLLCTRLA: Mmio(8, packed struct {
                reserved0: u1,
                /// DPLL Enable
                ENABLE: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                /// Run in Standby
                RUNSTDBY: u1,
                /// On Demand Control
                ONDEMAND: u1,
            }),

            /// DPLL Ratio Control
            DPLLRATIO: Mmio(32, packed struct {
                /// Loop Divider Ratio
                LDR: u13,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// Loop Divider Ratio Fractional Part
                LDRFRAC: u5,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
            }),

            /// DPLL Control B
            DPLLCTRLB: Mmio(32, packed struct {
                /// Proportional Integral Filter Selection
                FILTER: u4,
                /// Wake Up Fast
                WUF: u1,
                /// Reference Clock Selection
                REFCLK: u3,
                /// Lock Time
                LTIME: u3,
                /// Lock Bypass
                LBYPASS: u1,
                /// Sigma-Delta DCO Filter Selection
                DCOFILTER: u3,
                /// DCO Filter Enable
                DCOEN: u1,
                /// Clock Divider
                DIV: u11,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
            }),

            /// DPLL Synchronization Busy
            DPLLSYNCBUSY: Mmio(32, packed struct {
                reserved0: u1,
                /// DPLL Enable Synchronization Status
                ENABLE: u1,
                /// DPLL Loop Divider Ratio Synchronization Status
                DPLLRATIO: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
                padding27: u1,
                padding28: u1,
            }),

            /// DPLL Status
            DPLLSTATUS: Mmio(32, packed struct {
                /// DPLL Lock Status
                LOCK: u1,
                /// DPLL Clock Ready
                CLKRDY: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
                padding27: u1,
                padding28: u1,
                padding29: u1,
            }),
        }, base_address + 0x30);
    };

    /// 32kHz Oscillators Control
    pub const OSC32KCTRL = struct {
        pub const base_address = 0x40001400;
        pub const version = "U24001.0.0";

        /// address: 0x40001400
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// XOSC32K Ready Interrupt Enable
            XOSC32KRDY: u1,
            reserved0: u1,
            /// XOSC32K Clock Failure Detector Interrupt Enable
            XOSC32KFAIL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x0);

        /// address: 0x40001404
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// XOSC32K Ready Interrupt Enable
            XOSC32KRDY: u1,
            reserved0: u1,
            /// XOSC32K Clock Failure Detector Interrupt Enable
            XOSC32KFAIL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4);

        /// address: 0x40001408
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(32, packed struct {
            /// XOSC32K Ready
            XOSC32KRDY: u1,
            reserved0: u1,
            /// XOSC32K Clock Failure Detector
            XOSC32KFAIL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x8);

        /// address: 0x4000140c
        /// Power and Clocks Status
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// XOSC32K Ready
            XOSC32KRDY: u1,
            reserved0: u1,
            /// XOSC32K Clock Failure Detector
            XOSC32KFAIL: u1,
            /// XOSC32K Clock switch
            XOSC32KSW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0xc);

        /// address: 0x40001410
        /// RTC Clock Selection
        pub const RTCCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// RTC Clock Selection
            RTCSEL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x10);

        /// address: 0x40001414
        /// 32kHz External Crystal Oscillator (XOSC32K) Control
        pub const XOSC32K = @intToPtr(*volatile Mmio(16, packed struct {
            reserved0: u1,
            /// Oscillator Enable
            ENABLE: u1,
            /// Crystal Oscillator Enable
            XTALEN: u1,
            /// 32kHz Output Enable
            EN32K: u1,
            /// 1kHz Output Enable
            EN1K: u1,
            reserved1: u1,
            /// Run in Standby
            RUNSTDBY: u1,
            /// On Demand Control
            ONDEMAND: u1,
            /// Oscillator Start-Up Time
            STARTUP: u3,
            reserved2: u1,
            /// Write Lock
            WRTLOCK: u1,
            /// Control Gain Mode
            CGM: u2,
            padding0: u1,
        }), base_address + 0x14);

        /// address: 0x40001416
        /// Clock Failure Detector Control
        pub const CFDCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Clock Failure Detector Enable
            CFDEN: u1,
            /// Clock Switch Back
            SWBACK: u1,
            /// Clock Failure Detector Prescaler
            CFDPRESC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x16);

        /// address: 0x40001417
        /// Event Control
        pub const EVCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Clock Failure Detector Event Output Enable
            CFDEO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x17);

        /// address: 0x4000141c
        /// 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control
        pub const OSCULP32K = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Enable Out 32k
            EN32K: u1,
            /// Enable Out 1k
            EN1K: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Oscillator Calibration
            CALIB: u6,
            reserved6: u1,
            /// Write Lock
            WRTLOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);
    };

    /// Peripheral Access Controller
    pub const PAC = struct {
        pub const base_address = 0x40000000;
        pub const version = "U21201.2.0";

        /// address: 0x40000000
        /// Write control
        pub const WRCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral identifier
            PERID: u16,
            /// Peripheral access control key
            KEY: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40000004
        /// Event control
        pub const EVCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Peripheral acess error event output
            ERREO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x4);

        /// address: 0x40000008
        /// Interrupt enable clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Peripheral access error interrupt disable
            ERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x8);

        /// address: 0x40000009
        /// Interrupt enable set
        pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
            /// Peripheral access error interrupt enable
            ERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x9);

        /// address: 0x40000010
        /// Bridge interrupt flag status
        pub const INTFLAGAHB = @intToPtr(*volatile Mmio(32, packed struct {
            /// FLASH
            FLASH_: u1,
            /// FLASH_ALT
            FLASH_ALT_: u1,
            /// SEEPROM
            SEEPROM_: u1,
            /// RAMCM4S
            RAMCM4S_: u1,
            /// RAMPPPDSU
            RAMPPPDSU_: u1,
            /// RAMDMAWR
            RAMDMAWR_: u1,
            /// RAMDMACICM
            RAMDMACICM_: u1,
            /// HPB0
            HPB0_: u1,
            /// HPB1
            HPB1_: u1,
            /// HPB2
            HPB2_: u1,
            /// HPB3
            HPB3_: u1,
            /// PUKCC
            PUKCC_: u1,
            /// SDHC0
            SDHC0_: u1,
            reserved0: u1,
            /// QSPI
            QSPI_: u1,
            /// BKUPRAM
            BKUPRAM_: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40000014
        /// Peripheral interrupt flag status - Bridge A
        pub const INTFLAGA = @intToPtr(*volatile Mmio(32, packed struct {
            /// PAC
            PAC_: u1,
            /// PM
            PM_: u1,
            /// MCLK
            MCLK_: u1,
            /// RSTC
            RSTC_: u1,
            /// OSCCTRL
            OSCCTRL_: u1,
            /// OSC32KCTRL
            OSC32KCTRL_: u1,
            /// SUPC
            SUPC_: u1,
            /// GCLK
            GCLK_: u1,
            /// WDT
            WDT_: u1,
            /// RTC
            RTC_: u1,
            /// EIC
            EIC_: u1,
            /// FREQM
            FREQM_: u1,
            /// SERCOM0
            SERCOM0_: u1,
            /// SERCOM1
            SERCOM1_: u1,
            /// TC0
            TC0_: u1,
            /// TC1
            TC1_: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40000018
        /// Peripheral interrupt flag status - Bridge B
        pub const INTFLAGB = @intToPtr(*volatile Mmio(32, packed struct {
            /// USB
            USB_: u1,
            /// DSU
            DSU_: u1,
            /// NVMCTRL
            NVMCTRL_: u1,
            /// CMCC
            CMCC_: u1,
            /// PORT
            PORT_: u1,
            /// DMAC
            DMAC_: u1,
            /// HMATRIX
            HMATRIX_: u1,
            /// EVSYS
            EVSYS_: u1,
            reserved0: u1,
            /// SERCOM2
            SERCOM2_: u1,
            /// SERCOM3
            SERCOM3_: u1,
            /// TCC0
            TCC0_: u1,
            /// TCC1
            TCC1_: u1,
            /// TC2
            TC2_: u1,
            /// TC3
            TC3_: u1,
            reserved1: u1,
            /// RAMECC
            RAMECC_: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);

        /// address: 0x4000001c
        /// Peripheral interrupt flag status - Bridge C
        pub const INTFLAGC = @intToPtr(*volatile Mmio(32, packed struct {
            /// CAN0
            CAN0_: u1,
            /// CAN1
            CAN1_: u1,
            reserved0: u1,
            /// TCC2
            TCC2_: u1,
            /// TCC3
            TCC3_: u1,
            /// TC4
            TC4_: u1,
            /// TC5
            TC5_: u1,
            /// PDEC
            PDEC_: u1,
            /// AC
            AC_: u1,
            /// AES
            AES_: u1,
            /// TRNG
            TRNG_: u1,
            /// ICM
            ICM_: u1,
            /// PUKCC
            PUKCC_: u1,
            /// QSPI
            QSPI_: u1,
            /// CCL
            CCL_: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x1c);

        /// address: 0x40000020
        /// Peripheral interrupt flag status - Bridge D
        pub const INTFLAGD = @intToPtr(*volatile Mmio(32, packed struct {
            /// SERCOM4
            SERCOM4_: u1,
            /// SERCOM5
            SERCOM5_: u1,
            reserved0: u1,
            reserved1: u1,
            /// TCC4
            TCC4_: u1,
            reserved2: u1,
            reserved3: u1,
            /// ADC0
            ADC0_: u1,
            /// ADC1
            ADC1_: u1,
            /// DAC
            DAC_: u1,
            /// I2S
            I2S_: u1,
            /// PCC
            PCC_: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x20);

        /// address: 0x40000034
        /// Peripheral write protection status - Bridge A
        pub const STATUSA = @intToPtr(*volatile Mmio(32, packed struct {
            /// PAC APB Protect Enable
            PAC_: u1,
            /// PM APB Protect Enable
            PM_: u1,
            /// MCLK APB Protect Enable
            MCLK_: u1,
            /// RSTC APB Protect Enable
            RSTC_: u1,
            /// OSCCTRL APB Protect Enable
            OSCCTRL_: u1,
            /// OSC32KCTRL APB Protect Enable
            OSC32KCTRL_: u1,
            /// SUPC APB Protect Enable
            SUPC_: u1,
            /// GCLK APB Protect Enable
            GCLK_: u1,
            /// WDT APB Protect Enable
            WDT_: u1,
            /// RTC APB Protect Enable
            RTC_: u1,
            /// EIC APB Protect Enable
            EIC_: u1,
            /// FREQM APB Protect Enable
            FREQM_: u1,
            /// SERCOM0 APB Protect Enable
            SERCOM0_: u1,
            /// SERCOM1 APB Protect Enable
            SERCOM1_: u1,
            /// TC0 APB Protect Enable
            TC0_: u1,
            /// TC1 APB Protect Enable
            TC1_: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40000038
        /// Peripheral write protection status - Bridge B
        pub const STATUSB = @intToPtr(*volatile Mmio(32, packed struct {
            /// USB APB Protect Enable
            USB_: u1,
            /// DSU APB Protect Enable
            DSU_: u1,
            /// NVMCTRL APB Protect Enable
            NVMCTRL_: u1,
            /// CMCC APB Protect Enable
            CMCC_: u1,
            /// PORT APB Protect Enable
            PORT_: u1,
            /// DMAC APB Protect Enable
            DMAC_: u1,
            /// HMATRIX APB Protect Enable
            HMATRIX_: u1,
            /// EVSYS APB Protect Enable
            EVSYS_: u1,
            reserved0: u1,
            /// SERCOM2 APB Protect Enable
            SERCOM2_: u1,
            /// SERCOM3 APB Protect Enable
            SERCOM3_: u1,
            /// TCC0 APB Protect Enable
            TCC0_: u1,
            /// TCC1 APB Protect Enable
            TCC1_: u1,
            /// TC2 APB Protect Enable
            TC2_: u1,
            /// TC3 APB Protect Enable
            TC3_: u1,
            reserved1: u1,
            /// RAMECC APB Protect Enable
            RAMECC_: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x38);

        /// address: 0x4000003c
        /// Peripheral write protection status - Bridge C
        pub const STATUSC = @intToPtr(*volatile Mmio(32, packed struct {
            /// CAN0 APB Protect Enable
            CAN0_: u1,
            /// CAN1 APB Protect Enable
            CAN1_: u1,
            reserved0: u1,
            /// TCC2 APB Protect Enable
            TCC2_: u1,
            /// TCC3 APB Protect Enable
            TCC3_: u1,
            /// TC4 APB Protect Enable
            TC4_: u1,
            /// TC5 APB Protect Enable
            TC5_: u1,
            /// PDEC APB Protect Enable
            PDEC_: u1,
            /// AC APB Protect Enable
            AC_: u1,
            /// AES APB Protect Enable
            AES_: u1,
            /// TRNG APB Protect Enable
            TRNG_: u1,
            /// ICM APB Protect Enable
            ICM_: u1,
            /// PUKCC APB Protect Enable
            PUKCC_: u1,
            /// QSPI APB Protect Enable
            QSPI_: u1,
            /// CCL APB Protect Enable
            CCL_: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x3c);

        /// address: 0x40000040
        /// Peripheral write protection status - Bridge D
        pub const STATUSD = @intToPtr(*volatile Mmio(32, packed struct {
            /// SERCOM4 APB Protect Enable
            SERCOM4_: u1,
            /// SERCOM5 APB Protect Enable
            SERCOM5_: u1,
            reserved0: u1,
            reserved1: u1,
            /// TCC4 APB Protect Enable
            TCC4_: u1,
            reserved2: u1,
            reserved3: u1,
            /// ADC0 APB Protect Enable
            ADC0_: u1,
            /// ADC1 APB Protect Enable
            ADC1_: u1,
            /// DAC APB Protect Enable
            DAC_: u1,
            /// I2S APB Protect Enable
            I2S_: u1,
            /// PCC APB Protect Enable
            PCC_: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x40);
    };

    /// Parallel Capture Controller
    pub const PCC = struct {
        pub const base_address = 0x43002c00;
        pub const version = "U20171.1.0";

        /// address: 0x43002c00
        /// Mode Register
        pub const MR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parallel Capture Enable
            PCEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Data size
            DSIZE: u2,
            reserved3: u1,
            reserved4: u1,
            /// Scale data
            SCALE: u1,
            /// Always Sampling
            ALWYS: u1,
            /// Half Sampling
            HALFS: u1,
            /// First sample
            FRSTS: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Input Data Size
            ISIZE: u3,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// Clear If Disabled
            CID: u2,
        }), base_address + 0x0);

        /// address: 0x43002c04
        /// Interrupt Enable Register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Ready Interrupt Enable
            DRDY: u1,
            /// Overrun Error Interrupt Enable
            OVRE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x4);

        /// address: 0x43002c08
        /// Interrupt Disable Register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Ready Interrupt Disable
            DRDY: u1,
            /// Overrun Error Interrupt Disable
            OVRE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x8);

        /// address: 0x43002c0c
        /// Interrupt Mask Register
        pub const IMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Ready Interrupt Mask
            DRDY: u1,
            /// Overrun Error Interrupt Mask
            OVRE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x43002c10
        /// Interrupt Status Register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Ready Interrupt Status
            DRDY: u1,
            /// Overrun Error Interrupt Status
            OVRE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x10);

        /// address: 0x43002c14
        /// Reception Holding Register
        pub const RHR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reception Data
            RDATA: u32,
        }), base_address + 0x14);

        /// address: 0x43002ce0
        /// Write Protection Mode Register
        pub const WPMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write Protection Enable
            WPEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Write Protection Key
            WPKEY: u24,
        }), base_address + 0xe0);

        /// address: 0x43002ce4
        /// Write Protection Status Register
        pub const WPSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write Protection Violation Source
            WPVS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Write Protection Violation Status
            WPVSRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xe4);
    };

    /// Quadrature Decodeur
    pub const PDEC = struct {
        pub const base_address = 0x42001c00;
        pub const version = "U22631.0.0";

        /// address: 0x42001c00
        /// Control A
        pub const CTRLA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Reset
            SWRST: u1,
            /// Enable
            ENABLE: u1,
            /// Operation Mode
            MODE: u2,
            reserved0: u1,
            reserved1: u1,
            /// Run in Standby
            RUNSTDBY: u1,
            reserved2: u1,
            /// PDEC Configuration
            CONF: u3,
            /// Auto Lock
            ALOCK: u1,
            reserved3: u1,
            reserved4: u1,
            /// PDEC Phase A and B Swap
            SWAP: u1,
            /// Period Enable
            PEREN: u1,
            /// PDEC Input From Pin 0 Enable
            PINEN0: u1,
            /// PDEC Input From Pin 1 Enable
            PINEN1: u1,
            /// PDEC Input From Pin 2 Enable
            PINEN2: u1,
            reserved5: u1,
            /// IO Pin 0 Invert Enable
            PINVEN0: u1,
            /// IO Pin 1 Invert Enable
            PINVEN1: u1,
            /// IO Pin 2 Invert Enable
            PINVEN2: u1,
            reserved6: u1,
            /// Angular Counter Length
            ANGULAR: u3,
            reserved7: u1,
            /// Maximum Consecutive Missing Pulses
            MAXCMP: u4,
        }), base_address + 0x0);

        /// address: 0x42001c04
        /// Control B Clear
        pub const CTRLBCLR = @intToPtr(*volatile Mmio(8, packed struct {
            reserved0: u1,
            /// Lock Update
            LUPD: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Command
            CMD: u3,
        }), base_address + 0x4);

        /// address: 0x42001c05
        /// Control B Set
        pub const CTRLBSET = @intToPtr(*volatile Mmio(8, packed struct {
            reserved0: u1,
            /// Lock Update
            LUPD: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Command
            CMD: u3,
        }), base_address + 0x5);

        /// address: 0x42001c06
        /// Event Control
        pub const EVCTRL = @intToPtr(*volatile Mmio(16, packed struct {
            /// Event Action
            EVACT: u2,
            /// Inverted Event Input Enable
            EVINV: u3,
            /// Event Input Enable
            EVEI: u3,
            /// Overflow/Underflow Output Event Enable
            OVFEO: u1,
            /// Error Output Event Enable
            ERREO: u1,
            /// Direction Output Event Enable
            DIREO: u1,
            /// Velocity Output Event Enable
            VLCEO: u1,
            /// Match Channel 0 Event Output Enable
            MCEO0: u1,
            /// Match Channel 1 Event Output Enable
            MCEO1: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x6);

        /// address: 0x42001c08
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Overflow/Underflow Interrupt Disable
            OVF: u1,
            /// Error Interrupt Disable
            ERR: u1,
            /// Direction Interrupt Disable
            DIR: u1,
            /// Velocity Interrupt Disable
            VLC: u1,
            /// Channel 0 Compare Match Disable
            MC0: u1,
            /// Channel 1 Compare Match Disable
            MC1: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x8);

        /// address: 0x42001c09
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
            /// Overflow/Underflow Interrupt Enable
            OVF: u1,
            /// Error Interrupt Enable
            ERR: u1,
            /// Direction Interrupt Enable
            DIR: u1,
            /// Velocity Interrupt Enable
            VLC: u1,
            /// Channel 0 Compare Match Enable
            MC0: u1,
            /// Channel 1 Compare Match Enable
            MC1: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x9);

        /// address: 0x42001c0a
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
            /// Overflow/Underflow
            OVF: u1,
            /// Error
            ERR: u1,
            /// Direction Change
            DIR: u1,
            /// Velocity
            VLC: u1,
            /// Channel 0 Compare Match
            MC0: u1,
            /// Channel 1 Compare Match
            MC1: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xa);

        /// address: 0x42001c0c
        /// Status
        pub const STATUS = @intToPtr(*volatile Mmio(16, packed struct {
            /// Quadrature Error Flag
            QERR: u1,
            /// Index Error Flag
            IDXERR: u1,
            /// Missing Pulse Error flag
            MPERR: u1,
            reserved0: u1,
            /// Window Error Flag
            WINERR: u1,
            /// Hall Error Flag
            HERR: u1,
            /// Stop
            STOP: u1,
            /// Direction Status Flag
            DIR: u1,
            /// Prescaler Buffer Valid
            PRESCBUFV: u1,
            /// Filter Buffer Valid
            FILTERBUFV: u1,
            reserved1: u1,
            reserved2: u1,
            /// Compare Channel 0 Buffer Valid
            CCBUFV0: u1,
            /// Compare Channel 1 Buffer Valid
            CCBUFV1: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xc);

        /// address: 0x42001c0f
        /// Debug Control
        pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Debug Run Mode
            DBGRUN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0xf);

        /// address: 0x42001c10
        /// Synchronization Status
        pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Reset Synchronization Busy
            SWRST: u1,
            /// Enable Synchronization Busy
            ENABLE: u1,
            /// Control B Synchronization Busy
            CTRLB: u1,
            /// Status Synchronization Busy
            STATUS: u1,
            /// Prescaler Synchronization Busy
            PRESC: u1,
            /// Filter Synchronization Busy
            FILTER: u1,
            /// Count Synchronization Busy
            COUNT: u1,
            /// Compare Channel 0 Synchronization Busy
            CC0: u1,
            /// Compare Channel 1 Synchronization Busy
            CC1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x10);

        /// address: 0x42001c14
        /// Prescaler Value
        pub const PRESC = @intToPtr(*volatile MmioInt(8, u4), base_address + 0x14);

        /// address: 0x42001c15
        /// Filter Value
        pub const FILTER = @intToPtr(*volatile u8, base_address + 0x15);

        /// address: 0x42001c18
        /// Prescaler Buffer Value
        pub const PRESCBUF = @intToPtr(*volatile MmioInt(8, u4), base_address + 0x18);

        /// address: 0x42001c19
        /// Filter Buffer Value
        pub const FILTERBUF = @intToPtr(*volatile u8, base_address + 0x19);

        /// address: 0x42001c1c
        /// Counter Value
        pub const COUNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x1c);

        /// address: 0x42001c20
        /// Channel n Compare Value
        pub const CC = @intToPtr(*volatile [2]MmioInt(32, u16), base_address + 0x20);

        /// address: 0x42001c30
        /// Channel Compare Buffer Value
        pub const CCBUF = @intToPtr(*volatile [2]MmioInt(32, u16), base_address + 0x30);
    };

    /// Power Manager
    pub const PM = struct {
        pub const base_address = 0x40000400;
        pub const version = "U24061.0.0";

        /// address: 0x40000400
        /// Control A
        pub const CTRLA = @intToPtr(*volatile Mmio(8, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// I/O Retention
            IORET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x0);

        /// address: 0x40000401
        /// Sleep Configuration
        pub const SLEEPCFG = @intToPtr(*volatile Mmio(8, packed struct {
            /// Sleep Mode
            SLEEPMODE: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x1);

        /// address: 0x40000404
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Sleep Mode Entry Ready Enable
            SLEEPRDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x4);

        /// address: 0x40000405
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
            /// Sleep Mode Entry Ready Enable
            SLEEPRDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x5);

        /// address: 0x40000406
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
            /// Sleep Mode Entry Ready
            SLEEPRDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x6);

        /// address: 0x40000408
        /// Standby Configuration
        pub const STDBYCFG = @intToPtr(*volatile Mmio(8, packed struct {
            /// Ram Configuration
            RAMCFG: u2,
            reserved0: u1,
            reserved1: u1,
            /// Fast Wakeup
            FASTWKUP: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x8);

        /// address: 0x40000409
        /// Hibernate Configuration
        pub const HIBCFG = @intToPtr(*volatile Mmio(8, packed struct {
            /// Ram Configuration
            RAMCFG: u2,
            /// Backup Ram Configuration
            BRAMCFG: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x9);

        /// address: 0x4000040a
        /// Backup Configuration
        pub const BKUPCFG = @intToPtr(*volatile Mmio(8, packed struct {
            /// Ram Configuration
            BRAMCFG: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0xa);

        /// address: 0x40000412
        /// Power Switch Acknowledge Delay
        pub const PWSAKDLY = @intToPtr(*volatile Mmio(8, packed struct {
            /// Delay Value
            DLYVAL: u7,
            /// Ignore Acknowledge
            IGNACK: u1,
        }), base_address + 0x12);
    };

    /// Port Module
    pub const PORT = struct {
        pub const base_address = @intToPtr([*]u8, 0x41008000);
        pub const version = "U22102.2.0";

        pub const GROUP = @ptrCast(*volatile [2]packed struct {
            /// Data Direction
            DIR: u32,

            /// Data Direction Clear
            DIRCLR: u32,

            /// Data Direction Set
            DIRSET: u32,

            /// Data Direction Toggle
            DIRTGL: u32,

            /// Data Output Value
            OUT: u32,

            /// Data Output Value Clear
            OUTCLR: u32,

            /// Data Output Value Set
            OUTSET: u32,

            /// Data Output Value Toggle
            OUTTGL: u32,

            /// Data Input Value
            IN: u32,

            /// Control
            CTRL: Mmio(32, packed struct {
                /// Input Sampling Mode
                SAMPLING: u32,
            }),

            /// Write Configuration
            WRCONFIG: Mmio(32, packed struct {
                /// Pin Mask for Multiple Pin Configuration
                PINMASK: u16,
                /// Peripheral Multiplexer Enable
                PMUXEN: u1,
                /// Input Enable
                INEN: u1,
                /// Pull Enable
                PULLEN: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// Output Driver Strength Selection
                DRVSTR: u1,
                reserved3: u1,
                /// Peripheral Multiplexing
                PMUX: u4,
                /// Write PMUX
                WRPMUX: u1,
                reserved4: u1,
                /// Write PINCFG
                WRPINCFG: u1,
                /// Half-Word Select
                HWSEL: u1,
            }),

            /// Event Input Control
            EVCTRL: Mmio(32, packed struct {
                /// PORT Event Pin Identifier 0
                PID0: u5,
                /// PORT Event Action 0
                EVACT0: u2,
                /// PORT Event Input Enable 0
                PORTEI0: u1,
                /// PORT Event Pin Identifier 1
                PID1: u5,
                /// PORT Event Action 1
                EVACT1: u2,
                /// PORT Event Input Enable 1
                PORTEI1: u1,
                /// PORT Event Pin Identifier 2
                PID2: u5,
                /// PORT Event Action 2
                EVACT2: u2,
                /// PORT Event Input Enable 2
                PORTEI2: u1,
                /// PORT Event Pin Identifier 3
                PID3: u5,
                /// PORT Event Action 3
                EVACT3: u2,
                /// PORT Event Input Enable 3
                PORTEI3: u1,
            }),

            /// Peripheral Multiplexing
            PMUX: [16]Mmio(8, packed struct {
                /// Peripheral Multiplexing for Even-Numbered Pin
                PMUXE: u4,
                /// Peripheral Multiplexing for Odd-Numbered Pin
                PMUXO: u4,
            }),

            /// Pin Configuration
            PINCFG: [32]Mmio(8, packed struct {
                /// Peripheral Multiplexer Enable
                PMUXEN: u1,
                /// Input Enable
                INEN: u1,
                /// Pull Enable
                PULLEN: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// Output Driver Strength Selection
                DRVSTR: u1,
                padding0: u1,
            }),
            padding0: u32,
            padding1: u32,
            padding2: u32,
            padding3: u32,
            padding4: u32,
            padding5: u32,
            padding6: u32,
            padding7: u32,
            //padding8: u32,
            //padding9: u32,
            //padding10: u32,
            //padding11: u32,
            //padding12: u32,
            //padding13: u32,
            //padding14: u32,
            //padding15: u32,
            //padding16: u32,
            //padding17: u32,
            //padding18: u32,
        }, base_address);
    };

    /// Quad SPI interface
    pub const QSPI = struct {
        pub const base_address = 0x42003400;
        pub const version = "U20081.6.3";

        /// address: 0x42003400
        /// Control A
        pub const CTRLA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Reset
            SWRST: u1,
            /// Enable
            ENABLE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// Last Transfer
            LASTXFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x0);

        /// address: 0x42003404
        /// Control B
        pub const CTRLB = @intToPtr(*volatile Mmio(32, packed struct {
            /// Serial Memory Mode
            MODE: u1,
            /// Local Loopback Enable
            LOOPEN: u1,
            /// Wait Data Read Before Transfer
            WDRBT: u1,
            /// Serial Memory reg
            SMEMREG: u1,
            /// Chip Select Mode
            CSMODE: u2,
            reserved0: u1,
            reserved1: u1,
            /// Data Length
            DATALEN: u4,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Delay Between Consecutive Transfers
            DLYBCT: u8,
            /// Minimum Inactive CS Delay
            DLYCS: u8,
        }), base_address + 0x4);

        /// address: 0x42003408
        /// Baud Rate
        pub const BAUD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock Polarity
            CPOL: u1,
            /// Clock Phase
            CPHA: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Serial Clock Baud Rate
            BAUD: u8,
            /// Delay Before SCK
            DLYBS: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x8);

        /// address: 0x4200340c
        /// Receive Data
        pub const RXDATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive Data
            DATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x42003410
        /// Transmit Data
        pub const TXDATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Data
            DATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x42003414
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive Data Register Full Interrupt Disable
            RXC: u1,
            /// Transmit Data Register Empty Interrupt Disable
            DRE: u1,
            /// Transmission Complete Interrupt Disable
            TXC: u1,
            /// Overrun Error Interrupt Disable
            ERROR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Chip Select Rise Interrupt Disable
            CSRISE: u1,
            reserved4: u1,
            /// Instruction End Interrupt Disable
            INSTREND: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x14);

        /// address: 0x42003418
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive Data Register Full Interrupt Enable
            RXC: u1,
            /// Transmit Data Register Empty Interrupt Enable
            DRE: u1,
            /// Transmission Complete Interrupt Enable
            TXC: u1,
            /// Overrun Error Interrupt Enable
            ERROR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Chip Select Rise Interrupt Enable
            CSRISE: u1,
            reserved4: u1,
            /// Instruction End Interrupt Enable
            INSTREND: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x18);

        /// address: 0x4200341c
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive Data Register Full
            RXC: u1,
            /// Transmit Data Register Empty
            DRE: u1,
            /// Transmission Complete
            TXC: u1,
            /// Overrun Error
            ERROR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Chip Select Rise
            CSRISE: u1,
            reserved4: u1,
            /// Instruction End
            INSTREND: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1c);

        /// address: 0x42003420
        /// Status Register
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Enable
            ENABLE: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Chip Select
            CSSTATUS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);

        /// address: 0x42003430
        /// Instruction Address
        pub const INSTRADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Instruction Address
            ADDR: u32,
        }), base_address + 0x30);

        /// address: 0x42003434
        /// Instruction Code
        pub const INSTRCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Instruction Code
            INSTR: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Option Code
            OPTCODE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x42003438
        /// Instruction Frame
        pub const INSTRFRAME = @intToPtr(*volatile Mmio(32, packed struct {
            /// Instruction Code, Address, Option Code and Data Width
            WIDTH: u3,
            reserved0: u1,
            /// Instruction Enable
            INSTREN: u1,
            /// Address Enable
            ADDREN: u1,
            /// Option Enable
            OPTCODEEN: u1,
            /// Data Enable
            DATAEN: u1,
            /// Option Code Length
            OPTCODELEN: u2,
            /// Address Length
            ADDRLEN: u1,
            reserved1: u1,
            /// Data Transfer Type
            TFRTYPE: u2,
            /// Continuous Read Mode
            CRMODE: u1,
            /// Double Data Rate Enable
            DDREN: u1,
            /// Dummy Cycles Length
            DUMMYLEN: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x38);

        /// address: 0x42003440
        /// Scrambling Mode
        pub const SCRAMBCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Scrambling/Unscrambling Enable
            ENABLE: u1,
            /// Scrambling/Unscrambling Random Value Disable
            RANDOMDIS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x40);

        /// address: 0x42003444
        /// Scrambling Key
        pub const SCRAMBKEY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Scrambling User Key
            KEY: u32,
        }), base_address + 0x44);
    };

    /// RAM ECC
    pub const RAMECC = struct {
        pub const base_address = 0x41020000;
        pub const version = "U22681.0.0";

        /// address: 0x41020000
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Single Bit ECC Error Interrupt Enable Clear
            SINGLEE: u1,
            /// Dual Bit ECC Error Interrupt Enable Clear
            DUALE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x0);

        /// address: 0x41020001
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
            /// Single Bit ECC Error Interrupt Enable Set
            SINGLEE: u1,
            /// Dual Bit ECC Error Interrupt Enable Set
            DUALE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x1);

        /// address: 0x41020002
        /// Interrupt Flag
        pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
            /// Single Bit ECC Error Interrupt
            SINGLEE: u1,
            /// Dual Bit ECC Error Interrupt
            DUALE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x2);

        /// address: 0x41020003
        /// Status
        pub const STATUS = @intToPtr(*volatile Mmio(8, packed struct {
            /// ECC Disable
            ECCDIS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x3);

        /// address: 0x41020004
        /// Error Address
        pub const ERRADDR = @intToPtr(*volatile MmioInt(32, u17), base_address + 0x4);

        /// address: 0x4102000f
        /// Debug Control
        pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// ECC Disable
            ECCDIS: u1,
            /// ECC Error Log
            ECCELOG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0xf);
    };

    /// Reset Controller
    pub const RSTC = struct {
        pub const base_address = 0x40000c00;
        pub const version = "U22394.0.0";

        /// address: 0x40000c00
        /// Reset Cause
        pub const RCAUSE = @intToPtr(*volatile Mmio(8, packed struct {
            /// Power On Reset
            POR: u1,
            /// Brown Out CORE Detector Reset
            BODCORE: u1,
            /// Brown Out VDD Detector Reset
            BODVDD: u1,
            /// NVM Reset
            NVM: u1,
            /// External Reset
            EXT: u1,
            /// Watchdog Reset
            WDT: u1,
            /// System Reset Request
            SYST: u1,
            /// Backup Reset
            BACKUP: u1,
        }), base_address + 0x0);

        /// address: 0x40000c02
        /// Backup Exit Source
        pub const BKUPEXIT = @intToPtr(*volatile Mmio(8, packed struct {
            reserved0: u1,
            /// Real Timer Counter Interrupt
            RTC: u1,
            /// Battery Backup Power Switch
            BBPS: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Hibernate
            HIB: u1,
        }), base_address + 0x2);
    };

    /// Real-Time Counter
    pub const RTC = struct {
        pub const base_address = 0x40002400;
        pub const version = "U22502.1.0";

        /// 32-bit Counter with Single 32-bit Compare
        pub const MODE0 = struct {
            /// address: 0x40002400
            /// MODE0 Control A
            pub const CTRLA = @intToPtr(*volatile Mmio(16, packed struct {
                /// Software Reset
                SWRST: u1,
                /// Enable
                ENABLE: u1,
                /// Operating Mode
                MODE: u2,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// Clear on Match
                MATCHCLR: u1,
                /// Prescaler
                PRESCALER: u4,
                reserved3: u1,
                /// BKUP Registers Reset On Tamper Enable
                BKTRST: u1,
                /// GP Registers Reset On Tamper Enable
                GPTRST: u1,
                /// Count Read Synchronization Enable
                COUNTSYNC: u1,
            }), base_address + 0x0);

            /// address: 0x40002402
            /// MODE0 Control B
            pub const CTRLB = @intToPtr(*volatile Mmio(16, packed struct {
                /// General Purpose 0 Enable
                GP0EN: u1,
                /// General Purpose 2 Enable
                GP2EN: u1,
                reserved0: u1,
                reserved1: u1,
                /// Debouncer Majority Enable
                DEBMAJ: u1,
                /// Debouncer Asynchronous Enable
                DEBASYNC: u1,
                /// RTC Output Enable
                RTCOUT: u1,
                /// DMA Enable
                DMAEN: u1,
                /// Debounce Freqnuency
                DEBF: u3,
                reserved2: u1,
                /// Active Layer Freqnuency
                ACTF: u3,
                padding0: u1,
            }), base_address + 0x2);

            /// address: 0x40002404
            /// MODE0 Event Control
            pub const EVCTRL = @intToPtr(*volatile Mmio(32, packed struct {
                /// Periodic Interval 0 Event Output Enable
                PEREO0: u1,
                /// Periodic Interval 1 Event Output Enable
                PEREO1: u1,
                /// Periodic Interval 2 Event Output Enable
                PEREO2: u1,
                /// Periodic Interval 3 Event Output Enable
                PEREO3: u1,
                /// Periodic Interval 4 Event Output Enable
                PEREO4: u1,
                /// Periodic Interval 5 Event Output Enable
                PEREO5: u1,
                /// Periodic Interval 6 Event Output Enable
                PEREO6: u1,
                /// Periodic Interval 7 Event Output Enable
                PEREO7: u1,
                /// Compare 0 Event Output Enable
                CMPEO0: u1,
                /// Compare 1 Event Output Enable
                CMPEO1: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Tamper Event Output Enable
                TAMPEREO: u1,
                /// Overflow Event Output Enable
                OVFEO: u1,
                /// Tamper Event Input Enable
                TAMPEVEI: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
            }), base_address + 0x4);

            /// address: 0x40002408
            /// MODE0 Interrupt Enable Clear
            pub const INTENCLR = @intToPtr(*volatile Mmio(16, packed struct {
                /// Periodic Interval 0 Interrupt Enable
                PER0: u1,
                /// Periodic Interval 1 Interrupt Enable
                PER1: u1,
                /// Periodic Interval 2 Interrupt Enable
                PER2: u1,
                /// Periodic Interval 3 Interrupt Enable
                PER3: u1,
                /// Periodic Interval 4 Interrupt Enable
                PER4: u1,
                /// Periodic Interval 5 Interrupt Enable
                PER5: u1,
                /// Periodic Interval 6 Interrupt Enable
                PER6: u1,
                /// Periodic Interval 7 Interrupt Enable
                PER7: u1,
                /// Compare 0 Interrupt Enable
                CMP0: u1,
                /// Compare 1 Interrupt Enable
                CMP1: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Tamper Enable
                TAMPER: u1,
                /// Overflow Interrupt Enable
                OVF: u1,
            }), base_address + 0x8);

            /// address: 0x4000240a
            /// MODE0 Interrupt Enable Set
            pub const INTENSET = @intToPtr(*volatile Mmio(16, packed struct {
                /// Periodic Interval 0 Interrupt Enable
                PER0: u1,
                /// Periodic Interval 1 Interrupt Enable
                PER1: u1,
                /// Periodic Interval 2 Interrupt Enable
                PER2: u1,
                /// Periodic Interval 3 Interrupt Enable
                PER3: u1,
                /// Periodic Interval 4 Interrupt Enable
                PER4: u1,
                /// Periodic Interval 5 Interrupt Enable
                PER5: u1,
                /// Periodic Interval 6 Interrupt Enable
                PER6: u1,
                /// Periodic Interval 7 Interrupt Enable
                PER7: u1,
                /// Compare 0 Interrupt Enable
                CMP0: u1,
                /// Compare 1 Interrupt Enable
                CMP1: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Tamper Enable
                TAMPER: u1,
                /// Overflow Interrupt Enable
                OVF: u1,
            }), base_address + 0xa);

            /// address: 0x4000240c
            /// MODE0 Interrupt Flag Status and Clear
            pub const INTFLAG = @intToPtr(*volatile Mmio(16, packed struct {
                /// Periodic Interval 0
                PER0: u1,
                /// Periodic Interval 1
                PER1: u1,
                /// Periodic Interval 2
                PER2: u1,
                /// Periodic Interval 3
                PER3: u1,
                /// Periodic Interval 4
                PER4: u1,
                /// Periodic Interval 5
                PER5: u1,
                /// Periodic Interval 6
                PER6: u1,
                /// Periodic Interval 7
                PER7: u1,
                /// Compare 0
                CMP0: u1,
                /// Compare 1
                CMP1: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Tamper
                TAMPER: u1,
                /// Overflow
                OVF: u1,
            }), base_address + 0xc);

            /// address: 0x4000240e
            /// Debug Control
            pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
                /// Run During Debug
                DBGRUN: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0xe);

            /// address: 0x40002410
            /// MODE0 Synchronization Busy Status
            pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset Busy
                SWRST: u1,
                /// Enable Bit Busy
                ENABLE: u1,
                /// FREQCORR Register Busy
                FREQCORR: u1,
                /// COUNT Register Busy
                COUNT: u1,
                reserved0: u1,
                /// COMP 0 Register Busy
                COMP0: u1,
                /// COMP 1 Register Busy
                COMP1: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                /// Count Synchronization Enable Bit Busy
                COUNTSYNC: u1,
                /// General Purpose 0 Register Busy
                GP0: u1,
                /// General Purpose 1 Register Busy
                GP1: u1,
                /// General Purpose 2 Register Busy
                GP2: u1,
                /// General Purpose 3 Register Busy
                GP3: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
            }), base_address + 0x10);

            /// address: 0x40002414
            /// Frequency Correction
            pub const FREQCORR = @intToPtr(*volatile Mmio(8, packed struct {
                /// Correction Value
                VALUE: u7,
                /// Correction Sign
                SIGN: u1,
            }), base_address + 0x14);

            /// address: 0x40002418
            /// MODE0 Counter Value
            pub const COUNT = @intToPtr(*volatile u32, base_address + 0x18);

            /// address: 0x40002420
            /// MODE0 Compare n Value
            pub const COMP = @intToPtr(*volatile [2]u32, base_address + 0x20);

            /// address: 0x40002440
            /// General Purpose
            pub const GP = @intToPtr(*volatile [4]u32, base_address + 0x40);

            /// address: 0x40002460
            /// Tamper Control
            pub const TAMPCTRL = @intToPtr(*volatile Mmio(32, packed struct {
                /// Tamper Input 0 Action
                IN0ACT: u2,
                /// Tamper Input 1 Action
                IN1ACT: u2,
                /// Tamper Input 2 Action
                IN2ACT: u2,
                /// Tamper Input 3 Action
                IN3ACT: u2,
                /// Tamper Input 4 Action
                IN4ACT: u2,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                /// Tamper Level Select 0
                TAMLVL0: u1,
                /// Tamper Level Select 1
                TAMLVL1: u1,
                /// Tamper Level Select 2
                TAMLVL2: u1,
                /// Tamper Level Select 3
                TAMLVL3: u1,
                /// Tamper Level Select 4
                TAMLVL4: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                /// Debouncer Enable 0
                DEBNC0: u1,
                /// Debouncer Enable 1
                DEBNC1: u1,
                /// Debouncer Enable 2
                DEBNC2: u1,
                /// Debouncer Enable 3
                DEBNC3: u1,
                /// Debouncer Enable 4
                DEBNC4: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
            }), base_address + 0x60);

            /// address: 0x40002464
            /// MODE0 Timestamp
            pub const TIMESTAMP = @intToPtr(*volatile Mmio(32, packed struct {
                /// Count Timestamp Value
                COUNT: u32,
            }), base_address + 0x64);

            /// address: 0x40002468
            /// Tamper ID
            pub const TAMPID = @intToPtr(*volatile Mmio(32, packed struct {
                /// Tamper Input 0 Detected
                TAMPID0: u1,
                /// Tamper Input 1 Detected
                TAMPID1: u1,
                /// Tamper Input 2 Detected
                TAMPID2: u1,
                /// Tamper Input 3 Detected
                TAMPID3: u1,
                /// Tamper Input 4 Detected
                TAMPID4: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Tamper Event Detected
                TAMPEVT: u1,
            }), base_address + 0x68);

            /// address: 0x40002480
            /// Backup
            pub const BKUP = @intToPtr(*volatile [8]u32, base_address + 0x80);
        };

        /// 16-bit Counter with Two 16-bit Compares
        pub const MODE1 = struct {
            /// address: 0x40002400
            /// MODE1 Control A
            pub const CTRLA = @intToPtr(*volatile Mmio(16, packed struct {
                /// Software Reset
                SWRST: u1,
                /// Enable
                ENABLE: u1,
                /// Operating Mode
                MODE: u2,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Prescaler
                PRESCALER: u4,
                reserved4: u1,
                /// BKUP Registers Reset On Tamper Enable
                BKTRST: u1,
                /// GP Registers Reset On Tamper Enable
                GPTRST: u1,
                /// Count Read Synchronization Enable
                COUNTSYNC: u1,
            }), base_address + 0x0);

            /// address: 0x40002402
            /// MODE1 Control B
            pub const CTRLB = @intToPtr(*volatile Mmio(16, packed struct {
                /// General Purpose 0 Enable
                GP0EN: u1,
                /// General Purpose 2 Enable
                GP2EN: u1,
                reserved0: u1,
                reserved1: u1,
                /// Debouncer Majority Enable
                DEBMAJ: u1,
                /// Debouncer Asynchronous Enable
                DEBASYNC: u1,
                /// RTC Output Enable
                RTCOUT: u1,
                /// DMA Enable
                DMAEN: u1,
                /// Debounce Freqnuency
                DEBF: u3,
                reserved2: u1,
                /// Active Layer Freqnuency
                ACTF: u3,
                padding0: u1,
            }), base_address + 0x2);

            /// address: 0x40002404
            /// MODE1 Event Control
            pub const EVCTRL = @intToPtr(*volatile Mmio(32, packed struct {
                /// Periodic Interval 0 Event Output Enable
                PEREO0: u1,
                /// Periodic Interval 1 Event Output Enable
                PEREO1: u1,
                /// Periodic Interval 2 Event Output Enable
                PEREO2: u1,
                /// Periodic Interval 3 Event Output Enable
                PEREO3: u1,
                /// Periodic Interval 4 Event Output Enable
                PEREO4: u1,
                /// Periodic Interval 5 Event Output Enable
                PEREO5: u1,
                /// Periodic Interval 6 Event Output Enable
                PEREO6: u1,
                /// Periodic Interval 7 Event Output Enable
                PEREO7: u1,
                /// Compare 0 Event Output Enable
                CMPEO0: u1,
                /// Compare 1 Event Output Enable
                CMPEO1: u1,
                /// Compare 2 Event Output Enable
                CMPEO2: u1,
                /// Compare 3 Event Output Enable
                CMPEO3: u1,
                reserved0: u1,
                reserved1: u1,
                /// Tamper Event Output Enable
                TAMPEREO: u1,
                /// Overflow Event Output Enable
                OVFEO: u1,
                /// Tamper Event Input Enable
                TAMPEVEI: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
            }), base_address + 0x4);

            /// address: 0x40002408
            /// MODE1 Interrupt Enable Clear
            pub const INTENCLR = @intToPtr(*volatile Mmio(16, packed struct {
                /// Periodic Interval 0 Interrupt Enable
                PER0: u1,
                /// Periodic Interval 1 Interrupt Enable
                PER1: u1,
                /// Periodic Interval 2 Interrupt Enable
                PER2: u1,
                /// Periodic Interval 3 Interrupt Enable
                PER3: u1,
                /// Periodic Interval 4 Interrupt Enable
                PER4: u1,
                /// Periodic Interval 5 Interrupt Enable
                PER5: u1,
                /// Periodic Interval 6 Interrupt Enable
                PER6: u1,
                /// Periodic Interval 7 Interrupt Enable
                PER7: u1,
                /// Compare 0 Interrupt Enable
                CMP0: u1,
                /// Compare 1 Interrupt Enable
                CMP1: u1,
                /// Compare 2 Interrupt Enable
                CMP2: u1,
                /// Compare 3 Interrupt Enable
                CMP3: u1,
                reserved0: u1,
                reserved1: u1,
                /// Tamper Enable
                TAMPER: u1,
                /// Overflow Interrupt Enable
                OVF: u1,
            }), base_address + 0x8);

            /// address: 0x4000240a
            /// MODE1 Interrupt Enable Set
            pub const INTENSET = @intToPtr(*volatile Mmio(16, packed struct {
                /// Periodic Interval 0 Interrupt Enable
                PER0: u1,
                /// Periodic Interval 1 Interrupt Enable
                PER1: u1,
                /// Periodic Interval 2 Interrupt Enable
                PER2: u1,
                /// Periodic Interval 3 Interrupt Enable
                PER3: u1,
                /// Periodic Interval 4 Interrupt Enable
                PER4: u1,
                /// Periodic Interval 5 Interrupt Enable
                PER5: u1,
                /// Periodic Interval 6 Interrupt Enable
                PER6: u1,
                /// Periodic Interval 7 Interrupt Enable
                PER7: u1,
                /// Compare 0 Interrupt Enable
                CMP0: u1,
                /// Compare 1 Interrupt Enable
                CMP1: u1,
                /// Compare 2 Interrupt Enable
                CMP2: u1,
                /// Compare 3 Interrupt Enable
                CMP3: u1,
                reserved0: u1,
                reserved1: u1,
                /// Tamper Enable
                TAMPER: u1,
                /// Overflow Interrupt Enable
                OVF: u1,
            }), base_address + 0xa);

            /// address: 0x4000240c
            /// MODE1 Interrupt Flag Status and Clear
            pub const INTFLAG = @intToPtr(*volatile Mmio(16, packed struct {
                /// Periodic Interval 0
                PER0: u1,
                /// Periodic Interval 1
                PER1: u1,
                /// Periodic Interval 2
                PER2: u1,
                /// Periodic Interval 3
                PER3: u1,
                /// Periodic Interval 4
                PER4: u1,
                /// Periodic Interval 5
                PER5: u1,
                /// Periodic Interval 6
                PER6: u1,
                /// Periodic Interval 7
                PER7: u1,
                /// Compare 0
                CMP0: u1,
                /// Compare 1
                CMP1: u1,
                /// Compare 2
                CMP2: u1,
                /// Compare 3
                CMP3: u1,
                reserved0: u1,
                reserved1: u1,
                /// Tamper
                TAMPER: u1,
                /// Overflow
                OVF: u1,
            }), base_address + 0xc);

            /// address: 0x4000240e
            /// Debug Control
            pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
                /// Run During Debug
                DBGRUN: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0xe);

            /// address: 0x40002410
            /// MODE1 Synchronization Busy Status
            pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset Bit Busy
                SWRST: u1,
                /// Enable Bit Busy
                ENABLE: u1,
                /// FREQCORR Register Busy
                FREQCORR: u1,
                /// COUNT Register Busy
                COUNT: u1,
                /// PER Register Busy
                PER: u1,
                /// COMP 0 Register Busy
                COMP0: u1,
                /// COMP 1 Register Busy
                COMP1: u1,
                /// COMP 2 Register Busy
                COMP2: u1,
                /// COMP 3 Register Busy
                COMP3: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                /// Count Synchronization Enable Bit Busy
                COUNTSYNC: u1,
                /// General Purpose 0 Register Busy
                GP0: u1,
                /// General Purpose 1 Register Busy
                GP1: u1,
                /// General Purpose 2 Register Busy
                GP2: u1,
                /// General Purpose 3 Register Busy
                GP3: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
            }), base_address + 0x10);

            /// address: 0x40002414
            /// Frequency Correction
            pub const FREQCORR = @intToPtr(*volatile Mmio(8, packed struct {
                /// Correction Value
                VALUE: u7,
                /// Correction Sign
                SIGN: u1,
            }), base_address + 0x14);

            /// address: 0x40002418
            /// MODE1 Counter Value
            pub const COUNT = @intToPtr(*volatile u16, base_address + 0x18);

            /// address: 0x4000241c
            /// MODE1 Counter Period
            pub const PER = @intToPtr(*volatile u16, base_address + 0x1c);

            /// address: 0x40002420
            /// MODE1 Compare n Value
            pub const COMP = @intToPtr(*volatile [4]u16, base_address + 0x20);

            /// address: 0x40002440
            /// General Purpose
            pub const GP = @intToPtr(*volatile [4]u32, base_address + 0x40);

            /// address: 0x40002460
            /// Tamper Control
            pub const TAMPCTRL = @intToPtr(*volatile Mmio(32, packed struct {
                /// Tamper Input 0 Action
                IN0ACT: u2,
                /// Tamper Input 1 Action
                IN1ACT: u2,
                /// Tamper Input 2 Action
                IN2ACT: u2,
                /// Tamper Input 3 Action
                IN3ACT: u2,
                /// Tamper Input 4 Action
                IN4ACT: u2,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                /// Tamper Level Select 0
                TAMLVL0: u1,
                /// Tamper Level Select 1
                TAMLVL1: u1,
                /// Tamper Level Select 2
                TAMLVL2: u1,
                /// Tamper Level Select 3
                TAMLVL3: u1,
                /// Tamper Level Select 4
                TAMLVL4: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                /// Debouncer Enable 0
                DEBNC0: u1,
                /// Debouncer Enable 1
                DEBNC1: u1,
                /// Debouncer Enable 2
                DEBNC2: u1,
                /// Debouncer Enable 3
                DEBNC3: u1,
                /// Debouncer Enable 4
                DEBNC4: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
            }), base_address + 0x60);

            /// address: 0x40002464
            /// MODE1 Timestamp
            pub const TIMESTAMP = @intToPtr(*volatile Mmio(32, packed struct {
                /// Count Timestamp Value
                COUNT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x64);

            /// address: 0x40002468
            /// Tamper ID
            pub const TAMPID = @intToPtr(*volatile Mmio(32, packed struct {
                /// Tamper Input 0 Detected
                TAMPID0: u1,
                /// Tamper Input 1 Detected
                TAMPID1: u1,
                /// Tamper Input 2 Detected
                TAMPID2: u1,
                /// Tamper Input 3 Detected
                TAMPID3: u1,
                /// Tamper Input 4 Detected
                TAMPID4: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Tamper Event Detected
                TAMPEVT: u1,
            }), base_address + 0x68);

            /// address: 0x40002480
            /// Backup
            pub const BKUP = @intToPtr(*volatile [8]u32, base_address + 0x80);
        };

        /// Clock/Calendar with Alarm
        pub const MODE2 = struct {
            /// address: 0x40002400
            /// MODE2 Control A
            pub const CTRLA = @intToPtr(*volatile Mmio(16, packed struct {
                /// Software Reset
                SWRST: u1,
                /// Enable
                ENABLE: u1,
                /// Operating Mode
                MODE: u2,
                reserved0: u1,
                reserved1: u1,
                /// Clock Representation
                CLKREP: u1,
                /// Clear on Match
                MATCHCLR: u1,
                /// Prescaler
                PRESCALER: u4,
                reserved2: u1,
                /// BKUP Registers Reset On Tamper Enable
                BKTRST: u1,
                /// GP Registers Reset On Tamper Enable
                GPTRST: u1,
                /// Clock Read Synchronization Enable
                CLOCKSYNC: u1,
            }), base_address + 0x0);

            /// address: 0x40002402
            /// MODE2 Control B
            pub const CTRLB = @intToPtr(*volatile Mmio(16, packed struct {
                /// General Purpose 0 Enable
                GP0EN: u1,
                /// General Purpose 2 Enable
                GP2EN: u1,
                reserved0: u1,
                reserved1: u1,
                /// Debouncer Majority Enable
                DEBMAJ: u1,
                /// Debouncer Asynchronous Enable
                DEBASYNC: u1,
                /// RTC Output Enable
                RTCOUT: u1,
                /// DMA Enable
                DMAEN: u1,
                /// Debounce Freqnuency
                DEBF: u3,
                reserved2: u1,
                /// Active Layer Freqnuency
                ACTF: u3,
                padding0: u1,
            }), base_address + 0x2);

            /// address: 0x40002404
            /// MODE2 Event Control
            pub const EVCTRL = @intToPtr(*volatile Mmio(32, packed struct {
                /// Periodic Interval 0 Event Output Enable
                PEREO0: u1,
                /// Periodic Interval 1 Event Output Enable
                PEREO1: u1,
                /// Periodic Interval 2 Event Output Enable
                PEREO2: u1,
                /// Periodic Interval 3 Event Output Enable
                PEREO3: u1,
                /// Periodic Interval 4 Event Output Enable
                PEREO4: u1,
                /// Periodic Interval 5 Event Output Enable
                PEREO5: u1,
                /// Periodic Interval 6 Event Output Enable
                PEREO6: u1,
                /// Periodic Interval 7 Event Output Enable
                PEREO7: u1,
                /// Alarm 0 Event Output Enable
                ALARMEO0: u1,
                /// Alarm 1 Event Output Enable
                ALARMEO1: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Tamper Event Output Enable
                TAMPEREO: u1,
                /// Overflow Event Output Enable
                OVFEO: u1,
                /// Tamper Event Input Enable
                TAMPEVEI: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
            }), base_address + 0x4);

            /// address: 0x40002408
            /// MODE2 Interrupt Enable Clear
            pub const INTENCLR = @intToPtr(*volatile Mmio(16, packed struct {
                /// Periodic Interval 0 Interrupt Enable
                PER0: u1,
                /// Periodic Interval 1 Interrupt Enable
                PER1: u1,
                /// Periodic Interval 2 Interrupt Enable
                PER2: u1,
                /// Periodic Interval 3 Interrupt Enable
                PER3: u1,
                /// Periodic Interval 4 Interrupt Enable
                PER4: u1,
                /// Periodic Interval 5 Interrupt Enable
                PER5: u1,
                /// Periodic Interval 6 Interrupt Enable
                PER6: u1,
                /// Periodic Interval 7 Interrupt Enable
                PER7: u1,
                /// Alarm 0 Interrupt Enable
                ALARM0: u1,
                /// Alarm 1 Interrupt Enable
                ALARM1: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Tamper Enable
                TAMPER: u1,
                /// Overflow Interrupt Enable
                OVF: u1,
            }), base_address + 0x8);

            /// address: 0x4000240a
            /// MODE2 Interrupt Enable Set
            pub const INTENSET = @intToPtr(*volatile Mmio(16, packed struct {
                /// Periodic Interval 0 Enable
                PER0: u1,
                /// Periodic Interval 1 Enable
                PER1: u1,
                /// Periodic Interval 2 Enable
                PER2: u1,
                /// Periodic Interval 3 Enable
                PER3: u1,
                /// Periodic Interval 4 Enable
                PER4: u1,
                /// Periodic Interval 5 Enable
                PER5: u1,
                /// Periodic Interval 6 Enable
                PER6: u1,
                /// Periodic Interval 7 Enable
                PER7: u1,
                /// Alarm 0 Interrupt Enable
                ALARM0: u1,
                /// Alarm 1 Interrupt Enable
                ALARM1: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Tamper Enable
                TAMPER: u1,
                /// Overflow Interrupt Enable
                OVF: u1,
            }), base_address + 0xa);

            /// address: 0x4000240c
            /// MODE2 Interrupt Flag Status and Clear
            pub const INTFLAG = @intToPtr(*volatile Mmio(16, packed struct {
                /// Periodic Interval 0
                PER0: u1,
                /// Periodic Interval 1
                PER1: u1,
                /// Periodic Interval 2
                PER2: u1,
                /// Periodic Interval 3
                PER3: u1,
                /// Periodic Interval 4
                PER4: u1,
                /// Periodic Interval 5
                PER5: u1,
                /// Periodic Interval 6
                PER6: u1,
                /// Periodic Interval 7
                PER7: u1,
                /// Alarm 0
                ALARM0: u1,
                /// Alarm 1
                ALARM1: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Tamper
                TAMPER: u1,
                /// Overflow
                OVF: u1,
            }), base_address + 0xc);

            /// address: 0x4000240e
            /// Debug Control
            pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
                /// Run During Debug
                DBGRUN: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0xe);

            /// address: 0x40002410
            /// MODE2 Synchronization Busy Status
            pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset Bit Busy
                SWRST: u1,
                /// Enable Bit Busy
                ENABLE: u1,
                /// FREQCORR Register Busy
                FREQCORR: u1,
                /// CLOCK Register Busy
                CLOCK: u1,
                reserved0: u1,
                /// ALARM 0 Register Busy
                ALARM0: u1,
                /// ALARM 1 Register Busy
                ALARM1: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                /// MASK 0 Register Busy
                MASK0: u1,
                /// MASK 1 Register Busy
                MASK1: u1,
                reserved5: u1,
                reserved6: u1,
                /// Clock Synchronization Enable Bit Busy
                CLOCKSYNC: u1,
                /// General Purpose 0 Register Busy
                GP0: u1,
                /// General Purpose 1 Register Busy
                GP1: u1,
                /// General Purpose 2 Register Busy
                GP2: u1,
                /// General Purpose 3 Register Busy
                GP3: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
            }), base_address + 0x10);

            /// address: 0x40002414
            /// Frequency Correction
            pub const FREQCORR = @intToPtr(*volatile Mmio(8, packed struct {
                /// Correction Value
                VALUE: u7,
                /// Correction Sign
                SIGN: u1,
            }), base_address + 0x14);

            /// address: 0x40002418
            /// MODE2 Clock Value
            pub const CLOCK = @intToPtr(*volatile Mmio(32, packed struct {
                /// Second
                SECOND: u6,
                /// Minute
                MINUTE: u6,
                /// Hour
                HOUR: u5,
                /// Day
                DAY: u5,
                /// Month
                MONTH: u4,
                /// Year
                YEAR: u6,
            }), base_address + 0x18);

            /// address: 0x40002440
            /// General Purpose
            pub const GP = @intToPtr(*volatile [4]u32, base_address + 0x40);

            /// address: 0x40002420
            /// MODE2_ALARM Alarm n Value
            pub const ALARM0 = @intToPtr(*volatile Mmio(32, packed struct {
                /// Second
                SECOND: u6,
                /// Minute
                MINUTE: u6,
                /// Hour
                HOUR: u5,
                /// Day
                DAY: u5,
                /// Month
                MONTH: u4,
                /// Year
                YEAR: u6,
            }), base_address + 0x20);

            /// address: 0x40002424
            /// MODE2_ALARM Alarm n Mask
            pub const MASK0 = @intToPtr(*volatile Mmio(8, packed struct {
                /// Alarm Mask Selection
                SEL: u3,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
            }), base_address + 0x24);

            /// address: 0x40002428
            /// MODE2_ALARM Alarm n Value
            pub const ALARM1 = @intToPtr(*volatile Mmio(32, packed struct {
                /// Second
                SECOND: u6,
                /// Minute
                MINUTE: u6,
                /// Hour
                HOUR: u5,
                /// Day
                DAY: u5,
                /// Month
                MONTH: u4,
                /// Year
                YEAR: u6,
            }), base_address + 0x28);

            /// address: 0x4000242c
            /// MODE2_ALARM Alarm n Mask
            pub const MASK1 = @intToPtr(*volatile Mmio(8, packed struct {
                /// Alarm Mask Selection
                SEL: u3,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
            }), base_address + 0x2c);

            /// address: 0x40002460
            /// Tamper Control
            pub const TAMPCTRL = @intToPtr(*volatile Mmio(32, packed struct {
                /// Tamper Input 0 Action
                IN0ACT: u2,
                /// Tamper Input 1 Action
                IN1ACT: u2,
                /// Tamper Input 2 Action
                IN2ACT: u2,
                /// Tamper Input 3 Action
                IN3ACT: u2,
                /// Tamper Input 4 Action
                IN4ACT: u2,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                /// Tamper Level Select 0
                TAMLVL0: u1,
                /// Tamper Level Select 1
                TAMLVL1: u1,
                /// Tamper Level Select 2
                TAMLVL2: u1,
                /// Tamper Level Select 3
                TAMLVL3: u1,
                /// Tamper Level Select 4
                TAMLVL4: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                /// Debouncer Enable 0
                DEBNC0: u1,
                /// Debouncer Enable 1
                DEBNC1: u1,
                /// Debouncer Enable 2
                DEBNC2: u1,
                /// Debouncer Enable 3
                DEBNC3: u1,
                /// Debouncer Enable 4
                DEBNC4: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
            }), base_address + 0x60);

            /// address: 0x40002464
            /// MODE2 Timestamp
            pub const TIMESTAMP = @intToPtr(*volatile Mmio(32, packed struct {
                /// Second Timestamp Value
                SECOND: u6,
                /// Minute Timestamp Value
                MINUTE: u6,
                /// Hour Timestamp Value
                HOUR: u5,
                /// Day Timestamp Value
                DAY: u5,
                /// Month Timestamp Value
                MONTH: u4,
                /// Year Timestamp Value
                YEAR: u6,
            }), base_address + 0x64);

            /// address: 0x40002468
            /// Tamper ID
            pub const TAMPID = @intToPtr(*volatile Mmio(32, packed struct {
                /// Tamper Input 0 Detected
                TAMPID0: u1,
                /// Tamper Input 1 Detected
                TAMPID1: u1,
                /// Tamper Input 2 Detected
                TAMPID2: u1,
                /// Tamper Input 3 Detected
                TAMPID3: u1,
                /// Tamper Input 4 Detected
                TAMPID4: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Tamper Event Detected
                TAMPEVT: u1,
            }), base_address + 0x68);

            /// address: 0x40002480
            /// Backup
            pub const BKUP = @intToPtr(*volatile [8]u32, base_address + 0x80);
        };
    };

    /// SD/MMC Host Controller
    pub const SDHC0 = struct {
        pub const base_address = 0x45000000;
        pub const version = "U20111.8.3";

        /// address: 0x45000000
        /// SDMA System Address / Argument 2
        pub const SSAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SDMA System Address
            ADDR: u32,
        }), base_address + 0x0);

        /// address: 0x45000000
        /// SDMA System Address / Argument 2
        pub const SSAR_CMD23_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Argument 2
            ARG2: u32,
        }), base_address + 0x0);

        /// address: 0x45000004
        /// Block Size
        pub const BSR = @intToPtr(*volatile Mmio(16, packed struct {
            /// Transfer Block Size
            BLOCKSIZE: u10,
            reserved0: u1,
            reserved1: u1,
            /// SDMA Buffer Boundary
            BOUNDARY: u3,
            padding0: u1,
        }), base_address + 0x4);

        /// address: 0x45000006
        /// Block Count
        pub const BCR = @intToPtr(*volatile Mmio(16, packed struct {
            /// Blocks Count for Current Transfer
            BCNT: u16,
        }), base_address + 0x6);

        /// address: 0x45000008
        /// Argument 1
        pub const ARG1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Argument 1
            ARG: u32,
        }), base_address + 0x8);

        /// address: 0x4500000c
        /// Transfer Mode
        pub const TMR = @intToPtr(*volatile Mmio(16, packed struct {
            /// DMA Enable
            DMAEN: u1,
            /// Block Count Enable
            BCEN: u1,
            /// Auto Command Enable
            ACMDEN: u2,
            /// Data Transfer Direction Selection
            DTDSEL: u1,
            /// Multi/Single Block Selection
            MSBSEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0xc);

        /// address: 0x4500000e
        /// Command
        pub const CR = @intToPtr(*volatile Mmio(16, packed struct {
            /// Response Type
            RESPTYP: u2,
            reserved0: u1,
            /// Command CRC Check Enable
            CMDCCEN: u1,
            /// Command Index Check Enable
            CMDICEN: u1,
            /// Data Present Select
            DPSEL: u1,
            /// Command Type
            CMDTYP: u2,
            /// Command Index
            CMDIDX: u6,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xe);

        /// address: 0x45000010
        /// Response
        pub const RR = @intToPtr(*volatile [4]Mmio(32, packed struct {
            /// Command Response
            CMDRESP: u32,
        }), base_address + 0x10);

        /// address: 0x45000020
        /// Buffer Data Port
        pub const BDPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Data
            BUFDATA: u32,
        }), base_address + 0x20);

        /// address: 0x45000024
        /// Present State
        pub const PSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command Inhibit (CMD)
            CMDINHC: u1,
            /// Command Inhibit (DAT)
            CMDINHD: u1,
            /// DAT Line Active
            DLACT: u1,
            /// Re-Tuning Request
            RTREQ: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Write Transfer Active
            WTACT: u1,
            /// Read Transfer Active
            RTACT: u1,
            /// Buffer Write Enable
            BUFWREN: u1,
            /// Buffer Read Enable
            BUFRDEN: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Card Inserted
            CARDINS: u1,
            /// Card State Stable
            CARDSS: u1,
            /// Card Detect Pin Level
            CARDDPL: u1,
            /// Write Protect Pin Level
            WRPPL: u1,
            /// DAT[3:0] Line Level
            DATLL: u4,
            /// CMD Line Level
            CMDLL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x24);

        /// address: 0x45000028
        /// Host Control 1
        pub const HC1R = @intToPtr(*volatile Mmio(8, packed struct {
            /// LED Control
            LEDCTRL: u1,
            /// Data Width
            DW: u1,
            /// High Speed Enable
            HSEN: u1,
            /// DMA Select
            DMASEL: u2,
            reserved0: u1,
            /// Card Detect Test Level
            CARDDTL: u1,
            /// Card Detect Signal Selection
            CARDDSEL: u1,
        }), base_address + 0x28);

        /// address: 0x45000028
        /// Host Control 1
        pub const HC1R_EMMC_MODE = @intToPtr(*volatile Mmio(8, packed struct {
            reserved0: u1,
            /// Data Width
            DW: u1,
            /// High Speed Enable
            HSEN: u1,
            /// DMA Select
            DMASEL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x28);

        /// address: 0x45000029
        /// Power Control
        pub const PCR = @intToPtr(*volatile Mmio(8, packed struct {
            /// SD Bus Power
            SDBPWR: u1,
            /// SD Bus Voltage Select
            SDBVSEL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x29);

        /// address: 0x4500002a
        /// Block Gap Control
        pub const BGCR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Stop at Block Gap Request
            STPBGR: u1,
            /// Continue Request
            CONTR: u1,
            /// Read Wait Control
            RWCTRL: u1,
            /// Interrupt at Block Gap
            INTBG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x2a);

        /// address: 0x4500002a
        /// Block Gap Control
        pub const BGCR_EMMC_MODE = @intToPtr(*volatile Mmio(8, packed struct {
            /// Stop at Block Gap Request
            STPBGR: u1,
            /// Continue Request
            CONTR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x2a);

        /// address: 0x4500002b
        /// Wakeup Control
        pub const WCR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Wakeup Event Enable on Card Interrupt
            WKENCINT: u1,
            /// Wakeup Event Enable on Card Insertion
            WKENCINS: u1,
            /// Wakeup Event Enable on Card Removal
            WKENCREM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x2b);

        /// address: 0x4500002c
        /// Clock Control
        pub const CCR = @intToPtr(*volatile Mmio(16, packed struct {
            /// Internal Clock Enable
            INTCLKEN: u1,
            /// Internal Clock Stable
            INTCLKS: u1,
            /// SD Clock Enable
            SDCLKEN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock Generator Select
            CLKGSEL: u1,
            /// Upper Bits of SDCLK Frequency Select
            USDCLKFSEL: u2,
            /// SDCLK Frequency Select
            SDCLKFSEL: u8,
        }), base_address + 0x2c);

        /// address: 0x4500002e
        /// Timeout Control
        pub const TCR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Data Timeout Counter Value
            DTCVAL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x2e);

        /// address: 0x4500002f
        /// Software Reset
        pub const SRR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Software Reset For All
            SWRSTALL: u1,
            /// Software Reset For CMD Line
            SWRSTCMD: u1,
            /// Software Reset For DAT Line
            SWRSTDAT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x2f);

        /// address: 0x45000030
        /// Normal Interrupt Status
        pub const NISTR = @intToPtr(*volatile Mmio(16, packed struct {
            /// Command Complete
            CMDC: u1,
            /// Transfer Complete
            TRFC: u1,
            /// Block Gap Event
            BLKGE: u1,
            /// DMA Interrupt
            DMAINT: u1,
            /// Buffer Write Ready
            BWRRDY: u1,
            /// Buffer Read Ready
            BRDRDY: u1,
            /// Card Insertion
            CINS: u1,
            /// Card Removal
            CREM: u1,
            /// Card Interrupt
            CINT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Error Interrupt
            ERRINT: u1,
        }), base_address + 0x30);

        /// address: 0x45000030
        /// Normal Interrupt Status
        pub const NISTR_EMMC_MODE = @intToPtr(*volatile Mmio(16, packed struct {
            /// Command Complete
            CMDC: u1,
            /// Transfer Complete
            TRFC: u1,
            /// Block Gap Event
            BLKGE: u1,
            /// DMA Interrupt
            DMAINT: u1,
            /// Buffer Write Ready
            BWRRDY: u1,
            /// Buffer Read Ready
            BRDRDY: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Boot Acknowledge Received
            BOOTAR: u1,
            /// Error Interrupt
            ERRINT: u1,
        }), base_address + 0x30);

        /// address: 0x45000032
        /// Error Interrupt Status
        pub const EISTR = @intToPtr(*volatile Mmio(16, packed struct {
            /// Command Timeout Error
            CMDTEO: u1,
            /// Command CRC Error
            CMDCRC: u1,
            /// Command End Bit Error
            CMDEND: u1,
            /// Command Index Error
            CMDIDX: u1,
            /// Data Timeout Error
            DATTEO: u1,
            /// Data CRC Error
            DATCRC: u1,
            /// Data End Bit Error
            DATEND: u1,
            /// Current Limit Error
            CURLIM: u1,
            /// Auto CMD Error
            ACMD: u1,
            /// ADMA Error
            ADMA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x32);

        /// address: 0x45000032
        /// Error Interrupt Status
        pub const EISTR_EMMC_MODE = @intToPtr(*volatile Mmio(16, packed struct {
            /// Command Timeout Error
            CMDTEO: u1,
            /// Command CRC Error
            CMDCRC: u1,
            /// Command End Bit Error
            CMDEND: u1,
            /// Command Index Error
            CMDIDX: u1,
            /// Data Timeout Error
            DATTEO: u1,
            /// Data CRC Error
            DATCRC: u1,
            /// Data End Bit Error
            DATEND: u1,
            /// Current Limit Error
            CURLIM: u1,
            /// Auto CMD Error
            ACMD: u1,
            /// ADMA Error
            ADMA: u1,
            reserved0: u1,
            reserved1: u1,
            /// Boot Acknowledge Error
            BOOTAE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x32);

        /// address: 0x45000034
        /// Normal Interrupt Status Enable
        pub const NISTER = @intToPtr(*volatile Mmio(16, packed struct {
            /// Command Complete Status Enable
            CMDC: u1,
            /// Transfer Complete Status Enable
            TRFC: u1,
            /// Block Gap Event Status Enable
            BLKGE: u1,
            /// DMA Interrupt Status Enable
            DMAINT: u1,
            /// Buffer Write Ready Status Enable
            BWRRDY: u1,
            /// Buffer Read Ready Status Enable
            BRDRDY: u1,
            /// Card Insertion Status Enable
            CINS: u1,
            /// Card Removal Status Enable
            CREM: u1,
            /// Card Interrupt Status Enable
            CINT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x34);

        /// address: 0x45000034
        /// Normal Interrupt Status Enable
        pub const NISTER_EMMC_MODE = @intToPtr(*volatile Mmio(16, packed struct {
            /// Command Complete Status Enable
            CMDC: u1,
            /// Transfer Complete Status Enable
            TRFC: u1,
            /// Block Gap Event Status Enable
            BLKGE: u1,
            /// DMA Interrupt Status Enable
            DMAINT: u1,
            /// Buffer Write Ready Status Enable
            BWRRDY: u1,
            /// Buffer Read Ready Status Enable
            BRDRDY: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Boot Acknowledge Received Status Enable
            BOOTAR: u1,
            padding0: u1,
        }), base_address + 0x34);

        /// address: 0x45000036
        /// Error Interrupt Status Enable
        pub const EISTER = @intToPtr(*volatile Mmio(16, packed struct {
            /// Command Timeout Error Status Enable
            CMDTEO: u1,
            /// Command CRC Error Status Enable
            CMDCRC: u1,
            /// Command End Bit Error Status Enable
            CMDEND: u1,
            /// Command Index Error Status Enable
            CMDIDX: u1,
            /// Data Timeout Error Status Enable
            DATTEO: u1,
            /// Data CRC Error Status Enable
            DATCRC: u1,
            /// Data End Bit Error Status Enable
            DATEND: u1,
            /// Current Limit Error Status Enable
            CURLIM: u1,
            /// Auto CMD Error Status Enable
            ACMD: u1,
            /// ADMA Error Status Enable
            ADMA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x36);

        /// address: 0x45000036
        /// Error Interrupt Status Enable
        pub const EISTER_EMMC_MODE = @intToPtr(*volatile Mmio(16, packed struct {
            /// Command Timeout Error Status Enable
            CMDTEO: u1,
            /// Command CRC Error Status Enable
            CMDCRC: u1,
            /// Command End Bit Error Status Enable
            CMDEND: u1,
            /// Command Index Error Status Enable
            CMDIDX: u1,
            /// Data Timeout Error Status Enable
            DATTEO: u1,
            /// Data CRC Error Status Enable
            DATCRC: u1,
            /// Data End Bit Error Status Enable
            DATEND: u1,
            /// Current Limit Error Status Enable
            CURLIM: u1,
            /// Auto CMD Error Status Enable
            ACMD: u1,
            /// ADMA Error Status Enable
            ADMA: u1,
            reserved0: u1,
            reserved1: u1,
            /// Boot Acknowledge Error Status Enable
            BOOTAE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x36);

        /// address: 0x45000038
        /// Normal Interrupt Signal Enable
        pub const NISIER = @intToPtr(*volatile Mmio(16, packed struct {
            /// Command Complete Signal Enable
            CMDC: u1,
            /// Transfer Complete Signal Enable
            TRFC: u1,
            /// Block Gap Event Signal Enable
            BLKGE: u1,
            /// DMA Interrupt Signal Enable
            DMAINT: u1,
            /// Buffer Write Ready Signal Enable
            BWRRDY: u1,
            /// Buffer Read Ready Signal Enable
            BRDRDY: u1,
            /// Card Insertion Signal Enable
            CINS: u1,
            /// Card Removal Signal Enable
            CREM: u1,
            /// Card Interrupt Signal Enable
            CINT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x38);

        /// address: 0x45000038
        /// Normal Interrupt Signal Enable
        pub const NISIER_EMMC_MODE = @intToPtr(*volatile Mmio(16, packed struct {
            /// Command Complete Signal Enable
            CMDC: u1,
            /// Transfer Complete Signal Enable
            TRFC: u1,
            /// Block Gap Event Signal Enable
            BLKGE: u1,
            /// DMA Interrupt Signal Enable
            DMAINT: u1,
            /// Buffer Write Ready Signal Enable
            BWRRDY: u1,
            /// Buffer Read Ready Signal Enable
            BRDRDY: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Boot Acknowledge Received Signal Enable
            BOOTAR: u1,
            padding0: u1,
        }), base_address + 0x38);

        /// address: 0x4500003a
        /// Error Interrupt Signal Enable
        pub const EISIER = @intToPtr(*volatile Mmio(16, packed struct {
            /// Command Timeout Error Signal Enable
            CMDTEO: u1,
            /// Command CRC Error Signal Enable
            CMDCRC: u1,
            /// Command End Bit Error Signal Enable
            CMDEND: u1,
            /// Command Index Error Signal Enable
            CMDIDX: u1,
            /// Data Timeout Error Signal Enable
            DATTEO: u1,
            /// Data CRC Error Signal Enable
            DATCRC: u1,
            /// Data End Bit Error Signal Enable
            DATEND: u1,
            /// Current Limit Error Signal Enable
            CURLIM: u1,
            /// Auto CMD Error Signal Enable
            ACMD: u1,
            /// ADMA Error Signal Enable
            ADMA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x3a);

        /// address: 0x4500003a
        /// Error Interrupt Signal Enable
        pub const EISIER_EMMC_MODE = @intToPtr(*volatile Mmio(16, packed struct {
            /// Command Timeout Error Signal Enable
            CMDTEO: u1,
            /// Command CRC Error Signal Enable
            CMDCRC: u1,
            /// Command End Bit Error Signal Enable
            CMDEND: u1,
            /// Command Index Error Signal Enable
            CMDIDX: u1,
            /// Data Timeout Error Signal Enable
            DATTEO: u1,
            /// Data CRC Error Signal Enable
            DATCRC: u1,
            /// Data End Bit Error Signal Enable
            DATEND: u1,
            /// Current Limit Error Signal Enable
            CURLIM: u1,
            /// Auto CMD Error Signal Enable
            ACMD: u1,
            /// ADMA Error Signal Enable
            ADMA: u1,
            reserved0: u1,
            reserved1: u1,
            /// Boot Acknowledge Error Signal Enable
            BOOTAE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x3a);

        /// address: 0x4500003c
        /// Auto CMD Error Status
        pub const ACESR = @intToPtr(*volatile Mmio(16, packed struct {
            /// Auto CMD12 Not Executed
            ACMD12NE: u1,
            /// Auto CMD Timeout Error
            ACMDTEO: u1,
            /// Auto CMD CRC Error
            ACMDCRC: u1,
            /// Auto CMD End Bit Error
            ACMDEND: u1,
            /// Auto CMD Index Error
            ACMDIDX: u1,
            reserved0: u1,
            reserved1: u1,
            /// Command not Issued By Auto CMD12 Error
            CMDNI: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x3c);

        /// address: 0x4500003e
        /// Host Control 2
        pub const HC2R = @intToPtr(*volatile Mmio(16, packed struct {
            /// UHS Mode Select
            UHSMS: u3,
            /// 1.8V Signaling Enable
            VS18EN: u1,
            /// Driver Strength Select
            DRVSEL: u2,
            /// Execute Tuning
            EXTUN: u1,
            /// Sampling Clock Select
            SLCKSEL: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Asynchronous Interrupt Enable
            ASINTEN: u1,
            /// Preset Value Enable
            PVALEN: u1,
        }), base_address + 0x3e);

        /// address: 0x4500003e
        /// Host Control 2
        pub const HC2R_EMMC_MODE = @intToPtr(*volatile Mmio(16, packed struct {
            /// HS200 Mode Enable
            HS200EN: u4,
            /// Driver Strength Select
            DRVSEL: u2,
            /// Execute Tuning
            EXTUN: u1,
            /// Sampling Clock Select
            SLCKSEL: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Preset Value Enable
            PVALEN: u1,
        }), base_address + 0x3e);

        /// address: 0x45000040
        /// Capabilities 0
        pub const CA0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timeout Clock Frequency
            TEOCLKF: u6,
            reserved0: u1,
            /// Timeout Clock Unit
            TEOCLKU: u1,
            /// Base Clock Frequency
            BASECLKF: u8,
            /// Max Block Length
            MAXBLKL: u2,
            /// 8-bit Support for Embedded Device
            ED8SUP: u1,
            /// ADMA2 Support
            ADMA2SUP: u1,
            reserved1: u1,
            /// High Speed Support
            HSSUP: u1,
            /// SDMA Support
            SDMASUP: u1,
            /// Suspend/Resume Support
            SRSUP: u1,
            /// Voltage Support 3.3V
            V33VSUP: u1,
            /// Voltage Support 3.0V
            V30VSUP: u1,
            /// Voltage Support 1.8V
            V18VSUP: u1,
            reserved2: u1,
            /// 64-Bit System Bus Support
            SB64SUP: u1,
            /// Asynchronous Interrupt Support
            ASINTSUP: u1,
            /// Slot Type
            SLTYPE: u2,
        }), base_address + 0x40);

        /// address: 0x45000044
        /// Capabilities 1
        pub const CA1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// SDR50 Support
            SDR50SUP: u1,
            /// SDR104 Support
            SDR104SUP: u1,
            /// DDR50 Support
            DDR50SUP: u1,
            reserved0: u1,
            /// Driver Type A Support
            DRVASUP: u1,
            /// Driver Type C Support
            DRVCSUP: u1,
            /// Driver Type D Support
            DRVDSUP: u1,
            reserved1: u1,
            /// Timer Count for Re-Tuning
            TCNTRT: u4,
            reserved2: u1,
            /// Use Tuning for SDR50
            TSDR50: u1,
            reserved3: u1,
            reserved4: u1,
            /// Clock Multiplier
            CLKMULT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x44);

        /// address: 0x45000048
        /// Maximum Current Capabilities
        pub const MCCAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum Current for 3.3V
            MAXCUR33V: u8,
            /// Maximum Current for 3.0V
            MAXCUR30V: u8,
            /// Maximum Current for 1.8V
            MAXCUR18V: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x48);

        /// address: 0x45000050
        /// Force Event for Auto CMD Error Status
        pub const FERACES = @intToPtr(*volatile Mmio(16, packed struct {
            /// Force Event for Auto CMD12 Not Executed
            ACMD12NE: u1,
            /// Force Event for Auto CMD Timeout Error
            ACMDTEO: u1,
            /// Force Event for Auto CMD CRC Error
            ACMDCRC: u1,
            /// Force Event for Auto CMD End Bit Error
            ACMDEND: u1,
            /// Force Event for Auto CMD Index Error
            ACMDIDX: u1,
            reserved0: u1,
            reserved1: u1,
            /// Force Event for Command Not Issued By Auto CMD12 Error
            CMDNI: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x50);

        /// address: 0x45000052
        /// Force Event for Error Interrupt Status
        pub const FEREIS = @intToPtr(*volatile Mmio(16, packed struct {
            /// Force Event for Command Timeout Error
            CMDTEO: u1,
            /// Force Event for Command CRC Error
            CMDCRC: u1,
            /// Force Event for Command End Bit Error
            CMDEND: u1,
            /// Force Event for Command Index Error
            CMDIDX: u1,
            /// Force Event for Data Timeout Error
            DATTEO: u1,
            /// Force Event for Data CRC Error
            DATCRC: u1,
            /// Force Event for Data End Bit Error
            DATEND: u1,
            /// Force Event for Current Limit Error
            CURLIM: u1,
            /// Force Event for Auto CMD Error
            ACMD: u1,
            /// Force Event for ADMA Error
            ADMA: u1,
            reserved0: u1,
            reserved1: u1,
            /// Force Event for Boot Acknowledge Error
            BOOTAE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x52);

        /// address: 0x45000054
        /// ADMA Error Status
        pub const AESR = @intToPtr(*volatile Mmio(8, packed struct {
            /// ADMA Error State
            ERRST: u2,
            /// ADMA Length Mismatch Error
            LMIS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x54);

        /// address: 0x45000058
        /// ADMA System Address n
        pub const ASAR = @intToPtr(*volatile [1]Mmio(32, packed struct {
            /// ADMA System Address
            ADMASA: u32,
        }), base_address + 0x58);

        /// address: 0x45000060
        /// Preset Value n
        pub const PVR = @intToPtr(*volatile [8]Mmio(16, packed struct {
            /// SDCLK Frequency Select Value for Initialization
            SDCLKFSEL: u10,
            /// Clock Generator Select Value for Initialization
            CLKGSEL: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Driver Strength Select Value for Initialization
            DRVSEL: u2,
        }), base_address + 0x60);

        /// address: 0x450000fc
        /// Slot Interrupt Status
        pub const SISR = @intToPtr(*volatile Mmio(16, packed struct {
            /// Interrupt Signal for Each Slot
            INTSSL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xfc);

        /// address: 0x450000fe
        /// Host Controller Version
        pub const HCVR = @intToPtr(*volatile Mmio(16, packed struct {
            /// Spec Version
            SVER: u8,
            /// Vendor Version
            VVER: u8,
        }), base_address + 0xfe);

        /// address: 0x45000204
        /// MMC Control 1
        pub const MC1R = @intToPtr(*volatile Mmio(8, packed struct {
            /// e.MMC Command Type
            CMDTYP: u2,
            reserved0: u1,
            /// e.MMC HSDDR Mode
            DDR: u1,
            /// e.MMC Open Drain Mode
            OPD: u1,
            /// e.MMC Boot Acknowledge Enable
            BOOTA: u1,
            /// e.MMC Reset Signal
            RSTN: u1,
            /// e.MMC Force Card Detect
            FCD: u1,
        }), base_address + 0x204);

        /// address: 0x45000205
        /// MMC Control 2
        pub const MC2R = @intToPtr(*volatile Mmio(8, packed struct {
            /// e.MMC Abort Wait IRQ
            SRESP: u1,
            /// e.MMC Abort Boot
            ABOOT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x205);

        /// address: 0x45000208
        /// AHB Control
        pub const ACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// AHB Maximum Burst
            BMAX: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x208);

        /// address: 0x4500020c
        /// Clock Control 2
        pub const CC2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Force SDCK Disabled
            FSDCLKD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x20c);

        /// address: 0x45000230
        /// Capabilities Control
        pub const CACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capabilities Registers Write Enable (Required to write the correct frequencies
            /// in the Capabilities Registers)
            CAPWREN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Key (0x46)
            KEY: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x230);

        /// address: 0x45000234
        /// Debug
        pub const DBGR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Non-intrusive debug enable
            NIDBG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x234);
    };

    /// Serial Communication Interface
    pub const SERCOM0 = struct {
        pub const base_address = 0x40003000;
        pub const version = "U22015.0.0";

        /// I2C Master Mode
        pub const I2CM = struct {
            /// address: 0x40003000
            /// I2CM Control A
            pub const CTRLA = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset
                SWRST: u1,
                /// Enable
                ENABLE: u1,
                /// Operating Mode
                MODE: u3,
                reserved0: u1,
                reserved1: u1,
                /// Run in Standby
                RUNSTDBY: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                /// Pin Usage
                PINOUT: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                /// SDA Hold Time
                SDAHOLD: u2,
                /// Master SCL Low Extend Timeout
                MEXTTOEN: u1,
                /// Slave SCL Low Extend Timeout
                SEXTTOEN: u1,
                /// Transfer Speed
                SPEED: u2,
                reserved13: u1,
                /// SCL Clock Stretch Mode
                SCLSM: u1,
                /// Inactive Time-Out
                INACTOUT: u2,
                /// SCL Low Timeout Enable
                LOWTOUTEN: u1,
                padding0: u1,
            }), base_address + 0x0);

            /// address: 0x40003004
            /// I2CM Control B
            pub const CTRLB = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                /// Smart Mode Enable
                SMEN: u1,
                /// Quick Command Enable
                QCEN: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                /// Command
                CMD: u2,
                /// Acknowledge Action
                ACKACT: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
            }), base_address + 0x4);

            /// address: 0x40003008
            /// I2CM Control C
            pub const CTRLC = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                /// Data 32 Bit
                DATA32B: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0x8);

            /// address: 0x4000300c
            /// I2CM Baud Rate
            pub const BAUD = @intToPtr(*volatile Mmio(32, packed struct {
                /// Baud Rate Value
                BAUD: u8,
                /// Baud Rate Value Low
                BAUDLOW: u8,
                /// High Speed Baud Rate Value
                HSBAUD: u8,
                /// High Speed Baud Rate Value Low
                HSBAUDLOW: u8,
            }), base_address + 0xc);

            /// address: 0x40003014
            /// I2CM Interrupt Enable Clear
            pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
                /// Master On Bus Interrupt Disable
                MB: u1,
                /// Slave On Bus Interrupt Disable
                SB: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                /// Combined Error Interrupt Disable
                ERROR: u1,
            }), base_address + 0x14);

            /// address: 0x40003016
            /// I2CM Interrupt Enable Set
            pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
                /// Master On Bus Interrupt Enable
                MB: u1,
                /// Slave On Bus Interrupt Enable
                SB: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                /// Combined Error Interrupt Enable
                ERROR: u1,
            }), base_address + 0x16);

            /// address: 0x40003018
            /// I2CM Interrupt Flag Status and Clear
            pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
                /// Master On Bus Interrupt
                MB: u1,
                /// Slave On Bus Interrupt
                SB: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                /// Combined Error Interrupt
                ERROR: u1,
            }), base_address + 0x18);

            /// address: 0x4000301a
            /// I2CM Status
            pub const STATUS = @intToPtr(*volatile Mmio(16, packed struct {
                /// Bus Error
                BUSERR: u1,
                /// Arbitration Lost
                ARBLOST: u1,
                /// Received Not Acknowledge
                RXNACK: u1,
                reserved0: u1,
                /// Bus State
                BUSSTATE: u2,
                /// SCL Low Timeout
                LOWTOUT: u1,
                /// Clock Hold
                CLKHOLD: u1,
                /// Master SCL Low Extend Timeout
                MEXTTOUT: u1,
                /// Slave SCL Low Extend Timeout
                SEXTTOUT: u1,
                /// Length Error
                LENERR: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
            }), base_address + 0x1a);

            /// address: 0x4000301c
            /// I2CM Synchronization Busy
            pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset Synchronization Busy
                SWRST: u1,
                /// SERCOM Enable Synchronization Busy
                ENABLE: u1,
                /// System Operation Synchronization Busy
                SYSOP: u1,
                reserved0: u1,
                /// Length Synchronization Busy
                LENGTH: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
            }), base_address + 0x1c);

            /// address: 0x40003024
            /// I2CM Address
            pub const ADDR = @intToPtr(*volatile Mmio(32, packed struct {
                /// Address Value
                ADDR: u11,
                reserved0: u1,
                reserved1: u1,
                /// Length Enable
                LENEN: u1,
                /// High Speed Mode
                HS: u1,
                /// Ten Bit Addressing Enable
                TENBITEN: u1,
                /// Length
                LEN: u8,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x24);

            /// address: 0x40003028
            /// I2CM Data
            pub const DATA = @intToPtr(*volatile u8, base_address + 0x28);

            /// address: 0x40003030
            /// I2CM Debug Control
            pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
                /// Debug Mode
                DBGSTOP: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0x30);
        };

        /// I2C Slave Mode
        pub const I2CS = struct {
            /// address: 0x40003000
            /// I2CS Control A
            pub const CTRLA = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset
                SWRST: u1,
                /// Enable
                ENABLE: u1,
                /// Operating Mode
                MODE: u3,
                reserved0: u1,
                reserved1: u1,
                /// Run during Standby
                RUNSTDBY: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                /// Pin Usage
                PINOUT: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                /// SDA Hold Time
                SDAHOLD: u2,
                reserved13: u1,
                /// Slave SCL Low Extend Timeout
                SEXTTOEN: u1,
                /// Transfer Speed
                SPEED: u2,
                reserved14: u1,
                /// SCL Clock Stretch Mode
                SCLSM: u1,
                reserved15: u1,
                reserved16: u1,
                /// SCL Low Timeout Enable
                LOWTOUTEN: u1,
                padding0: u1,
            }), base_address + 0x0);

            /// address: 0x40003004
            /// I2CS Control B
            pub const CTRLB = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                /// Smart Mode Enable
                SMEN: u1,
                /// PMBus Group Command
                GCMD: u1,
                /// Automatic Address Acknowledge
                AACKEN: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                /// Address Mode
                AMODE: u2,
                /// Command
                CMD: u2,
                /// Acknowledge Action
                ACKACT: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
            }), base_address + 0x4);

            /// address: 0x40003008
            /// I2CS Control C
            pub const CTRLC = @intToPtr(*volatile Mmio(32, packed struct {
                /// SDA Setup Time
                SDASETUP: u4,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                /// Data 32 Bit
                DATA32B: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0x8);

            /// address: 0x40003014
            /// I2CS Interrupt Enable Clear
            pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
                /// Stop Received Interrupt Disable
                PREC: u1,
                /// Address Match Interrupt Disable
                AMATCH: u1,
                /// Data Interrupt Disable
                DRDY: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Combined Error Interrupt Disable
                ERROR: u1,
            }), base_address + 0x14);

            /// address: 0x40003016
            /// I2CS Interrupt Enable Set
            pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
                /// Stop Received Interrupt Enable
                PREC: u1,
                /// Address Match Interrupt Enable
                AMATCH: u1,
                /// Data Interrupt Enable
                DRDY: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Combined Error Interrupt Enable
                ERROR: u1,
            }), base_address + 0x16);

            /// address: 0x40003018
            /// I2CS Interrupt Flag Status and Clear
            pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
                /// Stop Received Interrupt
                PREC: u1,
                /// Address Match Interrupt
                AMATCH: u1,
                /// Data Interrupt
                DRDY: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Combined Error Interrupt
                ERROR: u1,
            }), base_address + 0x18);

            /// address: 0x4000301a
            /// I2CS Status
            pub const STATUS = @intToPtr(*volatile Mmio(16, packed struct {
                /// Bus Error
                BUSERR: u1,
                /// Transmit Collision
                COLL: u1,
                /// Received Not Acknowledge
                RXNACK: u1,
                /// Read/Write Direction
                DIR: u1,
                /// Repeated Start
                SR: u1,
                reserved0: u1,
                /// SCL Low Timeout
                LOWTOUT: u1,
                /// Clock Hold
                CLKHOLD: u1,
                reserved1: u1,
                /// Slave SCL Low Extend Timeout
                SEXTTOUT: u1,
                /// High Speed
                HS: u1,
                /// Transaction Length Error
                LENERR: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
            }), base_address + 0x1a);

            /// address: 0x4000301c
            /// I2CS Synchronization Busy
            pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset Synchronization Busy
                SWRST: u1,
                /// SERCOM Enable Synchronization Busy
                ENABLE: u1,
                reserved0: u1,
                reserved1: u1,
                /// Length Synchronization Busy
                LENGTH: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
            }), base_address + 0x1c);

            /// address: 0x40003022
            /// I2CS Length
            pub const LENGTH = @intToPtr(*volatile Mmio(16, packed struct {
                /// Data Length
                LEN: u8,
                /// Data Length Enable
                LENEN: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0x22);

            /// address: 0x40003024
            /// I2CS Address
            pub const ADDR = @intToPtr(*volatile Mmio(32, packed struct {
                /// General Call Address Enable
                GENCEN: u1,
                /// Address Value
                ADDR: u10,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Ten Bit Addressing Enable
                TENBITEN: u1,
                reserved4: u1,
                /// Address Mask
                ADDRMASK: u10,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
            }), base_address + 0x24);

            /// address: 0x40003028
            /// I2CS Data
            pub const DATA = @intToPtr(*volatile u32, base_address + 0x28);
        };

        /// SPI Slave Mode
        pub const SPIS = struct {
            /// address: 0x40003000
            /// SPIS Control A
            pub const CTRLA = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset
                SWRST: u1,
                /// Enable
                ENABLE: u1,
                /// Operating Mode
                MODE: u3,
                reserved0: u1,
                reserved1: u1,
                /// Run during Standby
                RUNSTDBY: u1,
                /// Immediate Buffer Overflow Notification
                IBON: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                /// Data Out Pinout
                DOPO: u2,
                reserved9: u1,
                reserved10: u1,
                /// Data In Pinout
                DIPO: u2,
                reserved11: u1,
                reserved12: u1,
                /// Frame Format
                FORM: u4,
                /// Clock Phase
                CPHA: u1,
                /// Clock Polarity
                CPOL: u1,
                /// Data Order
                DORD: u1,
                padding0: u1,
            }), base_address + 0x0);

            /// address: 0x40003004
            /// SPIS Control B
            pub const CTRLB = @intToPtr(*volatile Mmio(32, packed struct {
                /// Character Size
                CHSIZE: u3,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// Data Preload Enable
                PLOADEN: u1,
                reserved3: u1,
                reserved4: u1,
                /// Slave Select Low Detect Enable
                SSDE: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                /// Master Slave Select Enable
                MSSEN: u1,
                /// Address Mode
                AMODE: u2,
                reserved8: u1,
                /// Receiver Enable
                RXEN: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
            }), base_address + 0x4);

            /// address: 0x40003008
            /// SPIS Control C
            pub const CTRLC = @intToPtr(*volatile Mmio(32, packed struct {
                /// Inter-Character Spacing
                ICSPACE: u6,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                /// Data 32 Bit
                DATA32B: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0x8);

            /// address: 0x4000300c
            /// SPIS Baud Rate
            pub const BAUD = @intToPtr(*volatile u8, base_address + 0xc);

            /// address: 0x40003014
            /// SPIS Interrupt Enable Clear
            pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
                /// Data Register Empty Interrupt Disable
                DRE: u1,
                /// Transmit Complete Interrupt Disable
                TXC: u1,
                /// Receive Complete Interrupt Disable
                RXC: u1,
                /// Slave Select Low Interrupt Disable
                SSL: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// Combined Error Interrupt Disable
                ERROR: u1,
            }), base_address + 0x14);

            /// address: 0x40003016
            /// SPIS Interrupt Enable Set
            pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
                /// Data Register Empty Interrupt Enable
                DRE: u1,
                /// Transmit Complete Interrupt Enable
                TXC: u1,
                /// Receive Complete Interrupt Enable
                RXC: u1,
                /// Slave Select Low Interrupt Enable
                SSL: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// Combined Error Interrupt Enable
                ERROR: u1,
            }), base_address + 0x16);

            /// address: 0x40003018
            /// SPIS Interrupt Flag Status and Clear
            pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
                /// Data Register Empty Interrupt
                DRE: u1,
                /// Transmit Complete Interrupt
                TXC: u1,
                /// Receive Complete Interrupt
                RXC: u1,
                /// Slave Select Low Interrupt Flag
                SSL: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// Combined Error Interrupt
                ERROR: u1,
            }), base_address + 0x18);

            /// address: 0x4000301a
            /// SPIS Status
            pub const STATUS = @intToPtr(*volatile Mmio(16, packed struct {
                reserved0: u1,
                reserved1: u1,
                /// Buffer Overflow
                BUFOVF: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                /// Transaction Length Error
                LENERR: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
            }), base_address + 0x1a);

            /// address: 0x4000301c
            /// SPIS Synchronization Busy
            pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset Synchronization Busy
                SWRST: u1,
                /// SERCOM Enable Synchronization Busy
                ENABLE: u1,
                /// CTRLB Synchronization Busy
                CTRLB: u1,
                reserved0: u1,
                /// LENGTH Synchronization Busy
                LENGTH: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
            }), base_address + 0x1c);

            /// address: 0x40003022
            /// SPIS Length
            pub const LENGTH = @intToPtr(*volatile Mmio(16, packed struct {
                /// Data Length
                LEN: u8,
                /// Data Length Enable
                LENEN: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0x22);

            /// address: 0x40003024
            /// SPIS Address
            pub const ADDR = @intToPtr(*volatile Mmio(32, packed struct {
                /// Address Value
                ADDR: u8,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                /// Address Mask
                ADDRMASK: u8,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x24);

            /// address: 0x40003028
            /// SPIS Data
            pub const DATA = @intToPtr(*volatile u32, base_address + 0x28);

            /// address: 0x40003030
            /// SPIS Debug Control
            pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
                /// Debug Mode
                DBGSTOP: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0x30);
        };

        /// SPI Master Mode
        pub const SPIM = struct {
            /// address: 0x40003000
            /// SPIM Control A
            pub const CTRLA = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset
                SWRST: u1,
                /// Enable
                ENABLE: u1,
                /// Operating Mode
                MODE: u3,
                reserved0: u1,
                reserved1: u1,
                /// Run during Standby
                RUNSTDBY: u1,
                /// Immediate Buffer Overflow Notification
                IBON: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                /// Data Out Pinout
                DOPO: u2,
                reserved9: u1,
                reserved10: u1,
                /// Data In Pinout
                DIPO: u2,
                reserved11: u1,
                reserved12: u1,
                /// Frame Format
                FORM: u4,
                /// Clock Phase
                CPHA: u1,
                /// Clock Polarity
                CPOL: u1,
                /// Data Order
                DORD: u1,
                padding0: u1,
            }), base_address + 0x0);

            /// address: 0x40003004
            /// SPIM Control B
            pub const CTRLB = @intToPtr(*volatile Mmio(32, packed struct {
                /// Character Size
                CHSIZE: u3,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// Data Preload Enable
                PLOADEN: u1,
                reserved3: u1,
                reserved4: u1,
                /// Slave Select Low Detect Enable
                SSDE: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                /// Master Slave Select Enable
                MSSEN: u1,
                /// Address Mode
                AMODE: u2,
                reserved8: u1,
                /// Receiver Enable
                RXEN: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
            }), base_address + 0x4);

            /// address: 0x40003008
            /// SPIM Control C
            pub const CTRLC = @intToPtr(*volatile Mmio(32, packed struct {
                /// Inter-Character Spacing
                ICSPACE: u6,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                /// Data 32 Bit
                DATA32B: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0x8);

            /// address: 0x4000300c
            /// SPIM Baud Rate
            pub const BAUD = @intToPtr(*volatile u8, base_address + 0xc);

            /// address: 0x40003014
            /// SPIM Interrupt Enable Clear
            pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
                /// Data Register Empty Interrupt Disable
                DRE: u1,
                /// Transmit Complete Interrupt Disable
                TXC: u1,
                /// Receive Complete Interrupt Disable
                RXC: u1,
                /// Slave Select Low Interrupt Disable
                SSL: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// Combined Error Interrupt Disable
                ERROR: u1,
            }), base_address + 0x14);

            /// address: 0x40003016
            /// SPIM Interrupt Enable Set
            pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
                /// Data Register Empty Interrupt Enable
                DRE: u1,
                /// Transmit Complete Interrupt Enable
                TXC: u1,
                /// Receive Complete Interrupt Enable
                RXC: u1,
                /// Slave Select Low Interrupt Enable
                SSL: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// Combined Error Interrupt Enable
                ERROR: u1,
            }), base_address + 0x16);

            /// address: 0x40003018
            /// SPIM Interrupt Flag Status and Clear
            pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
                /// Data Register Empty Interrupt
                DRE: u1,
                /// Transmit Complete Interrupt
                TXC: u1,
                /// Receive Complete Interrupt
                RXC: u1,
                /// Slave Select Low Interrupt Flag
                SSL: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// Combined Error Interrupt
                ERROR: u1,
            }), base_address + 0x18);

            /// address: 0x4000301a
            /// SPIM Status
            pub const STATUS = @intToPtr(*volatile Mmio(16, packed struct {
                reserved0: u1,
                reserved1: u1,
                /// Buffer Overflow
                BUFOVF: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                /// Transaction Length Error
                LENERR: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
            }), base_address + 0x1a);

            /// address: 0x4000301c
            /// SPIM Synchronization Busy
            pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset Synchronization Busy
                SWRST: u1,
                /// SERCOM Enable Synchronization Busy
                ENABLE: u1,
                /// CTRLB Synchronization Busy
                CTRLB: u1,
                reserved0: u1,
                /// LENGTH Synchronization Busy
                LENGTH: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
            }), base_address + 0x1c);

            /// address: 0x40003022
            /// SPIM Length
            pub const LENGTH = @intToPtr(*volatile Mmio(16, packed struct {
                /// Data Length
                LEN: u8,
                /// Data Length Enable
                LENEN: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0x22);

            /// address: 0x40003024
            /// SPIM Address
            pub const ADDR = @intToPtr(*volatile Mmio(32, packed struct {
                /// Address Value
                ADDR: u8,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                /// Address Mask
                ADDRMASK: u8,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x24);

            /// address: 0x40003028
            /// SPIM Data
            pub const DATA = @intToPtr(*volatile u32, base_address + 0x28);

            /// address: 0x40003030
            /// SPIM Debug Control
            pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
                /// Debug Mode
                DBGSTOP: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0x30);
        };

        /// USART EXTERNAL CLOCK Mode
        pub const USART_EXT = struct {
            /// address: 0x40003000
            /// USART_EXT Control A
            pub const CTRLA = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset
                SWRST: u1,
                /// Enable
                ENABLE: u1,
                /// Operating Mode
                MODE: u3,
                reserved0: u1,
                reserved1: u1,
                /// Run during Standby
                RUNSTDBY: u1,
                /// Immediate Buffer Overflow Notification
                IBON: u1,
                /// Transmit Data Invert
                TXINV: u1,
                /// Receive Data Invert
                RXINV: u1,
                reserved2: u1,
                reserved3: u1,
                /// Sample
                SAMPR: u3,
                /// Transmit Data Pinout
                TXPO: u2,
                reserved4: u1,
                reserved5: u1,
                /// Receive Data Pinout
                RXPO: u2,
                /// Sample Adjustment
                SAMPA: u2,
                /// Frame Format
                FORM: u4,
                /// Communication Mode
                CMODE: u1,
                /// Clock Polarity
                CPOL: u1,
                /// Data Order
                DORD: u1,
                padding0: u1,
            }), base_address + 0x0);

            /// address: 0x40003004
            /// USART_EXT Control B
            pub const CTRLB = @intToPtr(*volatile Mmio(32, packed struct {
                /// Character Size
                CHSIZE: u3,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// Stop Bit Mode
                SBMODE: u1,
                reserved3: u1,
                /// Collision Detection Enable
                COLDEN: u1,
                /// Start of Frame Detection Enable
                SFDE: u1,
                /// Encoding Format
                ENC: u1,
                reserved4: u1,
                reserved5: u1,
                /// Parity Mode
                PMODE: u1,
                reserved6: u1,
                reserved7: u1,
                /// Transmitter Enable
                TXEN: u1,
                /// Receiver Enable
                RXEN: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                /// LIN Command
                LINCMD: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0x4);

            /// address: 0x40003008
            /// USART_EXT Control C
            pub const CTRLC = @intToPtr(*volatile Mmio(32, packed struct {
                /// Guard Time
                GTIME: u3,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                /// LIN Master Break Length
                BRKLEN: u2,
                /// LIN Master Header Delay
                HDRDLY: u2,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                /// Inhibit Not Acknowledge
                INACK: u1,
                /// Disable Successive NACK
                DSNACK: u1,
                reserved9: u1,
                reserved10: u1,
                /// Maximum Iterations
                MAXITER: u3,
                reserved11: u1,
                /// Data 32 Bit
                DATA32B: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0x8);

            /// address: 0x4000300c
            /// USART_EXT Baud Rate
            pub const BAUD = @intToPtr(*volatile u16, base_address + 0xc);

            /// address: 0x4000300c
            /// USART_EXT Baud Rate
            pub const BAUD_FRAC_MODE = @intToPtr(*volatile Mmio(16, packed struct {
                /// Baud Rate Value
                BAUD: u13,
                /// Fractional Part
                FP: u3,
            }), base_address + 0xc);

            /// address: 0x4000300c
            /// USART_EXT Baud Rate
            pub const BAUD_FRACFP_MODE = @intToPtr(*volatile Mmio(16, packed struct {
                /// Baud Rate Value
                BAUD: u13,
                /// Fractional Part
                FP: u3,
            }), base_address + 0xc);

            /// address: 0x4000300c
            /// USART_EXT Baud Rate
            pub const BAUD_USARTFP_MODE = @intToPtr(*volatile Mmio(16, packed struct {
                /// Baud Rate Value
                BAUD: u16,
            }), base_address + 0xc);

            /// address: 0x4000300e
            /// USART_EXT Receive Pulse Length
            pub const RXPL = @intToPtr(*volatile u8, base_address + 0xe);

            /// address: 0x40003014
            /// USART_EXT Interrupt Enable Clear
            pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
                /// Data Register Empty Interrupt Disable
                DRE: u1,
                /// Transmit Complete Interrupt Disable
                TXC: u1,
                /// Receive Complete Interrupt Disable
                RXC: u1,
                /// Receive Start Interrupt Disable
                RXS: u1,
                /// Clear To Send Input Change Interrupt Disable
                CTSIC: u1,
                /// Break Received Interrupt Disable
                RXBRK: u1,
                reserved0: u1,
                /// Combined Error Interrupt Disable
                ERROR: u1,
            }), base_address + 0x14);

            /// address: 0x40003016
            /// USART_EXT Interrupt Enable Set
            pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
                /// Data Register Empty Interrupt Enable
                DRE: u1,
                /// Transmit Complete Interrupt Enable
                TXC: u1,
                /// Receive Complete Interrupt Enable
                RXC: u1,
                /// Receive Start Interrupt Enable
                RXS: u1,
                /// Clear To Send Input Change Interrupt Enable
                CTSIC: u1,
                /// Break Received Interrupt Enable
                RXBRK: u1,
                reserved0: u1,
                /// Combined Error Interrupt Enable
                ERROR: u1,
            }), base_address + 0x16);

            /// address: 0x40003018
            /// USART_EXT Interrupt Flag Status and Clear
            pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
                /// Data Register Empty Interrupt
                DRE: u1,
                /// Transmit Complete Interrupt
                TXC: u1,
                /// Receive Complete Interrupt
                RXC: u1,
                /// Receive Start Interrupt
                RXS: u1,
                /// Clear To Send Input Change Interrupt
                CTSIC: u1,
                /// Break Received Interrupt
                RXBRK: u1,
                reserved0: u1,
                /// Combined Error Interrupt
                ERROR: u1,
            }), base_address + 0x18);

            /// address: 0x4000301a
            /// USART_EXT Status
            pub const STATUS = @intToPtr(*volatile Mmio(16, packed struct {
                /// Parity Error
                PERR: u1,
                /// Frame Error
                FERR: u1,
                /// Buffer Overflow
                BUFOVF: u1,
                /// Clear To Send
                CTS: u1,
                /// Inconsistent Sync Field
                ISF: u1,
                /// Collision Detected
                COLL: u1,
                /// Transmitter Empty
                TXE: u1,
                /// Maximum Number of Repetitions Reached
                ITER: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x1a);

            /// address: 0x4000301c
            /// USART_EXT Synchronization Busy
            pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset Synchronization Busy
                SWRST: u1,
                /// SERCOM Enable Synchronization Busy
                ENABLE: u1,
                /// CTRLB Synchronization Busy
                CTRLB: u1,
                /// RXERRCNT Synchronization Busy
                RXERRCNT: u1,
                /// LENGTH Synchronization Busy
                LENGTH: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
            }), base_address + 0x1c);

            /// address: 0x40003020
            /// USART_EXT Receive Error Count
            pub const RXERRCNT = @intToPtr(*volatile u8, base_address + 0x20);

            /// address: 0x40003022
            /// USART_EXT Length
            pub const LENGTH = @intToPtr(*volatile Mmio(16, packed struct {
                /// Data Length
                LEN: u8,
                /// Data Length Enable
                LENEN: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0x22);

            /// address: 0x40003028
            /// USART_EXT Data
            pub const DATA = @intToPtr(*volatile u32, base_address + 0x28);

            /// address: 0x40003030
            /// USART_EXT Debug Control
            pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
                /// Debug Mode
                DBGSTOP: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0x30);
        };

        /// USART INTERNAL CLOCK Mode
        pub const USART_INT = struct {
            /// address: 0x40003000
            /// USART_INT Control A
            pub const CTRLA = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset
                SWRST: u1,
                /// Enable
                ENABLE: u1,
                /// Operating Mode
                MODE: u3,
                reserved0: u1,
                reserved1: u1,
                /// Run during Standby
                RUNSTDBY: u1,
                /// Immediate Buffer Overflow Notification
                IBON: u1,
                /// Transmit Data Invert
                TXINV: u1,
                /// Receive Data Invert
                RXINV: u1,
                reserved2: u1,
                reserved3: u1,
                /// Sample
                SAMPR: u3,
                /// Transmit Data Pinout
                TXPO: u2,
                reserved4: u1,
                reserved5: u1,
                /// Receive Data Pinout
                RXPO: u2,
                /// Sample Adjustment
                SAMPA: u2,
                /// Frame Format
                FORM: u4,
                /// Communication Mode
                CMODE: u1,
                /// Clock Polarity
                CPOL: u1,
                /// Data Order
                DORD: u1,
                padding0: u1,
            }), base_address + 0x0);

            /// address: 0x40003004
            /// USART_INT Control B
            pub const CTRLB = @intToPtr(*volatile Mmio(32, packed struct {
                /// Character Size
                CHSIZE: u3,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// Stop Bit Mode
                SBMODE: u1,
                reserved3: u1,
                /// Collision Detection Enable
                COLDEN: u1,
                /// Start of Frame Detection Enable
                SFDE: u1,
                /// Encoding Format
                ENC: u1,
                reserved4: u1,
                reserved5: u1,
                /// Parity Mode
                PMODE: u1,
                reserved6: u1,
                reserved7: u1,
                /// Transmitter Enable
                TXEN: u1,
                /// Receiver Enable
                RXEN: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                /// LIN Command
                LINCMD: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0x4);

            /// address: 0x40003008
            /// USART_INT Control C
            pub const CTRLC = @intToPtr(*volatile Mmio(32, packed struct {
                /// Guard Time
                GTIME: u3,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                /// LIN Master Break Length
                BRKLEN: u2,
                /// LIN Master Header Delay
                HDRDLY: u2,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                /// Inhibit Not Acknowledge
                INACK: u1,
                /// Disable Successive NACK
                DSNACK: u1,
                reserved9: u1,
                reserved10: u1,
                /// Maximum Iterations
                MAXITER: u3,
                reserved11: u1,
                /// Data 32 Bit
                DATA32B: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0x8);

            /// address: 0x4000300c
            /// USART_INT Baud Rate
            pub const BAUD = @intToPtr(*volatile u16, base_address + 0xc);

            /// address: 0x4000300c
            /// USART_INT Baud Rate
            pub const BAUD_FRAC_MODE = @intToPtr(*volatile Mmio(16, packed struct {
                /// Baud Rate Value
                BAUD: u13,
                /// Fractional Part
                FP: u3,
            }), base_address + 0xc);

            /// address: 0x4000300c
            /// USART_INT Baud Rate
            pub const BAUD_FRACFP_MODE = @intToPtr(*volatile Mmio(16, packed struct {
                /// Baud Rate Value
                BAUD: u13,
                /// Fractional Part
                FP: u3,
            }), base_address + 0xc);

            /// address: 0x4000300c
            /// USART_INT Baud Rate
            pub const BAUD_USARTFP_MODE = @intToPtr(*volatile Mmio(16, packed struct {
                /// Baud Rate Value
                BAUD: u16,
            }), base_address + 0xc);

            /// address: 0x4000300e
            /// USART_INT Receive Pulse Length
            pub const RXPL = @intToPtr(*volatile u8, base_address + 0xe);

            /// address: 0x40003014
            /// USART_INT Interrupt Enable Clear
            pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
                /// Data Register Empty Interrupt Disable
                DRE: u1,
                /// Transmit Complete Interrupt Disable
                TXC: u1,
                /// Receive Complete Interrupt Disable
                RXC: u1,
                /// Receive Start Interrupt Disable
                RXS: u1,
                /// Clear To Send Input Change Interrupt Disable
                CTSIC: u1,
                /// Break Received Interrupt Disable
                RXBRK: u1,
                reserved0: u1,
                /// Combined Error Interrupt Disable
                ERROR: u1,
            }), base_address + 0x14);

            /// address: 0x40003016
            /// USART_INT Interrupt Enable Set
            pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
                /// Data Register Empty Interrupt Enable
                DRE: u1,
                /// Transmit Complete Interrupt Enable
                TXC: u1,
                /// Receive Complete Interrupt Enable
                RXC: u1,
                /// Receive Start Interrupt Enable
                RXS: u1,
                /// Clear To Send Input Change Interrupt Enable
                CTSIC: u1,
                /// Break Received Interrupt Enable
                RXBRK: u1,
                reserved0: u1,
                /// Combined Error Interrupt Enable
                ERROR: u1,
            }), base_address + 0x16);

            /// address: 0x40003018
            /// USART_INT Interrupt Flag Status and Clear
            pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
                /// Data Register Empty Interrupt
                DRE: u1,
                /// Transmit Complete Interrupt
                TXC: u1,
                /// Receive Complete Interrupt
                RXC: u1,
                /// Receive Start Interrupt
                RXS: u1,
                /// Clear To Send Input Change Interrupt
                CTSIC: u1,
                /// Break Received Interrupt
                RXBRK: u1,
                reserved0: u1,
                /// Combined Error Interrupt
                ERROR: u1,
            }), base_address + 0x18);

            /// address: 0x4000301a
            /// USART_INT Status
            pub const STATUS = @intToPtr(*volatile Mmio(16, packed struct {
                /// Parity Error
                PERR: u1,
                /// Frame Error
                FERR: u1,
                /// Buffer Overflow
                BUFOVF: u1,
                /// Clear To Send
                CTS: u1,
                /// Inconsistent Sync Field
                ISF: u1,
                /// Collision Detected
                COLL: u1,
                /// Transmitter Empty
                TXE: u1,
                /// Maximum Number of Repetitions Reached
                ITER: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x1a);

            /// address: 0x4000301c
            /// USART_INT Synchronization Busy
            pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset Synchronization Busy
                SWRST: u1,
                /// SERCOM Enable Synchronization Busy
                ENABLE: u1,
                /// CTRLB Synchronization Busy
                CTRLB: u1,
                /// RXERRCNT Synchronization Busy
                RXERRCNT: u1,
                /// LENGTH Synchronization Busy
                LENGTH: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
            }), base_address + 0x1c);

            /// address: 0x40003020
            /// USART_INT Receive Error Count
            pub const RXERRCNT = @intToPtr(*volatile u8, base_address + 0x20);

            /// address: 0x40003022
            /// USART_INT Length
            pub const LENGTH = @intToPtr(*volatile Mmio(16, packed struct {
                /// Data Length
                LEN: u8,
                /// Data Length Enable
                LENEN: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0x22);

            /// address: 0x40003028
            /// USART_INT Data
            pub const DATA = @intToPtr(*volatile u32, base_address + 0x28);

            /// address: 0x40003030
            /// USART_INT Debug Control
            pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
                /// Debug Mode
                DBGSTOP: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0x30);
        };
    };
    pub const SERCOM1 = struct {
        pub const base_address = 0x40003400;
    };
    pub const SERCOM2 = struct {
        pub const base_address = 0x41012000;
    };
    pub const SERCOM3 = struct {
        pub const base_address = 0x41014000;
    };
    pub const SERCOM4 = struct {
        pub const base_address = 0x43000000;
    };
    pub const SERCOM5 = struct {
        pub const base_address: usize = 0x43000400;

        pub const USART_INT = struct {
            /// address: 0x40003000
            /// USART_INT Control A
            pub const CTRLA = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset
                SWRST: u1,
                /// Enable
                ENABLE: u1,
                /// Operating Mode
                MODE: u3,
                reserved0: u1,
                reserved1: u1,
                /// Run during Standby
                RUNSTDBY: u1,
                /// Immediate Buffer Overflow Notification
                IBON: u1,
                /// Transmit Data Invert
                TXINV: u1,
                /// Receive Data Invert
                RXINV: u1,
                reserved2: u1,
                reserved3: u1,
                /// Sample
                SAMPR: u3,
                /// Transmit Data Pinout
                TXPO: u2,
                reserved4: u1,
                reserved5: u1,
                /// Receive Data Pinout
                RXPO: u2,
                /// Sample Adjustment
                SAMPA: u2,
                /// Frame Format
                FORM: u4,
                /// Communication Mode
                CMODE: u1,
                /// Clock Polarity
                CPOL: u1,
                /// Data Order
                DORD: u1,
                padding0: u1,
            }), base_address + 0x0);

            /// address: 0x40003004
            /// USART_INT Control B
            pub const CTRLB = @intToPtr(*volatile Mmio(32, packed struct {
                /// Character Size
                CHSIZE: u3,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// Stop Bit Mode
                SBMODE: u1,
                reserved3: u1,
                /// Collision Detection Enable
                COLDEN: u1,
                /// Start of Frame Detection Enable
                SFDE: u1,
                /// Encoding Format
                ENC: u1,
                reserved4: u1,
                reserved5: u1,
                /// Parity Mode
                PMODE: u1,
                reserved6: u1,
                reserved7: u1,
                /// Transmitter Enable
                TXEN: u1,
                /// Receiver Enable
                RXEN: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                /// LIN Command
                LINCMD: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0x4);

            /// address: 0x40003008
            /// USART_INT Control C
            pub const CTRLC = @intToPtr(*volatile Mmio(32, packed struct {
                /// Guard Time
                GTIME: u3,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                /// LIN Master Break Length
                BRKLEN: u2,
                /// LIN Master Header Delay
                HDRDLY: u2,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                /// Inhibit Not Acknowledge
                INACK: u1,
                /// Disable Successive NACK
                DSNACK: u1,
                reserved9: u1,
                reserved10: u1,
                /// Maximum Iterations
                MAXITER: u3,
                reserved11: u1,
                /// Data 32 Bit
                DATA32B: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0x8);

            /// address: 0x4000300c
            /// USART_INT Baud Rate
            pub const BAUD = @intToPtr(*volatile u16, base_address + 0xc);

            /// address: 0x4000300c
            /// USART_INT Baud Rate
            pub const BAUD_FRAC_MODE = @intToPtr(*volatile Mmio(16, packed struct {
                /// Baud Rate Value
                BAUD: u13,
                /// Fractional Part
                FP: u3,
            }), base_address + 0xc);

            /// address: 0x4000300c
            /// USART_INT Baud Rate
            pub const BAUD_FRACFP_MODE = @intToPtr(*volatile Mmio(16, packed struct {
                /// Baud Rate Value
                BAUD: u13,
                /// Fractional Part
                FP: u3,
            }), base_address + 0xc);

            /// address: 0x4000300c
            /// USART_INT Baud Rate
            pub const BAUD_USARTFP_MODE = @intToPtr(*volatile Mmio(16, packed struct {
                /// Baud Rate Value
                BAUD: u16,
            }), base_address + 0xc);

            /// address: 0x4000300e
            /// USART_INT Receive Pulse Length
            pub const RXPL = @intToPtr(*volatile u8, base_address + 0xe);

            /// address: 0x40003014
            /// USART_INT Interrupt Enable Clear
            pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
                /// Data Register Empty Interrupt Disable
                DRE: u1,
                /// Transmit Complete Interrupt Disable
                TXC: u1,
                /// Receive Complete Interrupt Disable
                RXC: u1,
                /// Receive Start Interrupt Disable
                RXS: u1,
                /// Clear To Send Input Change Interrupt Disable
                CTSIC: u1,
                /// Break Received Interrupt Disable
                RXBRK: u1,
                reserved0: u1,
                /// Combined Error Interrupt Disable
                ERROR: u1,
            }), base_address + 0x14);

            /// address: 0x40003016
            /// USART_INT Interrupt Enable Set
            pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
                /// Data Register Empty Interrupt Enable
                DRE: u1,
                /// Transmit Complete Interrupt Enable
                TXC: u1,
                /// Receive Complete Interrupt Enable
                RXC: u1,
                /// Receive Start Interrupt Enable
                RXS: u1,
                /// Clear To Send Input Change Interrupt Enable
                CTSIC: u1,
                /// Break Received Interrupt Enable
                RXBRK: u1,
                reserved0: u1,
                /// Combined Error Interrupt Enable
                ERROR: u1,
            }), base_address + 0x16);

            /// address: 0x40003018
            /// USART_INT Interrupt Flag Status and Clear
            pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
                /// Data Register Empty Interrupt
                DRE: u1,
                /// Transmit Complete Interrupt
                TXC: u1,
                /// Receive Complete Interrupt
                RXC: u1,
                /// Receive Start Interrupt
                RXS: u1,
                /// Clear To Send Input Change Interrupt
                CTSIC: u1,
                /// Break Received Interrupt
                RXBRK: u1,
                reserved0: u1,
                /// Combined Error Interrupt
                ERROR: u1,
            }), base_address + 0x18);

            /// address: 0x4000301a
            /// USART_INT Status
            pub const STATUS = @intToPtr(*volatile Mmio(16, packed struct {
                /// Parity Error
                PERR: u1,
                /// Frame Error
                FERR: u1,
                /// Buffer Overflow
                BUFOVF: u1,
                /// Clear To Send
                CTS: u1,
                /// Inconsistent Sync Field
                ISF: u1,
                /// Collision Detected
                COLL: u1,
                /// Transmitter Empty
                TXE: u1,
                /// Maximum Number of Repetitions Reached
                ITER: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x1a);

            /// address: 0x4000301c
            /// USART_INT Synchronization Busy
            pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset Synchronization Busy
                SWRST: u1,
                /// SERCOM Enable Synchronization Busy
                ENABLE: u1,
                /// CTRLB Synchronization Busy
                CTRLB: u1,
                /// RXERRCNT Synchronization Busy
                RXERRCNT: u1,
                /// LENGTH Synchronization Busy
                LENGTH: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
            }), base_address + 0x1c);

            /// address: 0x40003020
            /// USART_INT Receive Error Count
            pub const RXERRCNT = @intToPtr(*volatile u8, base_address + 0x20);

            /// address: 0x40003022
            /// USART_INT Length
            pub const LENGTH = @intToPtr(*volatile Mmio(16, packed struct {
                /// Data Length
                LEN: u8,
                /// Data Length Enable
                LENEN: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0x22);

            /// address: 0x40003028
            /// USART_INT Data
            pub const DATA = @intToPtr(*volatile u32, base_address + 0x28);

            /// address: 0x40003030
            /// USART_INT Debug Control
            pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
                /// Debug Mode
                DBGSTOP: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0x30);
        };
    };

    /// Supply Controller
    pub const SUPC = struct {
        pub const base_address = 0x40001800;
        pub const version = "U24071.1.0";

        /// address: 0x40001800
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// BOD33 Ready
            BOD33RDY: u1,
            /// BOD33 Detection
            BOD33DET: u1,
            /// BOD33 Synchronization Ready
            B33SRDY: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Voltage Regulator Ready
            VREGRDY: u1,
            reserved5: u1,
            /// VDDCORE Ready
            VCORERDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x0);

        /// address: 0x40001804
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// BOD33 Ready
            BOD33RDY: u1,
            /// BOD33 Detection
            BOD33DET: u1,
            /// BOD33 Synchronization Ready
            B33SRDY: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Voltage Regulator Ready
            VREGRDY: u1,
            reserved5: u1,
            /// VDDCORE Ready
            VCORERDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x4);

        /// address: 0x40001808
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(32, packed struct {
            /// BOD33 Ready
            BOD33RDY: u1,
            /// BOD33 Detection
            BOD33DET: u1,
            /// BOD33 Synchronization Ready
            B33SRDY: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Voltage Regulator Ready
            VREGRDY: u1,
            reserved5: u1,
            /// VDDCORE Ready
            VCORERDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x8);

        /// address: 0x4000180c
        /// Power and Clocks Status
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// BOD33 Ready
            BOD33RDY: u1,
            /// BOD33 Detection
            BOD33DET: u1,
            /// BOD33 Synchronization Ready
            B33SRDY: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Voltage Regulator Ready
            VREGRDY: u1,
            reserved5: u1,
            /// VDDCORE Ready
            VCORERDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0xc);

        /// address: 0x40001810
        /// BOD33 Control
        pub const BOD33 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Enable
            ENABLE: u1,
            /// Action when Threshold Crossed
            ACTION: u2,
            /// Configuration in Standby mode
            STDBYCFG: u1,
            /// Run in Standby mode
            RUNSTDBY: u1,
            /// Run in Hibernate mode
            RUNHIB: u1,
            /// Run in Backup mode
            RUNBKUP: u1,
            /// Hysteresis value
            HYST: u4,
            /// Prescaler Select
            PSEL: u3,
            reserved1: u1,
            /// Threshold Level for VDD
            LEVEL: u8,
            /// Threshold Level in battery backup sleep mode for VBAT
            VBATLEVEL: u8,
        }), base_address + 0x10);

        /// address: 0x40001818
        /// VREG Control
        pub const VREG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Enable
            ENABLE: u1,
            /// Voltage Regulator Selection
            SEL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Run in Backup mode
            RUNBKUP: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Voltage Scaling Enable
            VSEN: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// Voltage Scaling Period
            VSPER: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x18);

        /// address: 0x4000181c
        /// VREF Control
        pub const VREF = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Temperature Sensor Output Enable
            TSEN: u1,
            /// Voltage Reference Output Enable
            VREFOE: u1,
            /// Temperature Sensor Selection
            TSSEL: u1,
            reserved1: u1,
            reserved2: u1,
            /// Run during Standby
            RUNSTDBY: u1,
            /// On Demand Contrl
            ONDEMAND: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Voltage Reference Selection
            SEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x1c);

        /// address: 0x40001820
        /// Battery Backup Power Switch
        pub const BBPS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Battery Backup Configuration
            CONF: u1,
            reserved0: u1,
            /// Wake Enable
            WAKEEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x20);

        /// address: 0x40001824
        /// Backup Output Control
        pub const BKOUT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable OUT0
            ENOUT0: u1,
            /// Enable OUT1
            ENOUT1: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Clear OUT0
            CLROUT0: u1,
            /// Clear OUT1
            CLROUT1: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Set OUT0
            SETOUT0: u1,
            /// Set OUT1
            SETOUT1: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// RTC Toggle OUT0
            RTCTGLOUT0: u1,
            /// RTC Toggle OUT1
            RTCTGLOUT1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x24);

        /// address: 0x40001828
        /// Backup Input Control
        pub const BKIN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup Input 0
            BKIN0: u1,
            /// Backup Input 1
            BKIN1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x28);
    };

    /// Basic Timer Counter
    pub const TC0 = struct {
        pub const base_address = 0x40003800;
        pub const version = "U22493.0.0";

        /// 8-bit Counter Mode
        pub const COUNT8 = struct {
            /// address: 0x40003800
            /// Control A
            pub const CTRLA = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset
                SWRST: u1,
                /// Enable
                ENABLE: u1,
                /// Timer Counter Mode
                MODE: u2,
                /// Prescaler and Counter Synchronization
                PRESCSYNC: u2,
                /// Run during Standby
                RUNSTDBY: u1,
                /// Clock On Demand
                ONDEMAND: u1,
                /// Prescaler
                PRESCALER: u3,
                /// Auto Lock
                ALOCK: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Capture Channel 0 Enable
                CAPTEN0: u1,
                /// Capture Channel 1 Enable
                CAPTEN1: u1,
                reserved4: u1,
                reserved5: u1,
                /// Capture On Pin 0 Enable
                COPEN0: u1,
                /// Capture On Pin 1 Enable
                COPEN1: u1,
                reserved6: u1,
                reserved7: u1,
                /// Capture Mode Channel 0
                CAPTMODE0: u2,
                reserved8: u1,
                /// Capture mode Channel 1
                CAPTMODE1: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
            }), base_address + 0x0);

            /// address: 0x40003804
            /// Control B Clear
            pub const CTRLBCLR = @intToPtr(*volatile Mmio(8, packed struct {
                /// Counter Direction
                DIR: u1,
                /// Lock Update
                LUPD: u1,
                /// One-Shot on Counter
                ONESHOT: u1,
                reserved0: u1,
                reserved1: u1,
                /// Command
                CMD: u3,
            }), base_address + 0x4);

            /// address: 0x40003805
            /// Control B Set
            pub const CTRLBSET = @intToPtr(*volatile Mmio(8, packed struct {
                /// Counter Direction
                DIR: u1,
                /// Lock Update
                LUPD: u1,
                /// One-Shot on Counter
                ONESHOT: u1,
                reserved0: u1,
                reserved1: u1,
                /// Command
                CMD: u3,
            }), base_address + 0x5);

            /// address: 0x40003806
            /// Event Control
            pub const EVCTRL = @intToPtr(*volatile Mmio(16, packed struct {
                /// Event Action
                EVACT: u3,
                reserved0: u1,
                /// TC Event Input Polarity
                TCINV: u1,
                /// TC Event Enable
                TCEI: u1,
                reserved1: u1,
                reserved2: u1,
                /// Event Output Enable
                OVFEO: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                /// MC Event Output Enable 0
                MCEO0: u1,
                /// MC Event Output Enable 1
                MCEO1: u1,
                padding0: u1,
                padding1: u1,
            }), base_address + 0x6);

            /// address: 0x40003808
            /// Interrupt Enable Clear
            pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
                /// OVF Interrupt Disable
                OVF: u1,
                /// ERR Interrupt Disable
                ERR: u1,
                reserved0: u1,
                reserved1: u1,
                /// MC Interrupt Disable 0
                MC0: u1,
                /// MC Interrupt Disable 1
                MC1: u1,
                padding0: u1,
                padding1: u1,
            }), base_address + 0x8);

            /// address: 0x40003809
            /// Interrupt Enable Set
            pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
                /// OVF Interrupt Enable
                OVF: u1,
                /// ERR Interrupt Enable
                ERR: u1,
                reserved0: u1,
                reserved1: u1,
                /// MC Interrupt Enable 0
                MC0: u1,
                /// MC Interrupt Enable 1
                MC1: u1,
                padding0: u1,
                padding1: u1,
            }), base_address + 0x9);

            /// address: 0x4000380a
            /// Interrupt Flag Status and Clear
            pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
                /// OVF Interrupt Flag
                OVF: u1,
                /// ERR Interrupt Flag
                ERR: u1,
                reserved0: u1,
                reserved1: u1,
                /// MC Interrupt Flag 0
                MC0: u1,
                /// MC Interrupt Flag 1
                MC1: u1,
                padding0: u1,
                padding1: u1,
            }), base_address + 0xa);

            /// address: 0x4000380b
            /// Status
            pub const STATUS = @intToPtr(*volatile Mmio(8, packed struct {
                /// Stop Status Flag
                STOP: u1,
                /// Slave Status Flag
                SLAVE: u1,
                reserved0: u1,
                /// Synchronization Busy Status
                PERBUFV: u1,
                /// Compare channel buffer 0 valid
                CCBUFV0: u1,
                /// Compare channel buffer 1 valid
                CCBUFV1: u1,
                padding0: u1,
                padding1: u1,
            }), base_address + 0xb);

            /// address: 0x4000380c
            /// Waveform Generation Control
            pub const WAVE = @intToPtr(*volatile Mmio(8, packed struct {
                /// Waveform Generation Mode
                WAVEGEN: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0xc);

            /// address: 0x4000380d
            /// Control C
            pub const DRVCTRL = @intToPtr(*volatile Mmio(8, packed struct {
                /// Output Waveform Invert Enable 0
                INVEN0: u1,
                /// Output Waveform Invert Enable 1
                INVEN1: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0xd);

            /// address: 0x4000380f
            /// Debug Control
            pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
                /// Run During Debug
                DBGRUN: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0xf);

            /// address: 0x40003810
            /// Synchronization Status
            pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
                /// swrst
                SWRST: u1,
                /// enable
                ENABLE: u1,
                /// CTRLB
                CTRLB: u1,
                /// STATUS
                STATUS: u1,
                /// Counter
                COUNT: u1,
                /// Period
                PER: u1,
                /// Compare Channel 0
                CC0: u1,
                /// Compare Channel 1
                CC1: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
            }), base_address + 0x10);

            /// address: 0x40003814
            /// COUNT8 Count
            pub const COUNT = @intToPtr(*volatile u8, base_address + 0x14);

            /// address: 0x4000381b
            /// COUNT8 Period
            pub const PER = @intToPtr(*volatile u8, base_address + 0x1b);

            /// address: 0x4000381c
            /// COUNT8 Compare and Capture
            pub const CC = @intToPtr(*volatile [2]u8, base_address + 0x1c);

            /// address: 0x4000382f
            /// COUNT8 Period Buffer
            pub const PERBUF = @intToPtr(*volatile u8, base_address + 0x2f);

            /// address: 0x40003830
            /// COUNT8 Compare and Capture Buffer
            pub const CCBUF = @intToPtr(*volatile [2]u8, base_address + 0x30);
        };

        /// 16-bit Counter Mode
        pub const COUNT16 = struct {
            /// address: 0x40003800
            /// Control A
            pub const CTRLA = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset
                SWRST: u1,
                /// Enable
                ENABLE: u1,
                /// Timer Counter Mode
                MODE: u2,
                /// Prescaler and Counter Synchronization
                PRESCSYNC: u2,
                /// Run during Standby
                RUNSTDBY: u1,
                /// Clock On Demand
                ONDEMAND: u1,
                /// Prescaler
                PRESCALER: u3,
                /// Auto Lock
                ALOCK: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Capture Channel 0 Enable
                CAPTEN0: u1,
                /// Capture Channel 1 Enable
                CAPTEN1: u1,
                reserved4: u1,
                reserved5: u1,
                /// Capture On Pin 0 Enable
                COPEN0: u1,
                /// Capture On Pin 1 Enable
                COPEN1: u1,
                reserved6: u1,
                reserved7: u1,
                /// Capture Mode Channel 0
                CAPTMODE0: u2,
                reserved8: u1,
                /// Capture mode Channel 1
                CAPTMODE1: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
            }), base_address + 0x0);

            /// address: 0x40003804
            /// Control B Clear
            pub const CTRLBCLR = @intToPtr(*volatile Mmio(8, packed struct {
                /// Counter Direction
                DIR: u1,
                /// Lock Update
                LUPD: u1,
                /// One-Shot on Counter
                ONESHOT: u1,
                reserved0: u1,
                reserved1: u1,
                /// Command
                CMD: u3,
            }), base_address + 0x4);

            /// address: 0x40003805
            /// Control B Set
            pub const CTRLBSET = @intToPtr(*volatile Mmio(8, packed struct {
                /// Counter Direction
                DIR: u1,
                /// Lock Update
                LUPD: u1,
                /// One-Shot on Counter
                ONESHOT: u1,
                reserved0: u1,
                reserved1: u1,
                /// Command
                CMD: u3,
            }), base_address + 0x5);

            /// address: 0x40003806
            /// Event Control
            pub const EVCTRL = @intToPtr(*volatile Mmio(16, packed struct {
                /// Event Action
                EVACT: u3,
                reserved0: u1,
                /// TC Event Input Polarity
                TCINV: u1,
                /// TC Event Enable
                TCEI: u1,
                reserved1: u1,
                reserved2: u1,
                /// Event Output Enable
                OVFEO: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                /// MC Event Output Enable 0
                MCEO0: u1,
                /// MC Event Output Enable 1
                MCEO1: u1,
                padding0: u1,
                padding1: u1,
            }), base_address + 0x6);

            /// address: 0x40003808
            /// Interrupt Enable Clear
            pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
                /// OVF Interrupt Disable
                OVF: u1,
                /// ERR Interrupt Disable
                ERR: u1,
                reserved0: u1,
                reserved1: u1,
                /// MC Interrupt Disable 0
                MC0: u1,
                /// MC Interrupt Disable 1
                MC1: u1,
                padding0: u1,
                padding1: u1,
            }), base_address + 0x8);

            /// address: 0x40003809
            /// Interrupt Enable Set
            pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
                /// OVF Interrupt Enable
                OVF: u1,
                /// ERR Interrupt Enable
                ERR: u1,
                reserved0: u1,
                reserved1: u1,
                /// MC Interrupt Enable 0
                MC0: u1,
                /// MC Interrupt Enable 1
                MC1: u1,
                padding0: u1,
                padding1: u1,
            }), base_address + 0x9);

            /// address: 0x4000380a
            /// Interrupt Flag Status and Clear
            pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
                /// OVF Interrupt Flag
                OVF: u1,
                /// ERR Interrupt Flag
                ERR: u1,
                reserved0: u1,
                reserved1: u1,
                /// MC Interrupt Flag 0
                MC0: u1,
                /// MC Interrupt Flag 1
                MC1: u1,
                padding0: u1,
                padding1: u1,
            }), base_address + 0xa);

            /// address: 0x4000380b
            /// Status
            pub const STATUS = @intToPtr(*volatile Mmio(8, packed struct {
                /// Stop Status Flag
                STOP: u1,
                /// Slave Status Flag
                SLAVE: u1,
                reserved0: u1,
                /// Synchronization Busy Status
                PERBUFV: u1,
                /// Compare channel buffer 0 valid
                CCBUFV0: u1,
                /// Compare channel buffer 1 valid
                CCBUFV1: u1,
                padding0: u1,
                padding1: u1,
            }), base_address + 0xb);

            /// address: 0x4000380c
            /// Waveform Generation Control
            pub const WAVE = @intToPtr(*volatile Mmio(8, packed struct {
                /// Waveform Generation Mode
                WAVEGEN: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0xc);

            /// address: 0x4000380d
            /// Control C
            pub const DRVCTRL = @intToPtr(*volatile Mmio(8, packed struct {
                /// Output Waveform Invert Enable 0
                INVEN0: u1,
                /// Output Waveform Invert Enable 1
                INVEN1: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0xd);

            /// address: 0x4000380f
            /// Debug Control
            pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
                /// Run During Debug
                DBGRUN: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0xf);

            /// address: 0x40003810
            /// Synchronization Status
            pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
                /// swrst
                SWRST: u1,
                /// enable
                ENABLE: u1,
                /// CTRLB
                CTRLB: u1,
                /// STATUS
                STATUS: u1,
                /// Counter
                COUNT: u1,
                /// Period
                PER: u1,
                /// Compare Channel 0
                CC0: u1,
                /// Compare Channel 1
                CC1: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
            }), base_address + 0x10);

            /// address: 0x40003814
            /// COUNT16 Count
            pub const COUNT = @intToPtr(*volatile u16, base_address + 0x14);

            /// address: 0x4000381c
            /// COUNT16 Compare and Capture
            pub const CC = @intToPtr(*volatile [2]u16, base_address + 0x1c);

            /// address: 0x40003830
            /// COUNT16 Compare and Capture Buffer
            pub const CCBUF = @intToPtr(*volatile [2]u16, base_address + 0x30);
        };

        /// 32-bit Counter Mode
        pub const COUNT32 = struct {
            /// address: 0x40003800
            /// Control A
            pub const CTRLA = @intToPtr(*volatile Mmio(32, packed struct {
                /// Software Reset
                SWRST: u1,
                /// Enable
                ENABLE: u1,
                /// Timer Counter Mode
                MODE: u2,
                /// Prescaler and Counter Synchronization
                PRESCSYNC: u2,
                /// Run during Standby
                RUNSTDBY: u1,
                /// Clock On Demand
                ONDEMAND: u1,
                /// Prescaler
                PRESCALER: u3,
                /// Auto Lock
                ALOCK: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Capture Channel 0 Enable
                CAPTEN0: u1,
                /// Capture Channel 1 Enable
                CAPTEN1: u1,
                reserved4: u1,
                reserved5: u1,
                /// Capture On Pin 0 Enable
                COPEN0: u1,
                /// Capture On Pin 1 Enable
                COPEN1: u1,
                reserved6: u1,
                reserved7: u1,
                /// Capture Mode Channel 0
                CAPTMODE0: u2,
                reserved8: u1,
                /// Capture mode Channel 1
                CAPTMODE1: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
            }), base_address + 0x0);

            /// address: 0x40003804
            /// Control B Clear
            pub const CTRLBCLR = @intToPtr(*volatile Mmio(8, packed struct {
                /// Counter Direction
                DIR: u1,
                /// Lock Update
                LUPD: u1,
                /// One-Shot on Counter
                ONESHOT: u1,
                reserved0: u1,
                reserved1: u1,
                /// Command
                CMD: u3,
            }), base_address + 0x4);

            /// address: 0x40003805
            /// Control B Set
            pub const CTRLBSET = @intToPtr(*volatile Mmio(8, packed struct {
                /// Counter Direction
                DIR: u1,
                /// Lock Update
                LUPD: u1,
                /// One-Shot on Counter
                ONESHOT: u1,
                reserved0: u1,
                reserved1: u1,
                /// Command
                CMD: u3,
            }), base_address + 0x5);

            /// address: 0x40003806
            /// Event Control
            pub const EVCTRL = @intToPtr(*volatile Mmio(16, packed struct {
                /// Event Action
                EVACT: u3,
                reserved0: u1,
                /// TC Event Input Polarity
                TCINV: u1,
                /// TC Event Enable
                TCEI: u1,
                reserved1: u1,
                reserved2: u1,
                /// Event Output Enable
                OVFEO: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                /// MC Event Output Enable 0
                MCEO0: u1,
                /// MC Event Output Enable 1
                MCEO1: u1,
                padding0: u1,
                padding1: u1,
            }), base_address + 0x6);

            /// address: 0x40003808
            /// Interrupt Enable Clear
            pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
                /// OVF Interrupt Disable
                OVF: u1,
                /// ERR Interrupt Disable
                ERR: u1,
                reserved0: u1,
                reserved1: u1,
                /// MC Interrupt Disable 0
                MC0: u1,
                /// MC Interrupt Disable 1
                MC1: u1,
                padding0: u1,
                padding1: u1,
            }), base_address + 0x8);

            /// address: 0x40003809
            /// Interrupt Enable Set
            pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
                /// OVF Interrupt Enable
                OVF: u1,
                /// ERR Interrupt Enable
                ERR: u1,
                reserved0: u1,
                reserved1: u1,
                /// MC Interrupt Enable 0
                MC0: u1,
                /// MC Interrupt Enable 1
                MC1: u1,
                padding0: u1,
                padding1: u1,
            }), base_address + 0x9);

            /// address: 0x4000380a
            /// Interrupt Flag Status and Clear
            pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
                /// OVF Interrupt Flag
                OVF: u1,
                /// ERR Interrupt Flag
                ERR: u1,
                reserved0: u1,
                reserved1: u1,
                /// MC Interrupt Flag 0
                MC0: u1,
                /// MC Interrupt Flag 1
                MC1: u1,
                padding0: u1,
                padding1: u1,
            }), base_address + 0xa);

            /// address: 0x4000380b
            /// Status
            pub const STATUS = @intToPtr(*volatile Mmio(8, packed struct {
                /// Stop Status Flag
                STOP: u1,
                /// Slave Status Flag
                SLAVE: u1,
                reserved0: u1,
                /// Synchronization Busy Status
                PERBUFV: u1,
                /// Compare channel buffer 0 valid
                CCBUFV0: u1,
                /// Compare channel buffer 1 valid
                CCBUFV1: u1,
                padding0: u1,
                padding1: u1,
            }), base_address + 0xb);

            /// address: 0x4000380c
            /// Waveform Generation Control
            pub const WAVE = @intToPtr(*volatile Mmio(8, packed struct {
                /// Waveform Generation Mode
                WAVEGEN: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0xc);

            /// address: 0x4000380d
            /// Control C
            pub const DRVCTRL = @intToPtr(*volatile Mmio(8, packed struct {
                /// Output Waveform Invert Enable 0
                INVEN0: u1,
                /// Output Waveform Invert Enable 1
                INVEN1: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0xd);

            /// address: 0x4000380f
            /// Debug Control
            pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
                /// Run During Debug
                DBGRUN: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }), base_address + 0xf);

            /// address: 0x40003810
            /// Synchronization Status
            pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
                /// swrst
                SWRST: u1,
                /// enable
                ENABLE: u1,
                /// CTRLB
                CTRLB: u1,
                /// STATUS
                STATUS: u1,
                /// Counter
                COUNT: u1,
                /// Period
                PER: u1,
                /// Compare Channel 0
                CC0: u1,
                /// Compare Channel 1
                CC1: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
            }), base_address + 0x10);

            /// address: 0x40003814
            /// COUNT32 Count
            pub const COUNT = @intToPtr(*volatile u32, base_address + 0x14);

            /// address: 0x4000381c
            /// COUNT32 Compare and Capture
            pub const CC = @intToPtr(*volatile [2]u32, base_address + 0x1c);

            /// address: 0x40003830
            /// COUNT32 Compare and Capture Buffer
            pub const CCBUF = @intToPtr(*volatile [2]u32, base_address + 0x30);
        };
    };
    pub const TC1 = struct {
        pub const base_address = 0x40003c00;
    };
    pub const TC2 = struct {
        pub const base_address = 0x4101a000;
    };
    pub const TC3 = struct {
        pub const base_address = 0x4101c000;
    };
    pub const TC4 = struct {
        pub const base_address = 0x42001400;
    };
    pub const TC5 = struct {
        pub const base_address = 0x42001800;
    };

    /// Timer Counter Control
    pub const TCC0 = struct {
        pub const base_address = 0x41016000;
        pub const version = "U22133.1.0";

        /// address: 0x41016000
        /// Control A
        pub const CTRLA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Reset
            SWRST: u1,
            /// Enable
            ENABLE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Enhanced Resolution
            RESOLUTION: u2,
            reserved3: u1,
            /// Prescaler
            PRESCALER: u3,
            /// Run in Standby
            RUNSTDBY: u1,
            /// Prescaler and Counter Synchronization Selection
            PRESCSYNC: u2,
            /// Auto Lock
            ALOCK: u1,
            /// Master Synchronization (only for TCC Slave Instance)
            MSYNC: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// DMA One-shot Trigger Mode
            DMAOS: u1,
            /// Capture Channel 0 Enable
            CPTEN0: u1,
            /// Capture Channel 1 Enable
            CPTEN1: u1,
            /// Capture Channel 2 Enable
            CPTEN2: u1,
            /// Capture Channel 3 Enable
            CPTEN3: u1,
            /// Capture Channel 4 Enable
            CPTEN4: u1,
            /// Capture Channel 5 Enable
            CPTEN5: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x0);

        /// address: 0x41016004
        /// Control B Clear
        pub const CTRLBCLR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Counter Direction
            DIR: u1,
            /// Lock Update
            LUPD: u1,
            /// One-Shot
            ONESHOT: u1,
            /// Ramp Index Command
            IDXCMD: u2,
            /// TCC Command
            CMD: u3,
        }), base_address + 0x4);

        /// address: 0x41016005
        /// Control B Set
        pub const CTRLBSET = @intToPtr(*volatile Mmio(8, packed struct {
            /// Counter Direction
            DIR: u1,
            /// Lock Update
            LUPD: u1,
            /// One-Shot
            ONESHOT: u1,
            /// Ramp Index Command
            IDXCMD: u2,
            /// TCC Command
            CMD: u3,
        }), base_address + 0x5);

        /// address: 0x41016008
        /// Synchronization Busy
        pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Swrst Busy
            SWRST: u1,
            /// Enable Busy
            ENABLE: u1,
            /// Ctrlb Busy
            CTRLB: u1,
            /// Status Busy
            STATUS: u1,
            /// Count Busy
            COUNT: u1,
            /// Pattern Busy
            PATT: u1,
            /// Wave Busy
            WAVE: u1,
            /// Period Busy
            PER: u1,
            /// Compare Channel 0 Busy
            CC0: u1,
            /// Compare Channel 1 Busy
            CC1: u1,
            /// Compare Channel 2 Busy
            CC2: u1,
            /// Compare Channel 3 Busy
            CC3: u1,
            /// Compare Channel 4 Busy
            CC4: u1,
            /// Compare Channel 5 Busy
            CC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x8);

        /// address: 0x4101600c
        /// Recoverable Fault A Configuration
        pub const FCTRLA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fault A Source
            SRC: u2,
            reserved0: u1,
            /// Fault A Keeper
            KEEP: u1,
            /// Fault A Qualification
            QUAL: u1,
            /// Fault A Blanking Mode
            BLANK: u2,
            /// Fault A Restart
            RESTART: u1,
            /// Fault A Halt Mode
            HALT: u2,
            /// Fault A Capture Channel
            CHSEL: u2,
            /// Fault A Capture Action
            CAPTURE: u3,
            /// Fault A Blanking Prescaler
            BLANKPRESC: u1,
            /// Fault A Blanking Time
            BLANKVAL: u8,
            /// Fault A Filter Value
            FILTERVAL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xc);

        /// address: 0x41016010
        /// Recoverable Fault B Configuration
        pub const FCTRLB = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fault B Source
            SRC: u2,
            reserved0: u1,
            /// Fault B Keeper
            KEEP: u1,
            /// Fault B Qualification
            QUAL: u1,
            /// Fault B Blanking Mode
            BLANK: u2,
            /// Fault B Restart
            RESTART: u1,
            /// Fault B Halt Mode
            HALT: u2,
            /// Fault B Capture Channel
            CHSEL: u2,
            /// Fault B Capture Action
            CAPTURE: u3,
            /// Fault B Blanking Prescaler
            BLANKPRESC: u1,
            /// Fault B Blanking Time
            BLANKVAL: u8,
            /// Fault B Filter Value
            FILTERVAL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x10);

        /// address: 0x41016014
        /// Waveform Extension Configuration
        pub const WEXCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output Matrix
            OTMX: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Dead-time Insertion Generator 0 Enable
            DTIEN0: u1,
            /// Dead-time Insertion Generator 1 Enable
            DTIEN1: u1,
            /// Dead-time Insertion Generator 2 Enable
            DTIEN2: u1,
            /// Dead-time Insertion Generator 3 Enable
            DTIEN3: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Dead-time Low Side Outputs Value
            DTLS: u8,
            /// Dead-time High Side Outputs Value
            DTHS: u8,
        }), base_address + 0x14);

        /// address: 0x41016018
        /// Driver Control
        pub const DRVCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Non-Recoverable State 0 Output Enable
            NRE0: u1,
            /// Non-Recoverable State 1 Output Enable
            NRE1: u1,
            /// Non-Recoverable State 2 Output Enable
            NRE2: u1,
            /// Non-Recoverable State 3 Output Enable
            NRE3: u1,
            /// Non-Recoverable State 4 Output Enable
            NRE4: u1,
            /// Non-Recoverable State 5 Output Enable
            NRE5: u1,
            /// Non-Recoverable State 6 Output Enable
            NRE6: u1,
            /// Non-Recoverable State 7 Output Enable
            NRE7: u1,
            /// Non-Recoverable State 0 Output Value
            NRV0: u1,
            /// Non-Recoverable State 1 Output Value
            NRV1: u1,
            /// Non-Recoverable State 2 Output Value
            NRV2: u1,
            /// Non-Recoverable State 3 Output Value
            NRV3: u1,
            /// Non-Recoverable State 4 Output Value
            NRV4: u1,
            /// Non-Recoverable State 5 Output Value
            NRV5: u1,
            /// Non-Recoverable State 6 Output Value
            NRV6: u1,
            /// Non-Recoverable State 7 Output Value
            NRV7: u1,
            /// Output Waveform 0 Inversion
            INVEN0: u1,
            /// Output Waveform 1 Inversion
            INVEN1: u1,
            /// Output Waveform 2 Inversion
            INVEN2: u1,
            /// Output Waveform 3 Inversion
            INVEN3: u1,
            /// Output Waveform 4 Inversion
            INVEN4: u1,
            /// Output Waveform 5 Inversion
            INVEN5: u1,
            /// Output Waveform 6 Inversion
            INVEN6: u1,
            /// Output Waveform 7 Inversion
            INVEN7: u1,
            /// Non-Recoverable Fault Input 0 Filter Value
            FILTERVAL0: u4,
            /// Non-Recoverable Fault Input 1 Filter Value
            FILTERVAL1: u4,
        }), base_address + 0x18);

        /// address: 0x4101601e
        /// Debug Control
        pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Debug Running Mode
            DBGRUN: u1,
            reserved0: u1,
            /// Fault Detection on Debug Break Detection
            FDDBD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x1e);

        /// address: 0x41016020
        /// Event Control
        pub const EVCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer/counter Input Event0 Action
            EVACT0: u3,
            /// Timer/counter Input Event1 Action
            EVACT1: u3,
            /// Timer/counter Output Event Mode
            CNTSEL: u2,
            /// Overflow/Underflow Output Event Enable
            OVFEO: u1,
            /// Retrigger Output Event Enable
            TRGEO: u1,
            /// Timer/counter Output Event Enable
            CNTEO: u1,
            reserved0: u1,
            /// Inverted Event 0 Input Enable
            TCINV0: u1,
            /// Inverted Event 1 Input Enable
            TCINV1: u1,
            /// Timer/counter Event 0 Input Enable
            TCEI0: u1,
            /// Timer/counter Event 1 Input Enable
            TCEI1: u1,
            /// Match or Capture Channel 0 Event Input Enable
            MCEI0: u1,
            /// Match or Capture Channel 1 Event Input Enable
            MCEI1: u1,
            /// Match or Capture Channel 2 Event Input Enable
            MCEI2: u1,
            /// Match or Capture Channel 3 Event Input Enable
            MCEI3: u1,
            /// Match or Capture Channel 4 Event Input Enable
            MCEI4: u1,
            /// Match or Capture Channel 5 Event Input Enable
            MCEI5: u1,
            reserved1: u1,
            reserved2: u1,
            /// Match or Capture Channel 0 Event Output Enable
            MCEO0: u1,
            /// Match or Capture Channel 1 Event Output Enable
            MCEO1: u1,
            /// Match or Capture Channel 2 Event Output Enable
            MCEO2: u1,
            /// Match or Capture Channel 3 Event Output Enable
            MCEO3: u1,
            /// Match or Capture Channel 4 Event Output Enable
            MCEO4: u1,
            /// Match or Capture Channel 5 Event Output Enable
            MCEO5: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x20);

        /// address: 0x41016024
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overflow Interrupt Enable
            OVF: u1,
            /// Retrigger Interrupt Enable
            TRG: u1,
            /// Counter Interrupt Enable
            CNT: u1,
            /// Error Interrupt Enable
            ERR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Non-Recoverable Update Fault Interrupt Enable
            UFS: u1,
            /// Non-Recoverable Debug Fault Interrupt Enable
            DFS: u1,
            /// Recoverable Fault A Interrupt Enable
            FAULTA: u1,
            /// Recoverable Fault B Interrupt Enable
            FAULTB: u1,
            /// Non-Recoverable Fault 0 Interrupt Enable
            FAULT0: u1,
            /// Non-Recoverable Fault 1 Interrupt Enable
            FAULT1: u1,
            /// Match or Capture Channel 0 Interrupt Enable
            MC0: u1,
            /// Match or Capture Channel 1 Interrupt Enable
            MC1: u1,
            /// Match or Capture Channel 2 Interrupt Enable
            MC2: u1,
            /// Match or Capture Channel 3 Interrupt Enable
            MC3: u1,
            /// Match or Capture Channel 4 Interrupt Enable
            MC4: u1,
            /// Match or Capture Channel 5 Interrupt Enable
            MC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x24);

        /// address: 0x41016028
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overflow Interrupt Enable
            OVF: u1,
            /// Retrigger Interrupt Enable
            TRG: u1,
            /// Counter Interrupt Enable
            CNT: u1,
            /// Error Interrupt Enable
            ERR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Non-Recoverable Update Fault Interrupt Enable
            UFS: u1,
            /// Non-Recoverable Debug Fault Interrupt Enable
            DFS: u1,
            /// Recoverable Fault A Interrupt Enable
            FAULTA: u1,
            /// Recoverable Fault B Interrupt Enable
            FAULTB: u1,
            /// Non-Recoverable Fault 0 Interrupt Enable
            FAULT0: u1,
            /// Non-Recoverable Fault 1 Interrupt Enable
            FAULT1: u1,
            /// Match or Capture Channel 0 Interrupt Enable
            MC0: u1,
            /// Match or Capture Channel 1 Interrupt Enable
            MC1: u1,
            /// Match or Capture Channel 2 Interrupt Enable
            MC2: u1,
            /// Match or Capture Channel 3 Interrupt Enable
            MC3: u1,
            /// Match or Capture Channel 4 Interrupt Enable
            MC4: u1,
            /// Match or Capture Channel 5 Interrupt Enable
            MC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x28);

        /// address: 0x4101602c
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overflow
            OVF: u1,
            /// Retrigger
            TRG: u1,
            /// Counter
            CNT: u1,
            /// Error
            ERR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Non-Recoverable Update Fault
            UFS: u1,
            /// Non-Recoverable Debug Fault
            DFS: u1,
            /// Recoverable Fault A
            FAULTA: u1,
            /// Recoverable Fault B
            FAULTB: u1,
            /// Non-Recoverable Fault 0
            FAULT0: u1,
            /// Non-Recoverable Fault 1
            FAULT1: u1,
            /// Match or Capture 0
            MC0: u1,
            /// Match or Capture 1
            MC1: u1,
            /// Match or Capture 2
            MC2: u1,
            /// Match or Capture 3
            MC3: u1,
            /// Match or Capture 4
            MC4: u1,
            /// Match or Capture 5
            MC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x2c);

        /// address: 0x41016030
        /// Status
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stop
            STOP: u1,
            /// Ramp
            IDX: u1,
            /// Non-recoverable Update Fault State
            UFS: u1,
            /// Non-Recoverable Debug Fault State
            DFS: u1,
            /// Slave
            SLAVE: u1,
            /// Pattern Buffer Valid
            PATTBUFV: u1,
            reserved0: u1,
            /// Period Buffer Valid
            PERBUFV: u1,
            /// Recoverable Fault A Input
            FAULTAIN: u1,
            /// Recoverable Fault B Input
            FAULTBIN: u1,
            /// Non-Recoverable Fault0 Input
            FAULT0IN: u1,
            /// Non-Recoverable Fault1 Input
            FAULT1IN: u1,
            /// Recoverable Fault A State
            FAULTA: u1,
            /// Recoverable Fault B State
            FAULTB: u1,
            /// Non-Recoverable Fault 0 State
            FAULT0: u1,
            /// Non-Recoverable Fault 1 State
            FAULT1: u1,
            /// Compare Channel 0 Buffer Valid
            CCBUFV0: u1,
            /// Compare Channel 1 Buffer Valid
            CCBUFV1: u1,
            /// Compare Channel 2 Buffer Valid
            CCBUFV2: u1,
            /// Compare Channel 3 Buffer Valid
            CCBUFV3: u1,
            /// Compare Channel 4 Buffer Valid
            CCBUFV4: u1,
            /// Compare Channel 5 Buffer Valid
            CCBUFV5: u1,
            reserved1: u1,
            reserved2: u1,
            /// Compare Channel 0 Value
            CMP0: u1,
            /// Compare Channel 1 Value
            CMP1: u1,
            /// Compare Channel 2 Value
            CMP2: u1,
            /// Compare Channel 3 Value
            CMP3: u1,
            /// Compare Channel 4 Value
            CMP4: u1,
            /// Compare Channel 5 Value
            CMP5: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x30);

        /// address: 0x41016034
        /// Count
        pub const COUNT = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x34);

        /// address: 0x41016034
        /// Count
        pub const COUNT_DITH4_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Counter Value
            COUNT: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x41016034
        /// Count
        pub const COUNT_DITH5_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Counter Value
            COUNT: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x41016034
        /// Count
        pub const COUNT_DITH6_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Counter Value
            COUNT: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x41016038
        /// Pattern
        pub const PATT = @intToPtr(*volatile Mmio(16, packed struct {
            /// Pattern Generator 0 Output Enable
            PGE0: u1,
            /// Pattern Generator 1 Output Enable
            PGE1: u1,
            /// Pattern Generator 2 Output Enable
            PGE2: u1,
            /// Pattern Generator 3 Output Enable
            PGE3: u1,
            /// Pattern Generator 4 Output Enable
            PGE4: u1,
            /// Pattern Generator 5 Output Enable
            PGE5: u1,
            /// Pattern Generator 6 Output Enable
            PGE6: u1,
            /// Pattern Generator 7 Output Enable
            PGE7: u1,
            /// Pattern Generator 0 Output Value
            PGV0: u1,
            /// Pattern Generator 1 Output Value
            PGV1: u1,
            /// Pattern Generator 2 Output Value
            PGV2: u1,
            /// Pattern Generator 3 Output Value
            PGV3: u1,
            /// Pattern Generator 4 Output Value
            PGV4: u1,
            /// Pattern Generator 5 Output Value
            PGV5: u1,
            /// Pattern Generator 6 Output Value
            PGV6: u1,
            /// Pattern Generator 7 Output Value
            PGV7: u1,
        }), base_address + 0x38);

        /// address: 0x4101603c
        /// Waveform Control
        pub const WAVE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Waveform Generation
            WAVEGEN: u3,
            reserved0: u1,
            /// Ramp Mode
            RAMP: u2,
            reserved1: u1,
            /// Circular period Enable
            CIPEREN: u1,
            /// Circular Channel 0 Enable
            CICCEN0: u1,
            /// Circular Channel 1 Enable
            CICCEN1: u1,
            /// Circular Channel 2 Enable
            CICCEN2: u1,
            /// Circular Channel 3 Enable
            CICCEN3: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Channel 0 Polarity
            POL0: u1,
            /// Channel 1 Polarity
            POL1: u1,
            /// Channel 2 Polarity
            POL2: u1,
            /// Channel 3 Polarity
            POL3: u1,
            /// Channel 4 Polarity
            POL4: u1,
            /// Channel 5 Polarity
            POL5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Swap DTI Output Pair 0
            SWAP0: u1,
            /// Swap DTI Output Pair 1
            SWAP1: u1,
            /// Swap DTI Output Pair 2
            SWAP2: u1,
            /// Swap DTI Output Pair 3
            SWAP3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x3c);

        /// address: 0x41016040
        /// Period
        pub const PER = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x40);

        /// address: 0x41016040
        /// Period
        pub const PER_DITH4_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u4,
            /// Period Value
            PER: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x41016040
        /// Period
        pub const PER_DITH5_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u5,
            /// Period Value
            PER: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x41016040
        /// Period
        pub const PER_DITH6_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u6,
            /// Period Value
            PER: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x41016044
        /// Compare and Capture
        pub const CC = @intToPtr(*volatile [6]MmioInt(32, u24), base_address + 0x44);

        /// address: 0x41016044
        /// Compare and Capture
        pub const CC_DITH4_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u4,
            /// Channel Compare/Capture Value
            CC: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x44);

        /// address: 0x41016044
        /// Compare and Capture
        pub const CC_DITH5_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u5,
            /// Channel Compare/Capture Value
            CC: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x44);

        /// address: 0x41016044
        /// Compare and Capture
        pub const CC_DITH6_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u6,
            /// Channel Compare/Capture Value
            CC: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x44);

        /// address: 0x41016064
        /// Pattern Buffer
        pub const PATTBUF = @intToPtr(*volatile Mmio(16, packed struct {
            /// Pattern Generator 0 Output Enable Buffer
            PGEB0: u1,
            /// Pattern Generator 1 Output Enable Buffer
            PGEB1: u1,
            /// Pattern Generator 2 Output Enable Buffer
            PGEB2: u1,
            /// Pattern Generator 3 Output Enable Buffer
            PGEB3: u1,
            /// Pattern Generator 4 Output Enable Buffer
            PGEB4: u1,
            /// Pattern Generator 5 Output Enable Buffer
            PGEB5: u1,
            /// Pattern Generator 6 Output Enable Buffer
            PGEB6: u1,
            /// Pattern Generator 7 Output Enable Buffer
            PGEB7: u1,
            /// Pattern Generator 0 Output Enable
            PGVB0: u1,
            /// Pattern Generator 1 Output Enable
            PGVB1: u1,
            /// Pattern Generator 2 Output Enable
            PGVB2: u1,
            /// Pattern Generator 3 Output Enable
            PGVB3: u1,
            /// Pattern Generator 4 Output Enable
            PGVB4: u1,
            /// Pattern Generator 5 Output Enable
            PGVB5: u1,
            /// Pattern Generator 6 Output Enable
            PGVB6: u1,
            /// Pattern Generator 7 Output Enable
            PGVB7: u1,
        }), base_address + 0x64);

        /// address: 0x4101606c
        /// Period Buffer
        pub const PERBUF = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x6c);

        /// address: 0x4101606c
        /// Period Buffer
        pub const PERBUF_DITH4_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u4,
            /// Period Buffer Value
            PERBUF: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x4101606c
        /// Period Buffer
        pub const PERBUF_DITH5_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u5,
            /// Period Buffer Value
            PERBUF: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x4101606c
        /// Period Buffer
        pub const PERBUF_DITH6_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u6,
            /// Period Buffer Value
            PERBUF: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x41016070
        /// Compare and Capture Buffer
        pub const CCBUF = @intToPtr(*volatile [6]MmioInt(32, u24), base_address + 0x70);

        /// address: 0x41016070
        /// Compare and Capture Buffer
        pub const CCBUF_DITH4_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Channel Compare/Capture Buffer Value
            CCBUF: u4,
            /// Dithering Buffer Cycle Number
            DITHERBUF: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x70);

        /// address: 0x41016070
        /// Compare and Capture Buffer
        pub const CCBUF_DITH5_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u5,
            /// Channel Compare/Capture Buffer Value
            CCBUF: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x70);

        /// address: 0x41016070
        /// Compare and Capture Buffer
        pub const CCBUF_DITH6_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u6,
            /// Channel Compare/Capture Buffer Value
            CCBUF: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x70);
    };
    pub const TCC1 = struct {
        pub const base_address = 0x41018000;

        /// address: 0x41018000
        /// Control A
        pub const CTRLA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Reset
            SWRST: u1,
            /// Enable
            ENABLE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Enhanced Resolution
            RESOLUTION: u2,
            reserved3: u1,
            /// Prescaler
            PRESCALER: u3,
            /// Run in Standby
            RUNSTDBY: u1,
            /// Prescaler and Counter Synchronization Selection
            PRESCSYNC: u2,
            /// Auto Lock
            ALOCK: u1,
            /// Master Synchronization (only for TCC Slave Instance)
            MSYNC: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// DMA One-shot Trigger Mode
            DMAOS: u1,
            /// Capture Channel 0 Enable
            CPTEN0: u1,
            /// Capture Channel 1 Enable
            CPTEN1: u1,
            /// Capture Channel 2 Enable
            CPTEN2: u1,
            /// Capture Channel 3 Enable
            CPTEN3: u1,
            /// Capture Channel 4 Enable
            CPTEN4: u1,
            /// Capture Channel 5 Enable
            CPTEN5: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x0);

        /// address: 0x41018004
        /// Control B Clear
        pub const CTRLBCLR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Counter Direction
            DIR: u1,
            /// Lock Update
            LUPD: u1,
            /// One-Shot
            ONESHOT: u1,
            /// Ramp Index Command
            IDXCMD: u2,
            /// TCC Command
            CMD: u3,
        }), base_address + 0x4);

        /// address: 0x41018005
        /// Control B Set
        pub const CTRLBSET = @intToPtr(*volatile Mmio(8, packed struct {
            /// Counter Direction
            DIR: u1,
            /// Lock Update
            LUPD: u1,
            /// One-Shot
            ONESHOT: u1,
            /// Ramp Index Command
            IDXCMD: u2,
            /// TCC Command
            CMD: u3,
        }), base_address + 0x5);

        /// address: 0x41018008
        /// Synchronization Busy
        pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Swrst Busy
            SWRST: u1,
            /// Enable Busy
            ENABLE: u1,
            /// Ctrlb Busy
            CTRLB: u1,
            /// Status Busy
            STATUS: u1,
            /// Count Busy
            COUNT: u1,
            /// Pattern Busy
            PATT: u1,
            /// Wave Busy
            WAVE: u1,
            /// Period Busy
            PER: u1,
            /// Compare Channel 0 Busy
            CC0: u1,
            /// Compare Channel 1 Busy
            CC1: u1,
            /// Compare Channel 2 Busy
            CC2: u1,
            /// Compare Channel 3 Busy
            CC3: u1,
            /// Compare Channel 4 Busy
            CC4: u1,
            /// Compare Channel 5 Busy
            CC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x8);

        /// address: 0x4101800c
        /// Recoverable Fault A Configuration
        pub const FCTRLA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fault A Source
            SRC: u2,
            reserved0: u1,
            /// Fault A Keeper
            KEEP: u1,
            /// Fault A Qualification
            QUAL: u1,
            /// Fault A Blanking Mode
            BLANK: u2,
            /// Fault A Restart
            RESTART: u1,
            /// Fault A Halt Mode
            HALT: u2,
            /// Fault A Capture Channel
            CHSEL: u2,
            /// Fault A Capture Action
            CAPTURE: u3,
            /// Fault A Blanking Prescaler
            BLANKPRESC: u1,
            /// Fault A Blanking Time
            BLANKVAL: u8,
            /// Fault A Filter Value
            FILTERVAL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xc);

        /// address: 0x41018010
        /// Recoverable Fault B Configuration
        pub const FCTRLB = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fault B Source
            SRC: u2,
            reserved0: u1,
            /// Fault B Keeper
            KEEP: u1,
            /// Fault B Qualification
            QUAL: u1,
            /// Fault B Blanking Mode
            BLANK: u2,
            /// Fault B Restart
            RESTART: u1,
            /// Fault B Halt Mode
            HALT: u2,
            /// Fault B Capture Channel
            CHSEL: u2,
            /// Fault B Capture Action
            CAPTURE: u3,
            /// Fault B Blanking Prescaler
            BLANKPRESC: u1,
            /// Fault B Blanking Time
            BLANKVAL: u8,
            /// Fault B Filter Value
            FILTERVAL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x10);

        /// address: 0x41018014
        /// Waveform Extension Configuration
        pub const WEXCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output Matrix
            OTMX: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Dead-time Insertion Generator 0 Enable
            DTIEN0: u1,
            /// Dead-time Insertion Generator 1 Enable
            DTIEN1: u1,
            /// Dead-time Insertion Generator 2 Enable
            DTIEN2: u1,
            /// Dead-time Insertion Generator 3 Enable
            DTIEN3: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Dead-time Low Side Outputs Value
            DTLS: u8,
            /// Dead-time High Side Outputs Value
            DTHS: u8,
        }), base_address + 0x14);

        /// address: 0x41018018
        /// Driver Control
        pub const DRVCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Non-Recoverable State 0 Output Enable
            NRE0: u1,
            /// Non-Recoverable State 1 Output Enable
            NRE1: u1,
            /// Non-Recoverable State 2 Output Enable
            NRE2: u1,
            /// Non-Recoverable State 3 Output Enable
            NRE3: u1,
            /// Non-Recoverable State 4 Output Enable
            NRE4: u1,
            /// Non-Recoverable State 5 Output Enable
            NRE5: u1,
            /// Non-Recoverable State 6 Output Enable
            NRE6: u1,
            /// Non-Recoverable State 7 Output Enable
            NRE7: u1,
            /// Non-Recoverable State 0 Output Value
            NRV0: u1,
            /// Non-Recoverable State 1 Output Value
            NRV1: u1,
            /// Non-Recoverable State 2 Output Value
            NRV2: u1,
            /// Non-Recoverable State 3 Output Value
            NRV3: u1,
            /// Non-Recoverable State 4 Output Value
            NRV4: u1,
            /// Non-Recoverable State 5 Output Value
            NRV5: u1,
            /// Non-Recoverable State 6 Output Value
            NRV6: u1,
            /// Non-Recoverable State 7 Output Value
            NRV7: u1,
            /// Output Waveform 0 Inversion
            INVEN0: u1,
            /// Output Waveform 1 Inversion
            INVEN1: u1,
            /// Output Waveform 2 Inversion
            INVEN2: u1,
            /// Output Waveform 3 Inversion
            INVEN3: u1,
            /// Output Waveform 4 Inversion
            INVEN4: u1,
            /// Output Waveform 5 Inversion
            INVEN5: u1,
            /// Output Waveform 6 Inversion
            INVEN6: u1,
            /// Output Waveform 7 Inversion
            INVEN7: u1,
            /// Non-Recoverable Fault Input 0 Filter Value
            FILTERVAL0: u4,
            /// Non-Recoverable Fault Input 1 Filter Value
            FILTERVAL1: u4,
        }), base_address + 0x18);

        /// address: 0x4101801e
        /// Debug Control
        pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Debug Running Mode
            DBGRUN: u1,
            reserved0: u1,
            /// Fault Detection on Debug Break Detection
            FDDBD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x1e);

        /// address: 0x41018020
        /// Event Control
        pub const EVCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer/counter Input Event0 Action
            EVACT0: u3,
            /// Timer/counter Input Event1 Action
            EVACT1: u3,
            /// Timer/counter Output Event Mode
            CNTSEL: u2,
            /// Overflow/Underflow Output Event Enable
            OVFEO: u1,
            /// Retrigger Output Event Enable
            TRGEO: u1,
            /// Timer/counter Output Event Enable
            CNTEO: u1,
            reserved0: u1,
            /// Inverted Event 0 Input Enable
            TCINV0: u1,
            /// Inverted Event 1 Input Enable
            TCINV1: u1,
            /// Timer/counter Event 0 Input Enable
            TCEI0: u1,
            /// Timer/counter Event 1 Input Enable
            TCEI1: u1,
            /// Match or Capture Channel 0 Event Input Enable
            MCEI0: u1,
            /// Match or Capture Channel 1 Event Input Enable
            MCEI1: u1,
            /// Match or Capture Channel 2 Event Input Enable
            MCEI2: u1,
            /// Match or Capture Channel 3 Event Input Enable
            MCEI3: u1,
            /// Match or Capture Channel 4 Event Input Enable
            MCEI4: u1,
            /// Match or Capture Channel 5 Event Input Enable
            MCEI5: u1,
            reserved1: u1,
            reserved2: u1,
            /// Match or Capture Channel 0 Event Output Enable
            MCEO0: u1,
            /// Match or Capture Channel 1 Event Output Enable
            MCEO1: u1,
            /// Match or Capture Channel 2 Event Output Enable
            MCEO2: u1,
            /// Match or Capture Channel 3 Event Output Enable
            MCEO3: u1,
            /// Match or Capture Channel 4 Event Output Enable
            MCEO4: u1,
            /// Match or Capture Channel 5 Event Output Enable
            MCEO5: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x20);

        /// address: 0x41018024
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overflow Interrupt Enable
            OVF: u1,
            /// Retrigger Interrupt Enable
            TRG: u1,
            /// Counter Interrupt Enable
            CNT: u1,
            /// Error Interrupt Enable
            ERR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Non-Recoverable Update Fault Interrupt Enable
            UFS: u1,
            /// Non-Recoverable Debug Fault Interrupt Enable
            DFS: u1,
            /// Recoverable Fault A Interrupt Enable
            FAULTA: u1,
            /// Recoverable Fault B Interrupt Enable
            FAULTB: u1,
            /// Non-Recoverable Fault 0 Interrupt Enable
            FAULT0: u1,
            /// Non-Recoverable Fault 1 Interrupt Enable
            FAULT1: u1,
            /// Match or Capture Channel 0 Interrupt Enable
            MC0: u1,
            /// Match or Capture Channel 1 Interrupt Enable
            MC1: u1,
            /// Match or Capture Channel 2 Interrupt Enable
            MC2: u1,
            /// Match or Capture Channel 3 Interrupt Enable
            MC3: u1,
            /// Match or Capture Channel 4 Interrupt Enable
            MC4: u1,
            /// Match or Capture Channel 5 Interrupt Enable
            MC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x24);

        /// address: 0x41018028
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overflow Interrupt Enable
            OVF: u1,
            /// Retrigger Interrupt Enable
            TRG: u1,
            /// Counter Interrupt Enable
            CNT: u1,
            /// Error Interrupt Enable
            ERR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Non-Recoverable Update Fault Interrupt Enable
            UFS: u1,
            /// Non-Recoverable Debug Fault Interrupt Enable
            DFS: u1,
            /// Recoverable Fault A Interrupt Enable
            FAULTA: u1,
            /// Recoverable Fault B Interrupt Enable
            FAULTB: u1,
            /// Non-Recoverable Fault 0 Interrupt Enable
            FAULT0: u1,
            /// Non-Recoverable Fault 1 Interrupt Enable
            FAULT1: u1,
            /// Match or Capture Channel 0 Interrupt Enable
            MC0: u1,
            /// Match or Capture Channel 1 Interrupt Enable
            MC1: u1,
            /// Match or Capture Channel 2 Interrupt Enable
            MC2: u1,
            /// Match or Capture Channel 3 Interrupt Enable
            MC3: u1,
            /// Match or Capture Channel 4 Interrupt Enable
            MC4: u1,
            /// Match or Capture Channel 5 Interrupt Enable
            MC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x28);

        /// address: 0x4101802c
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overflow
            OVF: u1,
            /// Retrigger
            TRG: u1,
            /// Counter
            CNT: u1,
            /// Error
            ERR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Non-Recoverable Update Fault
            UFS: u1,
            /// Non-Recoverable Debug Fault
            DFS: u1,
            /// Recoverable Fault A
            FAULTA: u1,
            /// Recoverable Fault B
            FAULTB: u1,
            /// Non-Recoverable Fault 0
            FAULT0: u1,
            /// Non-Recoverable Fault 1
            FAULT1: u1,
            /// Match or Capture 0
            MC0: u1,
            /// Match or Capture 1
            MC1: u1,
            /// Match or Capture 2
            MC2: u1,
            /// Match or Capture 3
            MC3: u1,
            /// Match or Capture 4
            MC4: u1,
            /// Match or Capture 5
            MC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x2c);

        /// address: 0x41018030
        /// Status
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stop
            STOP: u1,
            /// Ramp
            IDX: u1,
            /// Non-recoverable Update Fault State
            UFS: u1,
            /// Non-Recoverable Debug Fault State
            DFS: u1,
            /// Slave
            SLAVE: u1,
            /// Pattern Buffer Valid
            PATTBUFV: u1,
            reserved0: u1,
            /// Period Buffer Valid
            PERBUFV: u1,
            /// Recoverable Fault A Input
            FAULTAIN: u1,
            /// Recoverable Fault B Input
            FAULTBIN: u1,
            /// Non-Recoverable Fault0 Input
            FAULT0IN: u1,
            /// Non-Recoverable Fault1 Input
            FAULT1IN: u1,
            /// Recoverable Fault A State
            FAULTA: u1,
            /// Recoverable Fault B State
            FAULTB: u1,
            /// Non-Recoverable Fault 0 State
            FAULT0: u1,
            /// Non-Recoverable Fault 1 State
            FAULT1: u1,
            /// Compare Channel 0 Buffer Valid
            CCBUFV0: u1,
            /// Compare Channel 1 Buffer Valid
            CCBUFV1: u1,
            /// Compare Channel 2 Buffer Valid
            CCBUFV2: u1,
            /// Compare Channel 3 Buffer Valid
            CCBUFV3: u1,
            /// Compare Channel 4 Buffer Valid
            CCBUFV4: u1,
            /// Compare Channel 5 Buffer Valid
            CCBUFV5: u1,
            reserved1: u1,
            reserved2: u1,
            /// Compare Channel 0 Value
            CMP0: u1,
            /// Compare Channel 1 Value
            CMP1: u1,
            /// Compare Channel 2 Value
            CMP2: u1,
            /// Compare Channel 3 Value
            CMP3: u1,
            /// Compare Channel 4 Value
            CMP4: u1,
            /// Compare Channel 5 Value
            CMP5: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x30);

        /// address: 0x41018034
        /// Count
        pub const COUNT = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x34);

        /// address: 0x41018034
        /// Count
        pub const COUNT_DITH4_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Counter Value
            COUNT: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x41018034
        /// Count
        pub const COUNT_DITH5_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Counter Value
            COUNT: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x41018034
        /// Count
        pub const COUNT_DITH6_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Counter Value
            COUNT: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x41018038
        /// Pattern
        pub const PATT = @intToPtr(*volatile Mmio(16, packed struct {
            /// Pattern Generator 0 Output Enable
            PGE0: u1,
            /// Pattern Generator 1 Output Enable
            PGE1: u1,
            /// Pattern Generator 2 Output Enable
            PGE2: u1,
            /// Pattern Generator 3 Output Enable
            PGE3: u1,
            /// Pattern Generator 4 Output Enable
            PGE4: u1,
            /// Pattern Generator 5 Output Enable
            PGE5: u1,
            /// Pattern Generator 6 Output Enable
            PGE6: u1,
            /// Pattern Generator 7 Output Enable
            PGE7: u1,
            /// Pattern Generator 0 Output Value
            PGV0: u1,
            /// Pattern Generator 1 Output Value
            PGV1: u1,
            /// Pattern Generator 2 Output Value
            PGV2: u1,
            /// Pattern Generator 3 Output Value
            PGV3: u1,
            /// Pattern Generator 4 Output Value
            PGV4: u1,
            /// Pattern Generator 5 Output Value
            PGV5: u1,
            /// Pattern Generator 6 Output Value
            PGV6: u1,
            /// Pattern Generator 7 Output Value
            PGV7: u1,
        }), base_address + 0x38);

        /// address: 0x4101803c
        /// Waveform Control
        pub const WAVE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Waveform Generation
            WAVEGEN: u3,
            reserved0: u1,
            /// Ramp Mode
            RAMP: u2,
            reserved1: u1,
            /// Circular period Enable
            CIPEREN: u1,
            /// Circular Channel 0 Enable
            CICCEN0: u1,
            /// Circular Channel 1 Enable
            CICCEN1: u1,
            /// Circular Channel 2 Enable
            CICCEN2: u1,
            /// Circular Channel 3 Enable
            CICCEN3: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Channel 0 Polarity
            POL0: u1,
            /// Channel 1 Polarity
            POL1: u1,
            /// Channel 2 Polarity
            POL2: u1,
            /// Channel 3 Polarity
            POL3: u1,
            /// Channel 4 Polarity
            POL4: u1,
            /// Channel 5 Polarity
            POL5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Swap DTI Output Pair 0
            SWAP0: u1,
            /// Swap DTI Output Pair 1
            SWAP1: u1,
            /// Swap DTI Output Pair 2
            SWAP2: u1,
            /// Swap DTI Output Pair 3
            SWAP3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x3c);

        /// address: 0x41018040
        /// Period
        pub const PER = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x40);

        /// address: 0x41018040
        /// Period
        pub const PER_DITH4_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u4,
            /// Period Value
            PER: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x41018040
        /// Period
        pub const PER_DITH5_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u5,
            /// Period Value
            PER: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x41018040
        /// Period
        pub const PER_DITH6_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u6,
            /// Period Value
            PER: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x41018044
        /// Compare and Capture
        pub const CC = @intToPtr(*volatile [6]MmioInt(32, u24), base_address + 0x44);

        /// address: 0x41018044
        /// Compare and Capture
        pub const CC_DITH4_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u4,
            /// Channel Compare/Capture Value
            CC: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x44);

        /// address: 0x41018044
        /// Compare and Capture
        pub const CC_DITH5_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u5,
            /// Channel Compare/Capture Value
            CC: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x44);

        /// address: 0x41018044
        /// Compare and Capture
        pub const CC_DITH6_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u6,
            /// Channel Compare/Capture Value
            CC: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x44);

        /// address: 0x41018064
        /// Pattern Buffer
        pub const PATTBUF = @intToPtr(*volatile Mmio(16, packed struct {
            /// Pattern Generator 0 Output Enable Buffer
            PGEB0: u1,
            /// Pattern Generator 1 Output Enable Buffer
            PGEB1: u1,
            /// Pattern Generator 2 Output Enable Buffer
            PGEB2: u1,
            /// Pattern Generator 3 Output Enable Buffer
            PGEB3: u1,
            /// Pattern Generator 4 Output Enable Buffer
            PGEB4: u1,
            /// Pattern Generator 5 Output Enable Buffer
            PGEB5: u1,
            /// Pattern Generator 6 Output Enable Buffer
            PGEB6: u1,
            /// Pattern Generator 7 Output Enable Buffer
            PGEB7: u1,
            /// Pattern Generator 0 Output Enable
            PGVB0: u1,
            /// Pattern Generator 1 Output Enable
            PGVB1: u1,
            /// Pattern Generator 2 Output Enable
            PGVB2: u1,
            /// Pattern Generator 3 Output Enable
            PGVB3: u1,
            /// Pattern Generator 4 Output Enable
            PGVB4: u1,
            /// Pattern Generator 5 Output Enable
            PGVB5: u1,
            /// Pattern Generator 6 Output Enable
            PGVB6: u1,
            /// Pattern Generator 7 Output Enable
            PGVB7: u1,
        }), base_address + 0x64);

        /// address: 0x4101806c
        /// Period Buffer
        pub const PERBUF = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x6c);

        /// address: 0x4101806c
        /// Period Buffer
        pub const PERBUF_DITH4_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u4,
            /// Period Buffer Value
            PERBUF: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x4101806c
        /// Period Buffer
        pub const PERBUF_DITH5_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u5,
            /// Period Buffer Value
            PERBUF: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x4101806c
        /// Period Buffer
        pub const PERBUF_DITH6_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u6,
            /// Period Buffer Value
            PERBUF: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x41018070
        /// Compare and Capture Buffer
        pub const CCBUF = @intToPtr(*volatile [6]MmioInt(32, u24), base_address + 0x70);

        /// address: 0x41018070
        /// Compare and Capture Buffer
        pub const CCBUF_DITH4_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Channel Compare/Capture Buffer Value
            CCBUF: u4,
            /// Dithering Buffer Cycle Number
            DITHERBUF: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x70);

        /// address: 0x41018070
        /// Compare and Capture Buffer
        pub const CCBUF_DITH5_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u5,
            /// Channel Compare/Capture Buffer Value
            CCBUF: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x70);

        /// address: 0x41018070
        /// Compare and Capture Buffer
        pub const CCBUF_DITH6_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u6,
            /// Channel Compare/Capture Buffer Value
            CCBUF: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x70);
    };
    pub const TCC2 = struct {
        pub const base_address = 0x42000c00;

        /// address: 0x42000c00
        /// Control A
        pub const CTRLA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Reset
            SWRST: u1,
            /// Enable
            ENABLE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Enhanced Resolution
            RESOLUTION: u2,
            reserved3: u1,
            /// Prescaler
            PRESCALER: u3,
            /// Run in Standby
            RUNSTDBY: u1,
            /// Prescaler and Counter Synchronization Selection
            PRESCSYNC: u2,
            /// Auto Lock
            ALOCK: u1,
            /// Master Synchronization (only for TCC Slave Instance)
            MSYNC: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// DMA One-shot Trigger Mode
            DMAOS: u1,
            /// Capture Channel 0 Enable
            CPTEN0: u1,
            /// Capture Channel 1 Enable
            CPTEN1: u1,
            /// Capture Channel 2 Enable
            CPTEN2: u1,
            /// Capture Channel 3 Enable
            CPTEN3: u1,
            /// Capture Channel 4 Enable
            CPTEN4: u1,
            /// Capture Channel 5 Enable
            CPTEN5: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x0);

        /// address: 0x42000c04
        /// Control B Clear
        pub const CTRLBCLR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Counter Direction
            DIR: u1,
            /// Lock Update
            LUPD: u1,
            /// One-Shot
            ONESHOT: u1,
            /// Ramp Index Command
            IDXCMD: u2,
            /// TCC Command
            CMD: u3,
        }), base_address + 0x4);

        /// address: 0x42000c05
        /// Control B Set
        pub const CTRLBSET = @intToPtr(*volatile Mmio(8, packed struct {
            /// Counter Direction
            DIR: u1,
            /// Lock Update
            LUPD: u1,
            /// One-Shot
            ONESHOT: u1,
            /// Ramp Index Command
            IDXCMD: u2,
            /// TCC Command
            CMD: u3,
        }), base_address + 0x5);

        /// address: 0x42000c08
        /// Synchronization Busy
        pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Swrst Busy
            SWRST: u1,
            /// Enable Busy
            ENABLE: u1,
            /// Ctrlb Busy
            CTRLB: u1,
            /// Status Busy
            STATUS: u1,
            /// Count Busy
            COUNT: u1,
            /// Pattern Busy
            PATT: u1,
            /// Wave Busy
            WAVE: u1,
            /// Period Busy
            PER: u1,
            /// Compare Channel 0 Busy
            CC0: u1,
            /// Compare Channel 1 Busy
            CC1: u1,
            /// Compare Channel 2 Busy
            CC2: u1,
            /// Compare Channel 3 Busy
            CC3: u1,
            /// Compare Channel 4 Busy
            CC4: u1,
            /// Compare Channel 5 Busy
            CC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x8);

        /// address: 0x42000c0c
        /// Recoverable Fault A Configuration
        pub const FCTRLA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fault A Source
            SRC: u2,
            reserved0: u1,
            /// Fault A Keeper
            KEEP: u1,
            /// Fault A Qualification
            QUAL: u1,
            /// Fault A Blanking Mode
            BLANK: u2,
            /// Fault A Restart
            RESTART: u1,
            /// Fault A Halt Mode
            HALT: u2,
            /// Fault A Capture Channel
            CHSEL: u2,
            /// Fault A Capture Action
            CAPTURE: u3,
            /// Fault A Blanking Prescaler
            BLANKPRESC: u1,
            /// Fault A Blanking Time
            BLANKVAL: u8,
            /// Fault A Filter Value
            FILTERVAL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xc);

        /// address: 0x42000c10
        /// Recoverable Fault B Configuration
        pub const FCTRLB = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fault B Source
            SRC: u2,
            reserved0: u1,
            /// Fault B Keeper
            KEEP: u1,
            /// Fault B Qualification
            QUAL: u1,
            /// Fault B Blanking Mode
            BLANK: u2,
            /// Fault B Restart
            RESTART: u1,
            /// Fault B Halt Mode
            HALT: u2,
            /// Fault B Capture Channel
            CHSEL: u2,
            /// Fault B Capture Action
            CAPTURE: u3,
            /// Fault B Blanking Prescaler
            BLANKPRESC: u1,
            /// Fault B Blanking Time
            BLANKVAL: u8,
            /// Fault B Filter Value
            FILTERVAL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x10);

        /// address: 0x42000c14
        /// Waveform Extension Configuration
        pub const WEXCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output Matrix
            OTMX: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Dead-time Insertion Generator 0 Enable
            DTIEN0: u1,
            /// Dead-time Insertion Generator 1 Enable
            DTIEN1: u1,
            /// Dead-time Insertion Generator 2 Enable
            DTIEN2: u1,
            /// Dead-time Insertion Generator 3 Enable
            DTIEN3: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Dead-time Low Side Outputs Value
            DTLS: u8,
            /// Dead-time High Side Outputs Value
            DTHS: u8,
        }), base_address + 0x14);

        /// address: 0x42000c18
        /// Driver Control
        pub const DRVCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Non-Recoverable State 0 Output Enable
            NRE0: u1,
            /// Non-Recoverable State 1 Output Enable
            NRE1: u1,
            /// Non-Recoverable State 2 Output Enable
            NRE2: u1,
            /// Non-Recoverable State 3 Output Enable
            NRE3: u1,
            /// Non-Recoverable State 4 Output Enable
            NRE4: u1,
            /// Non-Recoverable State 5 Output Enable
            NRE5: u1,
            /// Non-Recoverable State 6 Output Enable
            NRE6: u1,
            /// Non-Recoverable State 7 Output Enable
            NRE7: u1,
            /// Non-Recoverable State 0 Output Value
            NRV0: u1,
            /// Non-Recoverable State 1 Output Value
            NRV1: u1,
            /// Non-Recoverable State 2 Output Value
            NRV2: u1,
            /// Non-Recoverable State 3 Output Value
            NRV3: u1,
            /// Non-Recoverable State 4 Output Value
            NRV4: u1,
            /// Non-Recoverable State 5 Output Value
            NRV5: u1,
            /// Non-Recoverable State 6 Output Value
            NRV6: u1,
            /// Non-Recoverable State 7 Output Value
            NRV7: u1,
            /// Output Waveform 0 Inversion
            INVEN0: u1,
            /// Output Waveform 1 Inversion
            INVEN1: u1,
            /// Output Waveform 2 Inversion
            INVEN2: u1,
            /// Output Waveform 3 Inversion
            INVEN3: u1,
            /// Output Waveform 4 Inversion
            INVEN4: u1,
            /// Output Waveform 5 Inversion
            INVEN5: u1,
            /// Output Waveform 6 Inversion
            INVEN6: u1,
            /// Output Waveform 7 Inversion
            INVEN7: u1,
            /// Non-Recoverable Fault Input 0 Filter Value
            FILTERVAL0: u4,
            /// Non-Recoverable Fault Input 1 Filter Value
            FILTERVAL1: u4,
        }), base_address + 0x18);

        /// address: 0x42000c1e
        /// Debug Control
        pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Debug Running Mode
            DBGRUN: u1,
            reserved0: u1,
            /// Fault Detection on Debug Break Detection
            FDDBD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x1e);

        /// address: 0x42000c20
        /// Event Control
        pub const EVCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer/counter Input Event0 Action
            EVACT0: u3,
            /// Timer/counter Input Event1 Action
            EVACT1: u3,
            /// Timer/counter Output Event Mode
            CNTSEL: u2,
            /// Overflow/Underflow Output Event Enable
            OVFEO: u1,
            /// Retrigger Output Event Enable
            TRGEO: u1,
            /// Timer/counter Output Event Enable
            CNTEO: u1,
            reserved0: u1,
            /// Inverted Event 0 Input Enable
            TCINV0: u1,
            /// Inverted Event 1 Input Enable
            TCINV1: u1,
            /// Timer/counter Event 0 Input Enable
            TCEI0: u1,
            /// Timer/counter Event 1 Input Enable
            TCEI1: u1,
            /// Match or Capture Channel 0 Event Input Enable
            MCEI0: u1,
            /// Match or Capture Channel 1 Event Input Enable
            MCEI1: u1,
            /// Match or Capture Channel 2 Event Input Enable
            MCEI2: u1,
            /// Match or Capture Channel 3 Event Input Enable
            MCEI3: u1,
            /// Match or Capture Channel 4 Event Input Enable
            MCEI4: u1,
            /// Match or Capture Channel 5 Event Input Enable
            MCEI5: u1,
            reserved1: u1,
            reserved2: u1,
            /// Match or Capture Channel 0 Event Output Enable
            MCEO0: u1,
            /// Match or Capture Channel 1 Event Output Enable
            MCEO1: u1,
            /// Match or Capture Channel 2 Event Output Enable
            MCEO2: u1,
            /// Match or Capture Channel 3 Event Output Enable
            MCEO3: u1,
            /// Match or Capture Channel 4 Event Output Enable
            MCEO4: u1,
            /// Match or Capture Channel 5 Event Output Enable
            MCEO5: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x20);

        /// address: 0x42000c24
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overflow Interrupt Enable
            OVF: u1,
            /// Retrigger Interrupt Enable
            TRG: u1,
            /// Counter Interrupt Enable
            CNT: u1,
            /// Error Interrupt Enable
            ERR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Non-Recoverable Update Fault Interrupt Enable
            UFS: u1,
            /// Non-Recoverable Debug Fault Interrupt Enable
            DFS: u1,
            /// Recoverable Fault A Interrupt Enable
            FAULTA: u1,
            /// Recoverable Fault B Interrupt Enable
            FAULTB: u1,
            /// Non-Recoverable Fault 0 Interrupt Enable
            FAULT0: u1,
            /// Non-Recoverable Fault 1 Interrupt Enable
            FAULT1: u1,
            /// Match or Capture Channel 0 Interrupt Enable
            MC0: u1,
            /// Match or Capture Channel 1 Interrupt Enable
            MC1: u1,
            /// Match or Capture Channel 2 Interrupt Enable
            MC2: u1,
            /// Match or Capture Channel 3 Interrupt Enable
            MC3: u1,
            /// Match or Capture Channel 4 Interrupt Enable
            MC4: u1,
            /// Match or Capture Channel 5 Interrupt Enable
            MC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x24);

        /// address: 0x42000c28
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overflow Interrupt Enable
            OVF: u1,
            /// Retrigger Interrupt Enable
            TRG: u1,
            /// Counter Interrupt Enable
            CNT: u1,
            /// Error Interrupt Enable
            ERR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Non-Recoverable Update Fault Interrupt Enable
            UFS: u1,
            /// Non-Recoverable Debug Fault Interrupt Enable
            DFS: u1,
            /// Recoverable Fault A Interrupt Enable
            FAULTA: u1,
            /// Recoverable Fault B Interrupt Enable
            FAULTB: u1,
            /// Non-Recoverable Fault 0 Interrupt Enable
            FAULT0: u1,
            /// Non-Recoverable Fault 1 Interrupt Enable
            FAULT1: u1,
            /// Match or Capture Channel 0 Interrupt Enable
            MC0: u1,
            /// Match or Capture Channel 1 Interrupt Enable
            MC1: u1,
            /// Match or Capture Channel 2 Interrupt Enable
            MC2: u1,
            /// Match or Capture Channel 3 Interrupt Enable
            MC3: u1,
            /// Match or Capture Channel 4 Interrupt Enable
            MC4: u1,
            /// Match or Capture Channel 5 Interrupt Enable
            MC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x28);

        /// address: 0x42000c2c
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overflow
            OVF: u1,
            /// Retrigger
            TRG: u1,
            /// Counter
            CNT: u1,
            /// Error
            ERR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Non-Recoverable Update Fault
            UFS: u1,
            /// Non-Recoverable Debug Fault
            DFS: u1,
            /// Recoverable Fault A
            FAULTA: u1,
            /// Recoverable Fault B
            FAULTB: u1,
            /// Non-Recoverable Fault 0
            FAULT0: u1,
            /// Non-Recoverable Fault 1
            FAULT1: u1,
            /// Match or Capture 0
            MC0: u1,
            /// Match or Capture 1
            MC1: u1,
            /// Match or Capture 2
            MC2: u1,
            /// Match or Capture 3
            MC3: u1,
            /// Match or Capture 4
            MC4: u1,
            /// Match or Capture 5
            MC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x2c);

        /// address: 0x42000c30
        /// Status
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stop
            STOP: u1,
            /// Ramp
            IDX: u1,
            /// Non-recoverable Update Fault State
            UFS: u1,
            /// Non-Recoverable Debug Fault State
            DFS: u1,
            /// Slave
            SLAVE: u1,
            /// Pattern Buffer Valid
            PATTBUFV: u1,
            reserved0: u1,
            /// Period Buffer Valid
            PERBUFV: u1,
            /// Recoverable Fault A Input
            FAULTAIN: u1,
            /// Recoverable Fault B Input
            FAULTBIN: u1,
            /// Non-Recoverable Fault0 Input
            FAULT0IN: u1,
            /// Non-Recoverable Fault1 Input
            FAULT1IN: u1,
            /// Recoverable Fault A State
            FAULTA: u1,
            /// Recoverable Fault B State
            FAULTB: u1,
            /// Non-Recoverable Fault 0 State
            FAULT0: u1,
            /// Non-Recoverable Fault 1 State
            FAULT1: u1,
            /// Compare Channel 0 Buffer Valid
            CCBUFV0: u1,
            /// Compare Channel 1 Buffer Valid
            CCBUFV1: u1,
            /// Compare Channel 2 Buffer Valid
            CCBUFV2: u1,
            /// Compare Channel 3 Buffer Valid
            CCBUFV3: u1,
            /// Compare Channel 4 Buffer Valid
            CCBUFV4: u1,
            /// Compare Channel 5 Buffer Valid
            CCBUFV5: u1,
            reserved1: u1,
            reserved2: u1,
            /// Compare Channel 0 Value
            CMP0: u1,
            /// Compare Channel 1 Value
            CMP1: u1,
            /// Compare Channel 2 Value
            CMP2: u1,
            /// Compare Channel 3 Value
            CMP3: u1,
            /// Compare Channel 4 Value
            CMP4: u1,
            /// Compare Channel 5 Value
            CMP5: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x30);

        /// address: 0x42000c34
        /// Count
        pub const COUNT = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x34);

        /// address: 0x42000c34
        /// Count
        pub const COUNT_DITH4_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Counter Value
            COUNT: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x42000c34
        /// Count
        pub const COUNT_DITH5_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Counter Value
            COUNT: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x42000c34
        /// Count
        pub const COUNT_DITH6_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Counter Value
            COUNT: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x42000c38
        /// Pattern
        pub const PATT = @intToPtr(*volatile Mmio(16, packed struct {
            /// Pattern Generator 0 Output Enable
            PGE0: u1,
            /// Pattern Generator 1 Output Enable
            PGE1: u1,
            /// Pattern Generator 2 Output Enable
            PGE2: u1,
            /// Pattern Generator 3 Output Enable
            PGE3: u1,
            /// Pattern Generator 4 Output Enable
            PGE4: u1,
            /// Pattern Generator 5 Output Enable
            PGE5: u1,
            /// Pattern Generator 6 Output Enable
            PGE6: u1,
            /// Pattern Generator 7 Output Enable
            PGE7: u1,
            /// Pattern Generator 0 Output Value
            PGV0: u1,
            /// Pattern Generator 1 Output Value
            PGV1: u1,
            /// Pattern Generator 2 Output Value
            PGV2: u1,
            /// Pattern Generator 3 Output Value
            PGV3: u1,
            /// Pattern Generator 4 Output Value
            PGV4: u1,
            /// Pattern Generator 5 Output Value
            PGV5: u1,
            /// Pattern Generator 6 Output Value
            PGV6: u1,
            /// Pattern Generator 7 Output Value
            PGV7: u1,
        }), base_address + 0x38);

        /// address: 0x42000c3c
        /// Waveform Control
        pub const WAVE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Waveform Generation
            WAVEGEN: u3,
            reserved0: u1,
            /// Ramp Mode
            RAMP: u2,
            reserved1: u1,
            /// Circular period Enable
            CIPEREN: u1,
            /// Circular Channel 0 Enable
            CICCEN0: u1,
            /// Circular Channel 1 Enable
            CICCEN1: u1,
            /// Circular Channel 2 Enable
            CICCEN2: u1,
            /// Circular Channel 3 Enable
            CICCEN3: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Channel 0 Polarity
            POL0: u1,
            /// Channel 1 Polarity
            POL1: u1,
            /// Channel 2 Polarity
            POL2: u1,
            /// Channel 3 Polarity
            POL3: u1,
            /// Channel 4 Polarity
            POL4: u1,
            /// Channel 5 Polarity
            POL5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Swap DTI Output Pair 0
            SWAP0: u1,
            /// Swap DTI Output Pair 1
            SWAP1: u1,
            /// Swap DTI Output Pair 2
            SWAP2: u1,
            /// Swap DTI Output Pair 3
            SWAP3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x3c);

        /// address: 0x42000c40
        /// Period
        pub const PER = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x40);

        /// address: 0x42000c40
        /// Period
        pub const PER_DITH4_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u4,
            /// Period Value
            PER: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x42000c40
        /// Period
        pub const PER_DITH5_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u5,
            /// Period Value
            PER: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x42000c40
        /// Period
        pub const PER_DITH6_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u6,
            /// Period Value
            PER: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x42000c44
        /// Compare and Capture
        pub const CC = @intToPtr(*volatile [6]MmioInt(32, u24), base_address + 0x44);

        /// address: 0x42000c44
        /// Compare and Capture
        pub const CC_DITH4_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u4,
            /// Channel Compare/Capture Value
            CC: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x44);

        /// address: 0x42000c44
        /// Compare and Capture
        pub const CC_DITH5_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u5,
            /// Channel Compare/Capture Value
            CC: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x44);

        /// address: 0x42000c44
        /// Compare and Capture
        pub const CC_DITH6_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u6,
            /// Channel Compare/Capture Value
            CC: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x44);

        /// address: 0x42000c64
        /// Pattern Buffer
        pub const PATTBUF = @intToPtr(*volatile Mmio(16, packed struct {
            /// Pattern Generator 0 Output Enable Buffer
            PGEB0: u1,
            /// Pattern Generator 1 Output Enable Buffer
            PGEB1: u1,
            /// Pattern Generator 2 Output Enable Buffer
            PGEB2: u1,
            /// Pattern Generator 3 Output Enable Buffer
            PGEB3: u1,
            /// Pattern Generator 4 Output Enable Buffer
            PGEB4: u1,
            /// Pattern Generator 5 Output Enable Buffer
            PGEB5: u1,
            /// Pattern Generator 6 Output Enable Buffer
            PGEB6: u1,
            /// Pattern Generator 7 Output Enable Buffer
            PGEB7: u1,
            /// Pattern Generator 0 Output Enable
            PGVB0: u1,
            /// Pattern Generator 1 Output Enable
            PGVB1: u1,
            /// Pattern Generator 2 Output Enable
            PGVB2: u1,
            /// Pattern Generator 3 Output Enable
            PGVB3: u1,
            /// Pattern Generator 4 Output Enable
            PGVB4: u1,
            /// Pattern Generator 5 Output Enable
            PGVB5: u1,
            /// Pattern Generator 6 Output Enable
            PGVB6: u1,
            /// Pattern Generator 7 Output Enable
            PGVB7: u1,
        }), base_address + 0x64);

        /// address: 0x42000c6c
        /// Period Buffer
        pub const PERBUF = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x6c);

        /// address: 0x42000c6c
        /// Period Buffer
        pub const PERBUF_DITH4_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u4,
            /// Period Buffer Value
            PERBUF: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x42000c6c
        /// Period Buffer
        pub const PERBUF_DITH5_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u5,
            /// Period Buffer Value
            PERBUF: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x42000c6c
        /// Period Buffer
        pub const PERBUF_DITH6_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u6,
            /// Period Buffer Value
            PERBUF: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x42000c70
        /// Compare and Capture Buffer
        pub const CCBUF = @intToPtr(*volatile [6]MmioInt(32, u24), base_address + 0x70);

        /// address: 0x42000c70
        /// Compare and Capture Buffer
        pub const CCBUF_DITH4_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Channel Compare/Capture Buffer Value
            CCBUF: u4,
            /// Dithering Buffer Cycle Number
            DITHERBUF: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x70);

        /// address: 0x42000c70
        /// Compare and Capture Buffer
        pub const CCBUF_DITH5_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u5,
            /// Channel Compare/Capture Buffer Value
            CCBUF: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x70);

        /// address: 0x42000c70
        /// Compare and Capture Buffer
        pub const CCBUF_DITH6_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u6,
            /// Channel Compare/Capture Buffer Value
            CCBUF: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x70);
    };
    pub const TCC3 = struct {
        pub const base_address = 0x42001000;

        /// address: 0x42001000
        /// Control A
        pub const CTRLA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Reset
            SWRST: u1,
            /// Enable
            ENABLE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Enhanced Resolution
            RESOLUTION: u2,
            reserved3: u1,
            /// Prescaler
            PRESCALER: u3,
            /// Run in Standby
            RUNSTDBY: u1,
            /// Prescaler and Counter Synchronization Selection
            PRESCSYNC: u2,
            /// Auto Lock
            ALOCK: u1,
            /// Master Synchronization (only for TCC Slave Instance)
            MSYNC: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// DMA One-shot Trigger Mode
            DMAOS: u1,
            /// Capture Channel 0 Enable
            CPTEN0: u1,
            /// Capture Channel 1 Enable
            CPTEN1: u1,
            /// Capture Channel 2 Enable
            CPTEN2: u1,
            /// Capture Channel 3 Enable
            CPTEN3: u1,
            /// Capture Channel 4 Enable
            CPTEN4: u1,
            /// Capture Channel 5 Enable
            CPTEN5: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x0);

        /// address: 0x42001004
        /// Control B Clear
        pub const CTRLBCLR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Counter Direction
            DIR: u1,
            /// Lock Update
            LUPD: u1,
            /// One-Shot
            ONESHOT: u1,
            /// Ramp Index Command
            IDXCMD: u2,
            /// TCC Command
            CMD: u3,
        }), base_address + 0x4);

        /// address: 0x42001005
        /// Control B Set
        pub const CTRLBSET = @intToPtr(*volatile Mmio(8, packed struct {
            /// Counter Direction
            DIR: u1,
            /// Lock Update
            LUPD: u1,
            /// One-Shot
            ONESHOT: u1,
            /// Ramp Index Command
            IDXCMD: u2,
            /// TCC Command
            CMD: u3,
        }), base_address + 0x5);

        /// address: 0x42001008
        /// Synchronization Busy
        pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Swrst Busy
            SWRST: u1,
            /// Enable Busy
            ENABLE: u1,
            /// Ctrlb Busy
            CTRLB: u1,
            /// Status Busy
            STATUS: u1,
            /// Count Busy
            COUNT: u1,
            /// Pattern Busy
            PATT: u1,
            /// Wave Busy
            WAVE: u1,
            /// Period Busy
            PER: u1,
            /// Compare Channel 0 Busy
            CC0: u1,
            /// Compare Channel 1 Busy
            CC1: u1,
            /// Compare Channel 2 Busy
            CC2: u1,
            /// Compare Channel 3 Busy
            CC3: u1,
            /// Compare Channel 4 Busy
            CC4: u1,
            /// Compare Channel 5 Busy
            CC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x8);

        /// address: 0x4200100c
        /// Recoverable Fault A Configuration
        pub const FCTRLA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fault A Source
            SRC: u2,
            reserved0: u1,
            /// Fault A Keeper
            KEEP: u1,
            /// Fault A Qualification
            QUAL: u1,
            /// Fault A Blanking Mode
            BLANK: u2,
            /// Fault A Restart
            RESTART: u1,
            /// Fault A Halt Mode
            HALT: u2,
            /// Fault A Capture Channel
            CHSEL: u2,
            /// Fault A Capture Action
            CAPTURE: u3,
            /// Fault A Blanking Prescaler
            BLANKPRESC: u1,
            /// Fault A Blanking Time
            BLANKVAL: u8,
            /// Fault A Filter Value
            FILTERVAL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xc);

        /// address: 0x42001010
        /// Recoverable Fault B Configuration
        pub const FCTRLB = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fault B Source
            SRC: u2,
            reserved0: u1,
            /// Fault B Keeper
            KEEP: u1,
            /// Fault B Qualification
            QUAL: u1,
            /// Fault B Blanking Mode
            BLANK: u2,
            /// Fault B Restart
            RESTART: u1,
            /// Fault B Halt Mode
            HALT: u2,
            /// Fault B Capture Channel
            CHSEL: u2,
            /// Fault B Capture Action
            CAPTURE: u3,
            /// Fault B Blanking Prescaler
            BLANKPRESC: u1,
            /// Fault B Blanking Time
            BLANKVAL: u8,
            /// Fault B Filter Value
            FILTERVAL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x10);

        /// address: 0x42001014
        /// Waveform Extension Configuration
        pub const WEXCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output Matrix
            OTMX: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Dead-time Insertion Generator 0 Enable
            DTIEN0: u1,
            /// Dead-time Insertion Generator 1 Enable
            DTIEN1: u1,
            /// Dead-time Insertion Generator 2 Enable
            DTIEN2: u1,
            /// Dead-time Insertion Generator 3 Enable
            DTIEN3: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Dead-time Low Side Outputs Value
            DTLS: u8,
            /// Dead-time High Side Outputs Value
            DTHS: u8,
        }), base_address + 0x14);

        /// address: 0x42001018
        /// Driver Control
        pub const DRVCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Non-Recoverable State 0 Output Enable
            NRE0: u1,
            /// Non-Recoverable State 1 Output Enable
            NRE1: u1,
            /// Non-Recoverable State 2 Output Enable
            NRE2: u1,
            /// Non-Recoverable State 3 Output Enable
            NRE3: u1,
            /// Non-Recoverable State 4 Output Enable
            NRE4: u1,
            /// Non-Recoverable State 5 Output Enable
            NRE5: u1,
            /// Non-Recoverable State 6 Output Enable
            NRE6: u1,
            /// Non-Recoverable State 7 Output Enable
            NRE7: u1,
            /// Non-Recoverable State 0 Output Value
            NRV0: u1,
            /// Non-Recoverable State 1 Output Value
            NRV1: u1,
            /// Non-Recoverable State 2 Output Value
            NRV2: u1,
            /// Non-Recoverable State 3 Output Value
            NRV3: u1,
            /// Non-Recoverable State 4 Output Value
            NRV4: u1,
            /// Non-Recoverable State 5 Output Value
            NRV5: u1,
            /// Non-Recoverable State 6 Output Value
            NRV6: u1,
            /// Non-Recoverable State 7 Output Value
            NRV7: u1,
            /// Output Waveform 0 Inversion
            INVEN0: u1,
            /// Output Waveform 1 Inversion
            INVEN1: u1,
            /// Output Waveform 2 Inversion
            INVEN2: u1,
            /// Output Waveform 3 Inversion
            INVEN3: u1,
            /// Output Waveform 4 Inversion
            INVEN4: u1,
            /// Output Waveform 5 Inversion
            INVEN5: u1,
            /// Output Waveform 6 Inversion
            INVEN6: u1,
            /// Output Waveform 7 Inversion
            INVEN7: u1,
            /// Non-Recoverable Fault Input 0 Filter Value
            FILTERVAL0: u4,
            /// Non-Recoverable Fault Input 1 Filter Value
            FILTERVAL1: u4,
        }), base_address + 0x18);

        /// address: 0x4200101e
        /// Debug Control
        pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Debug Running Mode
            DBGRUN: u1,
            reserved0: u1,
            /// Fault Detection on Debug Break Detection
            FDDBD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x1e);

        /// address: 0x42001020
        /// Event Control
        pub const EVCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer/counter Input Event0 Action
            EVACT0: u3,
            /// Timer/counter Input Event1 Action
            EVACT1: u3,
            /// Timer/counter Output Event Mode
            CNTSEL: u2,
            /// Overflow/Underflow Output Event Enable
            OVFEO: u1,
            /// Retrigger Output Event Enable
            TRGEO: u1,
            /// Timer/counter Output Event Enable
            CNTEO: u1,
            reserved0: u1,
            /// Inverted Event 0 Input Enable
            TCINV0: u1,
            /// Inverted Event 1 Input Enable
            TCINV1: u1,
            /// Timer/counter Event 0 Input Enable
            TCEI0: u1,
            /// Timer/counter Event 1 Input Enable
            TCEI1: u1,
            /// Match or Capture Channel 0 Event Input Enable
            MCEI0: u1,
            /// Match or Capture Channel 1 Event Input Enable
            MCEI1: u1,
            /// Match or Capture Channel 2 Event Input Enable
            MCEI2: u1,
            /// Match or Capture Channel 3 Event Input Enable
            MCEI3: u1,
            /// Match or Capture Channel 4 Event Input Enable
            MCEI4: u1,
            /// Match or Capture Channel 5 Event Input Enable
            MCEI5: u1,
            reserved1: u1,
            reserved2: u1,
            /// Match or Capture Channel 0 Event Output Enable
            MCEO0: u1,
            /// Match or Capture Channel 1 Event Output Enable
            MCEO1: u1,
            /// Match or Capture Channel 2 Event Output Enable
            MCEO2: u1,
            /// Match or Capture Channel 3 Event Output Enable
            MCEO3: u1,
            /// Match or Capture Channel 4 Event Output Enable
            MCEO4: u1,
            /// Match or Capture Channel 5 Event Output Enable
            MCEO5: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x20);

        /// address: 0x42001024
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overflow Interrupt Enable
            OVF: u1,
            /// Retrigger Interrupt Enable
            TRG: u1,
            /// Counter Interrupt Enable
            CNT: u1,
            /// Error Interrupt Enable
            ERR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Non-Recoverable Update Fault Interrupt Enable
            UFS: u1,
            /// Non-Recoverable Debug Fault Interrupt Enable
            DFS: u1,
            /// Recoverable Fault A Interrupt Enable
            FAULTA: u1,
            /// Recoverable Fault B Interrupt Enable
            FAULTB: u1,
            /// Non-Recoverable Fault 0 Interrupt Enable
            FAULT0: u1,
            /// Non-Recoverable Fault 1 Interrupt Enable
            FAULT1: u1,
            /// Match or Capture Channel 0 Interrupt Enable
            MC0: u1,
            /// Match or Capture Channel 1 Interrupt Enable
            MC1: u1,
            /// Match or Capture Channel 2 Interrupt Enable
            MC2: u1,
            /// Match or Capture Channel 3 Interrupt Enable
            MC3: u1,
            /// Match or Capture Channel 4 Interrupt Enable
            MC4: u1,
            /// Match or Capture Channel 5 Interrupt Enable
            MC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x24);

        /// address: 0x42001028
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overflow Interrupt Enable
            OVF: u1,
            /// Retrigger Interrupt Enable
            TRG: u1,
            /// Counter Interrupt Enable
            CNT: u1,
            /// Error Interrupt Enable
            ERR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Non-Recoverable Update Fault Interrupt Enable
            UFS: u1,
            /// Non-Recoverable Debug Fault Interrupt Enable
            DFS: u1,
            /// Recoverable Fault A Interrupt Enable
            FAULTA: u1,
            /// Recoverable Fault B Interrupt Enable
            FAULTB: u1,
            /// Non-Recoverable Fault 0 Interrupt Enable
            FAULT0: u1,
            /// Non-Recoverable Fault 1 Interrupt Enable
            FAULT1: u1,
            /// Match or Capture Channel 0 Interrupt Enable
            MC0: u1,
            /// Match or Capture Channel 1 Interrupt Enable
            MC1: u1,
            /// Match or Capture Channel 2 Interrupt Enable
            MC2: u1,
            /// Match or Capture Channel 3 Interrupt Enable
            MC3: u1,
            /// Match or Capture Channel 4 Interrupt Enable
            MC4: u1,
            /// Match or Capture Channel 5 Interrupt Enable
            MC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x28);

        /// address: 0x4200102c
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overflow
            OVF: u1,
            /// Retrigger
            TRG: u1,
            /// Counter
            CNT: u1,
            /// Error
            ERR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Non-Recoverable Update Fault
            UFS: u1,
            /// Non-Recoverable Debug Fault
            DFS: u1,
            /// Recoverable Fault A
            FAULTA: u1,
            /// Recoverable Fault B
            FAULTB: u1,
            /// Non-Recoverable Fault 0
            FAULT0: u1,
            /// Non-Recoverable Fault 1
            FAULT1: u1,
            /// Match or Capture 0
            MC0: u1,
            /// Match or Capture 1
            MC1: u1,
            /// Match or Capture 2
            MC2: u1,
            /// Match or Capture 3
            MC3: u1,
            /// Match or Capture 4
            MC4: u1,
            /// Match or Capture 5
            MC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x2c);

        /// address: 0x42001030
        /// Status
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stop
            STOP: u1,
            /// Ramp
            IDX: u1,
            /// Non-recoverable Update Fault State
            UFS: u1,
            /// Non-Recoverable Debug Fault State
            DFS: u1,
            /// Slave
            SLAVE: u1,
            /// Pattern Buffer Valid
            PATTBUFV: u1,
            reserved0: u1,
            /// Period Buffer Valid
            PERBUFV: u1,
            /// Recoverable Fault A Input
            FAULTAIN: u1,
            /// Recoverable Fault B Input
            FAULTBIN: u1,
            /// Non-Recoverable Fault0 Input
            FAULT0IN: u1,
            /// Non-Recoverable Fault1 Input
            FAULT1IN: u1,
            /// Recoverable Fault A State
            FAULTA: u1,
            /// Recoverable Fault B State
            FAULTB: u1,
            /// Non-Recoverable Fault 0 State
            FAULT0: u1,
            /// Non-Recoverable Fault 1 State
            FAULT1: u1,
            /// Compare Channel 0 Buffer Valid
            CCBUFV0: u1,
            /// Compare Channel 1 Buffer Valid
            CCBUFV1: u1,
            /// Compare Channel 2 Buffer Valid
            CCBUFV2: u1,
            /// Compare Channel 3 Buffer Valid
            CCBUFV3: u1,
            /// Compare Channel 4 Buffer Valid
            CCBUFV4: u1,
            /// Compare Channel 5 Buffer Valid
            CCBUFV5: u1,
            reserved1: u1,
            reserved2: u1,
            /// Compare Channel 0 Value
            CMP0: u1,
            /// Compare Channel 1 Value
            CMP1: u1,
            /// Compare Channel 2 Value
            CMP2: u1,
            /// Compare Channel 3 Value
            CMP3: u1,
            /// Compare Channel 4 Value
            CMP4: u1,
            /// Compare Channel 5 Value
            CMP5: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x30);

        /// address: 0x42001034
        /// Count
        pub const COUNT = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x34);

        /// address: 0x42001034
        /// Count
        pub const COUNT_DITH4_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Counter Value
            COUNT: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x42001034
        /// Count
        pub const COUNT_DITH5_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Counter Value
            COUNT: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x42001034
        /// Count
        pub const COUNT_DITH6_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Counter Value
            COUNT: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x42001038
        /// Pattern
        pub const PATT = @intToPtr(*volatile Mmio(16, packed struct {
            /// Pattern Generator 0 Output Enable
            PGE0: u1,
            /// Pattern Generator 1 Output Enable
            PGE1: u1,
            /// Pattern Generator 2 Output Enable
            PGE2: u1,
            /// Pattern Generator 3 Output Enable
            PGE3: u1,
            /// Pattern Generator 4 Output Enable
            PGE4: u1,
            /// Pattern Generator 5 Output Enable
            PGE5: u1,
            /// Pattern Generator 6 Output Enable
            PGE6: u1,
            /// Pattern Generator 7 Output Enable
            PGE7: u1,
            /// Pattern Generator 0 Output Value
            PGV0: u1,
            /// Pattern Generator 1 Output Value
            PGV1: u1,
            /// Pattern Generator 2 Output Value
            PGV2: u1,
            /// Pattern Generator 3 Output Value
            PGV3: u1,
            /// Pattern Generator 4 Output Value
            PGV4: u1,
            /// Pattern Generator 5 Output Value
            PGV5: u1,
            /// Pattern Generator 6 Output Value
            PGV6: u1,
            /// Pattern Generator 7 Output Value
            PGV7: u1,
        }), base_address + 0x38);

        /// address: 0x4200103c
        /// Waveform Control
        pub const WAVE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Waveform Generation
            WAVEGEN: u3,
            reserved0: u1,
            /// Ramp Mode
            RAMP: u2,
            reserved1: u1,
            /// Circular period Enable
            CIPEREN: u1,
            /// Circular Channel 0 Enable
            CICCEN0: u1,
            /// Circular Channel 1 Enable
            CICCEN1: u1,
            /// Circular Channel 2 Enable
            CICCEN2: u1,
            /// Circular Channel 3 Enable
            CICCEN3: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Channel 0 Polarity
            POL0: u1,
            /// Channel 1 Polarity
            POL1: u1,
            /// Channel 2 Polarity
            POL2: u1,
            /// Channel 3 Polarity
            POL3: u1,
            /// Channel 4 Polarity
            POL4: u1,
            /// Channel 5 Polarity
            POL5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Swap DTI Output Pair 0
            SWAP0: u1,
            /// Swap DTI Output Pair 1
            SWAP1: u1,
            /// Swap DTI Output Pair 2
            SWAP2: u1,
            /// Swap DTI Output Pair 3
            SWAP3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x3c);

        /// address: 0x42001040
        /// Period
        pub const PER = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x40);

        /// address: 0x42001040
        /// Period
        pub const PER_DITH4_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u4,
            /// Period Value
            PER: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x42001040
        /// Period
        pub const PER_DITH5_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u5,
            /// Period Value
            PER: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x42001040
        /// Period
        pub const PER_DITH6_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u6,
            /// Period Value
            PER: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x42001044
        /// Compare and Capture
        pub const CC = @intToPtr(*volatile [6]MmioInt(32, u24), base_address + 0x44);

        /// address: 0x42001044
        /// Compare and Capture
        pub const CC_DITH4_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u4,
            /// Channel Compare/Capture Value
            CC: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x44);

        /// address: 0x42001044
        /// Compare and Capture
        pub const CC_DITH5_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u5,
            /// Channel Compare/Capture Value
            CC: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x44);

        /// address: 0x42001044
        /// Compare and Capture
        pub const CC_DITH6_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u6,
            /// Channel Compare/Capture Value
            CC: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x44);

        /// address: 0x42001064
        /// Pattern Buffer
        pub const PATTBUF = @intToPtr(*volatile Mmio(16, packed struct {
            /// Pattern Generator 0 Output Enable Buffer
            PGEB0: u1,
            /// Pattern Generator 1 Output Enable Buffer
            PGEB1: u1,
            /// Pattern Generator 2 Output Enable Buffer
            PGEB2: u1,
            /// Pattern Generator 3 Output Enable Buffer
            PGEB3: u1,
            /// Pattern Generator 4 Output Enable Buffer
            PGEB4: u1,
            /// Pattern Generator 5 Output Enable Buffer
            PGEB5: u1,
            /// Pattern Generator 6 Output Enable Buffer
            PGEB6: u1,
            /// Pattern Generator 7 Output Enable Buffer
            PGEB7: u1,
            /// Pattern Generator 0 Output Enable
            PGVB0: u1,
            /// Pattern Generator 1 Output Enable
            PGVB1: u1,
            /// Pattern Generator 2 Output Enable
            PGVB2: u1,
            /// Pattern Generator 3 Output Enable
            PGVB3: u1,
            /// Pattern Generator 4 Output Enable
            PGVB4: u1,
            /// Pattern Generator 5 Output Enable
            PGVB5: u1,
            /// Pattern Generator 6 Output Enable
            PGVB6: u1,
            /// Pattern Generator 7 Output Enable
            PGVB7: u1,
        }), base_address + 0x64);

        /// address: 0x4200106c
        /// Period Buffer
        pub const PERBUF = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x6c);

        /// address: 0x4200106c
        /// Period Buffer
        pub const PERBUF_DITH4_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u4,
            /// Period Buffer Value
            PERBUF: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x4200106c
        /// Period Buffer
        pub const PERBUF_DITH5_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u5,
            /// Period Buffer Value
            PERBUF: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x4200106c
        /// Period Buffer
        pub const PERBUF_DITH6_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u6,
            /// Period Buffer Value
            PERBUF: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x42001070
        /// Compare and Capture Buffer
        pub const CCBUF = @intToPtr(*volatile [6]MmioInt(32, u24), base_address + 0x70);

        /// address: 0x42001070
        /// Compare and Capture Buffer
        pub const CCBUF_DITH4_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Channel Compare/Capture Buffer Value
            CCBUF: u4,
            /// Dithering Buffer Cycle Number
            DITHERBUF: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x70);

        /// address: 0x42001070
        /// Compare and Capture Buffer
        pub const CCBUF_DITH5_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u5,
            /// Channel Compare/Capture Buffer Value
            CCBUF: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x70);

        /// address: 0x42001070
        /// Compare and Capture Buffer
        pub const CCBUF_DITH6_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u6,
            /// Channel Compare/Capture Buffer Value
            CCBUF: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x70);
    };
    pub const TCC4 = struct {
        pub const base_address = 0x43001000;

        /// address: 0x43001000
        /// Control A
        pub const CTRLA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Reset
            SWRST: u1,
            /// Enable
            ENABLE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Enhanced Resolution
            RESOLUTION: u2,
            reserved3: u1,
            /// Prescaler
            PRESCALER: u3,
            /// Run in Standby
            RUNSTDBY: u1,
            /// Prescaler and Counter Synchronization Selection
            PRESCSYNC: u2,
            /// Auto Lock
            ALOCK: u1,
            /// Master Synchronization (only for TCC Slave Instance)
            MSYNC: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// DMA One-shot Trigger Mode
            DMAOS: u1,
            /// Capture Channel 0 Enable
            CPTEN0: u1,
            /// Capture Channel 1 Enable
            CPTEN1: u1,
            /// Capture Channel 2 Enable
            CPTEN2: u1,
            /// Capture Channel 3 Enable
            CPTEN3: u1,
            /// Capture Channel 4 Enable
            CPTEN4: u1,
            /// Capture Channel 5 Enable
            CPTEN5: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x0);

        /// address: 0x43001004
        /// Control B Clear
        pub const CTRLBCLR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Counter Direction
            DIR: u1,
            /// Lock Update
            LUPD: u1,
            /// One-Shot
            ONESHOT: u1,
            /// Ramp Index Command
            IDXCMD: u2,
            /// TCC Command
            CMD: u3,
        }), base_address + 0x4);

        /// address: 0x43001005
        /// Control B Set
        pub const CTRLBSET = @intToPtr(*volatile Mmio(8, packed struct {
            /// Counter Direction
            DIR: u1,
            /// Lock Update
            LUPD: u1,
            /// One-Shot
            ONESHOT: u1,
            /// Ramp Index Command
            IDXCMD: u2,
            /// TCC Command
            CMD: u3,
        }), base_address + 0x5);

        /// address: 0x43001008
        /// Synchronization Busy
        pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Swrst Busy
            SWRST: u1,
            /// Enable Busy
            ENABLE: u1,
            /// Ctrlb Busy
            CTRLB: u1,
            /// Status Busy
            STATUS: u1,
            /// Count Busy
            COUNT: u1,
            /// Pattern Busy
            PATT: u1,
            /// Wave Busy
            WAVE: u1,
            /// Period Busy
            PER: u1,
            /// Compare Channel 0 Busy
            CC0: u1,
            /// Compare Channel 1 Busy
            CC1: u1,
            /// Compare Channel 2 Busy
            CC2: u1,
            /// Compare Channel 3 Busy
            CC3: u1,
            /// Compare Channel 4 Busy
            CC4: u1,
            /// Compare Channel 5 Busy
            CC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x8);

        /// address: 0x4300100c
        /// Recoverable Fault A Configuration
        pub const FCTRLA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fault A Source
            SRC: u2,
            reserved0: u1,
            /// Fault A Keeper
            KEEP: u1,
            /// Fault A Qualification
            QUAL: u1,
            /// Fault A Blanking Mode
            BLANK: u2,
            /// Fault A Restart
            RESTART: u1,
            /// Fault A Halt Mode
            HALT: u2,
            /// Fault A Capture Channel
            CHSEL: u2,
            /// Fault A Capture Action
            CAPTURE: u3,
            /// Fault A Blanking Prescaler
            BLANKPRESC: u1,
            /// Fault A Blanking Time
            BLANKVAL: u8,
            /// Fault A Filter Value
            FILTERVAL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xc);

        /// address: 0x43001010
        /// Recoverable Fault B Configuration
        pub const FCTRLB = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fault B Source
            SRC: u2,
            reserved0: u1,
            /// Fault B Keeper
            KEEP: u1,
            /// Fault B Qualification
            QUAL: u1,
            /// Fault B Blanking Mode
            BLANK: u2,
            /// Fault B Restart
            RESTART: u1,
            /// Fault B Halt Mode
            HALT: u2,
            /// Fault B Capture Channel
            CHSEL: u2,
            /// Fault B Capture Action
            CAPTURE: u3,
            /// Fault B Blanking Prescaler
            BLANKPRESC: u1,
            /// Fault B Blanking Time
            BLANKVAL: u8,
            /// Fault B Filter Value
            FILTERVAL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x10);

        /// address: 0x43001014
        /// Waveform Extension Configuration
        pub const WEXCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output Matrix
            OTMX: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Dead-time Insertion Generator 0 Enable
            DTIEN0: u1,
            /// Dead-time Insertion Generator 1 Enable
            DTIEN1: u1,
            /// Dead-time Insertion Generator 2 Enable
            DTIEN2: u1,
            /// Dead-time Insertion Generator 3 Enable
            DTIEN3: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Dead-time Low Side Outputs Value
            DTLS: u8,
            /// Dead-time High Side Outputs Value
            DTHS: u8,
        }), base_address + 0x14);

        /// address: 0x43001018
        /// Driver Control
        pub const DRVCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Non-Recoverable State 0 Output Enable
            NRE0: u1,
            /// Non-Recoverable State 1 Output Enable
            NRE1: u1,
            /// Non-Recoverable State 2 Output Enable
            NRE2: u1,
            /// Non-Recoverable State 3 Output Enable
            NRE3: u1,
            /// Non-Recoverable State 4 Output Enable
            NRE4: u1,
            /// Non-Recoverable State 5 Output Enable
            NRE5: u1,
            /// Non-Recoverable State 6 Output Enable
            NRE6: u1,
            /// Non-Recoverable State 7 Output Enable
            NRE7: u1,
            /// Non-Recoverable State 0 Output Value
            NRV0: u1,
            /// Non-Recoverable State 1 Output Value
            NRV1: u1,
            /// Non-Recoverable State 2 Output Value
            NRV2: u1,
            /// Non-Recoverable State 3 Output Value
            NRV3: u1,
            /// Non-Recoverable State 4 Output Value
            NRV4: u1,
            /// Non-Recoverable State 5 Output Value
            NRV5: u1,
            /// Non-Recoverable State 6 Output Value
            NRV6: u1,
            /// Non-Recoverable State 7 Output Value
            NRV7: u1,
            /// Output Waveform 0 Inversion
            INVEN0: u1,
            /// Output Waveform 1 Inversion
            INVEN1: u1,
            /// Output Waveform 2 Inversion
            INVEN2: u1,
            /// Output Waveform 3 Inversion
            INVEN3: u1,
            /// Output Waveform 4 Inversion
            INVEN4: u1,
            /// Output Waveform 5 Inversion
            INVEN5: u1,
            /// Output Waveform 6 Inversion
            INVEN6: u1,
            /// Output Waveform 7 Inversion
            INVEN7: u1,
            /// Non-Recoverable Fault Input 0 Filter Value
            FILTERVAL0: u4,
            /// Non-Recoverable Fault Input 1 Filter Value
            FILTERVAL1: u4,
        }), base_address + 0x18);

        /// address: 0x4300101e
        /// Debug Control
        pub const DBGCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Debug Running Mode
            DBGRUN: u1,
            reserved0: u1,
            /// Fault Detection on Debug Break Detection
            FDDBD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x1e);

        /// address: 0x43001020
        /// Event Control
        pub const EVCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer/counter Input Event0 Action
            EVACT0: u3,
            /// Timer/counter Input Event1 Action
            EVACT1: u3,
            /// Timer/counter Output Event Mode
            CNTSEL: u2,
            /// Overflow/Underflow Output Event Enable
            OVFEO: u1,
            /// Retrigger Output Event Enable
            TRGEO: u1,
            /// Timer/counter Output Event Enable
            CNTEO: u1,
            reserved0: u1,
            /// Inverted Event 0 Input Enable
            TCINV0: u1,
            /// Inverted Event 1 Input Enable
            TCINV1: u1,
            /// Timer/counter Event 0 Input Enable
            TCEI0: u1,
            /// Timer/counter Event 1 Input Enable
            TCEI1: u1,
            /// Match or Capture Channel 0 Event Input Enable
            MCEI0: u1,
            /// Match or Capture Channel 1 Event Input Enable
            MCEI1: u1,
            /// Match or Capture Channel 2 Event Input Enable
            MCEI2: u1,
            /// Match or Capture Channel 3 Event Input Enable
            MCEI3: u1,
            /// Match or Capture Channel 4 Event Input Enable
            MCEI4: u1,
            /// Match or Capture Channel 5 Event Input Enable
            MCEI5: u1,
            reserved1: u1,
            reserved2: u1,
            /// Match or Capture Channel 0 Event Output Enable
            MCEO0: u1,
            /// Match or Capture Channel 1 Event Output Enable
            MCEO1: u1,
            /// Match or Capture Channel 2 Event Output Enable
            MCEO2: u1,
            /// Match or Capture Channel 3 Event Output Enable
            MCEO3: u1,
            /// Match or Capture Channel 4 Event Output Enable
            MCEO4: u1,
            /// Match or Capture Channel 5 Event Output Enable
            MCEO5: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x20);

        /// address: 0x43001024
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overflow Interrupt Enable
            OVF: u1,
            /// Retrigger Interrupt Enable
            TRG: u1,
            /// Counter Interrupt Enable
            CNT: u1,
            /// Error Interrupt Enable
            ERR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Non-Recoverable Update Fault Interrupt Enable
            UFS: u1,
            /// Non-Recoverable Debug Fault Interrupt Enable
            DFS: u1,
            /// Recoverable Fault A Interrupt Enable
            FAULTA: u1,
            /// Recoverable Fault B Interrupt Enable
            FAULTB: u1,
            /// Non-Recoverable Fault 0 Interrupt Enable
            FAULT0: u1,
            /// Non-Recoverable Fault 1 Interrupt Enable
            FAULT1: u1,
            /// Match or Capture Channel 0 Interrupt Enable
            MC0: u1,
            /// Match or Capture Channel 1 Interrupt Enable
            MC1: u1,
            /// Match or Capture Channel 2 Interrupt Enable
            MC2: u1,
            /// Match or Capture Channel 3 Interrupt Enable
            MC3: u1,
            /// Match or Capture Channel 4 Interrupt Enable
            MC4: u1,
            /// Match or Capture Channel 5 Interrupt Enable
            MC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x24);

        /// address: 0x43001028
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overflow Interrupt Enable
            OVF: u1,
            /// Retrigger Interrupt Enable
            TRG: u1,
            /// Counter Interrupt Enable
            CNT: u1,
            /// Error Interrupt Enable
            ERR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Non-Recoverable Update Fault Interrupt Enable
            UFS: u1,
            /// Non-Recoverable Debug Fault Interrupt Enable
            DFS: u1,
            /// Recoverable Fault A Interrupt Enable
            FAULTA: u1,
            /// Recoverable Fault B Interrupt Enable
            FAULTB: u1,
            /// Non-Recoverable Fault 0 Interrupt Enable
            FAULT0: u1,
            /// Non-Recoverable Fault 1 Interrupt Enable
            FAULT1: u1,
            /// Match or Capture Channel 0 Interrupt Enable
            MC0: u1,
            /// Match or Capture Channel 1 Interrupt Enable
            MC1: u1,
            /// Match or Capture Channel 2 Interrupt Enable
            MC2: u1,
            /// Match or Capture Channel 3 Interrupt Enable
            MC3: u1,
            /// Match or Capture Channel 4 Interrupt Enable
            MC4: u1,
            /// Match or Capture Channel 5 Interrupt Enable
            MC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x28);

        /// address: 0x4300102c
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overflow
            OVF: u1,
            /// Retrigger
            TRG: u1,
            /// Counter
            CNT: u1,
            /// Error
            ERR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Non-Recoverable Update Fault
            UFS: u1,
            /// Non-Recoverable Debug Fault
            DFS: u1,
            /// Recoverable Fault A
            FAULTA: u1,
            /// Recoverable Fault B
            FAULTB: u1,
            /// Non-Recoverable Fault 0
            FAULT0: u1,
            /// Non-Recoverable Fault 1
            FAULT1: u1,
            /// Match or Capture 0
            MC0: u1,
            /// Match or Capture 1
            MC1: u1,
            /// Match or Capture 2
            MC2: u1,
            /// Match or Capture 3
            MC3: u1,
            /// Match or Capture 4
            MC4: u1,
            /// Match or Capture 5
            MC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x2c);

        /// address: 0x43001030
        /// Status
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stop
            STOP: u1,
            /// Ramp
            IDX: u1,
            /// Non-recoverable Update Fault State
            UFS: u1,
            /// Non-Recoverable Debug Fault State
            DFS: u1,
            /// Slave
            SLAVE: u1,
            /// Pattern Buffer Valid
            PATTBUFV: u1,
            reserved0: u1,
            /// Period Buffer Valid
            PERBUFV: u1,
            /// Recoverable Fault A Input
            FAULTAIN: u1,
            /// Recoverable Fault B Input
            FAULTBIN: u1,
            /// Non-Recoverable Fault0 Input
            FAULT0IN: u1,
            /// Non-Recoverable Fault1 Input
            FAULT1IN: u1,
            /// Recoverable Fault A State
            FAULTA: u1,
            /// Recoverable Fault B State
            FAULTB: u1,
            /// Non-Recoverable Fault 0 State
            FAULT0: u1,
            /// Non-Recoverable Fault 1 State
            FAULT1: u1,
            /// Compare Channel 0 Buffer Valid
            CCBUFV0: u1,
            /// Compare Channel 1 Buffer Valid
            CCBUFV1: u1,
            /// Compare Channel 2 Buffer Valid
            CCBUFV2: u1,
            /// Compare Channel 3 Buffer Valid
            CCBUFV3: u1,
            /// Compare Channel 4 Buffer Valid
            CCBUFV4: u1,
            /// Compare Channel 5 Buffer Valid
            CCBUFV5: u1,
            reserved1: u1,
            reserved2: u1,
            /// Compare Channel 0 Value
            CMP0: u1,
            /// Compare Channel 1 Value
            CMP1: u1,
            /// Compare Channel 2 Value
            CMP2: u1,
            /// Compare Channel 3 Value
            CMP3: u1,
            /// Compare Channel 4 Value
            CMP4: u1,
            /// Compare Channel 5 Value
            CMP5: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x30);

        /// address: 0x43001034
        /// Count
        pub const COUNT = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x34);

        /// address: 0x43001034
        /// Count
        pub const COUNT_DITH4_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Counter Value
            COUNT: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x43001034
        /// Count
        pub const COUNT_DITH5_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Counter Value
            COUNT: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x43001034
        /// Count
        pub const COUNT_DITH6_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Counter Value
            COUNT: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x43001038
        /// Pattern
        pub const PATT = @intToPtr(*volatile Mmio(16, packed struct {
            /// Pattern Generator 0 Output Enable
            PGE0: u1,
            /// Pattern Generator 1 Output Enable
            PGE1: u1,
            /// Pattern Generator 2 Output Enable
            PGE2: u1,
            /// Pattern Generator 3 Output Enable
            PGE3: u1,
            /// Pattern Generator 4 Output Enable
            PGE4: u1,
            /// Pattern Generator 5 Output Enable
            PGE5: u1,
            /// Pattern Generator 6 Output Enable
            PGE6: u1,
            /// Pattern Generator 7 Output Enable
            PGE7: u1,
            /// Pattern Generator 0 Output Value
            PGV0: u1,
            /// Pattern Generator 1 Output Value
            PGV1: u1,
            /// Pattern Generator 2 Output Value
            PGV2: u1,
            /// Pattern Generator 3 Output Value
            PGV3: u1,
            /// Pattern Generator 4 Output Value
            PGV4: u1,
            /// Pattern Generator 5 Output Value
            PGV5: u1,
            /// Pattern Generator 6 Output Value
            PGV6: u1,
            /// Pattern Generator 7 Output Value
            PGV7: u1,
        }), base_address + 0x38);

        /// address: 0x4300103c
        /// Waveform Control
        pub const WAVE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Waveform Generation
            WAVEGEN: u3,
            reserved0: u1,
            /// Ramp Mode
            RAMP: u2,
            reserved1: u1,
            /// Circular period Enable
            CIPEREN: u1,
            /// Circular Channel 0 Enable
            CICCEN0: u1,
            /// Circular Channel 1 Enable
            CICCEN1: u1,
            /// Circular Channel 2 Enable
            CICCEN2: u1,
            /// Circular Channel 3 Enable
            CICCEN3: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Channel 0 Polarity
            POL0: u1,
            /// Channel 1 Polarity
            POL1: u1,
            /// Channel 2 Polarity
            POL2: u1,
            /// Channel 3 Polarity
            POL3: u1,
            /// Channel 4 Polarity
            POL4: u1,
            /// Channel 5 Polarity
            POL5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Swap DTI Output Pair 0
            SWAP0: u1,
            /// Swap DTI Output Pair 1
            SWAP1: u1,
            /// Swap DTI Output Pair 2
            SWAP2: u1,
            /// Swap DTI Output Pair 3
            SWAP3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x3c);

        /// address: 0x43001040
        /// Period
        pub const PER = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x40);

        /// address: 0x43001040
        /// Period
        pub const PER_DITH4_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u4,
            /// Period Value
            PER: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x43001040
        /// Period
        pub const PER_DITH5_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u5,
            /// Period Value
            PER: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x43001040
        /// Period
        pub const PER_DITH6_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u6,
            /// Period Value
            PER: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x43001044
        /// Compare and Capture
        pub const CC = @intToPtr(*volatile [6]MmioInt(32, u24), base_address + 0x44);

        /// address: 0x43001044
        /// Compare and Capture
        pub const CC_DITH4_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u4,
            /// Channel Compare/Capture Value
            CC: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x44);

        /// address: 0x43001044
        /// Compare and Capture
        pub const CC_DITH5_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u5,
            /// Channel Compare/Capture Value
            CC: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x44);

        /// address: 0x43001044
        /// Compare and Capture
        pub const CC_DITH6_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Cycle Number
            DITHER: u6,
            /// Channel Compare/Capture Value
            CC: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x44);

        /// address: 0x43001064
        /// Pattern Buffer
        pub const PATTBUF = @intToPtr(*volatile Mmio(16, packed struct {
            /// Pattern Generator 0 Output Enable Buffer
            PGEB0: u1,
            /// Pattern Generator 1 Output Enable Buffer
            PGEB1: u1,
            /// Pattern Generator 2 Output Enable Buffer
            PGEB2: u1,
            /// Pattern Generator 3 Output Enable Buffer
            PGEB3: u1,
            /// Pattern Generator 4 Output Enable Buffer
            PGEB4: u1,
            /// Pattern Generator 5 Output Enable Buffer
            PGEB5: u1,
            /// Pattern Generator 6 Output Enable Buffer
            PGEB6: u1,
            /// Pattern Generator 7 Output Enable Buffer
            PGEB7: u1,
            /// Pattern Generator 0 Output Enable
            PGVB0: u1,
            /// Pattern Generator 1 Output Enable
            PGVB1: u1,
            /// Pattern Generator 2 Output Enable
            PGVB2: u1,
            /// Pattern Generator 3 Output Enable
            PGVB3: u1,
            /// Pattern Generator 4 Output Enable
            PGVB4: u1,
            /// Pattern Generator 5 Output Enable
            PGVB5: u1,
            /// Pattern Generator 6 Output Enable
            PGVB6: u1,
            /// Pattern Generator 7 Output Enable
            PGVB7: u1,
        }), base_address + 0x64);

        /// address: 0x4300106c
        /// Period Buffer
        pub const PERBUF = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x6c);

        /// address: 0x4300106c
        /// Period Buffer
        pub const PERBUF_DITH4_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u4,
            /// Period Buffer Value
            PERBUF: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x4300106c
        /// Period Buffer
        pub const PERBUF_DITH5_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u5,
            /// Period Buffer Value
            PERBUF: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x4300106c
        /// Period Buffer
        pub const PERBUF_DITH6_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u6,
            /// Period Buffer Value
            PERBUF: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x43001070
        /// Compare and Capture Buffer
        pub const CCBUF = @intToPtr(*volatile [6]MmioInt(32, u24), base_address + 0x70);

        /// address: 0x43001070
        /// Compare and Capture Buffer
        pub const CCBUF_DITH4_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Channel Compare/Capture Buffer Value
            CCBUF: u4,
            /// Dithering Buffer Cycle Number
            DITHERBUF: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x70);

        /// address: 0x43001070
        /// Compare and Capture Buffer
        pub const CCBUF_DITH5_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u5,
            /// Channel Compare/Capture Buffer Value
            CCBUF: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x70);

        /// address: 0x43001070
        /// Compare and Capture Buffer
        pub const CCBUF_DITH6_MODE = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Dithering Buffer Cycle Number
            DITHERBUF: u6,
            /// Channel Compare/Capture Buffer Value
            CCBUF: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x70);
    };

    /// True Random Generator
    pub const TRNG = struct {
        pub const base_address = 0x42002800;
        pub const version = "U22421.1.0";

        /// address: 0x42002800
        /// Control A
        pub const CTRLA = @intToPtr(*volatile Mmio(8, packed struct {
            reserved0: u1,
            /// Enable
            ENABLE: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Run in Standby
            RUNSTDBY: u1,
            padding0: u1,
        }), base_address + 0x0);

        /// address: 0x42002804
        /// Event Control
        pub const EVCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Data Ready Event Output
            DATARDYEO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x4);

        /// address: 0x42002808
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Data Ready Interrupt Enable
            DATARDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x8);

        /// address: 0x42002809
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
            /// Data Ready Interrupt Enable
            DATARDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x9);

        /// address: 0x4200280a
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
            /// Data Ready Interrupt Flag
            DATARDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0xa);

        /// address: 0x42002820
        /// Output Data
        pub const DATA = @intToPtr(*volatile u32, base_address + 0x20);
    };

    /// Universal Serial Bus
    pub const USB = struct {
        pub const base_address = 0x41000000;
        pub const version = "U22221.2.0";

        /// USB is Device
        pub const DEVICE = struct {
            /// address: 0x41000000
            /// Control A
            pub const CTRLA = @intToPtr(*volatile Mmio(8, packed struct {
                /// Software Reset
                SWRST: u1,
                /// Enable
                ENABLE: u1,
                /// Run in Standby Mode
                RUNSTDBY: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Operating Mode
                MODE: u1,
            }), base_address + 0x0);

            /// address: 0x41000002
            /// Synchronization Busy
            pub const SYNCBUSY = @intToPtr(*volatile Mmio(8, packed struct {
                /// Software Reset Synchronization Busy
                SWRST: u1,
                /// Enable Synchronization Busy
                ENABLE: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0x2);

            /// address: 0x41000003
            /// USB Quality Of Service
            pub const QOSCTRL = @intToPtr(*volatile Mmio(8, packed struct {
                /// Configuration Quality of Service
                CQOS: u2,
                /// Data Quality of Service
                DQOS: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
            }), base_address + 0x3);

            /// address: 0x41000008
            /// DEVICE Control B
            pub const CTRLB = @intToPtr(*volatile Mmio(16, packed struct {
                /// Detach
                DETACH: u1,
                /// Upstream Resume
                UPRSM: u1,
                /// Speed Configuration
                SPDCONF: u2,
                /// No Reply
                NREPLY: u1,
                /// Test mode J
                TSTJ: u1,
                /// Test mode K
                TSTK: u1,
                /// Test packet mode
                TSTPCKT: u1,
                /// Specific Operational Mode
                OPMODE2: u1,
                /// Global NAK
                GNAK: u1,
                /// Link Power Management Handshake
                LPMHDSK: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
            }), base_address + 0x8);

            /// address: 0x4100000a
            /// DEVICE Device Address
            pub const DADD = @intToPtr(*volatile Mmio(8, packed struct {
                /// Device Address
                DADD: u7,
                /// Device Address Enable
                ADDEN: u1,
            }), base_address + 0xa);

            /// address: 0x4100000c
            /// DEVICE Status
            pub const STATUS = @intToPtr(*volatile Mmio(8, packed struct {
                reserved0: u1,
                reserved1: u1,
                /// Speed Status
                SPEED: u2,
                reserved2: u1,
                reserved3: u1,
                /// USB Line State Status
                LINESTATE: u2,
            }), base_address + 0xc);

            /// address: 0x4100000d
            /// Finite State Machine Status
            pub const FSMSTATUS = @intToPtr(*volatile Mmio(8, packed struct {
                /// Fine State Machine Status
                FSMSTATE: u7,
                padding0: u1,
            }), base_address + 0xd);

            /// address: 0x41000010
            /// DEVICE Device Frame Number
            pub const FNUM = @intToPtr(*volatile Mmio(16, packed struct {
                /// Micro Frame Number
                MFNUM: u3,
                /// Frame Number
                FNUM: u11,
                reserved0: u1,
                /// Frame Number CRC Error
                FNCERR: u1,
            }), base_address + 0x10);

            /// address: 0x41000014
            /// DEVICE Device Interrupt Enable Clear
            pub const INTENCLR = @intToPtr(*volatile Mmio(16, packed struct {
                /// Suspend Interrupt Enable
                SUSPEND: u1,
                /// Micro Start of Frame Interrupt Enable in High Speed Mode
                MSOF: u1,
                /// Start Of Frame Interrupt Enable
                SOF: u1,
                /// End of Reset Interrupt Enable
                EORST: u1,
                /// Wake Up Interrupt Enable
                WAKEUP: u1,
                /// End Of Resume Interrupt Enable
                EORSM: u1,
                /// Upstream Resume Interrupt Enable
                UPRSM: u1,
                /// Ram Access Interrupt Enable
                RAMACER: u1,
                /// Link Power Management Not Yet Interrupt Enable
                LPMNYET: u1,
                /// Link Power Management Suspend Interrupt Enable
                LPMSUSP: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0x14);

            /// address: 0x41000018
            /// DEVICE Device Interrupt Enable Set
            pub const INTENSET = @intToPtr(*volatile Mmio(16, packed struct {
                /// Suspend Interrupt Enable
                SUSPEND: u1,
                /// Micro Start of Frame Interrupt Enable in High Speed Mode
                MSOF: u1,
                /// Start Of Frame Interrupt Enable
                SOF: u1,
                /// End of Reset Interrupt Enable
                EORST: u1,
                /// Wake Up Interrupt Enable
                WAKEUP: u1,
                /// End Of Resume Interrupt Enable
                EORSM: u1,
                /// Upstream Resume Interrupt Enable
                UPRSM: u1,
                /// Ram Access Interrupt Enable
                RAMACER: u1,
                /// Link Power Management Not Yet Interrupt Enable
                LPMNYET: u1,
                /// Link Power Management Suspend Interrupt Enable
                LPMSUSP: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0x18);

            /// address: 0x4100001c
            /// DEVICE Device Interrupt Flag
            pub const INTFLAG = @intToPtr(*volatile Mmio(16, packed struct {
                /// Suspend
                SUSPEND: u1,
                /// Micro Start of Frame in High Speed Mode
                MSOF: u1,
                /// Start Of Frame
                SOF: u1,
                /// End of Reset
                EORST: u1,
                /// Wake Up
                WAKEUP: u1,
                /// End Of Resume
                EORSM: u1,
                /// Upstream Resume
                UPRSM: u1,
                /// Ram Access
                RAMACER: u1,
                /// Link Power Management Not Yet
                LPMNYET: u1,
                /// Link Power Management Suspend
                LPMSUSP: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0x1c);

            /// address: 0x41000020
            /// DEVICE End Point Interrupt Summary
            pub const EPINTSMRY = @intToPtr(*volatile Mmio(16, packed struct {
                /// End Point 0 Interrupt
                EPINT0: u1,
                /// End Point 1 Interrupt
                EPINT1: u1,
                /// End Point 2 Interrupt
                EPINT2: u1,
                /// End Point 3 Interrupt
                EPINT3: u1,
                /// End Point 4 Interrupt
                EPINT4: u1,
                /// End Point 5 Interrupt
                EPINT5: u1,
                /// End Point 6 Interrupt
                EPINT6: u1,
                /// End Point 7 Interrupt
                EPINT7: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x20);

            /// address: 0x41000024
            /// Descriptor Address
            pub const DESCADD = @intToPtr(*volatile u32, base_address + 0x24);

            /// address: 0x41000028
            /// USB PAD Calibration
            pub const PADCAL = @intToPtr(*volatile Mmio(16, packed struct {
                /// USB Pad Transp calibration
                TRANSP: u5,
                reserved0: u1,
                /// USB Pad Transn calibration
                TRANSN: u5,
                reserved1: u1,
                /// USB Pad Trim calibration
                TRIM: u3,
                padding0: u1,
            }), base_address + 0x28);
        };

        /// USB is Host
        pub const HOST = struct {
            /// address: 0x41000000
            /// Control A
            pub const CTRLA = @intToPtr(*volatile Mmio(8, packed struct {
                /// Software Reset
                SWRST: u1,
                /// Enable
                ENABLE: u1,
                /// Run in Standby Mode
                RUNSTDBY: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Operating Mode
                MODE: u1,
            }), base_address + 0x0);

            /// address: 0x41000002
            /// Synchronization Busy
            pub const SYNCBUSY = @intToPtr(*volatile Mmio(8, packed struct {
                /// Software Reset Synchronization Busy
                SWRST: u1,
                /// Enable Synchronization Busy
                ENABLE: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0x2);

            /// address: 0x41000003
            /// USB Quality Of Service
            pub const QOSCTRL = @intToPtr(*volatile Mmio(8, packed struct {
                /// Configuration Quality of Service
                CQOS: u2,
                /// Data Quality of Service
                DQOS: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
            }), base_address + 0x3);

            /// address: 0x41000008
            /// HOST Control B
            pub const CTRLB = @intToPtr(*volatile Mmio(16, packed struct {
                reserved0: u1,
                /// Send USB Resume
                RESUME: u1,
                /// Speed Configuration for Host
                SPDCONF: u2,
                /// Auto Resume Enable
                AUTORESUME: u1,
                /// Test mode J
                TSTJ: u1,
                /// Test mode K
                TSTK: u1,
                reserved1: u1,
                /// Start of Frame Generation Enable
                SOFE: u1,
                /// Send USB Reset
                BUSRESET: u1,
                /// VBUS is OK
                VBUSOK: u1,
                /// Send L1 Resume
                L1RESUME: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
            }), base_address + 0x8);

            /// address: 0x4100000a
            /// HOST Host Start Of Frame Control
            pub const HSOFC = @intToPtr(*volatile Mmio(8, packed struct {
                /// Frame Length Control
                FLENC: u4,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// Frame Length Control Enable
                FLENCE: u1,
            }), base_address + 0xa);

            /// address: 0x4100000c
            /// HOST Status
            pub const STATUS = @intToPtr(*volatile Mmio(8, packed struct {
                reserved0: u1,
                reserved1: u1,
                /// Speed Status
                SPEED: u2,
                reserved2: u1,
                reserved3: u1,
                /// USB Line State Status
                LINESTATE: u2,
            }), base_address + 0xc);

            /// address: 0x4100000d
            /// Finite State Machine Status
            pub const FSMSTATUS = @intToPtr(*volatile Mmio(8, packed struct {
                /// Fine State Machine Status
                FSMSTATE: u7,
                padding0: u1,
            }), base_address + 0xd);

            /// address: 0x41000010
            /// HOST Host Frame Number
            pub const FNUM = @intToPtr(*volatile Mmio(16, packed struct {
                /// Micro Frame Number
                MFNUM: u3,
                /// Frame Number
                FNUM: u11,
                padding0: u1,
                padding1: u1,
            }), base_address + 0x10);

            /// address: 0x41000012
            /// HOST Host Frame Length
            pub const FLENHIGH = @intToPtr(*volatile u8, base_address + 0x12);

            /// address: 0x41000014
            /// HOST Host Interrupt Enable Clear
            pub const INTENCLR = @intToPtr(*volatile Mmio(16, packed struct {
                reserved0: u1,
                reserved1: u1,
                /// Host Start Of Frame Interrupt Disable
                HSOF: u1,
                /// BUS Reset Interrupt Disable
                RST: u1,
                /// Wake Up Interrupt Disable
                WAKEUP: u1,
                /// DownStream to Device Interrupt Disable
                DNRSM: u1,
                /// Upstream Resume from Device Interrupt Disable
                UPRSM: u1,
                /// Ram Access Interrupt Disable
                RAMACER: u1,
                /// Device Connection Interrupt Disable
                DCONN: u1,
                /// Device Disconnection Interrupt Disable
                DDISC: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0x14);

            /// address: 0x41000018
            /// HOST Host Interrupt Enable Set
            pub const INTENSET = @intToPtr(*volatile Mmio(16, packed struct {
                reserved0: u1,
                reserved1: u1,
                /// Host Start Of Frame Interrupt Enable
                HSOF: u1,
                /// Bus Reset Interrupt Enable
                RST: u1,
                /// Wake Up Interrupt Enable
                WAKEUP: u1,
                /// DownStream to the Device Interrupt Enable
                DNRSM: u1,
                /// Upstream Resume fromthe device Interrupt Enable
                UPRSM: u1,
                /// Ram Access Interrupt Enable
                RAMACER: u1,
                /// Link Power Management Interrupt Enable
                DCONN: u1,
                /// Device Disconnection Interrupt Enable
                DDISC: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0x18);

            /// address: 0x4100001c
            /// HOST Host Interrupt Flag
            pub const INTFLAG = @intToPtr(*volatile Mmio(16, packed struct {
                reserved0: u1,
                reserved1: u1,
                /// Host Start Of Frame
                HSOF: u1,
                /// Bus Reset
                RST: u1,
                /// Wake Up
                WAKEUP: u1,
                /// Downstream
                DNRSM: u1,
                /// Upstream Resume from the Device
                UPRSM: u1,
                /// Ram Access
                RAMACER: u1,
                /// Device Connection
                DCONN: u1,
                /// Device Disconnection
                DDISC: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
            }), base_address + 0x1c);

            /// address: 0x41000020
            /// HOST Pipe Interrupt Summary
            pub const PINTSMRY = @intToPtr(*volatile Mmio(16, packed struct {
                /// Pipe 0 Interrupt
                EPINT0: u1,
                /// Pipe 1 Interrupt
                EPINT1: u1,
                /// Pipe 2 Interrupt
                EPINT2: u1,
                /// Pipe 3 Interrupt
                EPINT3: u1,
                /// Pipe 4 Interrupt
                EPINT4: u1,
                /// Pipe 5 Interrupt
                EPINT5: u1,
                /// Pipe 6 Interrupt
                EPINT6: u1,
                /// Pipe 7 Interrupt
                EPINT7: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x20);

            /// address: 0x41000024
            /// Descriptor Address
            pub const DESCADD = @intToPtr(*volatile u32, base_address + 0x24);

            /// address: 0x41000028
            /// USB PAD Calibration
            pub const PADCAL = @intToPtr(*volatile Mmio(16, packed struct {
                /// USB Pad Transp calibration
                TRANSP: u5,
                reserved0: u1,
                /// USB Pad Transn calibration
                TRANSN: u5,
                reserved1: u1,
                /// USB Pad Trim calibration
                TRIM: u3,
                padding0: u1,
            }), base_address + 0x28);
        };
    };

    /// Watchdog Timer
    pub const WDT = struct {
        pub const base_address = 0x40002000;
        pub const version = "U22511.1.0";

        /// address: 0x40002000
        /// Control
        pub const CTRLA = @intToPtr(*volatile Mmio(8, packed struct {
            reserved0: u1,
            /// Enable
            ENABLE: u1,
            /// Watchdog Timer Window Mode Enable
            WEN: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Always-On
            ALWAYSON: u1,
        }), base_address + 0x0);

        /// address: 0x40002001
        /// Configuration
        pub const CONFIG = @intToPtr(*volatile Mmio(8, packed struct {
            /// Time-Out Period
            PER: u4,
            /// Window Mode Time-Out Period
            WINDOW: u4,
        }), base_address + 0x1);

        /// address: 0x40002002
        /// Early Warning Interrupt Control
        pub const EWCTRL = @intToPtr(*volatile Mmio(8, packed struct {
            /// Early Warning Interrupt Time Offset
            EWOFFSET: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x2);

        /// address: 0x40002004
        /// Interrupt Enable Clear
        pub const INTENCLR = @intToPtr(*volatile Mmio(8, packed struct {
            /// Early Warning Interrupt Enable
            EW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x4);

        /// address: 0x40002005
        /// Interrupt Enable Set
        pub const INTENSET = @intToPtr(*volatile Mmio(8, packed struct {
            /// Early Warning Interrupt Enable
            EW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x5);

        /// address: 0x40002006
        /// Interrupt Flag Status and Clear
        pub const INTFLAG = @intToPtr(*volatile Mmio(8, packed struct {
            /// Early Warning
            EW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x6);

        /// address: 0x40002008
        /// Synchronization Busy
        pub const SYNCBUSY = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Enable Synchronization Busy
            ENABLE: u1,
            /// Window Enable Synchronization Busy
            WEN: u1,
            /// Always-On Synchronization Busy
            ALWAYSON: u1,
            /// Clear Synchronization Busy
            CLEAR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x8);

        /// address: 0x4000200c
        /// Clear
        pub const CLEAR = @intToPtr(*volatile u8, base_address + 0xc);
    };

    /// Core Debug Register
    pub const CoreDebug = struct {
        pub const base_address = 0xe000edf0;

        /// address: 0xe000edf0
        /// Debug Halting Control and Status Register
        pub const DHCSR = @intToPtr(*volatile Mmio(32, packed struct {
            C_DEBUGEN: u1,
            C_HALT: u1,
            C_STEP: u1,
            C_MASKINTS: u1,
            reserved0: u1,
            C_SNAPSTALL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            S_REGRDY: u1,
            S_HALT: u1,
            S_SLEEP: u1,
            S_LOCKUP: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            S_RETIRE_ST: u1,
            S_RESET_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x0);

        /// address: 0xe000edf4
        /// Debug Core Register Selector Register
        pub const DCRSR = @intToPtr(*volatile Mmio(32, packed struct {
            REGSEL: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            REGWnR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x4);

        /// address: 0xe000edf8
        /// Debug Core Register Data Register
        pub const DCRDR = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0xe000edfc
        /// Debug Exception and Monitor Control Register
        pub const DEMCR = @intToPtr(*volatile Mmio(32, packed struct {
            VC_CORERESET: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            VC_MMERR: u1,
            VC_NOCPERR: u1,
            VC_CHKERR: u1,
            VC_STATERR: u1,
            VC_BUSERR: u1,
            VC_INTERR: u1,
            VC_HARDERR: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            MON_EN: u1,
            MON_PEND: u1,
            MON_STEP: u1,
            MON_REQ: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            TRCENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0xc);
    };

    /// Data Watchpoint and Trace Register
    pub const DWT = struct {
        pub const base_address = 0xe0001000;

        /// address: 0xe0001000
        /// Control Register
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            CYCCNTENA: u1,
            POSTPRESET: u4,
            POSTINIT: u4,
            CYCTAP: u1,
            SYNCTAP: u2,
            PCSAMPLENA: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            EXCTRCENA: u1,
            CPIEVTENA: u1,
            EXCEVTENA: u1,
            SLEEPEVTENA: u1,
            LSUEVTENA: u1,
            FOLDEVTENA: u1,
            CYCEVTENA: u1,
            reserved3: u1,
            NOPRFCNT: u1,
            NOCYCCNT: u1,
            NOEXTTRIG: u1,
            NOTRCPKT: u1,
            NUMCOMP: u4,
        }), base_address + 0x0);

        /// address: 0xe0001004
        /// Cycle Count Register
        pub const CYCCNT = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0xe0001008
        /// CPI Count Register
        pub const CPICNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x8);

        /// address: 0xe000100c
        /// Exception Overhead Count Register
        pub const EXCCNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xc);

        /// address: 0xe0001010
        /// Sleep Count Register
        pub const SLEEPCNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x10);

        /// address: 0xe0001014
        /// LSU Count Register
        pub const LSUCNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x14);

        /// address: 0xe0001018
        /// Folded-instruction Count Register
        pub const FOLDCNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x18);

        /// address: 0xe000101c
        /// Program Counter Sample Register
        pub const PCSR = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0xe0001020
        /// Comparator Register 0
        pub const COMP0 = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0xe0001024
        /// Mask Register 0
        pub const MASK0 = @intToPtr(*volatile Mmio(32, packed struct {
            MASK: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x24);

        /// address: 0xe0001028
        /// Function Register 0
        pub const FUNCTION0 = @intToPtr(*volatile Mmio(32, packed struct {
            FUNCTION: u4,
            reserved0: u1,
            EMITRANGE: u1,
            reserved1: u1,
            CYCMATCH: u1,
            DATAVMATCH: u1,
            LNK1ENA: u1,
            DATAVSIZE: u2,
            DATAVADDR0: u4,
            DATAVADDR1: u4,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            MATCHED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x28);

        /// address: 0xe0001030
        /// Comparator Register 1
        pub const COMP1 = @intToPtr(*volatile u32, base_address + 0x30);

        /// address: 0xe0001034
        /// Mask Register 1
        pub const MASK1 = @intToPtr(*volatile Mmio(32, packed struct {
            MASK: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x34);

        /// address: 0xe0001038
        /// Function Register 1
        pub const FUNCTION1 = @intToPtr(*volatile Mmio(32, packed struct {
            FUNCTION: u4,
            reserved0: u1,
            EMITRANGE: u1,
            reserved1: u1,
            CYCMATCH: u1,
            DATAVMATCH: u1,
            LNK1ENA: u1,
            DATAVSIZE: u2,
            DATAVADDR0: u4,
            DATAVADDR1: u4,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            MATCHED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x38);

        /// address: 0xe0001040
        /// Comparator Register 2
        pub const COMP2 = @intToPtr(*volatile u32, base_address + 0x40);

        /// address: 0xe0001044
        /// Mask Register 2
        pub const MASK2 = @intToPtr(*volatile Mmio(32, packed struct {
            MASK: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x44);

        /// address: 0xe0001048
        /// Function Register 2
        pub const FUNCTION2 = @intToPtr(*volatile Mmio(32, packed struct {
            FUNCTION: u4,
            reserved0: u1,
            EMITRANGE: u1,
            reserved1: u1,
            CYCMATCH: u1,
            DATAVMATCH: u1,
            LNK1ENA: u1,
            DATAVSIZE: u2,
            DATAVADDR0: u4,
            DATAVADDR1: u4,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            MATCHED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x48);

        /// address: 0xe0001050
        /// Comparator Register 3
        pub const COMP3 = @intToPtr(*volatile u32, base_address + 0x50);

        /// address: 0xe0001054
        /// Mask Register 3
        pub const MASK3 = @intToPtr(*volatile Mmio(32, packed struct {
            MASK: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x54);

        /// address: 0xe0001058
        /// Function Register 3
        pub const FUNCTION3 = @intToPtr(*volatile Mmio(32, packed struct {
            FUNCTION: u4,
            reserved0: u1,
            EMITRANGE: u1,
            reserved1: u1,
            CYCMATCH: u1,
            DATAVMATCH: u1,
            LNK1ENA: u1,
            DATAVSIZE: u2,
            DATAVADDR0: u4,
            DATAVADDR1: u4,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            MATCHED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x58);
    };

    /// Embedded Trace Macrocell
    pub const ETM = struct {
        pub const base_address = 0xe0041000;

        /// address: 0xe0041000
        /// ETM Main Control Register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ETM Power Down
            ETMPD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Port Size bits 2:0
            PORTSIZE: u3,
            /// Stall Processor
            STALL: u1,
            /// Branch Output
            BROUT: u1,
            /// Debug Request Control
            DBGRQ: u1,
            /// ETM Programming
            PROG: u1,
            /// ETM Port Select
            PORTSEL: u1,
            reserved3: u1,
            /// Port Mode bit 2
            PORTMODE2: u1,
            reserved4: u1,
            reserved5: u1,
            /// Port Mode bits 1:0
            PORTMODE: u2,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Port Size bit 3
            PORTSIZE3: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// TimeStamp Enable
            TSEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0xe0041004
        /// ETM Configuration Code Register
        pub const CCR = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0xe0041008
        /// ETM Trigger Event Register
        pub const TRIGGER = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0xe0041010
        /// ETM Status Register
        pub const SR = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0xe0041014
        /// ETM System Configuration Register
        pub const SCR = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0xe0041020
        /// ETM TraceEnable Event Register
        pub const TEEVR = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0xe0041024
        /// ETM TraceEnable Control 1 Register
        pub const TECR1 = @intToPtr(*volatile u32, base_address + 0x24);

        /// address: 0xe0041028
        /// ETM FIFO Full Level Register
        pub const FFLR = @intToPtr(*volatile u32, base_address + 0x28);

        /// address: 0xe0041140
        /// ETM Free-running Counter Reload Value
        pub const CNTRLDVR1 = @intToPtr(*volatile u32, base_address + 0x140);

        /// address: 0xe00411e0
        /// ETM Synchronization Frequency Register
        pub const SYNCFR = @intToPtr(*volatile u32, base_address + 0x1e0);

        /// address: 0xe00411e4
        /// ETM ID Register
        pub const IDR = @intToPtr(*volatile u32, base_address + 0x1e4);

        /// address: 0xe00411e8
        /// ETM Configuration Code Extension Register
        pub const CCER = @intToPtr(*volatile u32, base_address + 0x1e8);

        /// address: 0xe00411f0
        /// ETM TraceEnable Start/Stop EmbeddedICE Control Register
        pub const TESSEICR = @intToPtr(*volatile u32, base_address + 0x1f0);

        /// address: 0xe00411f8
        /// ETM TimeStamp Event Register
        pub const TSEVT = @intToPtr(*volatile u32, base_address + 0x1f8);

        /// address: 0xe0041200
        /// ETM CoreSight Trace ID Register
        pub const TRACEIDR = @intToPtr(*volatile u32, base_address + 0x200);

        /// address: 0xe0041208
        /// ETM ID Register 2
        pub const IDR2 = @intToPtr(*volatile u32, base_address + 0x208);

        /// address: 0xe0041314
        /// ETM Device Power-Down Status Register
        pub const PDSR = @intToPtr(*volatile u32, base_address + 0x314);

        /// address: 0xe0041ee0
        /// ETM Integration Test Miscellaneous Inputs
        pub const ITMISCIN = @intToPtr(*volatile u32, base_address + 0xee0);

        /// address: 0xe0041ee8
        /// ETM Integration Test Trigger Out
        pub const ITTRIGOUT = @intToPtr(*volatile u32, base_address + 0xee8);

        /// address: 0xe0041ef0
        /// ETM Integration Test ATB Control 2
        pub const ITATBCTR2 = @intToPtr(*volatile u32, base_address + 0xef0);

        /// address: 0xe0041ef8
        /// ETM Integration Test ATB Control 0
        pub const ITATBCTR0 = @intToPtr(*volatile u32, base_address + 0xef8);

        /// address: 0xe0041f00
        /// ETM Integration Mode Control Register
        pub const ITCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            INTEGRATION: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xf00);

        /// address: 0xe0041fa0
        /// ETM Claim Tag Set Register
        pub const CLAIMSET = @intToPtr(*volatile u32, base_address + 0xfa0);

        /// address: 0xe0041fa4
        /// ETM Claim Tag Clear Register
        pub const CLAIMCLR = @intToPtr(*volatile u32, base_address + 0xfa4);

        /// address: 0xe0041fb0
        /// ETM Lock Access Register
        pub const LAR = @intToPtr(*volatile u32, base_address + 0xfb0);

        /// address: 0xe0041fb4
        /// ETM Lock Status Register
        pub const LSR = @intToPtr(*volatile Mmio(32, packed struct {
            Present: u1,
            Access: u1,
            ByteAcc: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xfb4);

        /// address: 0xe0041fb8
        /// ETM Authentication Status Register
        pub const AUTHSTATUS = @intToPtr(*volatile u32, base_address + 0xfb8);

        /// address: 0xe0041fcc
        /// ETM CoreSight Device Type Register
        pub const DEVTYPE = @intToPtr(*volatile u32, base_address + 0xfcc);

        /// address: 0xe0041fd0
        /// ETM Peripheral Identification Register #4
        pub const PIDR4 = @intToPtr(*volatile u32, base_address + 0xfd0);

        /// address: 0xe0041fd4
        /// ETM Peripheral Identification Register #5
        pub const PIDR5 = @intToPtr(*volatile u32, base_address + 0xfd4);

        /// address: 0xe0041fd8
        /// ETM Peripheral Identification Register #6
        pub const PIDR6 = @intToPtr(*volatile u32, base_address + 0xfd8);

        /// address: 0xe0041fdc
        /// ETM Peripheral Identification Register #7
        pub const PIDR7 = @intToPtr(*volatile u32, base_address + 0xfdc);

        /// address: 0xe0041fe0
        /// ETM Peripheral Identification Register #0
        pub const PIDR0 = @intToPtr(*volatile u32, base_address + 0xfe0);

        /// address: 0xe0041fe4
        /// ETM Peripheral Identification Register #1
        pub const PIDR1 = @intToPtr(*volatile u32, base_address + 0xfe4);

        /// address: 0xe0041fe8
        /// ETM Peripheral Identification Register #2
        pub const PIDR2 = @intToPtr(*volatile u32, base_address + 0xfe8);

        /// address: 0xe0041fec
        /// ETM Peripheral Identification Register #3
        pub const PIDR3 = @intToPtr(*volatile u32, base_address + 0xfec);

        /// address: 0xe0041ff0
        /// ETM Component Identification Register #0
        pub const CIDR0 = @intToPtr(*volatile u32, base_address + 0xff0);

        /// address: 0xe0041ff4
        /// ETM Component Identification Register #1
        pub const CIDR1 = @intToPtr(*volatile u32, base_address + 0xff4);

        /// address: 0xe0041ff8
        /// ETM Component Identification Register #2
        pub const CIDR2 = @intToPtr(*volatile u32, base_address + 0xff8);

        /// address: 0xe0041ffc
        /// ETM Component Identification Register #3
        pub const CIDR3 = @intToPtr(*volatile u32, base_address + 0xffc);
    };

    /// Floating Point Unit
    pub const FPU = struct {
        pub const base_address = 0xe000ef30;

        /// address: 0xe000ef34
        /// Floating-Point Context Control Register
        pub const FPCCR = @intToPtr(*volatile Mmio(32, packed struct {
            LSPACT: u1,
            USER: u1,
            reserved0: u1,
            THREAD: u1,
            HFRDY: u1,
            MMRDY: u1,
            BFRDY: u1,
            reserved1: u1,
            MONRDY: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            LSPEN: u1,
            ASPEN: u1,
        }), base_address + 0x4);

        /// address: 0xe000ef38
        /// Floating-Point Context Address Register
        pub const FPCAR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Address for FP registers in exception stack frame
            ADDRESS: u29,
        }), base_address + 0x8);

        /// address: 0xe000ef3c
        /// Floating-Point Default Status Control Register
        pub const FPDSCR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// Default value for FPSCR.RMODE
            RMODE: u2,
            /// Default value for FPSCR.FZ
            FZ: u1,
            /// Default value for FPSCR.DN
            DN: u1,
            /// Default value for FPSCR.AHP
            AHP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0xc);

        /// address: 0xe000ef40
        /// Media and FP Feature Register 0
        pub const MVFR0 = @intToPtr(*volatile Mmio(32, packed struct {
            A_SIMD_registers: u4,
            Single_precision: u4,
            Double_precision: u4,
            FP_excep_trapping: u4,
            Divide: u4,
            Square_root: u4,
            Short_vectors: u4,
            FP_rounding_modes: u4,
        }), base_address + 0x10);

        /// address: 0xe000ef44
        /// Media and FP Feature Register 1
        pub const MVFR1 = @intToPtr(*volatile Mmio(32, packed struct {
            FtZ_mode: u4,
            D_NaN_mode: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            FP_HPFP: u4,
            FP_fused_MAC: u4,
        }), base_address + 0x14);
    };

    /// Instrumentation Trace Macrocell
    pub const ITM = struct {
        pub const base_address = 0xe0000000;

        /// address: 0xe0000000
        /// ITM Stimulus Port Registers
        pub const PORT_WORD_MODE = @intToPtr(*volatile [32]Mmio(32, packed struct {
            PORT: u32,
        }), base_address + 0x0);

        /// address: 0xe0000000
        /// ITM Stimulus Port Registers
        pub const PORT_BYTE_MODE = @intToPtr(*volatile [32]Mmio(32, packed struct {
            PORT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0xe0000000
        /// ITM Stimulus Port Registers
        pub const PORT_HWORD_MODE = @intToPtr(*volatile [32]Mmio(32, packed struct {
            PORT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0xe0000e00
        /// ITM Trace Enable Register
        pub const TER = @intToPtr(*volatile u32, base_address + 0xe00);

        /// address: 0xe0000e40
        /// ITM Trace Privilege Register
        pub const TPR = @intToPtr(*volatile Mmio(32, packed struct {
            PRIVMASK: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0xe40);

        /// address: 0xe0000e80
        /// ITM Trace Control Register
        pub const TCR = @intToPtr(*volatile Mmio(32, packed struct {
            ITMENA: u1,
            TSENA: u1,
            SYNCENA: u1,
            DWTENA: u1,
            SWOENA: u1,
            STALLENA: u1,
            reserved0: u1,
            reserved1: u1,
            TSPrescale: u2,
            GTSFREQ: u2,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            TraceBusID: u7,
            BUSY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xe80);

        /// address: 0xe0000ef8
        /// ITM Integration Write Register
        pub const IWR = @intToPtr(*volatile Mmio(32, packed struct {
            ATVALIDM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xef8);

        /// address: 0xe0000efc
        /// ITM Integration Read Register
        pub const IRR = @intToPtr(*volatile Mmio(32, packed struct {
            ATREADYM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xefc);
    };

    /// Memory Protection Unit
    pub const MPU = struct {
        pub const base_address = 0xe000ed90;

        /// address: 0xe000ed90
        /// MPU Type Register
        pub const TYPE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Separate instruction and Data Memory MapsRegions
            SEPARATE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Number of Data Regions
            DREGION: u8,
            /// Number of Instruction Regions
            IREGION: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0xe000ed94
        /// MPU Control Register
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPU Enable
            ENABLE: u1,
            /// Enable Hard Fault and NMI handlers
            HFNMIENA: u1,
            /// Enables privileged software access to default memory map
            PRIVDEFENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4);

        /// address: 0xe000ed98
        /// MPU Region Number Register
        pub const RNR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Region referenced by RBAR and RASR
            REGION: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0xe000ed9c
        /// MPU Region Base Address Register
        pub const RBAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Region number
            REGION: u4,
            /// Region number valid
            VALID: u1,
            /// Region base address
            ADDR: u27,
        }), base_address + 0xc);

        /// address: 0xe000eda0
        /// MPU Region Attribute and Size Register
        pub const RASR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Region Enable
            ENABLE: u1,
            /// Region Size
            SIZE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Sub-region disable
            SRD: u8,
            /// Bufferable bit
            B: u1,
            /// Cacheable bit
            C: u1,
            /// Shareable bit
            S: u1,
            /// TEX bit
            TEX: u3,
            reserved6: u1,
            reserved7: u1,
            /// Access Permission
            AP: u3,
            reserved8: u1,
            /// Execute Never Attribute
            XN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x10);

        /// address: 0xe000eda4
        /// MPU Alias 1 Region Base Address Register
        pub const RBAR_A1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Region number
            REGION: u4,
            /// Region number valid
            VALID: u1,
            /// Region base address
            ADDR: u27,
        }), base_address + 0x14);

        /// address: 0xe000eda8
        /// MPU Alias 1 Region Attribute and Size Register
        pub const RASR_A1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Region Enable
            ENABLE: u1,
            /// Region Size
            SIZE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Sub-region disable
            SRD: u8,
            /// Bufferable bit
            B: u1,
            /// Cacheable bit
            C: u1,
            /// Shareable bit
            S: u1,
            /// TEX bit
            TEX: u3,
            reserved6: u1,
            reserved7: u1,
            /// Access Permission
            AP: u3,
            reserved8: u1,
            /// Execute Never Attribute
            XN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x18);

        /// address: 0xe000edac
        /// MPU Alias 2 Region Base Address Register
        pub const RBAR_A2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Region number
            REGION: u4,
            /// Region number valid
            VALID: u1,
            /// Region base address
            ADDR: u27,
        }), base_address + 0x1c);

        /// address: 0xe000edb0
        /// MPU Alias 2 Region Attribute and Size Register
        pub const RASR_A2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Region Enable
            ENABLE: u1,
            /// Region Size
            SIZE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Sub-region disable
            SRD: u8,
            /// Bufferable bit
            B: u1,
            /// Cacheable bit
            C: u1,
            /// Shareable bit
            S: u1,
            /// TEX bit
            TEX: u3,
            reserved6: u1,
            reserved7: u1,
            /// Access Permission
            AP: u3,
            reserved8: u1,
            /// Execute Never Attribute
            XN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x20);

        /// address: 0xe000edb4
        /// MPU Alias 3 Region Base Address Register
        pub const RBAR_A3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Region number
            REGION: u4,
            /// Region number valid
            VALID: u1,
            /// Region base address
            ADDR: u27,
        }), base_address + 0x24);

        /// address: 0xe000edb8
        /// MPU Alias 3 Region Attribute and Size Register
        pub const RASR_A3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Region Enable
            ENABLE: u1,
            /// Region Size
            SIZE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Sub-region disable
            SRD: u8,
            /// Bufferable bit
            B: u1,
            /// Cacheable bit
            C: u1,
            /// Shareable bit
            S: u1,
            /// TEX bit
            TEX: u3,
            reserved6: u1,
            reserved7: u1,
            /// Access Permission
            AP: u3,
            reserved8: u1,
            /// Execute Never Attribute
            XN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x28);
    };

    /// Nested Vectored Interrupt Controller
    pub const NVIC = struct {
        pub const base_address = 0xe000e100;

        /// address: 0xe000e100
        /// Interrupt Set Enable Register
        pub const ISER = @intToPtr(*volatile [5]Mmio(32, packed struct {
            /// Interrupt set enable bits
            SETENA: u32,
        }), base_address + 0x0);

        /// address: 0xe000e180
        /// Interrupt Clear Enable Register
        pub const ICER = @intToPtr(*volatile [5]Mmio(32, packed struct {
            /// Interrupt clear-enable bits
            CLRENA: u32,
        }), base_address + 0x80);

        /// address: 0xe000e200
        /// Interrupt Set Pending Register
        pub const ISPR = @intToPtr(*volatile [5]Mmio(32, packed struct {
            /// Interrupt set-pending bits
            SETPEND: u32,
        }), base_address + 0x100);

        /// address: 0xe000e280
        /// Interrupt Clear Pending Register
        pub const ICPR = @intToPtr(*volatile [5]Mmio(32, packed struct {
            /// Interrupt clear-pending bits
            CLRPEND: u32,
        }), base_address + 0x180);

        /// address: 0xe000e300
        /// Interrupt Active Bit Register
        pub const IABR = @intToPtr(*volatile [5]Mmio(32, packed struct {
            /// Interrupt active bits
            ACTIVE: u32,
        }), base_address + 0x200);

        /// address: 0xe000e400
        /// Interrupt Priority Register n
        pub const IP = @intToPtr(*volatile [35]Mmio(8, packed struct {
            /// Priority of interrupt n
            PRI0: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x300);

        /// address: 0xe000ef00
        /// Software Trigger Interrupt Register
        pub const STIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt ID to trigger
            INTID: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0xe00);
    };

    /// System timer
    pub const SysTick = struct {
        pub const base_address = 0xe000e010;
    };

    /// System Control Registers
    pub const SystemControl = struct {
        pub const base_address = 0xe000e000;

        /// address: 0xe000e004
        /// Interrupt Controller Type Register
        pub const ICTR = @intToPtr(*volatile Mmio(32, packed struct {
            INTLINESNUM: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x4);

        /// address: 0xe000e008
        /// Auxiliary Control Register
        pub const ACTLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Disable interruption of LDM/STM instructions
            DISMCYCINT: u1,
            /// Disable wruite buffer use during default memory map accesses
            DISDEFWBUF: u1,
            /// Disable IT folding
            DISFOLD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Disable automatic update of CONTROL.FPCA
            DISFPCA: u1,
            /// Disable out-of-order FP instructions
            DISOOFP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x8);

        /// address: 0xe000ed00
        /// CPUID Base Register
        pub const CPUID = @intToPtr(*volatile Mmio(32, packed struct {
            /// Processor revision number
            REVISION: u4,
            /// Process Part Number, 0xC24=Cortex-M4
            PARTNO: u12,
            /// Constant
            CONSTANT: u4,
            /// Variant number
            VARIANT: u4,
            /// Implementer code, 0x41=ARM
            IMPLEMENTER: u8,
        }), base_address + 0xd00);

        /// address: 0xe000ed04
        /// Interrupt Control and State Register
        pub const ICSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Active exception number
            VECTACTIVE: u9,
            reserved0: u1,
            reserved1: u1,
            /// No preempted active exceptions to execute
            RETTOBASE: u1,
            /// Exception number of the highest priority pending enabled exception
            VECTPENDING: u6,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Interrupt pending flag
            ISRPENDING: u1,
            /// Debug only
            ISRPREEMPT: u1,
            reserved6: u1,
            /// SysTick clear-pending bit
            PENDSTCLR: u1,
            /// SysTick set-pending bit
            PENDSTSET: u1,
            /// PendSV clear-pending bit
            PENDSVCLR: u1,
            /// PendSV set-pending bit
            PENDSVSET: u1,
            reserved7: u1,
            reserved8: u1,
            /// NMI set-pending bit
            NMIPENDSET: u1,
        }), base_address + 0xd04);

        /// address: 0xe000ed08
        /// Vector Table Offset Register
        pub const VTOR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Vector table base offset
            TBLOFF: u25,
        }), base_address + 0xd08);

        /// address: 0xe000ed0c
        /// Application Interrupt and Reset Control Register
        pub const AIRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Must write 0
            VECTRESET: u1,
            /// Must write 0
            VECTCLRACTIVE: u1,
            /// System Reset Request
            SYSRESETREQ: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Interrupt priority grouping
            PRIGROUP: u3,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Data endianness, 0=little, 1=big
            ENDIANNESS: u1,
            /// Register key
            VECTKEY: u16,
        }), base_address + 0xd0c);

        /// address: 0xe000ed10
        /// System Control Register
        pub const SCR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Sleep-on-exit on handler return
            SLEEPONEXIT: u1,
            /// Deep Sleep used as low power mode
            SLEEPDEEP: u1,
            reserved1: u1,
            /// Send Event on Pending bit
            SEVONPEND: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0xd10);

        /// address: 0xe000ed14
        /// Configuration and Control Register
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates how processor enters Thread mode
            NONBASETHRDENA: u1,
            /// Enables unprivileged software access to STIR register
            USERSETMPEND: u1,
            reserved0: u1,
            /// Enables unaligned access traps
            UNALIGN_TRP: u1,
            /// Enables divide by 0 trap
            DIV_0_TRP: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Ignore LDM/STM BusFault for -1/-2 priority handlers
            BFHFNMIGN: u1,
            /// Indicates stack alignment on exception entry
            STKALIGN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0xd14);

        /// address: 0xe000ed18
        /// System Handler Priority Register 1
        pub const SHPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Priority of system handler 4, MemManage
            PRI_4: u8,
            /// Priority of system handler 5, BusFault
            PRI_5: u8,
            /// Priority of system handler 6, UsageFault
            PRI_6: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xd18);

        /// address: 0xe000ed1c
        /// System Handler Priority Register 2
        pub const SHPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// Priority of system handler 11, SVCall
            PRI_11: u8,
        }), base_address + 0xd1c);

        /// address: 0xe000ed20
        /// System Handler Priority Register 3
        pub const SHPR3 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Priority of system handler 14, PendSV
            PRI_14: u8,
            /// Priority of system handler 15, SysTick exception
            PRI_15: u8,
        }), base_address + 0xd20);

        /// address: 0xe000ed24
        /// System Handler Control and State Register
        pub const SHCSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MemManage exception active bit
            MEMFAULTACT: u1,
            /// BusFault exception active bit
            BUSFAULTACT: u1,
            reserved0: u1,
            /// UsageFault exception active bit
            USGFAULTACT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// SVCall active bit
            SVCALLACT: u1,
            /// DebugMonitor exception active bit
            MONITORACT: u1,
            reserved4: u1,
            /// PendSV exception active bit
            PENDSVACT: u1,
            /// SysTick exception active bit
            SYSTICKACT: u1,
            /// UsageFault exception pending bit
            USGFAULTPENDED: u1,
            /// MemManage exception pending bit
            MEMFAULTPENDED: u1,
            /// BusFault exception pending bit
            BUSFAULTPENDED: u1,
            /// SVCall pending bit
            SVCALLPENDED: u1,
            /// MemManage enable bit
            MEMFAULTENA: u1,
            /// BusFault enable bit
            BUSFAULTENA: u1,
            /// UsageFault enable bit
            USGFAULTENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xd24);

        /// address: 0xe000ed28
        /// Configurable Fault Status Register
        pub const CFSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Instruction access violation
            IACCVIOL: u1,
            /// Data access violation
            DACCVIOL: u1,
            reserved0: u1,
            /// MemManage Fault on unstacking for exception return
            MUNSTKERR: u1,
            /// MemManage Fault on stacking for exception entry
            MSTKERR: u1,
            /// MemManager Fault occured during FP lazy state preservation
            MLSPERR: u1,
            reserved1: u1,
            /// MemManage Fault Address Register valid
            MMARVALID: u1,
            /// Instruction bus error
            IBUSERR: u1,
            /// Precise data bus error
            PRECISERR: u1,
            /// Imprecise data bus error
            IMPRECISERR: u1,
            /// BusFault on unstacking for exception return
            UNSTKERR: u1,
            /// BusFault on stacking for exception entry
            STKERR: u1,
            /// BusFault occured during FP lazy state preservation
            LSPERR: u1,
            reserved2: u1,
            /// BusFault Address Register valid
            BFARVALID: u1,
            /// Undefined instruction UsageFault
            UNDEFINSTR: u1,
            /// Invalid state UsageFault
            INVSTATE: u1,
            /// Invalid PC load UsageFault
            INVPC: u1,
            /// No coprocessor UsageFault
            NOCP: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Unaligned access UsageFault
            UNALIGNED: u1,
            /// Divide by zero UsageFault
            DIVBYZERO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0xd28);

        /// address: 0xe000ed2c
        /// HardFault Status Register
        pub const HFSR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// BusFault on a Vector Table read during exception processing
            VECTTBL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            /// Forced Hard Fault
            FORCED: u1,
            /// Debug: always write 0
            DEBUGEVT: u1,
        }), base_address + 0xd2c);

        /// address: 0xe000ed30
        /// Debug Fault Status Register
        pub const DFSR = @intToPtr(*volatile Mmio(32, packed struct {
            HALTED: u1,
            BKPT: u1,
            DWTTRAP: u1,
            VCATCH: u1,
            EXTERNAL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0xd30);

        /// address: 0xe000ed34
        /// MemManage Fault Address Register
        pub const MMFAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address that generated the MemManage fault
            ADDRESS: u32,
        }), base_address + 0xd34);

        /// address: 0xe000ed38
        /// BusFault Address Register
        pub const BFAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address that generated the BusFault
            ADDRESS: u32,
        }), base_address + 0xd38);

        /// address: 0xe000ed3c
        /// Auxiliary Fault Status Register
        pub const AFSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// AUXFAULT input signals
            IMPDEF: u32,
        }), base_address + 0xd3c);

        /// address: 0xe000ed40
        /// Processor Feature Register
        pub const PFR = @intToPtr(*volatile [2]u32, base_address + 0xd40);

        /// address: 0xe000ed48
        /// Debug Feature Register
        pub const DFR = @intToPtr(*volatile u32, base_address + 0xd48);

        /// address: 0xe000ed4c
        /// Auxiliary Feature Register
        pub const ADR = @intToPtr(*volatile u32, base_address + 0xd4c);

        /// address: 0xe000ed50
        /// Memory Model Feature Register
        pub const MMFR = @intToPtr(*volatile [4]u32, base_address + 0xd50);

        /// address: 0xe000ed60
        /// Instruction Set Attributes Register
        pub const ISAR = @intToPtr(*volatile [5]u32, base_address + 0xd60);

        /// address: 0xe000ed88
        /// Coprocessor Access Control Register
        pub const CPACR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// Access privileges for coprocessor 10
            CP10: u2,
            /// Access privileges for coprocessor 11
            CP11: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xd88);
    };

    /// Trace Port Interface Register
    pub const TPI = struct {
        pub const base_address = 0xe0040000;

        /// address: 0xe0040000
        /// Supported Parallel Port Size Register
        pub const SSPSR = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0xe0040004
        /// Current Parallel Port Size Register
        pub const CSPSR = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0xe0040010
        /// Asynchronous Clock Prescaler Register
        pub const ACPR = @intToPtr(*volatile Mmio(32, packed struct {
            PRESCALER: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0xe00400f0
        /// Selected Pin Protocol Register
        pub const SPPR = @intToPtr(*volatile Mmio(32, packed struct {
            TXMODE: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xf0);

        /// address: 0xe0040300
        /// Formatter and Flush Status Register
        pub const FFSR = @intToPtr(*volatile Mmio(32, packed struct {
            FlInProg: u1,
            FtStopped: u1,
            TCPresent: u1,
            FtNonStop: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x300);

        /// address: 0xe0040304
        /// Formatter and Flush Control Register
        pub const FFCR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            EnFCont: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            TrigIn: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x304);

        /// address: 0xe0040308
        /// Formatter Synchronization Counter Register
        pub const FSCR = @intToPtr(*volatile u32, base_address + 0x308);

        /// address: 0xe0040ee8
        /// TRIGGER
        pub const TRIGGER = @intToPtr(*volatile MmioInt(32, u1), base_address + 0xee8);

        /// address: 0xe0040eec
        /// Integration ETM Data
        pub const FIFO0 = @intToPtr(*volatile Mmio(32, packed struct {
            ETM0: u8,
            ETM1: u8,
            ETM2: u8,
            ETM_bytecount: u2,
            ETM_ATVALID: u1,
            ITM_bytecount: u2,
            ITM_ATVALID: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xeec);

        /// address: 0xe0040ef0
        /// ITATBCTR2
        pub const ITATBCTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            ATREADY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xef0);

        /// address: 0xe0040ef8
        /// ITATBCTR0
        pub const ITATBCTR0 = @intToPtr(*volatile Mmio(32, packed struct {
            ATREADY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xef8);

        /// address: 0xe0040efc
        /// Integration ITM Data
        pub const FIFO1 = @intToPtr(*volatile Mmio(32, packed struct {
            ITM0: u8,
            ITM1: u8,
            ITM2: u8,
            ETM_bytecount: u2,
            ETM_ATVALID: u1,
            ITM_bytecount: u2,
            ITM_ATVALID: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xefc);

        /// address: 0xe0040f00
        /// Integration Mode Control
        pub const ITCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            Mode: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xf00);

        /// address: 0xe0040fa0
        /// Claim tag set
        pub const CLAIMSET = @intToPtr(*volatile u32, base_address + 0xfa0);

        /// address: 0xe0040fa4
        /// Claim tag clear
        pub const CLAIMCLR = @intToPtr(*volatile u32, base_address + 0xfa4);

        /// address: 0xe0040fc8
        /// TPIU_DEVID
        pub const DEVID = @intToPtr(*volatile Mmio(32, packed struct {
            NrTraceInput: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            AsynClkIn: u1,
            MinBufSz: u3,
            PTINVALID: u1,
            MANCVALID: u1,
            NRZVALID: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0xfc8);

        /// address: 0xe0040fcc
        /// TPIU_DEVTYPE
        pub const DEVTYPE = @intToPtr(*volatile Mmio(32, packed struct {
            SubType: u4,
            MajorType: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xfcc);
    };
};

const std = @import("std");

pub fn mmio(addr: usize, comptime size: u8, comptime PackedT: type) *volatile Mmio(size, PackedT) {
    return @intToPtr(*volatile Mmio(size, PackedT), addr);
}

pub fn Mmio(comptime size: u8, comptime PackedT: type) type {
    if ((size % 8) != 0)
        @compileError("size must be divisible by 8!");

    if (!std.math.isPowerOfTwo(size / 8))
        @compileError("size must encode a power of two number of bytes!");

    const IntT = std.meta.Int(.unsigned, size);

    if (@sizeOf(PackedT) != (size / 8))
        @compileError(std.fmt.comptimePrint("IntT and PackedT must have the same size!, they are {} and {} bytes respectively", .{ size / 8, @sizeOf(PackedT) }));

    return extern struct {
        const Self = @This();

        raw: IntT,

        pub const underlying_type = PackedT;

        pub inline fn read(addr: *volatile Self) PackedT {
            return @bitCast(PackedT, addr.raw);
        }

        pub inline fn write(addr: *volatile Self, val: PackedT) void {
            // This is a workaround for a compiler bug related to miscompilation
            // If the tmp var is not used, result location will fuck things up
            var tmp = @bitCast(IntT, val);
            addr.raw = tmp;
        }

        pub inline fn modify(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, field.name) = @field(fields, field.name);
            }
            write(addr, val);
        }

        pub inline fn toggle(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, @tagName(field.default_value.?)) = !@field(val, @tagName(field.default_value.?));
            }
            write(addr, val);
        }
    };
}

pub fn MmioInt(comptime size: u8, comptime T: type) type {
    return extern struct {
        const Self = @This();

        raw: std.meta.Int(.unsigned, size),

        pub inline fn read(addr: *volatile Self) T {
            return @truncate(T, addr.raw);
        }

        pub inline fn modify(addr: *volatile Self, val: T) void {
            const Int = std.meta.Int(.unsigned, size);
            const mask = ~@as(Int, (1 << @bitSizeOf(T)) - 1);

            var tmp = addr.raw;
            addr.raw = (tmp & mask) | val;
        }
    };
}

pub fn mmioInt(addr: usize, comptime size: usize, comptime T: type) *volatile MmioInt(size, T) {
    return @intToPtr(*volatile MmioInt(size, T), addr);
}

pub const InterruptVector = extern union {
    C: fn () callconv(.C) void,
    Naked: fn () callconv(.Naked) void,
    // Interrupt is not supported on arm
};

const unhandled = InterruptVector{
    .C = struct {
        fn tmp() callconv(.C) noreturn {
            @panic("unhandled interrupt");
        }
    }.tmp,
};
