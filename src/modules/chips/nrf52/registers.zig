// this file is generated by regz
//
// vendor: Nordic Semiconductor
// device: nrf52
// cpu: CM4

pub const VectorTable = extern struct {
    initial_stack_pointer: u32,
    Reset: InterruptVector = unhandled,
    NMI: InterruptVector = unhandled,
    HardFault: InterruptVector = unhandled,
    MemManage: InterruptVector = unhandled,
    BusFault: InterruptVector = unhandled,
    UsageFault: InterruptVector = unhandled,
    reserved0: [4]u32 = undefined,
    SVCall: InterruptVector = unhandled,
    reserved1: [2]u32 = undefined,
    PendSV: InterruptVector = unhandled,
    SysTick: InterruptVector = unhandled,
    POWER_CLOCK: InterruptVector = unhandled,
    RADIO: InterruptVector = unhandled,
    UARTE0_UART0: InterruptVector = unhandled,
    SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0: InterruptVector = unhandled,
    SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1: InterruptVector = unhandled,
    NFCT: InterruptVector = unhandled,
    GPIOTE: InterruptVector = unhandled,
    SAADC: InterruptVector = unhandled,
    TIMER0: InterruptVector = unhandled,
    TIMER1: InterruptVector = unhandled,
    TIMER2: InterruptVector = unhandled,
    RTC0: InterruptVector = unhandled,
    TEMP: InterruptVector = unhandled,
    RNG: InterruptVector = unhandled,
    ECB: InterruptVector = unhandled,
    CCM_AAR: InterruptVector = unhandled,
    WDT: InterruptVector = unhandled,
    RTC1: InterruptVector = unhandled,
    QDEC: InterruptVector = unhandled,
    COMP_LPCOMP: InterruptVector = unhandled,
    SWI0_EGU0: InterruptVector = unhandled,
    SWI1_EGU1: InterruptVector = unhandled,
    SWI2_EGU2: InterruptVector = unhandled,
    SWI3_EGU3: InterruptVector = unhandled,
    SWI4_EGU4: InterruptVector = unhandled,
    SWI5_EGU5: InterruptVector = unhandled,
    TIMER3: InterruptVector = unhandled,
    TIMER4: InterruptVector = unhandled,
    PWM0: InterruptVector = unhandled,
    PDM: InterruptVector = unhandled,
    reserved2: u32 = undefined,
    reserved3: u32 = undefined,
    MWU: InterruptVector = unhandled,
    PWM1: InterruptVector = unhandled,
    PWM2: InterruptVector = unhandled,
    SPIM2_SPIS2_SPI2: InterruptVector = unhandled,
    RTC2: InterruptVector = unhandled,
    I2S: InterruptVector = unhandled,
    FPU: InterruptVector = unhandled,
};

pub const registers = struct {
    /// Factory Information Configuration Registers
    pub const FICR = struct {
        pub const base_address = 0x10000000;

        /// address: 0x10000010
        /// Code memory page size
        pub const CODEPAGESIZE = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x10000014
        /// Code memory size
        pub const CODESIZE = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x10000060
        /// Description collection[0]: Device identifier
        pub const DEVICEID = @intToPtr(*volatile [2]u32, base_address + 0x60);

        /// address: 0x10000080
        /// Description collection[0]: Encryption Root, word 0
        pub const ER = @intToPtr(*volatile [4]u32, base_address + 0x80);

        /// address: 0x10000090
        /// Description collection[0]: Identity Root, word 0
        pub const IR = @intToPtr(*volatile [4]u32, base_address + 0x90);

        /// address: 0x100000a0
        /// Device address type
        pub const DEVICEADDRTYPE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0xa0);

        /// address: 0x100000a4
        /// Description collection[0]: Device address 0
        pub const DEVICEADDR = @intToPtr(*volatile [2]u32, base_address + 0xa4);

        /// Device info
        pub const INFO = struct {

            /// address: 0x10000000
            /// Part code
            pub const PART = @intToPtr(*volatile u32, base_address + 0x0);

            /// address: 0x10000004
            /// Part Variant, Hardware version and Production configuration
            pub const VARIANT = @intToPtr(*volatile u32, base_address + 0x4);

            /// address: 0x10000008
            /// Package option
            pub const PACKAGE = @intToPtr(*volatile u32, base_address + 0x8);

            /// address: 0x1000000c
            /// RAM variant
            pub const RAM = @intToPtr(*volatile u32, base_address + 0xc);

            /// address: 0x10000010
            /// Flash variant
            pub const FLASH = @intToPtr(*volatile u32, base_address + 0x10);

            /// address: 0x10000014
            /// Description collection[0]: Unspecified
            pub const UNUSED0 = @intToPtr(*volatile [3]u32, base_address + 0x14);
        };

        /// Registers storing factory TEMP module linearization coefficients
        pub const TEMP = struct {

            /// address: 0x10000000
            /// Slope definition A0.
            pub const A0 = @intToPtr(*volatile Mmio(32, packed struct {
                /// A (slope definition) register.
                A: u12,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
            }), base_address + 0x0);

            /// address: 0x10000004
            /// Slope definition A1.
            pub const A1 = @intToPtr(*volatile Mmio(32, packed struct {
                /// A (slope definition) register.
                A: u12,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
            }), base_address + 0x4);

            /// address: 0x10000008
            /// Slope definition A2.
            pub const A2 = @intToPtr(*volatile Mmio(32, packed struct {
                /// A (slope definition) register.
                A: u12,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
            }), base_address + 0x8);

            /// address: 0x1000000c
            /// Slope definition A3.
            pub const A3 = @intToPtr(*volatile Mmio(32, packed struct {
                /// A (slope definition) register.
                A: u12,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
            }), base_address + 0xc);

            /// address: 0x10000010
            /// Slope definition A4.
            pub const A4 = @intToPtr(*volatile Mmio(32, packed struct {
                /// A (slope definition) register.
                A: u12,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
            }), base_address + 0x10);

            /// address: 0x10000014
            /// Slope definition A5.
            pub const A5 = @intToPtr(*volatile Mmio(32, packed struct {
                /// A (slope definition) register.
                A: u12,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
            }), base_address + 0x14);

            /// address: 0x10000018
            /// y-intercept B0.
            pub const B0 = @intToPtr(*volatile Mmio(32, packed struct {
                /// B (y-intercept)
                B: u14,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
            }), base_address + 0x18);

            /// address: 0x1000001c
            /// y-intercept B1.
            pub const B1 = @intToPtr(*volatile Mmio(32, packed struct {
                /// B (y-intercept)
                B: u14,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
            }), base_address + 0x1c);

            /// address: 0x10000020
            /// y-intercept B2.
            pub const B2 = @intToPtr(*volatile Mmio(32, packed struct {
                /// B (y-intercept)
                B: u14,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
            }), base_address + 0x20);

            /// address: 0x10000024
            /// y-intercept B3.
            pub const B3 = @intToPtr(*volatile Mmio(32, packed struct {
                /// B (y-intercept)
                B: u14,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
            }), base_address + 0x24);

            /// address: 0x10000028
            /// y-intercept B4.
            pub const B4 = @intToPtr(*volatile Mmio(32, packed struct {
                /// B (y-intercept)
                B: u14,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
            }), base_address + 0x28);

            /// address: 0x1000002c
            /// y-intercept B5.
            pub const B5 = @intToPtr(*volatile Mmio(32, packed struct {
                /// B (y-intercept)
                B: u14,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
            }), base_address + 0x2c);

            /// address: 0x10000030
            /// Segment end T0.
            pub const T0 = @intToPtr(*volatile Mmio(32, packed struct {
                /// T (segment end)register.
                T: u8,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
            }), base_address + 0x30);

            /// address: 0x10000034
            /// Segment end T1.
            pub const T1 = @intToPtr(*volatile Mmio(32, packed struct {
                /// T (segment end)register.
                T: u8,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
            }), base_address + 0x34);

            /// address: 0x10000038
            /// Segment end T2.
            pub const T2 = @intToPtr(*volatile Mmio(32, packed struct {
                /// T (segment end)register.
                T: u8,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
            }), base_address + 0x38);

            /// address: 0x1000003c
            /// Segment end T3.
            pub const T3 = @intToPtr(*volatile Mmio(32, packed struct {
                /// T (segment end)register.
                T: u8,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
            }), base_address + 0x3c);

            /// address: 0x10000040
            /// Segment end T4.
            pub const T4 = @intToPtr(*volatile Mmio(32, packed struct {
                /// T (segment end)register.
                T: u8,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
            }), base_address + 0x40);
        };

        pub const NFC = struct {

            /// address: 0x10000000
            /// Default header for NFC Tag. Software can read these values to populate
            /// NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
            pub const TAGHEADER0 = @intToPtr(*volatile Mmio(32, packed struct {
                /// Default Manufacturer ID: Nordic Semiconductor ASA has ICM 0x5F
                MFGID: u8,
                /// Unique identifier byte 1
                UD1: u8,
                /// Unique identifier byte 2
                UD2: u8,
                /// Unique identifier byte 3
                UD3: u8,
            }), base_address + 0x0);

            /// address: 0x10000004
            /// Default header for NFC Tag. Software can read these values to populate
            /// NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
            pub const TAGHEADER1 = @intToPtr(*volatile Mmio(32, packed struct {
                /// Unique identifier byte 4
                UD4: u8,
                /// Unique identifier byte 5
                UD5: u8,
                /// Unique identifier byte 6
                UD6: u8,
                /// Unique identifier byte 7
                UD7: u8,
            }), base_address + 0x4);

            /// address: 0x10000008
            /// Default header for NFC Tag. Software can read these values to populate
            /// NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
            pub const TAGHEADER2 = @intToPtr(*volatile Mmio(32, packed struct {
                /// Unique identifier byte 8
                UD8: u8,
                /// Unique identifier byte 9
                UD9: u8,
                /// Unique identifier byte 10
                UD10: u8,
                /// Unique identifier byte 11
                UD11: u8,
            }), base_address + 0x8);

            /// address: 0x1000000c
            /// Default header for NFC Tag. Software can read these values to populate
            /// NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST.
            pub const TAGHEADER3 = @intToPtr(*volatile Mmio(32, packed struct {
                /// Unique identifier byte 12
                UD12: u8,
                /// Unique identifier byte 13
                UD13: u8,
                /// Unique identifier byte 14
                UD14: u8,
                /// Unique identifier byte 15
                UD15: u8,
            }), base_address + 0xc);
        };
    };
    /// User Information Configuration Registers
    pub const UICR = struct {
        pub const base_address = 0x10001000;

        /// address: 0x10001000
        /// Unspecified
        pub const UNUSED0 = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x10001004
        /// Unspecified
        pub const UNUSED1 = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x10001008
        /// Unspecified
        pub const UNUSED2 = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x10001010
        /// Unspecified
        pub const UNUSED3 = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x10001014
        /// Description collection[0]: Reserved for Nordic firmware design
        pub const NRFFW = @intToPtr(*volatile [15]u32, base_address + 0x14);

        /// address: 0x10001050
        /// Description collection[0]: Reserved for Nordic hardware design
        pub const NRFHW = @intToPtr(*volatile [12]u32, base_address + 0x50);

        /// address: 0x10001080
        /// Description collection[0]: Reserved for customer
        pub const CUSTOMER = @intToPtr(*volatile [32]u32, base_address + 0x80);

        /// address: 0x10001200
        /// Description collection[0]: Mapping of the nRESET function (see POWER chapter for
        /// details)
        pub const PSELRESET = @intToPtr(*volatile [2]Mmio(32, packed struct {
            /// GPIO number P0.n onto which Reset is exposed
            PIN: u6,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            /// Connection
            CONNECT: u1,
        }), base_address + 0x200);

        /// address: 0x10001208
        /// Access Port protection
        pub const APPROTECT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable Access Port protection. Any other value than 0xFF being
            /// written to this field will enable protection.
            PALL: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x208);

        /// address: 0x1000120c
        /// Setting of pins dedicated to NFC functionality: NFC antenna or GPIO
        pub const NFCPINS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Setting of pins dedicated to NFC functionality
            PROTECT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x20c);
    };
    /// Block Protect
    pub const BPROT = struct {
        pub const base_address = 0x40000000;

        /// address: 0x40000600
        /// Block protect configuration register 0
        pub const CONFIG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable protection for region 0. Write '0' has no effect.
            REGION0: u1,
            /// Enable protection for region 1. Write '0' has no effect.
            REGION1: u1,
            /// Enable protection for region 2. Write '0' has no effect.
            REGION2: u1,
            /// Enable protection for region 3. Write '0' has no effect.
            REGION3: u1,
            /// Enable protection for region 4. Write '0' has no effect.
            REGION4: u1,
            /// Enable protection for region 5. Write '0' has no effect.
            REGION5: u1,
            /// Enable protection for region 6. Write '0' has no effect.
            REGION6: u1,
            /// Enable protection for region 7. Write '0' has no effect.
            REGION7: u1,
            /// Enable protection for region 8. Write '0' has no effect.
            REGION8: u1,
            /// Enable protection for region 9. Write '0' has no effect.
            REGION9: u1,
            /// Enable protection for region 10. Write '0' has no effect.
            REGION10: u1,
            /// Enable protection for region 11. Write '0' has no effect.
            REGION11: u1,
            /// Enable protection for region 12. Write '0' has no effect.
            REGION12: u1,
            /// Enable protection for region 13. Write '0' has no effect.
            REGION13: u1,
            /// Enable protection for region 14. Write '0' has no effect.
            REGION14: u1,
            /// Enable protection for region 15. Write '0' has no effect.
            REGION15: u1,
            /// Enable protection for region 16. Write '0' has no effect.
            REGION16: u1,
            /// Enable protection for region 17. Write '0' has no effect.
            REGION17: u1,
            /// Enable protection for region 18. Write '0' has no effect.
            REGION18: u1,
            /// Enable protection for region 19. Write '0' has no effect.
            REGION19: u1,
            /// Enable protection for region 20. Write '0' has no effect.
            REGION20: u1,
            /// Enable protection for region 21. Write '0' has no effect.
            REGION21: u1,
            /// Enable protection for region 22. Write '0' has no effect.
            REGION22: u1,
            /// Enable protection for region 23. Write '0' has no effect.
            REGION23: u1,
            /// Enable protection for region 24. Write '0' has no effect.
            REGION24: u1,
            /// Enable protection for region 25. Write '0' has no effect.
            REGION25: u1,
            /// Enable protection for region 26. Write '0' has no effect.
            REGION26: u1,
            /// Enable protection for region 27. Write '0' has no effect.
            REGION27: u1,
            /// Enable protection for region 28. Write '0' has no effect.
            REGION28: u1,
            /// Enable protection for region 29. Write '0' has no effect.
            REGION29: u1,
            /// Enable protection for region 30. Write '0' has no effect.
            REGION30: u1,
            /// Enable protection for region 31. Write '0' has no effect.
            REGION31: u1,
        }), base_address + 0x600);

        /// address: 0x40000604
        /// Block protect configuration register 1
        pub const CONFIG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable protection for region 32. Write '0' has no effect.
            REGION32: u1,
            /// Enable protection for region 33. Write '0' has no effect.
            REGION33: u1,
            /// Enable protection for region 34. Write '0' has no effect.
            REGION34: u1,
            /// Enable protection for region 35. Write '0' has no effect.
            REGION35: u1,
            /// Enable protection for region 36. Write '0' has no effect.
            REGION36: u1,
            /// Enable protection for region 37. Write '0' has no effect.
            REGION37: u1,
            /// Enable protection for region 38. Write '0' has no effect.
            REGION38: u1,
            /// Enable protection for region 39. Write '0' has no effect.
            REGION39: u1,
            /// Enable protection for region 40. Write '0' has no effect.
            REGION40: u1,
            /// Enable protection for region 41. Write '0' has no effect.
            REGION41: u1,
            /// Enable protection for region 42. Write '0' has no effect.
            REGION42: u1,
            /// Enable protection for region 43. Write '0' has no effect.
            REGION43: u1,
            /// Enable protection for region 44. Write '0' has no effect.
            REGION44: u1,
            /// Enable protection for region 45. Write '0' has no effect.
            REGION45: u1,
            /// Enable protection for region 46. Write '0' has no effect.
            REGION46: u1,
            /// Enable protection for region 47. Write '0' has no effect.
            REGION47: u1,
            /// Enable protection for region 48. Write '0' has no effect.
            REGION48: u1,
            /// Enable protection for region 49. Write '0' has no effect.
            REGION49: u1,
            /// Enable protection for region 50. Write '0' has no effect.
            REGION50: u1,
            /// Enable protection for region 51. Write '0' has no effect.
            REGION51: u1,
            /// Enable protection for region 52. Write '0' has no effect.
            REGION52: u1,
            /// Enable protection for region 53. Write '0' has no effect.
            REGION53: u1,
            /// Enable protection for region 54. Write '0' has no effect.
            REGION54: u1,
            /// Enable protection for region 55. Write '0' has no effect.
            REGION55: u1,
            /// Enable protection for region 56. Write '0' has no effect.
            REGION56: u1,
            /// Enable protection for region 57. Write '0' has no effect.
            REGION57: u1,
            /// Enable protection for region 58. Write '0' has no effect.
            REGION58: u1,
            /// Enable protection for region 59. Write '0' has no effect.
            REGION59: u1,
            /// Enable protection for region 60. Write '0' has no effect.
            REGION60: u1,
            /// Enable protection for region 61. Write '0' has no effect.
            REGION61: u1,
            /// Enable protection for region 62. Write '0' has no effect.
            REGION62: u1,
            /// Enable protection for region 63. Write '0' has no effect.
            REGION63: u1,
        }), base_address + 0x604);

        /// address: 0x40000608
        /// Disable protection mechanism in debug interface mode
        pub const DISABLEINDEBUG = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x608);

        /// address: 0x4000060c
        /// Unspecified
        pub const UNUSED0 = @intToPtr(*volatile u32, base_address + 0x60c);

        /// address: 0x40000610
        /// Block protect configuration register 2
        pub const CONFIG2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable protection for region 64. Write '0' has no effect.
            REGION64: u1,
            /// Enable protection for region 65. Write '0' has no effect.
            REGION65: u1,
            /// Enable protection for region 66. Write '0' has no effect.
            REGION66: u1,
            /// Enable protection for region 67. Write '0' has no effect.
            REGION67: u1,
            /// Enable protection for region 68. Write '0' has no effect.
            REGION68: u1,
            /// Enable protection for region 69. Write '0' has no effect.
            REGION69: u1,
            /// Enable protection for region 70. Write '0' has no effect.
            REGION70: u1,
            /// Enable protection for region 71. Write '0' has no effect.
            REGION71: u1,
            /// Enable protection for region 72. Write '0' has no effect.
            REGION72: u1,
            /// Enable protection for region 73. Write '0' has no effect.
            REGION73: u1,
            /// Enable protection for region 74. Write '0' has no effect.
            REGION74: u1,
            /// Enable protection for region 75. Write '0' has no effect.
            REGION75: u1,
            /// Enable protection for region 76. Write '0' has no effect.
            REGION76: u1,
            /// Enable protection for region 77. Write '0' has no effect.
            REGION77: u1,
            /// Enable protection for region 78. Write '0' has no effect.
            REGION78: u1,
            /// Enable protection for region 79. Write '0' has no effect.
            REGION79: u1,
            /// Enable protection for region 80. Write '0' has no effect.
            REGION80: u1,
            /// Enable protection for region 81. Write '0' has no effect.
            REGION81: u1,
            /// Enable protection for region 82. Write '0' has no effect.
            REGION82: u1,
            /// Enable protection for region 83. Write '0' has no effect.
            REGION83: u1,
            /// Enable protection for region 84. Write '0' has no effect.
            REGION84: u1,
            /// Enable protection for region 85. Write '0' has no effect.
            REGION85: u1,
            /// Enable protection for region 86. Write '0' has no effect.
            REGION86: u1,
            /// Enable protection for region 87. Write '0' has no effect.
            REGION87: u1,
            /// Enable protection for region 88. Write '0' has no effect.
            REGION88: u1,
            /// Enable protection for region 89. Write '0' has no effect.
            REGION89: u1,
            /// Enable protection for region 90. Write '0' has no effect.
            REGION90: u1,
            /// Enable protection for region 91. Write '0' has no effect.
            REGION91: u1,
            /// Enable protection for region 92. Write '0' has no effect.
            REGION92: u1,
            /// Enable protection for region 93. Write '0' has no effect.
            REGION93: u1,
            /// Enable protection for region 94. Write '0' has no effect.
            REGION94: u1,
            /// Enable protection for region 95. Write '0' has no effect.
            REGION95: u1,
        }), base_address + 0x610);

        /// address: 0x40000614
        /// Block protect configuration register 3
        pub const CONFIG3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable protection for region 96. Write '0' has no effect.
            REGION96: u1,
            /// Enable protection for region 97. Write '0' has no effect.
            REGION97: u1,
            /// Enable protection for region 98. Write '0' has no effect.
            REGION98: u1,
            /// Enable protection for region 99. Write '0' has no effect.
            REGION99: u1,
            /// Enable protection for region 100. Write '0' has no effect.
            REGION100: u1,
            /// Enable protection for region 101. Write '0' has no effect.
            REGION101: u1,
            /// Enable protection for region 102. Write '0' has no effect.
            REGION102: u1,
            /// Enable protection for region 103. Write '0' has no effect.
            REGION103: u1,
            /// Enable protection for region 104. Write '0' has no effect.
            REGION104: u1,
            /// Enable protection for region 105. Write '0' has no effect.
            REGION105: u1,
            /// Enable protection for region 106. Write '0' has no effect.
            REGION106: u1,
            /// Enable protection for region 107. Write '0' has no effect.
            REGION107: u1,
            /// Enable protection for region 108. Write '0' has no effect.
            REGION108: u1,
            /// Enable protection for region 109. Write '0' has no effect.
            REGION109: u1,
            /// Enable protection for region 110. Write '0' has no effect.
            REGION110: u1,
            /// Enable protection for region 111. Write '0' has no effect.
            REGION111: u1,
            /// Enable protection for region 112. Write '0' has no effect.
            REGION112: u1,
            /// Enable protection for region 113. Write '0' has no effect.
            REGION113: u1,
            /// Enable protection for region 114. Write '0' has no effect.
            REGION114: u1,
            /// Enable protection for region 115. Write '0' has no effect.
            REGION115: u1,
            /// Enable protection for region 116. Write '0' has no effect.
            REGION116: u1,
            /// Enable protection for region 117. Write '0' has no effect.
            REGION117: u1,
            /// Enable protection for region 118. Write '0' has no effect.
            REGION118: u1,
            /// Enable protection for region 119. Write '0' has no effect.
            REGION119: u1,
            /// Enable protection for region 120. Write '0' has no effect.
            REGION120: u1,
            /// Enable protection for region 121. Write '0' has no effect.
            REGION121: u1,
            /// Enable protection for region 122. Write '0' has no effect.
            REGION122: u1,
            /// Enable protection for region 123. Write '0' has no effect.
            REGION123: u1,
            /// Enable protection for region 124. Write '0' has no effect.
            REGION124: u1,
            /// Enable protection for region 125. Write '0' has no effect.
            REGION125: u1,
            /// Enable protection for region 126. Write '0' has no effect.
            REGION126: u1,
            /// Enable protection for region 127. Write '0' has no effect.
            REGION127: u1,
        }), base_address + 0x614);
    };
    /// Power control
    pub const POWER = struct {
        pub const base_address = 0x40000000;

        /// address: 0x40000078
        /// Enable constant latency mode
        pub const TASKS_CONSTLAT = @intToPtr(*volatile u32, base_address + 0x78);

        /// address: 0x4000007c
        /// Enable low power mode (variable latency)
        pub const TASKS_LOWPWR = @intToPtr(*volatile u32, base_address + 0x7c);

        /// address: 0x40000108
        /// Power failure warning
        pub const EVENTS_POFWARN = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x40000114
        /// CPU entered WFI/WFE sleep
        pub const EVENTS_SLEEPENTER = @intToPtr(*volatile u32, base_address + 0x114);

        /// address: 0x40000118
        /// CPU exited WFI/WFE sleep
        pub const EVENTS_SLEEPEXIT = @intToPtr(*volatile u32, base_address + 0x118);

        /// address: 0x40000304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Write '1' to Enable interrupt for POFWARN event
            POFWARN: u1,
            reserved2: u1,
            reserved3: u1,
            /// Write '1' to Enable interrupt for SLEEPENTER event
            SLEEPENTER: u1,
            /// Write '1' to Enable interrupt for SLEEPEXIT event
            SLEEPEXIT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x304);

        /// address: 0x40000308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Write '1' to Disable interrupt for POFWARN event
            POFWARN: u1,
            reserved2: u1,
            reserved3: u1,
            /// Write '1' to Disable interrupt for SLEEPENTER event
            SLEEPENTER: u1,
            /// Write '1' to Disable interrupt for SLEEPEXIT event
            SLEEPEXIT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x308);

        /// address: 0x40000400
        /// Reset reason
        pub const RESETREAS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reset from pin-reset detected
            RESETPIN: u1,
            /// Reset from watchdog detected
            DOG: u1,
            /// Reset from soft reset detected
            SREQ: u1,
            /// Reset from CPU lock-up detected
            LOCKUP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Reset due to wake up from System OFF mode when wakeup is triggered from DETECT
            /// signal from GPIO
            OFF: u1,
            /// Reset due to wake up from System OFF mode when wakeup is triggered from
            /// ANADETECT signal from LPCOMP
            LPCOMP: u1,
            /// Reset due to wake up from System OFF mode when wakeup is triggered from entering
            /// into debug interface mode
            DIF: u1,
            /// Reset due to wake up from System OFF mode by NFC field detect
            NFC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x400);

        /// address: 0x40000428
        /// Deprecated register - RAM status register
        pub const RAMSTATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// RAM block 0 is on or off/powering up
            RAMBLOCK0: u1,
            /// RAM block 1 is on or off/powering up
            RAMBLOCK1: u1,
            /// RAM block 2 is on or off/powering up
            RAMBLOCK2: u1,
            /// RAM block 3 is on or off/powering up
            RAMBLOCK3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x428);

        /// address: 0x40000500
        /// System OFF register
        pub const SYSTEMOFF = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x500);

        /// address: 0x40000510
        /// Power failure comparator configuration
        pub const POFCON = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable power failure comparator
            POF: u1,
            /// Power failure comparator threshold setting
            THRESHOLD: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x510);

        /// address: 0x4000051c
        /// General purpose retention register
        pub const GPREGRET = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x51c);

        /// address: 0x40000520
        /// General purpose retention register
        pub const GPREGRET2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// General purpose retention register
            GPREGRET: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x520);

        /// address: 0x40000524
        /// Deprecated register - RAM on/off register (this register is retained)
        pub const RAMON = @intToPtr(*volatile Mmio(32, packed struct {
            /// Keep RAM block 0 on or off in system ON Mode
            ONRAM0: u1,
            /// Keep RAM block 1 on or off in system ON Mode
            ONRAM1: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Keep retention on RAM block 0 when RAM block is switched off
            OFFRAM0: u1,
            /// Keep retention on RAM block 1 when RAM block is switched off
            OFFRAM1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x524);

        /// address: 0x40000554
        /// Deprecated register - RAM on/off register (this register is retained)
        pub const RAMONB = @intToPtr(*volatile Mmio(32, packed struct {
            /// Keep RAM block 2 on or off in system ON Mode
            ONRAM2: u1,
            /// Keep RAM block 3 on or off in system ON Mode
            ONRAM3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Keep retention on RAM block 2 when RAM block is switched off
            OFFRAM2: u1,
            /// Keep retention on RAM block 3 when RAM block is switched off
            OFFRAM3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x554);

        /// address: 0x40000578
        /// DC/DC enable register
        pub const DCDCEN = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x578);

        pub const RAM = @ptrCast(*volatile [8]packed struct {
            /// Description cluster[0]: RAM0 power control register
            POWER: Mmio(32, packed struct {
                /// Keep RAM section S0 ON or OFF in System ON mode.
                S0POWER: u1,
                /// Keep RAM section S1 ON or OFF in System ON mode.
                S1POWER: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                /// Keep retention on RAM section S0 when RAM section is in OFF
                S0RETENTION: u1,
                /// Keep retention on RAM section S1 when RAM section is in OFF
                S1RETENTION: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
            }),

            /// Description cluster[0]: RAM0 power control set register
            POWERSET: Mmio(32, packed struct {
                /// Keep RAM section S0 of RAM0 on or off in System ON mode
                S0POWER: u1,
                /// Keep RAM section S1 of RAM0 on or off in System ON mode
                S1POWER: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                /// Keep retention on RAM section S0 when RAM section is switched off
                S0RETENTION: u1,
                /// Keep retention on RAM section S1 when RAM section is switched off
                S1RETENTION: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
            }),

            /// Description cluster[0]: RAM0 power control clear register
            POWERCLR: Mmio(32, packed struct {
                /// Keep RAM section S0 of RAM0 on or off in System ON mode
                S0POWER: u1,
                /// Keep RAM section S1 of RAM0 on or off in System ON mode
                S1POWER: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                /// Keep retention on RAM section S0 when RAM section is switched off
                S0RETENTION: u1,
                /// Keep retention on RAM section S1 when RAM section is switched off
                S1RETENTION: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
            }),
            padding0: u32,
        }, base_address + 0x900);
    };
    /// Clock control
    pub const CLOCK = struct {
        pub const base_address = 0x40000000;

        /// address: 0x40000000
        /// Start HFCLK crystal oscillator
        pub const TASKS_HFCLKSTART = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40000004
        /// Stop HFCLK crystal oscillator
        pub const TASKS_HFCLKSTOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40000008
        /// Start LFCLK source
        pub const TASKS_LFCLKSTART = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4000000c
        /// Stop LFCLK source
        pub const TASKS_LFCLKSTOP = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x40000010
        /// Start calibration of LFRC oscillator
        pub const TASKS_CAL = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40000014
        /// Start calibration timer
        pub const TASKS_CTSTART = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x40000018
        /// Stop calibration timer
        pub const TASKS_CTSTOP = @intToPtr(*volatile u32, base_address + 0x18);

        /// address: 0x40000100
        /// HFCLK oscillator started
        pub const EVENTS_HFCLKSTARTED = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x40000104
        /// LFCLK started
        pub const EVENTS_LFCLKSTARTED = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x4000010c
        /// Calibration of LFCLK RC oscillator complete event
        pub const EVENTS_DONE = @intToPtr(*volatile u32, base_address + 0x10c);

        /// address: 0x40000110
        /// Calibration timer timeout
        pub const EVENTS_CTTO = @intToPtr(*volatile u32, base_address + 0x110);

        /// address: 0x40000304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for HFCLKSTARTED event
            HFCLKSTARTED: u1,
            /// Write '1' to Enable interrupt for LFCLKSTARTED event
            LFCLKSTARTED: u1,
            reserved0: u1,
            /// Write '1' to Enable interrupt for DONE event
            DONE: u1,
            /// Write '1' to Enable interrupt for CTTO event
            CTTO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x304);

        /// address: 0x40000308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for HFCLKSTARTED event
            HFCLKSTARTED: u1,
            /// Write '1' to Disable interrupt for LFCLKSTARTED event
            LFCLKSTARTED: u1,
            reserved0: u1,
            /// Write '1' to Disable interrupt for DONE event
            DONE: u1,
            /// Write '1' to Disable interrupt for CTTO event
            CTTO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x308);

        /// address: 0x40000408
        /// Status indicating that HFCLKSTART task has been triggered
        pub const HFCLKRUN = @intToPtr(*volatile Mmio(32, packed struct {
            /// HFCLKSTART task triggered or not
            STATUS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x408);

        /// address: 0x4000040c
        /// HFCLK status
        pub const HFCLKSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Source of HFCLK
            SRC: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// HFCLK state
            STATE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x40c);

        /// address: 0x40000414
        /// Status indicating that LFCLKSTART task has been triggered
        pub const LFCLKRUN = @intToPtr(*volatile Mmio(32, packed struct {
            /// LFCLKSTART task triggered or not
            STATUS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x414);

        /// address: 0x40000418
        /// LFCLK status
        pub const LFCLKSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Source of LFCLK
            SRC: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// LFCLK state
            STATE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x418);

        /// address: 0x4000041c
        /// Copy of LFCLKSRC register, set when LFCLKSTART task was triggered
        pub const LFCLKSRCCOPY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock source
            SRC: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x41c);

        /// address: 0x40000518
        /// Clock source for the LFCLK
        pub const LFCLKSRC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock source
            SRC: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Enable or disable bypass of LFCLK crystal oscillator with external clock source
            BYPASS: u1,
            /// Enable or disable external source for LFCLK
            EXTERNAL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x518);

        /// address: 0x40000538
        /// Calibration timer interval
        pub const CTIV = @intToPtr(*volatile MmioInt(32, u7), base_address + 0x538);

        /// address: 0x4000055c
        /// Clocking options for the Trace Port debug interface
        pub const TRACECONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Speed of Trace Port clock. Note that the TRACECLK pin will output this clock
            /// divided by two.
            TRACEPORTSPEED: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Pin multiplexing of trace signals.
            TRACEMUX: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x55c);
    };
    /// 2.4 GHz Radio
    pub const RADIO = struct {
        pub const base_address = 0x40001000;

        /// address: 0x40001000
        /// Enable RADIO in TX mode
        pub const TASKS_TXEN = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40001004
        /// Enable RADIO in RX mode
        pub const TASKS_RXEN = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40001008
        /// Start RADIO
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4000100c
        /// Stop RADIO
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x40001010
        /// Disable RADIO
        pub const TASKS_DISABLE = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40001014
        /// Start the RSSI and take one single sample of the receive signal strength.
        pub const TASKS_RSSISTART = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x40001018
        /// Stop the RSSI measurement
        pub const TASKS_RSSISTOP = @intToPtr(*volatile u32, base_address + 0x18);

        /// address: 0x4000101c
        /// Start the bit counter
        pub const TASKS_BCSTART = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x40001020
        /// Stop the bit counter
        pub const TASKS_BCSTOP = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x40001100
        /// RADIO has ramped up and is ready to be started
        pub const EVENTS_READY = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x40001104
        /// Address sent or received
        pub const EVENTS_ADDRESS = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40001108
        /// Packet payload sent or received
        pub const EVENTS_PAYLOAD = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x4000110c
        /// Packet sent or received
        pub const EVENTS_END = @intToPtr(*volatile u32, base_address + 0x10c);

        /// address: 0x40001110
        /// RADIO has been disabled
        pub const EVENTS_DISABLED = @intToPtr(*volatile u32, base_address + 0x110);

        /// address: 0x40001114
        /// A device address match occurred on the last received packet
        pub const EVENTS_DEVMATCH = @intToPtr(*volatile u32, base_address + 0x114);

        /// address: 0x40001118
        /// No device address match occurred on the last received packet
        pub const EVENTS_DEVMISS = @intToPtr(*volatile u32, base_address + 0x118);

        /// address: 0x4000111c
        /// Sampling of receive signal strength complete.
        pub const EVENTS_RSSIEND = @intToPtr(*volatile u32, base_address + 0x11c);

        /// address: 0x40001128
        /// Bit counter reached bit count value.
        pub const EVENTS_BCMATCH = @intToPtr(*volatile u32, base_address + 0x128);

        /// address: 0x40001130
        /// Packet received with CRC ok
        pub const EVENTS_CRCOK = @intToPtr(*volatile u32, base_address + 0x130);

        /// address: 0x40001134
        /// Packet received with CRC error
        pub const EVENTS_CRCERROR = @intToPtr(*volatile u32, base_address + 0x134);

        /// address: 0x40001200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Shortcut between READY event and START task
            READY_START: u1,
            /// Shortcut between END event and DISABLE task
            END_DISABLE: u1,
            /// Shortcut between DISABLED event and TXEN task
            DISABLED_TXEN: u1,
            /// Shortcut between DISABLED event and RXEN task
            DISABLED_RXEN: u1,
            /// Shortcut between ADDRESS event and RSSISTART task
            ADDRESS_RSSISTART: u1,
            /// Shortcut between END event and START task
            END_START: u1,
            /// Shortcut between ADDRESS event and BCSTART task
            ADDRESS_BCSTART: u1,
            reserved0: u1,
            /// Shortcut between DISABLED event and RSSISTOP task
            DISABLED_RSSISTOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x200);

        /// address: 0x40001304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for READY event
            READY: u1,
            /// Write '1' to Enable interrupt for ADDRESS event
            ADDRESS: u1,
            /// Write '1' to Enable interrupt for PAYLOAD event
            PAYLOAD: u1,
            /// Write '1' to Enable interrupt for END event
            END: u1,
            /// Write '1' to Enable interrupt for DISABLED event
            DISABLED: u1,
            /// Write '1' to Enable interrupt for DEVMATCH event
            DEVMATCH: u1,
            /// Write '1' to Enable interrupt for DEVMISS event
            DEVMISS: u1,
            /// Write '1' to Enable interrupt for RSSIEND event
            RSSIEND: u1,
            reserved0: u1,
            reserved1: u1,
            /// Write '1' to Enable interrupt for BCMATCH event
            BCMATCH: u1,
            reserved2: u1,
            /// Write '1' to Enable interrupt for CRCOK event
            CRCOK: u1,
            /// Write '1' to Enable interrupt for CRCERROR event
            CRCERROR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x304);

        /// address: 0x40001308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for READY event
            READY: u1,
            /// Write '1' to Disable interrupt for ADDRESS event
            ADDRESS: u1,
            /// Write '1' to Disable interrupt for PAYLOAD event
            PAYLOAD: u1,
            /// Write '1' to Disable interrupt for END event
            END: u1,
            /// Write '1' to Disable interrupt for DISABLED event
            DISABLED: u1,
            /// Write '1' to Disable interrupt for DEVMATCH event
            DEVMATCH: u1,
            /// Write '1' to Disable interrupt for DEVMISS event
            DEVMISS: u1,
            /// Write '1' to Disable interrupt for RSSIEND event
            RSSIEND: u1,
            reserved0: u1,
            reserved1: u1,
            /// Write '1' to Disable interrupt for BCMATCH event
            BCMATCH: u1,
            reserved2: u1,
            /// Write '1' to Disable interrupt for CRCOK event
            CRCOK: u1,
            /// Write '1' to Disable interrupt for CRCERROR event
            CRCERROR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x308);

        /// address: 0x40001400
        /// CRC status
        pub const CRCSTATUS = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x400);

        /// address: 0x40001408
        /// Received address
        pub const RXMATCH = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x408);

        /// address: 0x4000140c
        /// CRC field of previously received packet
        pub const RXCRC = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x40c);

        /// address: 0x40001410
        /// Device address match index
        pub const DAI = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x410);

        /// address: 0x40001504
        /// Packet pointer
        pub const PACKETPTR = @intToPtr(*volatile u32, base_address + 0x504);

        /// address: 0x40001508
        /// Frequency
        pub const FREQUENCY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Radio channel frequency
            FREQUENCY: u7,
            reserved0: u1,
            /// Channel map selection.
            MAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x508);

        /// address: 0x4000150c
        /// Output power
        pub const TXPOWER = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x50c);

        /// address: 0x40001510
        /// Data rate and modulation
        pub const MODE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x510);

        /// address: 0x40001514
        /// Packet configuration register 0
        pub const PCNF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Length on air of LENGTH field in number of bits.
            LFLEN: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Length on air of S0 field in number of bytes.
            S0LEN: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Length on air of S1 field in number of bits.
            S1LEN: u4,
            /// Include or exclude S1 field in RAM
            S1INCL: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Length of preamble on air. Decision point: TASKS_START task
            PLEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x514);

        /// address: 0x40001518
        /// Packet configuration register 1
        pub const PCNF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum length of packet payload. If the packet payload is larger than MAXLEN,
            /// the radio will truncate the payload to MAXLEN.
            MAXLEN: u8,
            /// Static length in number of bytes
            STATLEN: u8,
            /// Base address length in number of bytes
            BALEN: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// On air endianness of packet, this applies to the S0, LENGTH, S1 and the PAYLOAD
            /// fields.
            ENDIAN: u1,
            /// Enable or disable packet whitening
            WHITEEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x518);

        /// address: 0x4000151c
        /// Base address 0
        pub const BASE0 = @intToPtr(*volatile u32, base_address + 0x51c);

        /// address: 0x40001520
        /// Base address 1
        pub const BASE1 = @intToPtr(*volatile u32, base_address + 0x520);

        /// address: 0x40001524
        /// Prefixes bytes for logical addresses 0-3
        pub const PREFIX0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address prefix 0.
            AP0: u8,
            /// Address prefix 1.
            AP1: u8,
            /// Address prefix 2.
            AP2: u8,
            /// Address prefix 3.
            AP3: u8,
        }), base_address + 0x524);

        /// address: 0x40001528
        /// Prefixes bytes for logical addresses 4-7
        pub const PREFIX1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address prefix 4.
            AP4: u8,
            /// Address prefix 5.
            AP5: u8,
            /// Address prefix 6.
            AP6: u8,
            /// Address prefix 7.
            AP7: u8,
        }), base_address + 0x528);

        /// address: 0x4000152c
        /// Transmit address select
        pub const TXADDRESS = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x52c);

        /// address: 0x40001530
        /// Receive address select
        pub const RXADDRESSES = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable reception on logical address 0.
            ADDR0: u1,
            /// Enable or disable reception on logical address 1.
            ADDR1: u1,
            /// Enable or disable reception on logical address 2.
            ADDR2: u1,
            /// Enable or disable reception on logical address 3.
            ADDR3: u1,
            /// Enable or disable reception on logical address 4.
            ADDR4: u1,
            /// Enable or disable reception on logical address 5.
            ADDR5: u1,
            /// Enable or disable reception on logical address 6.
            ADDR6: u1,
            /// Enable or disable reception on logical address 7.
            ADDR7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x530);

        /// address: 0x40001534
        /// CRC configuration
        pub const CRCCNF = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC length in number of bytes.
            LEN: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Include or exclude packet address field out of CRC calculation.
            SKIPADDR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x534);

        /// address: 0x40001538
        /// CRC polynomial
        pub const CRCPOLY = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x538);

        /// address: 0x4000153c
        /// CRC initial value
        pub const CRCINIT = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x53c);

        /// address: 0x40001540
        /// Unspecified
        pub const UNUSED0 = @intToPtr(*volatile u32, base_address + 0x540);

        /// address: 0x40001544
        /// Inter Frame Spacing in us
        pub const TIFS = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x544);

        /// address: 0x40001548
        /// RSSI sample
        pub const RSSISAMPLE = @intToPtr(*volatile MmioInt(32, u7), base_address + 0x548);

        /// address: 0x40001550
        /// Current radio state
        pub const STATE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x550);

        /// address: 0x40001554
        /// Data whitening initial value
        pub const DATAWHITEIV = @intToPtr(*volatile MmioInt(32, u7), base_address + 0x554);

        /// address: 0x40001560
        /// Bit counter compare
        pub const BCC = @intToPtr(*volatile u32, base_address + 0x560);

        /// address: 0x40001600
        /// Description collection[0]: Device address base segment 0
        pub const DAB = @intToPtr(*volatile [8]u32, base_address + 0x600);

        /// address: 0x40001620
        /// Description collection[0]: Device address prefix 0
        pub const DAP = @intToPtr(*volatile [8]MmioInt(32, u16), base_address + 0x620);

        /// address: 0x40001640
        /// Device address match configuration
        pub const DACNF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable device address matching using device address 0
            ENA0: u1,
            /// Enable or disable device address matching using device address 1
            ENA1: u1,
            /// Enable or disable device address matching using device address 2
            ENA2: u1,
            /// Enable or disable device address matching using device address 3
            ENA3: u1,
            /// Enable or disable device address matching using device address 4
            ENA4: u1,
            /// Enable or disable device address matching using device address 5
            ENA5: u1,
            /// Enable or disable device address matching using device address 6
            ENA6: u1,
            /// Enable or disable device address matching using device address 7
            ENA7: u1,
            /// TxAdd for device address 0
            TXADD0: u1,
            /// TxAdd for device address 1
            TXADD1: u1,
            /// TxAdd for device address 2
            TXADD2: u1,
            /// TxAdd for device address 3
            TXADD3: u1,
            /// TxAdd for device address 4
            TXADD4: u1,
            /// TxAdd for device address 5
            TXADD5: u1,
            /// TxAdd for device address 6
            TXADD6: u1,
            /// TxAdd for device address 7
            TXADD7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x640);

        /// address: 0x40001650
        /// Radio mode configuration register 0
        pub const MODECNF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Radio ramp-up time
            RU: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Default TX value
            DTX: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x650);

        /// address: 0x40001ffc
        /// Peripheral power control
        pub const POWER = @intToPtr(*volatile MmioInt(32, u1), base_address + 0xffc);
    };
    /// UART with EasyDMA
    pub const UARTE0 = struct {
        pub const base_address = 0x40002000;

        /// address: 0x40002000
        /// Start UART receiver
        pub const TASKS_STARTRX = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40002004
        /// Stop UART receiver
        pub const TASKS_STOPRX = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40002008
        /// Start UART transmitter
        pub const TASKS_STARTTX = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4000200c
        /// Stop UART transmitter
        pub const TASKS_STOPTX = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x4000202c
        /// Flush RX FIFO into RX buffer
        pub const TASKS_FLUSHRX = @intToPtr(*volatile u32, base_address + 0x2c);

        /// address: 0x40002100
        /// CTS is activated (set low). Clear To Send.
        pub const EVENTS_CTS = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x40002104
        /// CTS is deactivated (set high). Not Clear To Send.
        pub const EVENTS_NCTS = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40002108
        /// Data received in RXD (but potentially not yet transferred to Data RAM)
        pub const EVENTS_RXDRDY = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x40002110
        /// Receive buffer is filled up
        pub const EVENTS_ENDRX = @intToPtr(*volatile u32, base_address + 0x110);

        /// address: 0x4000211c
        /// Data sent from TXD
        pub const EVENTS_TXDRDY = @intToPtr(*volatile u32, base_address + 0x11c);

        /// address: 0x40002120
        /// Last TX byte transmitted
        pub const EVENTS_ENDTX = @intToPtr(*volatile u32, base_address + 0x120);

        /// address: 0x40002124
        /// Error detected
        pub const EVENTS_ERROR = @intToPtr(*volatile u32, base_address + 0x124);

        /// address: 0x40002144
        /// Receiver timeout
        pub const EVENTS_RXTO = @intToPtr(*volatile u32, base_address + 0x144);

        /// address: 0x4000214c
        /// UART receiver has started
        pub const EVENTS_RXSTARTED = @intToPtr(*volatile u32, base_address + 0x14c);

        /// address: 0x40002150
        /// UART transmitter has started
        pub const EVENTS_TXSTARTED = @intToPtr(*volatile u32, base_address + 0x150);

        /// address: 0x40002158
        /// Transmitter stopped
        pub const EVENTS_TXSTOPPED = @intToPtr(*volatile u32, base_address + 0x158);

        /// address: 0x40002200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Shortcut between ENDRX event and STARTRX task
            ENDRX_STARTRX: u1,
            /// Shortcut between ENDRX event and STOPRX task
            ENDRX_STOPRX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x200);

        /// address: 0x40002300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable interrupt for CTS event
            CTS: u1,
            /// Enable or disable interrupt for NCTS event
            NCTS: u1,
            /// Enable or disable interrupt for RXDRDY event
            RXDRDY: u1,
            reserved0: u1,
            /// Enable or disable interrupt for ENDRX event
            ENDRX: u1,
            reserved1: u1,
            reserved2: u1,
            /// Enable or disable interrupt for TXDRDY event
            TXDRDY: u1,
            /// Enable or disable interrupt for ENDTX event
            ENDTX: u1,
            /// Enable or disable interrupt for ERROR event
            ERROR: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Enable or disable interrupt for RXTO event
            RXTO: u1,
            reserved10: u1,
            /// Enable or disable interrupt for RXSTARTED event
            RXSTARTED: u1,
            /// Enable or disable interrupt for TXSTARTED event
            TXSTARTED: u1,
            reserved11: u1,
            /// Enable or disable interrupt for TXSTOPPED event
            TXSTOPPED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x300);

        /// address: 0x40002304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for CTS event
            CTS: u1,
            /// Write '1' to Enable interrupt for NCTS event
            NCTS: u1,
            /// Write '1' to Enable interrupt for RXDRDY event
            RXDRDY: u1,
            reserved0: u1,
            /// Write '1' to Enable interrupt for ENDRX event
            ENDRX: u1,
            reserved1: u1,
            reserved2: u1,
            /// Write '1' to Enable interrupt for TXDRDY event
            TXDRDY: u1,
            /// Write '1' to Enable interrupt for ENDTX event
            ENDTX: u1,
            /// Write '1' to Enable interrupt for ERROR event
            ERROR: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Write '1' to Enable interrupt for RXTO event
            RXTO: u1,
            reserved10: u1,
            /// Write '1' to Enable interrupt for RXSTARTED event
            RXSTARTED: u1,
            /// Write '1' to Enable interrupt for TXSTARTED event
            TXSTARTED: u1,
            reserved11: u1,
            /// Write '1' to Enable interrupt for TXSTOPPED event
            TXSTOPPED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x304);

        /// address: 0x40002308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for CTS event
            CTS: u1,
            /// Write '1' to Disable interrupt for NCTS event
            NCTS: u1,
            /// Write '1' to Disable interrupt for RXDRDY event
            RXDRDY: u1,
            reserved0: u1,
            /// Write '1' to Disable interrupt for ENDRX event
            ENDRX: u1,
            reserved1: u1,
            reserved2: u1,
            /// Write '1' to Disable interrupt for TXDRDY event
            TXDRDY: u1,
            /// Write '1' to Disable interrupt for ENDTX event
            ENDTX: u1,
            /// Write '1' to Disable interrupt for ERROR event
            ERROR: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Write '1' to Disable interrupt for RXTO event
            RXTO: u1,
            reserved10: u1,
            /// Write '1' to Disable interrupt for RXSTARTED event
            RXSTARTED: u1,
            /// Write '1' to Disable interrupt for TXSTARTED event
            TXSTARTED: u1,
            reserved11: u1,
            /// Write '1' to Disable interrupt for TXSTOPPED event
            TXSTOPPED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x308);

        /// address: 0x40002480
        /// Error source
        pub const ERRORSRC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overrun error
            OVERRUN: u1,
            /// Parity error
            PARITY: u1,
            /// Framing error occurred
            FRAMING: u1,
            /// Break condition
            BREAK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x480);

        /// address: 0x40002500
        /// Enable UART
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x500);

        /// address: 0x40002524
        /// Baud rate. Accuracy depends on the HFCLK source selected.
        pub const BAUDRATE = @intToPtr(*volatile u32, base_address + 0x524);

        /// address: 0x4000256c
        /// Configuration of parity and hardware flow control
        pub const CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Hardware flow control
            HWFC: u1,
            /// Parity
            PARITY: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x56c);

        pub const PSEL = struct {

            /// address: 0x40002000
            /// Pin select for RTS signal
            pub const RTS = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x0);

            /// address: 0x40002004
            /// Pin select for TXD signal
            pub const TXD = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x4);

            /// address: 0x40002008
            /// Pin select for CTS signal
            pub const CTS = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x8);

            /// address: 0x4000200c
            /// Pin select for RXD signal
            pub const RXD = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0xc);
        };

        /// RXD EasyDMA channel
        pub const RXD = struct {

            /// address: 0x40002000
            /// Data pointer
            pub const PTR = @intToPtr(*volatile u32, base_address + 0x0);

            /// address: 0x40002004
            /// Maximum number of bytes in receive buffer
            pub const MAXCNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x4);

            /// address: 0x40002008
            /// Number of bytes transferred in the last transaction
            pub const AMOUNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x8);
        };

        /// TXD EasyDMA channel
        pub const TXD = struct {

            /// address: 0x40002000
            /// Data pointer
            pub const PTR = @intToPtr(*volatile u32, base_address + 0x0);

            /// address: 0x40002004
            /// Maximum number of bytes in transmit buffer
            pub const MAXCNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x4);

            /// address: 0x40002008
            /// Number of bytes transferred in the last transaction
            pub const AMOUNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x8);
        };
    };
    /// Universal Asynchronous Receiver/Transmitter
    pub const UART0 = struct {
        pub const base_address = 0x40002000;

        /// address: 0x40002000
        /// Start UART receiver
        pub const TASKS_STARTRX = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40002004
        /// Stop UART receiver
        pub const TASKS_STOPRX = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40002008
        /// Start UART transmitter
        pub const TASKS_STARTTX = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4000200c
        /// Stop UART transmitter
        pub const TASKS_STOPTX = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x4000201c
        /// Suspend UART
        pub const TASKS_SUSPEND = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x40002100
        /// CTS is activated (set low). Clear To Send.
        pub const EVENTS_CTS = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x40002104
        /// CTS is deactivated (set high). Not Clear To Send.
        pub const EVENTS_NCTS = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40002108
        /// Data received in RXD
        pub const EVENTS_RXDRDY = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x4000211c
        /// Data sent from TXD
        pub const EVENTS_TXDRDY = @intToPtr(*volatile u32, base_address + 0x11c);

        /// address: 0x40002124
        /// Error detected
        pub const EVENTS_ERROR = @intToPtr(*volatile u32, base_address + 0x124);

        /// address: 0x40002144
        /// Receiver timeout
        pub const EVENTS_RXTO = @intToPtr(*volatile u32, base_address + 0x144);

        /// address: 0x40002200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Shortcut between CTS event and STARTRX task
            CTS_STARTRX: u1,
            /// Shortcut between NCTS event and STOPRX task
            NCTS_STOPRX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x200);

        /// address: 0x40002304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for CTS event
            CTS: u1,
            /// Write '1' to Enable interrupt for NCTS event
            NCTS: u1,
            /// Write '1' to Enable interrupt for RXDRDY event
            RXDRDY: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Write '1' to Enable interrupt for TXDRDY event
            TXDRDY: u1,
            reserved4: u1,
            /// Write '1' to Enable interrupt for ERROR event
            ERROR: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Write '1' to Enable interrupt for RXTO event
            RXTO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x304);

        /// address: 0x40002308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for CTS event
            CTS: u1,
            /// Write '1' to Disable interrupt for NCTS event
            NCTS: u1,
            /// Write '1' to Disable interrupt for RXDRDY event
            RXDRDY: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Write '1' to Disable interrupt for TXDRDY event
            TXDRDY: u1,
            reserved4: u1,
            /// Write '1' to Disable interrupt for ERROR event
            ERROR: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Write '1' to Disable interrupt for RXTO event
            RXTO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x308);

        /// address: 0x40002480
        /// Error source
        pub const ERRORSRC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overrun error
            OVERRUN: u1,
            /// Parity error
            PARITY: u1,
            /// Framing error occurred
            FRAMING: u1,
            /// Break condition
            BREAK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x480);

        /// address: 0x40002500
        /// Enable UART
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x500);

        /// address: 0x40002508
        /// Pin select for RTS
        pub const PSELRTS = @intToPtr(*volatile u32, base_address + 0x508);

        /// address: 0x4000250c
        /// Pin select for TXD
        pub const PSELTXD = @intToPtr(*volatile u32, base_address + 0x50c);

        /// address: 0x40002510
        /// Pin select for CTS
        pub const PSELCTS = @intToPtr(*volatile u32, base_address + 0x510);

        /// address: 0x40002514
        /// Pin select for RXD
        pub const PSELRXD = @intToPtr(*volatile u32, base_address + 0x514);

        /// address: 0x40002518
        /// RXD register
        pub const RXD = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x518);

        /// address: 0x4000251c
        /// TXD register
        pub const TXD = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x51c);

        /// address: 0x40002524
        /// Baud rate
        pub const BAUDRATE = @intToPtr(*volatile u32, base_address + 0x524);

        /// address: 0x4000256c
        /// Configuration of parity and hardware flow control
        pub const CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Hardware flow control
            HWFC: u1,
            /// Parity
            PARITY: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x56c);
    };
    /// Serial Peripheral Interface Master with EasyDMA 0
    pub const SPIM0 = struct {
        pub const base_address = 0x40003000;

        /// address: 0x40003010
        /// Start SPI transaction
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40003014
        /// Stop SPI transaction
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x4000301c
        /// Suspend SPI transaction
        pub const TASKS_SUSPEND = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x40003020
        /// Resume SPI transaction
        pub const TASKS_RESUME = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x40003104
        /// SPI transaction has stopped
        pub const EVENTS_STOPPED = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40003110
        /// End of RXD buffer reached
        pub const EVENTS_ENDRX = @intToPtr(*volatile u32, base_address + 0x110);

        /// address: 0x40003118
        /// End of RXD buffer and TXD buffer reached
        pub const EVENTS_END = @intToPtr(*volatile u32, base_address + 0x118);

        /// address: 0x40003120
        /// End of TXD buffer reached
        pub const EVENTS_ENDTX = @intToPtr(*volatile u32, base_address + 0x120);

        /// address: 0x4000314c
        /// Transaction started
        pub const EVENTS_STARTED = @intToPtr(*volatile u32, base_address + 0x14c);

        /// address: 0x40003200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Shortcut between END event and START task
            END_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x200);

        /// address: 0x40003304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Enable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            /// Write '1' to Enable interrupt for ENDRX event
            ENDRX: u1,
            reserved3: u1,
            /// Write '1' to Enable interrupt for END event
            END: u1,
            reserved4: u1,
            /// Write '1' to Enable interrupt for ENDTX event
            ENDTX: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// Write '1' to Enable interrupt for STARTED event
            STARTED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x304);

        /// address: 0x40003308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Disable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            /// Write '1' to Disable interrupt for ENDRX event
            ENDRX: u1,
            reserved3: u1,
            /// Write '1' to Disable interrupt for END event
            END: u1,
            reserved4: u1,
            /// Write '1' to Disable interrupt for ENDTX event
            ENDTX: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// Write '1' to Disable interrupt for STARTED event
            STARTED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x308);

        /// address: 0x40003500
        /// Enable SPIM
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x500);

        /// address: 0x40003524
        /// SPI frequency. Accuracy depends on the HFCLK source selected.
        pub const FREQUENCY = @intToPtr(*volatile u32, base_address + 0x524);

        /// address: 0x40003554
        /// Configuration register
        pub const CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bit order
            ORDER: u1,
            /// Serial clock (SCK) phase
            CPHA: u1,
            /// Serial clock (SCK) polarity
            CPOL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x554);

        /// address: 0x400035c0
        /// Over-read character. Character clocked out in case and over-read of the TXD
        /// buffer.
        pub const ORC = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x5c0);

        pub const PSEL = struct {

            /// address: 0x40003000
            /// Pin select for SCK
            pub const SCK = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x0);

            /// address: 0x40003004
            /// Pin select for MOSI signal
            pub const MOSI = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x4);

            /// address: 0x40003008
            /// Pin select for MISO signal
            pub const MISO = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x8);
        };

        /// RXD EasyDMA channel
        pub const RXD = struct {

            /// address: 0x40003000
            /// Data pointer
            pub const PTR = @intToPtr(*volatile u32, base_address + 0x0);

            /// address: 0x40003004
            /// Maximum number of bytes in receive buffer
            pub const MAXCNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x4);

            /// address: 0x40003008
            /// Number of bytes transferred in the last transaction
            pub const AMOUNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x8);

            /// address: 0x4000300c
            /// EasyDMA list type
            pub const LIST = @intToPtr(*volatile MmioInt(32, u3), base_address + 0xc);
        };

        /// TXD EasyDMA channel
        pub const TXD = struct {

            /// address: 0x40003000
            /// Data pointer
            pub const PTR = @intToPtr(*volatile u32, base_address + 0x0);

            /// address: 0x40003004
            /// Maximum number of bytes in transmit buffer
            pub const MAXCNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x4);

            /// address: 0x40003008
            /// Number of bytes transferred in the last transaction
            pub const AMOUNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x8);

            /// address: 0x4000300c
            /// EasyDMA list type
            pub const LIST = @intToPtr(*volatile MmioInt(32, u3), base_address + 0xc);
        };
    };
    /// SPI Slave 0
    pub const SPIS0 = struct {
        pub const base_address = 0x40003000;

        /// address: 0x40003024
        /// Acquire SPI semaphore
        pub const TASKS_ACQUIRE = @intToPtr(*volatile u32, base_address + 0x24);

        /// address: 0x40003028
        /// Release SPI semaphore, enabling the SPI slave to acquire it
        pub const TASKS_RELEASE = @intToPtr(*volatile u32, base_address + 0x28);

        /// address: 0x40003104
        /// Granted transaction completed
        pub const EVENTS_END = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40003110
        /// End of RXD buffer reached
        pub const EVENTS_ENDRX = @intToPtr(*volatile u32, base_address + 0x110);

        /// address: 0x40003128
        /// Semaphore acquired
        pub const EVENTS_ACQUIRED = @intToPtr(*volatile u32, base_address + 0x128);

        /// address: 0x40003200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Shortcut between END event and ACQUIRE task
            END_ACQUIRE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x200);

        /// address: 0x40003304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Enable interrupt for END event
            END: u1,
            reserved1: u1,
            reserved2: u1,
            /// Write '1' to Enable interrupt for ENDRX event
            ENDRX: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Write '1' to Enable interrupt for ACQUIRED event
            ACQUIRED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x304);

        /// address: 0x40003308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Disable interrupt for END event
            END: u1,
            reserved1: u1,
            reserved2: u1,
            /// Write '1' to Disable interrupt for ENDRX event
            ENDRX: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Write '1' to Disable interrupt for ACQUIRED event
            ACQUIRED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x308);

        /// address: 0x40003400
        /// Semaphore status register
        pub const SEMSTAT = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x400);

        /// address: 0x40003440
        /// Status from last transaction
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX buffer over-read detected, and prevented
            OVERREAD: u1,
            /// RX buffer overflow detected, and prevented
            OVERFLOW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x440);

        /// address: 0x40003500
        /// Enable SPI slave
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x500);

        /// address: 0x40003554
        /// Configuration register
        pub const CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bit order
            ORDER: u1,
            /// Serial clock (SCK) phase
            CPHA: u1,
            /// Serial clock (SCK) polarity
            CPOL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x554);

        /// address: 0x4000355c
        /// Default character. Character clocked out in case of an ignored transaction.
        pub const DEF = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x55c);

        /// address: 0x400035c0
        /// Over-read character
        pub const ORC = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x5c0);

        pub const PSEL = struct {

            /// address: 0x40003000
            /// Pin select for SCK
            pub const SCK = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x0);

            /// address: 0x40003004
            /// Pin select for MISO signal
            pub const MISO = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x4);

            /// address: 0x40003008
            /// Pin select for MOSI signal
            pub const MOSI = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x8);

            /// address: 0x4000300c
            /// Pin select for CSN signal
            pub const CSN = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0xc);
        };

        pub const RXD = struct {

            /// address: 0x40003000
            /// RXD data pointer
            pub const PTR = @intToPtr(*volatile u32, base_address + 0x0);

            /// address: 0x40003004
            /// Maximum number of bytes in receive buffer
            pub const MAXCNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x4);

            /// address: 0x40003008
            /// Number of bytes received in last granted transaction
            pub const AMOUNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x8);
        };

        pub const TXD = struct {

            /// address: 0x40003000
            /// TXD data pointer
            pub const PTR = @intToPtr(*volatile u32, base_address + 0x0);

            /// address: 0x40003004
            /// Maximum number of bytes in transmit buffer
            pub const MAXCNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x4);

            /// address: 0x40003008
            /// Number of bytes transmitted in last granted transaction
            pub const AMOUNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x8);
        };
    };
    /// I2C compatible Two-Wire Master Interface with EasyDMA 0
    pub const TWIM0 = struct {
        pub const base_address = 0x40003000;

        /// address: 0x40003000
        /// Start TWI receive sequence
        pub const TASKS_STARTRX = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40003008
        /// Start TWI transmit sequence
        pub const TASKS_STARTTX = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x40003014
        /// Stop TWI transaction. Must be issued while the TWI master is not suspended.
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x4000301c
        /// Suspend TWI transaction
        pub const TASKS_SUSPEND = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x40003020
        /// Resume TWI transaction
        pub const TASKS_RESUME = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x40003104
        /// TWI stopped
        pub const EVENTS_STOPPED = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40003124
        /// TWI error
        pub const EVENTS_ERROR = @intToPtr(*volatile u32, base_address + 0x124);

        /// address: 0x40003148
        /// Last byte has been sent out after the SUSPEND task has been issued, TWI traffic
        /// is now suspended.
        pub const EVENTS_SUSPENDED = @intToPtr(*volatile u32, base_address + 0x148);

        /// address: 0x4000314c
        /// Receive sequence started
        pub const EVENTS_RXSTARTED = @intToPtr(*volatile u32, base_address + 0x14c);

        /// address: 0x40003150
        /// Transmit sequence started
        pub const EVENTS_TXSTARTED = @intToPtr(*volatile u32, base_address + 0x150);

        /// address: 0x4000315c
        /// Byte boundary, starting to receive the last byte
        pub const EVENTS_LASTRX = @intToPtr(*volatile u32, base_address + 0x15c);

        /// address: 0x40003160
        /// Byte boundary, starting to transmit the last byte
        pub const EVENTS_LASTTX = @intToPtr(*volatile u32, base_address + 0x160);

        /// address: 0x40003200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Shortcut between LASTTX event and STARTRX task
            LASTTX_STARTRX: u1,
            /// Shortcut between LASTTX event and SUSPEND task
            LASTTX_SUSPEND: u1,
            /// Shortcut between LASTTX event and STOP task
            LASTTX_STOP: u1,
            /// Shortcut between LASTRX event and STARTTX task
            LASTRX_STARTTX: u1,
            reserved7: u1,
            /// Shortcut between LASTRX event and STOP task
            LASTRX_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x200);

        /// address: 0x40003300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Enable or disable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Enable or disable interrupt for ERROR event
            ERROR: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Enable or disable interrupt for SUSPENDED event
            SUSPENDED: u1,
            /// Enable or disable interrupt for RXSTARTED event
            RXSTARTED: u1,
            /// Enable or disable interrupt for TXSTARTED event
            TXSTARTED: u1,
            reserved16: u1,
            reserved17: u1,
            /// Enable or disable interrupt for LASTRX event
            LASTRX: u1,
            /// Enable or disable interrupt for LASTTX event
            LASTTX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x300);

        /// address: 0x40003304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Enable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Write '1' to Enable interrupt for ERROR event
            ERROR: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Write '1' to Enable interrupt for SUSPENDED event
            SUSPENDED: u1,
            /// Write '1' to Enable interrupt for RXSTARTED event
            RXSTARTED: u1,
            /// Write '1' to Enable interrupt for TXSTARTED event
            TXSTARTED: u1,
            reserved16: u1,
            reserved17: u1,
            /// Write '1' to Enable interrupt for LASTRX event
            LASTRX: u1,
            /// Write '1' to Enable interrupt for LASTTX event
            LASTTX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x304);

        /// address: 0x40003308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Disable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Write '1' to Disable interrupt for ERROR event
            ERROR: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Write '1' to Disable interrupt for SUSPENDED event
            SUSPENDED: u1,
            /// Write '1' to Disable interrupt for RXSTARTED event
            RXSTARTED: u1,
            /// Write '1' to Disable interrupt for TXSTARTED event
            TXSTARTED: u1,
            reserved16: u1,
            reserved17: u1,
            /// Write '1' to Disable interrupt for LASTRX event
            LASTRX: u1,
            /// Write '1' to Disable interrupt for LASTTX event
            LASTTX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x308);

        /// address: 0x400034c4
        /// Error source
        pub const ERRORSRC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overrun error
            OVERRUN: u1,
            /// NACK received after sending the address (write '1' to clear)
            ANACK: u1,
            /// NACK received after sending a data byte (write '1' to clear)
            DNACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4c4);

        /// address: 0x40003500
        /// Enable TWIM
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x500);

        /// address: 0x40003524
        /// TWI frequency
        pub const FREQUENCY = @intToPtr(*volatile u32, base_address + 0x524);

        /// address: 0x40003588
        /// Address used in the TWI transfer
        pub const ADDRESS = @intToPtr(*volatile MmioInt(32, u7), base_address + 0x588);

        pub const PSEL = struct {

            /// address: 0x40003000
            /// Pin select for SCL signal
            pub const SCL = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x0);

            /// address: 0x40003004
            /// Pin select for SDA signal
            pub const SDA = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x4);
        };

        /// RXD EasyDMA channel
        pub const RXD = struct {

            /// address: 0x40003000
            /// Data pointer
            pub const PTR = @intToPtr(*volatile u32, base_address + 0x0);

            /// address: 0x40003004
            /// Maximum number of bytes in receive buffer
            pub const MAXCNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x4);

            /// address: 0x40003008
            /// Number of bytes transferred in the last transaction
            pub const AMOUNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x8);

            /// address: 0x4000300c
            /// EasyDMA list type
            pub const LIST = @intToPtr(*volatile MmioInt(32, u3), base_address + 0xc);
        };

        /// TXD EasyDMA channel
        pub const TXD = struct {

            /// address: 0x40003000
            /// Data pointer
            pub const PTR = @intToPtr(*volatile u32, base_address + 0x0);

            /// address: 0x40003004
            /// Maximum number of bytes in transmit buffer
            pub const MAXCNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x4);

            /// address: 0x40003008
            /// Number of bytes transferred in the last transaction
            pub const AMOUNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x8);

            /// address: 0x4000300c
            /// EasyDMA list type
            pub const LIST = @intToPtr(*volatile MmioInt(32, u3), base_address + 0xc);
        };
    };
    /// I2C compatible Two-Wire Slave Interface with EasyDMA 0
    pub const TWIS0 = struct {
        pub const base_address = 0x40003000;

        /// address: 0x40003014
        /// Stop TWI transaction
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x4000301c
        /// Suspend TWI transaction
        pub const TASKS_SUSPEND = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x40003020
        /// Resume TWI transaction
        pub const TASKS_RESUME = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x40003030
        /// Prepare the TWI slave to respond to a write command
        pub const TASKS_PREPARERX = @intToPtr(*volatile u32, base_address + 0x30);

        /// address: 0x40003034
        /// Prepare the TWI slave to respond to a read command
        pub const TASKS_PREPARETX = @intToPtr(*volatile u32, base_address + 0x34);

        /// address: 0x40003104
        /// TWI stopped
        pub const EVENTS_STOPPED = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40003124
        /// TWI error
        pub const EVENTS_ERROR = @intToPtr(*volatile u32, base_address + 0x124);

        /// address: 0x4000314c
        /// Receive sequence started
        pub const EVENTS_RXSTARTED = @intToPtr(*volatile u32, base_address + 0x14c);

        /// address: 0x40003150
        /// Transmit sequence started
        pub const EVENTS_TXSTARTED = @intToPtr(*volatile u32, base_address + 0x150);

        /// address: 0x40003164
        /// Write command received
        pub const EVENTS_WRITE = @intToPtr(*volatile u32, base_address + 0x164);

        /// address: 0x40003168
        /// Read command received
        pub const EVENTS_READ = @intToPtr(*volatile u32, base_address + 0x168);

        /// address: 0x40003200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Shortcut between WRITE event and SUSPEND task
            WRITE_SUSPEND: u1,
            /// Shortcut between READ event and SUSPEND task
            READ_SUSPEND: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x200);

        /// address: 0x40003300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Enable or disable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Enable or disable interrupt for ERROR event
            ERROR: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Enable or disable interrupt for RXSTARTED event
            RXSTARTED: u1,
            /// Enable or disable interrupt for TXSTARTED event
            TXSTARTED: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Enable or disable interrupt for WRITE event
            WRITE: u1,
            /// Enable or disable interrupt for READ event
            READ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x300);

        /// address: 0x40003304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Enable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Write '1' to Enable interrupt for ERROR event
            ERROR: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Write '1' to Enable interrupt for RXSTARTED event
            RXSTARTED: u1,
            /// Write '1' to Enable interrupt for TXSTARTED event
            TXSTARTED: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Write '1' to Enable interrupt for WRITE event
            WRITE: u1,
            /// Write '1' to Enable interrupt for READ event
            READ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x304);

        /// address: 0x40003308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Disable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Write '1' to Disable interrupt for ERROR event
            ERROR: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Write '1' to Disable interrupt for RXSTARTED event
            RXSTARTED: u1,
            /// Write '1' to Disable interrupt for TXSTARTED event
            TXSTARTED: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Write '1' to Disable interrupt for WRITE event
            WRITE: u1,
            /// Write '1' to Disable interrupt for READ event
            READ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x308);

        /// address: 0x400034d0
        /// Error source
        pub const ERRORSRC = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX buffer overflow detected, and prevented
            OVERFLOW: u1,
            reserved0: u1,
            /// NACK sent after receiving a data byte
            DNACK: u1,
            /// TX buffer over-read detected, and prevented
            OVERREAD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x4d0);

        /// address: 0x400034d4
        /// Status register indicating which address had a match
        pub const MATCH = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x4d4);

        /// address: 0x40003500
        /// Enable TWIS
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x500);

        /// address: 0x40003588
        /// Description collection[0]: TWI slave address 0
        pub const ADDRESS = @intToPtr(*volatile [2]MmioInt(32, u7), base_address + 0x588);

        /// address: 0x40003594
        /// Configuration register for the address match mechanism
        pub const CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable address matching on ADDRESS[0]
            ADDRESS0: u1,
            /// Enable or disable address matching on ADDRESS[1]
            ADDRESS1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x594);

        /// address: 0x400035c0
        /// Over-read character. Character sent out in case of an over-read of the transmit
        /// buffer.
        pub const ORC = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x5c0);

        pub const PSEL = struct {

            /// address: 0x40003000
            /// Pin select for SCL signal
            pub const SCL = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x0);

            /// address: 0x40003004
            /// Pin select for SDA signal
            pub const SDA = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x4);
        };

        /// RXD EasyDMA channel
        pub const RXD = struct {

            /// address: 0x40003000
            /// RXD Data pointer
            pub const PTR = @intToPtr(*volatile u32, base_address + 0x0);

            /// address: 0x40003004
            /// Maximum number of bytes in RXD buffer
            pub const MAXCNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x4);

            /// address: 0x40003008
            /// Number of bytes transferred in the last RXD transaction
            pub const AMOUNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x8);
        };

        /// TXD EasyDMA channel
        pub const TXD = struct {

            /// address: 0x40003000
            /// TXD Data pointer
            pub const PTR = @intToPtr(*volatile u32, base_address + 0x0);

            /// address: 0x40003004
            /// Maximum number of bytes in TXD buffer
            pub const MAXCNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x4);

            /// address: 0x40003008
            /// Number of bytes transferred in the last TXD transaction
            pub const AMOUNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x8);
        };
    };
    /// Serial Peripheral Interface 0
    pub const SPI0 = struct {
        pub const base_address = 0x40003000;

        /// address: 0x40003108
        /// TXD byte sent and RXD byte received
        pub const EVENTS_READY = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x40003304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Write '1' to Enable interrupt for READY event
            READY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x304);

        /// address: 0x40003308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Write '1' to Disable interrupt for READY event
            READY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x308);

        /// address: 0x40003500
        /// Enable SPI
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x500);

        /// address: 0x40003518
        /// RXD register
        pub const RXD = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x518);

        /// address: 0x4000351c
        /// TXD register
        pub const TXD = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x51c);

        /// address: 0x40003524
        /// SPI frequency
        pub const FREQUENCY = @intToPtr(*volatile u32, base_address + 0x524);

        /// address: 0x40003554
        /// Configuration register
        pub const CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bit order
            ORDER: u1,
            /// Serial clock (SCK) phase
            CPHA: u1,
            /// Serial clock (SCK) polarity
            CPOL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x554);

        pub const PSEL = struct {

            /// address: 0x40003000
            /// Pin select for SCK
            pub const SCK = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number configuration for SPI SCK signal
                PSELSCK: u32,
            }), base_address + 0x0);

            /// address: 0x40003004
            /// Pin select for MOSI
            pub const MOSI = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number configuration for SPI MOSI signal
                PSELMOSI: u32,
            }), base_address + 0x4);

            /// address: 0x40003008
            /// Pin select for MISO
            pub const MISO = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number configuration for SPI MISO signal
                PSELMISO: u32,
            }), base_address + 0x8);
        };
    };
    /// I2C compatible Two-Wire Interface 0
    pub const TWI0 = struct {
        pub const base_address = 0x40003000;

        /// address: 0x40003000
        /// Start TWI receive sequence
        pub const TASKS_STARTRX = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40003008
        /// Start TWI transmit sequence
        pub const TASKS_STARTTX = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x40003014
        /// Stop TWI transaction
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x4000301c
        /// Suspend TWI transaction
        pub const TASKS_SUSPEND = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x40003020
        /// Resume TWI transaction
        pub const TASKS_RESUME = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x40003104
        /// TWI stopped
        pub const EVENTS_STOPPED = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40003108
        /// TWI RXD byte received
        pub const EVENTS_RXDREADY = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x4000311c
        /// TWI TXD byte sent
        pub const EVENTS_TXDSENT = @intToPtr(*volatile u32, base_address + 0x11c);

        /// address: 0x40003124
        /// TWI error
        pub const EVENTS_ERROR = @intToPtr(*volatile u32, base_address + 0x124);

        /// address: 0x40003138
        /// TWI byte boundary, generated before each byte that is sent or received
        pub const EVENTS_BB = @intToPtr(*volatile u32, base_address + 0x138);

        /// address: 0x40003148
        /// TWI entered the suspended state
        pub const EVENTS_SUSPENDED = @intToPtr(*volatile u32, base_address + 0x148);

        /// address: 0x40003200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Shortcut between BB event and SUSPEND task
            BB_SUSPEND: u1,
            /// Shortcut between BB event and STOP task
            BB_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x200);

        /// address: 0x40003304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Enable interrupt for STOPPED event
            STOPPED: u1,
            /// Write '1' to Enable interrupt for RXDREADY event
            RXDREADY: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Write '1' to Enable interrupt for TXDSENT event
            TXDSENT: u1,
            reserved5: u1,
            /// Write '1' to Enable interrupt for ERROR event
            ERROR: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Write '1' to Enable interrupt for BB event
            BB: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Write '1' to Enable interrupt for SUSPENDED event
            SUSPENDED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x304);

        /// address: 0x40003308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Disable interrupt for STOPPED event
            STOPPED: u1,
            /// Write '1' to Disable interrupt for RXDREADY event
            RXDREADY: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Write '1' to Disable interrupt for TXDSENT event
            TXDSENT: u1,
            reserved5: u1,
            /// Write '1' to Disable interrupt for ERROR event
            ERROR: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Write '1' to Disable interrupt for BB event
            BB: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Write '1' to Disable interrupt for SUSPENDED event
            SUSPENDED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x308);

        /// address: 0x400034c4
        /// Error source
        pub const ERRORSRC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overrun error
            OVERRUN: u1,
            /// NACK received after sending the address (write '1' to clear)
            ANACK: u1,
            /// NACK received after sending a data byte (write '1' to clear)
            DNACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4c4);

        /// address: 0x40003500
        /// Enable TWI
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x500);

        /// address: 0x40003508
        /// Pin select for SCL
        pub const PSELSCL = @intToPtr(*volatile u32, base_address + 0x508);

        /// address: 0x4000350c
        /// Pin select for SDA
        pub const PSELSDA = @intToPtr(*volatile u32, base_address + 0x50c);

        /// address: 0x40003518
        /// RXD register
        pub const RXD = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x518);

        /// address: 0x4000351c
        /// TXD register
        pub const TXD = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x51c);

        /// address: 0x40003524
        /// TWI frequency
        pub const FREQUENCY = @intToPtr(*volatile u32, base_address + 0x524);

        /// address: 0x40003588
        /// Address used in the TWI transfer
        pub const ADDRESS = @intToPtr(*volatile MmioInt(32, u7), base_address + 0x588);
    };
    /// Serial Peripheral Interface Master with EasyDMA 1
    pub const SPIM1 = struct {
        pub const base_address = 0x40004000;

        /// address: 0x40004010
        /// Start SPI transaction
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40004014
        /// Stop SPI transaction
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x4000401c
        /// Suspend SPI transaction
        pub const TASKS_SUSPEND = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x40004020
        /// Resume SPI transaction
        pub const TASKS_RESUME = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x40004104
        /// SPI transaction has stopped
        pub const EVENTS_STOPPED = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40004110
        /// End of RXD buffer reached
        pub const EVENTS_ENDRX = @intToPtr(*volatile u32, base_address + 0x110);

        /// address: 0x40004118
        /// End of RXD buffer and TXD buffer reached
        pub const EVENTS_END = @intToPtr(*volatile u32, base_address + 0x118);

        /// address: 0x40004120
        /// End of TXD buffer reached
        pub const EVENTS_ENDTX = @intToPtr(*volatile u32, base_address + 0x120);

        /// address: 0x4000414c
        /// Transaction started
        pub const EVENTS_STARTED = @intToPtr(*volatile u32, base_address + 0x14c);

        /// address: 0x40004200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Shortcut between END event and START task
            END_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x200);

        /// address: 0x40004304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Enable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            /// Write '1' to Enable interrupt for ENDRX event
            ENDRX: u1,
            reserved3: u1,
            /// Write '1' to Enable interrupt for END event
            END: u1,
            reserved4: u1,
            /// Write '1' to Enable interrupt for ENDTX event
            ENDTX: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// Write '1' to Enable interrupt for STARTED event
            STARTED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x304);

        /// address: 0x40004308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Disable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            /// Write '1' to Disable interrupt for ENDRX event
            ENDRX: u1,
            reserved3: u1,
            /// Write '1' to Disable interrupt for END event
            END: u1,
            reserved4: u1,
            /// Write '1' to Disable interrupt for ENDTX event
            ENDTX: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// Write '1' to Disable interrupt for STARTED event
            STARTED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x308);

        /// address: 0x40004500
        /// Enable SPIM
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x500);

        /// address: 0x40004524
        /// SPI frequency. Accuracy depends on the HFCLK source selected.
        pub const FREQUENCY = @intToPtr(*volatile u32, base_address + 0x524);

        /// address: 0x40004554
        /// Configuration register
        pub const CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bit order
            ORDER: u1,
            /// Serial clock (SCK) phase
            CPHA: u1,
            /// Serial clock (SCK) polarity
            CPOL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x554);

        /// address: 0x400045c0
        /// Over-read character. Character clocked out in case and over-read of the TXD
        /// buffer.
        pub const ORC = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x5c0);
    };
    /// SPI Slave 1
    pub const SPIS1 = struct {
        pub const base_address = 0x40004000;

        /// address: 0x40004024
        /// Acquire SPI semaphore
        pub const TASKS_ACQUIRE = @intToPtr(*volatile u32, base_address + 0x24);

        /// address: 0x40004028
        /// Release SPI semaphore, enabling the SPI slave to acquire it
        pub const TASKS_RELEASE = @intToPtr(*volatile u32, base_address + 0x28);

        /// address: 0x40004104
        /// Granted transaction completed
        pub const EVENTS_END = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40004110
        /// End of RXD buffer reached
        pub const EVENTS_ENDRX = @intToPtr(*volatile u32, base_address + 0x110);

        /// address: 0x40004128
        /// Semaphore acquired
        pub const EVENTS_ACQUIRED = @intToPtr(*volatile u32, base_address + 0x128);

        /// address: 0x40004200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Shortcut between END event and ACQUIRE task
            END_ACQUIRE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x200);

        /// address: 0x40004304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Enable interrupt for END event
            END: u1,
            reserved1: u1,
            reserved2: u1,
            /// Write '1' to Enable interrupt for ENDRX event
            ENDRX: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Write '1' to Enable interrupt for ACQUIRED event
            ACQUIRED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x304);

        /// address: 0x40004308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Disable interrupt for END event
            END: u1,
            reserved1: u1,
            reserved2: u1,
            /// Write '1' to Disable interrupt for ENDRX event
            ENDRX: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Write '1' to Disable interrupt for ACQUIRED event
            ACQUIRED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x308);

        /// address: 0x40004400
        /// Semaphore status register
        pub const SEMSTAT = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x400);

        /// address: 0x40004440
        /// Status from last transaction
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX buffer over-read detected, and prevented
            OVERREAD: u1,
            /// RX buffer overflow detected, and prevented
            OVERFLOW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x440);

        /// address: 0x40004500
        /// Enable SPI slave
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x500);

        /// address: 0x40004554
        /// Configuration register
        pub const CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bit order
            ORDER: u1,
            /// Serial clock (SCK) phase
            CPHA: u1,
            /// Serial clock (SCK) polarity
            CPOL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x554);

        /// address: 0x4000455c
        /// Default character. Character clocked out in case of an ignored transaction.
        pub const DEF = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x55c);

        /// address: 0x400045c0
        /// Over-read character
        pub const ORC = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x5c0);
    };
    /// I2C compatible Two-Wire Master Interface with EasyDMA 1
    pub const TWIM1 = struct {
        pub const base_address = 0x40004000;

        /// address: 0x40004000
        /// Start TWI receive sequence
        pub const TASKS_STARTRX = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40004008
        /// Start TWI transmit sequence
        pub const TASKS_STARTTX = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x40004014
        /// Stop TWI transaction. Must be issued while the TWI master is not suspended.
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x4000401c
        /// Suspend TWI transaction
        pub const TASKS_SUSPEND = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x40004020
        /// Resume TWI transaction
        pub const TASKS_RESUME = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x40004104
        /// TWI stopped
        pub const EVENTS_STOPPED = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40004124
        /// TWI error
        pub const EVENTS_ERROR = @intToPtr(*volatile u32, base_address + 0x124);

        /// address: 0x40004148
        /// Last byte has been sent out after the SUSPEND task has been issued, TWI traffic
        /// is now suspended.
        pub const EVENTS_SUSPENDED = @intToPtr(*volatile u32, base_address + 0x148);

        /// address: 0x4000414c
        /// Receive sequence started
        pub const EVENTS_RXSTARTED = @intToPtr(*volatile u32, base_address + 0x14c);

        /// address: 0x40004150
        /// Transmit sequence started
        pub const EVENTS_TXSTARTED = @intToPtr(*volatile u32, base_address + 0x150);

        /// address: 0x4000415c
        /// Byte boundary, starting to receive the last byte
        pub const EVENTS_LASTRX = @intToPtr(*volatile u32, base_address + 0x15c);

        /// address: 0x40004160
        /// Byte boundary, starting to transmit the last byte
        pub const EVENTS_LASTTX = @intToPtr(*volatile u32, base_address + 0x160);

        /// address: 0x40004200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Shortcut between LASTTX event and STARTRX task
            LASTTX_STARTRX: u1,
            /// Shortcut between LASTTX event and SUSPEND task
            LASTTX_SUSPEND: u1,
            /// Shortcut between LASTTX event and STOP task
            LASTTX_STOP: u1,
            /// Shortcut between LASTRX event and STARTTX task
            LASTRX_STARTTX: u1,
            reserved7: u1,
            /// Shortcut between LASTRX event and STOP task
            LASTRX_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x200);

        /// address: 0x40004300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Enable or disable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Enable or disable interrupt for ERROR event
            ERROR: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Enable or disable interrupt for SUSPENDED event
            SUSPENDED: u1,
            /// Enable or disable interrupt for RXSTARTED event
            RXSTARTED: u1,
            /// Enable or disable interrupt for TXSTARTED event
            TXSTARTED: u1,
            reserved16: u1,
            reserved17: u1,
            /// Enable or disable interrupt for LASTRX event
            LASTRX: u1,
            /// Enable or disable interrupt for LASTTX event
            LASTTX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x300);

        /// address: 0x40004304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Enable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Write '1' to Enable interrupt for ERROR event
            ERROR: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Write '1' to Enable interrupt for SUSPENDED event
            SUSPENDED: u1,
            /// Write '1' to Enable interrupt for RXSTARTED event
            RXSTARTED: u1,
            /// Write '1' to Enable interrupt for TXSTARTED event
            TXSTARTED: u1,
            reserved16: u1,
            reserved17: u1,
            /// Write '1' to Enable interrupt for LASTRX event
            LASTRX: u1,
            /// Write '1' to Enable interrupt for LASTTX event
            LASTTX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x304);

        /// address: 0x40004308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Disable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Write '1' to Disable interrupt for ERROR event
            ERROR: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Write '1' to Disable interrupt for SUSPENDED event
            SUSPENDED: u1,
            /// Write '1' to Disable interrupt for RXSTARTED event
            RXSTARTED: u1,
            /// Write '1' to Disable interrupt for TXSTARTED event
            TXSTARTED: u1,
            reserved16: u1,
            reserved17: u1,
            /// Write '1' to Disable interrupt for LASTRX event
            LASTRX: u1,
            /// Write '1' to Disable interrupt for LASTTX event
            LASTTX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x308);

        /// address: 0x400044c4
        /// Error source
        pub const ERRORSRC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overrun error
            OVERRUN: u1,
            /// NACK received after sending the address (write '1' to clear)
            ANACK: u1,
            /// NACK received after sending a data byte (write '1' to clear)
            DNACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4c4);

        /// address: 0x40004500
        /// Enable TWIM
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x500);

        /// address: 0x40004524
        /// TWI frequency
        pub const FREQUENCY = @intToPtr(*volatile u32, base_address + 0x524);

        /// address: 0x40004588
        /// Address used in the TWI transfer
        pub const ADDRESS = @intToPtr(*volatile MmioInt(32, u7), base_address + 0x588);
    };
    /// I2C compatible Two-Wire Slave Interface with EasyDMA 1
    pub const TWIS1 = struct {
        pub const base_address = 0x40004000;

        /// address: 0x40004014
        /// Stop TWI transaction
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x4000401c
        /// Suspend TWI transaction
        pub const TASKS_SUSPEND = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x40004020
        /// Resume TWI transaction
        pub const TASKS_RESUME = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x40004030
        /// Prepare the TWI slave to respond to a write command
        pub const TASKS_PREPARERX = @intToPtr(*volatile u32, base_address + 0x30);

        /// address: 0x40004034
        /// Prepare the TWI slave to respond to a read command
        pub const TASKS_PREPARETX = @intToPtr(*volatile u32, base_address + 0x34);

        /// address: 0x40004104
        /// TWI stopped
        pub const EVENTS_STOPPED = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40004124
        /// TWI error
        pub const EVENTS_ERROR = @intToPtr(*volatile u32, base_address + 0x124);

        /// address: 0x4000414c
        /// Receive sequence started
        pub const EVENTS_RXSTARTED = @intToPtr(*volatile u32, base_address + 0x14c);

        /// address: 0x40004150
        /// Transmit sequence started
        pub const EVENTS_TXSTARTED = @intToPtr(*volatile u32, base_address + 0x150);

        /// address: 0x40004164
        /// Write command received
        pub const EVENTS_WRITE = @intToPtr(*volatile u32, base_address + 0x164);

        /// address: 0x40004168
        /// Read command received
        pub const EVENTS_READ = @intToPtr(*volatile u32, base_address + 0x168);

        /// address: 0x40004200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Shortcut between WRITE event and SUSPEND task
            WRITE_SUSPEND: u1,
            /// Shortcut between READ event and SUSPEND task
            READ_SUSPEND: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x200);

        /// address: 0x40004300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Enable or disable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Enable or disable interrupt for ERROR event
            ERROR: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Enable or disable interrupt for RXSTARTED event
            RXSTARTED: u1,
            /// Enable or disable interrupt for TXSTARTED event
            TXSTARTED: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Enable or disable interrupt for WRITE event
            WRITE: u1,
            /// Enable or disable interrupt for READ event
            READ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x300);

        /// address: 0x40004304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Enable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Write '1' to Enable interrupt for ERROR event
            ERROR: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Write '1' to Enable interrupt for RXSTARTED event
            RXSTARTED: u1,
            /// Write '1' to Enable interrupt for TXSTARTED event
            TXSTARTED: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Write '1' to Enable interrupt for WRITE event
            WRITE: u1,
            /// Write '1' to Enable interrupt for READ event
            READ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x304);

        /// address: 0x40004308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Disable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Write '1' to Disable interrupt for ERROR event
            ERROR: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Write '1' to Disable interrupt for RXSTARTED event
            RXSTARTED: u1,
            /// Write '1' to Disable interrupt for TXSTARTED event
            TXSTARTED: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Write '1' to Disable interrupt for WRITE event
            WRITE: u1,
            /// Write '1' to Disable interrupt for READ event
            READ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x308);

        /// address: 0x400044d0
        /// Error source
        pub const ERRORSRC = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX buffer overflow detected, and prevented
            OVERFLOW: u1,
            reserved0: u1,
            /// NACK sent after receiving a data byte
            DNACK: u1,
            /// TX buffer over-read detected, and prevented
            OVERREAD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x4d0);

        /// address: 0x400044d4
        /// Status register indicating which address had a match
        pub const MATCH = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x4d4);

        /// address: 0x40004500
        /// Enable TWIS
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x500);

        /// address: 0x40004588
        /// Description collection[0]: TWI slave address 0
        pub const ADDRESS = @intToPtr(*volatile [2]MmioInt(32, u7), base_address + 0x588);

        /// address: 0x40004594
        /// Configuration register for the address match mechanism
        pub const CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable address matching on ADDRESS[0]
            ADDRESS0: u1,
            /// Enable or disable address matching on ADDRESS[1]
            ADDRESS1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x594);

        /// address: 0x400045c0
        /// Over-read character. Character sent out in case of an over-read of the transmit
        /// buffer.
        pub const ORC = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x5c0);
    };
    /// Serial Peripheral Interface 1
    pub const SPI1 = struct {
        pub const base_address = 0x40004000;

        /// address: 0x40004108
        /// TXD byte sent and RXD byte received
        pub const EVENTS_READY = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x40004304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Write '1' to Enable interrupt for READY event
            READY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x304);

        /// address: 0x40004308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Write '1' to Disable interrupt for READY event
            READY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x308);

        /// address: 0x40004500
        /// Enable SPI
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x500);

        /// address: 0x40004518
        /// RXD register
        pub const RXD = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x518);

        /// address: 0x4000451c
        /// TXD register
        pub const TXD = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x51c);

        /// address: 0x40004524
        /// SPI frequency
        pub const FREQUENCY = @intToPtr(*volatile u32, base_address + 0x524);

        /// address: 0x40004554
        /// Configuration register
        pub const CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bit order
            ORDER: u1,
            /// Serial clock (SCK) phase
            CPHA: u1,
            /// Serial clock (SCK) polarity
            CPOL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x554);
    };
    /// I2C compatible Two-Wire Interface 1
    pub const TWI1 = struct {
        pub const base_address = 0x40004000;

        /// address: 0x40004000
        /// Start TWI receive sequence
        pub const TASKS_STARTRX = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40004008
        /// Start TWI transmit sequence
        pub const TASKS_STARTTX = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x40004014
        /// Stop TWI transaction
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x4000401c
        /// Suspend TWI transaction
        pub const TASKS_SUSPEND = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x40004020
        /// Resume TWI transaction
        pub const TASKS_RESUME = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x40004104
        /// TWI stopped
        pub const EVENTS_STOPPED = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40004108
        /// TWI RXD byte received
        pub const EVENTS_RXDREADY = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x4000411c
        /// TWI TXD byte sent
        pub const EVENTS_TXDSENT = @intToPtr(*volatile u32, base_address + 0x11c);

        /// address: 0x40004124
        /// TWI error
        pub const EVENTS_ERROR = @intToPtr(*volatile u32, base_address + 0x124);

        /// address: 0x40004138
        /// TWI byte boundary, generated before each byte that is sent or received
        pub const EVENTS_BB = @intToPtr(*volatile u32, base_address + 0x138);

        /// address: 0x40004148
        /// TWI entered the suspended state
        pub const EVENTS_SUSPENDED = @intToPtr(*volatile u32, base_address + 0x148);

        /// address: 0x40004200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Shortcut between BB event and SUSPEND task
            BB_SUSPEND: u1,
            /// Shortcut between BB event and STOP task
            BB_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x200);

        /// address: 0x40004304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Enable interrupt for STOPPED event
            STOPPED: u1,
            /// Write '1' to Enable interrupt for RXDREADY event
            RXDREADY: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Write '1' to Enable interrupt for TXDSENT event
            TXDSENT: u1,
            reserved5: u1,
            /// Write '1' to Enable interrupt for ERROR event
            ERROR: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Write '1' to Enable interrupt for BB event
            BB: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Write '1' to Enable interrupt for SUSPENDED event
            SUSPENDED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x304);

        /// address: 0x40004308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Disable interrupt for STOPPED event
            STOPPED: u1,
            /// Write '1' to Disable interrupt for RXDREADY event
            RXDREADY: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Write '1' to Disable interrupt for TXDSENT event
            TXDSENT: u1,
            reserved5: u1,
            /// Write '1' to Disable interrupt for ERROR event
            ERROR: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Write '1' to Disable interrupt for BB event
            BB: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Write '1' to Disable interrupt for SUSPENDED event
            SUSPENDED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x308);

        /// address: 0x400044c4
        /// Error source
        pub const ERRORSRC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overrun error
            OVERRUN: u1,
            /// NACK received after sending the address (write '1' to clear)
            ANACK: u1,
            /// NACK received after sending a data byte (write '1' to clear)
            DNACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4c4);

        /// address: 0x40004500
        /// Enable TWI
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x500);

        /// address: 0x40004508
        /// Pin select for SCL
        pub const PSELSCL = @intToPtr(*volatile u32, base_address + 0x508);

        /// address: 0x4000450c
        /// Pin select for SDA
        pub const PSELSDA = @intToPtr(*volatile u32, base_address + 0x50c);

        /// address: 0x40004518
        /// RXD register
        pub const RXD = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x518);

        /// address: 0x4000451c
        /// TXD register
        pub const TXD = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x51c);

        /// address: 0x40004524
        /// TWI frequency
        pub const FREQUENCY = @intToPtr(*volatile u32, base_address + 0x524);

        /// address: 0x40004588
        /// Address used in the TWI transfer
        pub const ADDRESS = @intToPtr(*volatile MmioInt(32, u7), base_address + 0x588);
    };
    /// NFC-A compatible radio
    pub const NFCT = struct {
        pub const base_address = 0x40005000;

        /// address: 0x40005000
        /// Activate NFC peripheral for incoming and outgoing frames, change state to
        /// activated
        pub const TASKS_ACTIVATE = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40005004
        /// Disable NFC peripheral
        pub const TASKS_DISABLE = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40005008
        /// Enable NFC sense field mode, change state to sense mode
        pub const TASKS_SENSE = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4000500c
        /// Start transmission of a outgoing frame, change state to transmit
        pub const TASKS_STARTTX = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x4000501c
        /// Initializes the EasyDMA for receive.
        pub const TASKS_ENABLERXDATA = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x40005024
        /// Force state machine to IDLE state
        pub const TASKS_GOIDLE = @intToPtr(*volatile u32, base_address + 0x24);

        /// address: 0x40005028
        /// Force state machine to SLEEP_A state
        pub const TASKS_GOSLEEP = @intToPtr(*volatile u32, base_address + 0x28);

        /// address: 0x40005100
        /// The NFC peripheral is ready to receive and send frames
        pub const EVENTS_READY = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x40005104
        /// Remote NFC field detected
        pub const EVENTS_FIELDDETECTED = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40005108
        /// Remote NFC field lost
        pub const EVENTS_FIELDLOST = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x4000510c
        /// Marks the start of the first symbol of a transmitted frame
        pub const EVENTS_TXFRAMESTART = @intToPtr(*volatile u32, base_address + 0x10c);

        /// address: 0x40005110
        /// Marks the end of the last transmitted on-air symbol of a frame
        pub const EVENTS_TXFRAMEEND = @intToPtr(*volatile u32, base_address + 0x110);

        /// address: 0x40005114
        /// Marks the end of the first symbol of a received frame
        pub const EVENTS_RXFRAMESTART = @intToPtr(*volatile u32, base_address + 0x114);

        /// address: 0x40005118
        /// Received data have been checked (CRC, parity) and transferred to RAM, and
        /// EasyDMA has ended accessing the RX buffer
        pub const EVENTS_RXFRAMEEND = @intToPtr(*volatile u32, base_address + 0x118);

        /// address: 0x4000511c
        /// NFC error reported. The ERRORSTATUS register contains details on the source of
        /// the error.
        pub const EVENTS_ERROR = @intToPtr(*volatile u32, base_address + 0x11c);

        /// address: 0x40005128
        /// NFC RX frame error reported. The FRAMESTATUS.RX register contains details on the
        /// source of the error.
        pub const EVENTS_RXERROR = @intToPtr(*volatile u32, base_address + 0x128);

        /// address: 0x4000512c
        /// RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full.
        pub const EVENTS_ENDRX = @intToPtr(*volatile u32, base_address + 0x12c);

        /// address: 0x40005130
        /// Transmission of data in RAM has ended, and EasyDMA has ended accessing the TX
        /// buffer
        pub const EVENTS_ENDTX = @intToPtr(*volatile u32, base_address + 0x130);

        /// address: 0x40005138
        /// Auto collision resolution process has started
        pub const EVENTS_AUTOCOLRESSTARTED = @intToPtr(*volatile u32, base_address + 0x138);

        /// address: 0x40005148
        /// NFC Auto collision resolution error reported.
        pub const EVENTS_COLLISION = @intToPtr(*volatile u32, base_address + 0x148);

        /// address: 0x4000514c
        /// NFC Auto collision resolution successfully completed
        pub const EVENTS_SELECTED = @intToPtr(*volatile u32, base_address + 0x14c);

        /// address: 0x40005150
        /// EasyDMA is ready to receive or send frames.
        pub const EVENTS_STARTED = @intToPtr(*volatile u32, base_address + 0x150);

        /// address: 0x40005200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Shortcut between FIELDDETECTED event and ACTIVATE task
            FIELDDETECTED_ACTIVATE: u1,
            /// Shortcut between FIELDLOST event and SENSE task
            FIELDLOST_SENSE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x200);

        /// address: 0x40005300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable interrupt for READY event
            READY: u1,
            /// Enable or disable interrupt for FIELDDETECTED event
            FIELDDETECTED: u1,
            /// Enable or disable interrupt for FIELDLOST event
            FIELDLOST: u1,
            /// Enable or disable interrupt for TXFRAMESTART event
            TXFRAMESTART: u1,
            /// Enable or disable interrupt for TXFRAMEEND event
            TXFRAMEEND: u1,
            /// Enable or disable interrupt for RXFRAMESTART event
            RXFRAMESTART: u1,
            /// Enable or disable interrupt for RXFRAMEEND event
            RXFRAMEEND: u1,
            /// Enable or disable interrupt for ERROR event
            ERROR: u1,
            reserved0: u1,
            reserved1: u1,
            /// Enable or disable interrupt for RXERROR event
            RXERROR: u1,
            /// Enable or disable interrupt for ENDRX event
            ENDRX: u1,
            /// Enable or disable interrupt for ENDTX event
            ENDTX: u1,
            reserved2: u1,
            /// Enable or disable interrupt for AUTOCOLRESSTARTED event
            AUTOCOLRESSTARTED: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Enable or disable interrupt for COLLISION event
            COLLISION: u1,
            /// Enable or disable interrupt for SELECTED event
            SELECTED: u1,
            /// Enable or disable interrupt for STARTED event
            STARTED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x300);

        /// address: 0x40005304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for READY event
            READY: u1,
            /// Write '1' to Enable interrupt for FIELDDETECTED event
            FIELDDETECTED: u1,
            /// Write '1' to Enable interrupt for FIELDLOST event
            FIELDLOST: u1,
            /// Write '1' to Enable interrupt for TXFRAMESTART event
            TXFRAMESTART: u1,
            /// Write '1' to Enable interrupt for TXFRAMEEND event
            TXFRAMEEND: u1,
            /// Write '1' to Enable interrupt for RXFRAMESTART event
            RXFRAMESTART: u1,
            /// Write '1' to Enable interrupt for RXFRAMEEND event
            RXFRAMEEND: u1,
            /// Write '1' to Enable interrupt for ERROR event
            ERROR: u1,
            reserved0: u1,
            reserved1: u1,
            /// Write '1' to Enable interrupt for RXERROR event
            RXERROR: u1,
            /// Write '1' to Enable interrupt for ENDRX event
            ENDRX: u1,
            /// Write '1' to Enable interrupt for ENDTX event
            ENDTX: u1,
            reserved2: u1,
            /// Write '1' to Enable interrupt for AUTOCOLRESSTARTED event
            AUTOCOLRESSTARTED: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Write '1' to Enable interrupt for COLLISION event
            COLLISION: u1,
            /// Write '1' to Enable interrupt for SELECTED event
            SELECTED: u1,
            /// Write '1' to Enable interrupt for STARTED event
            STARTED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x304);

        /// address: 0x40005308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for READY event
            READY: u1,
            /// Write '1' to Disable interrupt for FIELDDETECTED event
            FIELDDETECTED: u1,
            /// Write '1' to Disable interrupt for FIELDLOST event
            FIELDLOST: u1,
            /// Write '1' to Disable interrupt for TXFRAMESTART event
            TXFRAMESTART: u1,
            /// Write '1' to Disable interrupt for TXFRAMEEND event
            TXFRAMEEND: u1,
            /// Write '1' to Disable interrupt for RXFRAMESTART event
            RXFRAMESTART: u1,
            /// Write '1' to Disable interrupt for RXFRAMEEND event
            RXFRAMEEND: u1,
            /// Write '1' to Disable interrupt for ERROR event
            ERROR: u1,
            reserved0: u1,
            reserved1: u1,
            /// Write '1' to Disable interrupt for RXERROR event
            RXERROR: u1,
            /// Write '1' to Disable interrupt for ENDRX event
            ENDRX: u1,
            /// Write '1' to Disable interrupt for ENDTX event
            ENDTX: u1,
            reserved2: u1,
            /// Write '1' to Disable interrupt for AUTOCOLRESSTARTED event
            AUTOCOLRESSTARTED: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Write '1' to Disable interrupt for COLLISION event
            COLLISION: u1,
            /// Write '1' to Disable interrupt for SELECTED event
            SELECTED: u1,
            /// Write '1' to Disable interrupt for STARTED event
            STARTED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x308);

        /// address: 0x40005404
        /// NFC Error Status register
        pub const ERRORSTATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// No STARTTX task triggered before expiration of the time set in FRAMEDELAYMAX
            FRAMEDELAYTIMEOUT: u1,
            reserved0: u1,
            /// Field level is too high at max load resistance
            NFCFIELDTOOSTRONG: u1,
            /// Field level is too low at min load resistance
            NFCFIELDTOOWEAK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x404);

        /// address: 0x40005430
        /// Current value driven to the NFC Load Control
        pub const CURRENTLOADCTRL = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x430);

        /// address: 0x4000543c
        /// Indicates the presence or not of a valid field
        pub const FIELDPRESENT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates the presence or not of a valid field. Available only in the activated
            /// state.
            FIELDPRESENT: u1,
            /// Indicates if the low level has locked to the field
            LOCKDETECT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x43c);

        /// address: 0x40005504
        /// Minimum frame delay
        pub const FRAMEDELAYMIN = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x504);

        /// address: 0x40005508
        /// Maximum frame delay
        pub const FRAMEDELAYMAX = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x508);

        /// address: 0x4000550c
        /// Configuration register for the Frame Delay Timer
        pub const FRAMEDELAYMODE = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x50c);

        /// address: 0x40005510
        /// Packet pointer for TXD and RXD data storage in Data RAM
        pub const PACKETPTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet pointer for TXD and RXD data storage in Data RAM. This address is a byte
            /// aligned RAM address.
            PTR: u32,
        }), base_address + 0x510);

        /// address: 0x40005514
        /// Size of allocated for TXD and RXD data storage buffer in Data RAM
        pub const MAXLEN = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x514);

        /// address: 0x40005590
        /// Last NFCID1 part (4, 7 or 10 bytes ID)
        pub const NFCID1_LAST = @intToPtr(*volatile Mmio(32, packed struct {
            /// NFCID1 byte Z (very last byte sent)
            NFCID1_Z: u8,
            /// NFCID1 byte Y
            NFCID1_Y: u8,
            /// NFCID1 byte X
            NFCID1_X: u8,
            /// NFCID1 byte W
            NFCID1_W: u8,
        }), base_address + 0x590);

        /// address: 0x40005594
        /// Second last NFCID1 part (7 or 10 bytes ID)
        pub const NFCID1_2ND_LAST = @intToPtr(*volatile Mmio(32, packed struct {
            /// NFCID1 byte V
            NFCID1_V: u8,
            /// NFCID1 byte U
            NFCID1_U: u8,
            /// NFCID1 byte T
            NFCID1_T: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x594);

        /// address: 0x40005598
        /// Third last NFCID1 part (10 bytes ID)
        pub const NFCID1_3RD_LAST = @intToPtr(*volatile Mmio(32, packed struct {
            /// NFCID1 byte S
            NFCID1_S: u8,
            /// NFCID1 byte R
            NFCID1_R: u8,
            /// NFCID1 byte Q
            NFCID1_Q: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x598);

        /// address: 0x400055a0
        /// NFC-A SENS_RES auto-response settings
        pub const SENSRES = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bit frame SDD as defined by the b5:b1 of byte 1 in SENS_RES response in the NFC
            /// Forum, NFC Digital Protocol Technical Specification
            BITFRAMESDD: u5,
            /// Reserved for future use. Shall be 0.
            RFU5: u1,
            /// NFCID1 size. This value is used by the Auto collision resolution engine.
            NFCIDSIZE: u2,
            /// Tag platform configuration as defined by the b4:b1 of byte 2 in SENS_RES
            /// response in the NFC Forum, NFC Digital Protocol Technical Specification
            PLATFCONFIG: u4,
            /// Reserved for future use. Shall be 0.
            RFU74: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5a0);

        /// address: 0x400055a4
        /// NFC-A SEL_RES auto-response settings
        pub const SELRES = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved for future use. Shall be 0.
            RFU10: u2,
            /// Cascade bit (controlled by hardware, write has no effect)
            CASCADE: u1,
            /// Reserved for future use. Shall be 0.
            RFU43: u2,
            /// Protocol as defined by the b7:b6 of SEL_RES response in the NFC Forum, NFC
            /// Digital Protocol Technical Specification
            PROTOCOL: u2,
            /// Reserved for future use. Shall be 0.
            RFU7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x5a4);

        pub const FRAMESTATUS = struct {

            /// address: 0x40005000
            /// Result of last incoming frames
            pub const RX = @intToPtr(*volatile Mmio(32, packed struct {
                /// No valid End of Frame detected
                CRCERROR: u1,
                reserved0: u1,
                /// Parity status of received frame
                PARITYSTATUS: u1,
                /// Overrun detected
                OVERRUN: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
                padding27: u1,
            }), base_address + 0x0);
        };

        pub const TXD = struct {

            /// address: 0x40005000
            /// Configuration of outgoing frames
            pub const FRAMECONFIG = @intToPtr(*volatile Mmio(32, packed struct {
                /// Adding parity or not in the frame
                PARITY: u1,
                /// Discarding unused bits in start or at end of a Frame
                DISCARDMODE: u1,
                /// Adding SoF or not in TX frames
                SOF: u1,
                reserved0: u1,
                /// CRC mode for outgoing frames
                CRCMODETX: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
            }), base_address + 0x0);

            /// address: 0x40005004
            /// Size of outgoing frame
            pub const AMOUNT = @intToPtr(*volatile Mmio(32, packed struct {
                /// Number of bits in the last or first byte read from RAM that shall be included in
                /// the frame (excluding parity bit).
                TXDATABITS: u3,
                /// Number of complete bytes that shall be included in the frame, excluding CRC,
                /// parity and framing
                TXDATABYTES: u9,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
            }), base_address + 0x4);
        };

        pub const RXD = struct {

            /// address: 0x40005000
            /// Configuration of incoming frames
            pub const FRAMECONFIG = @intToPtr(*volatile Mmio(32, packed struct {
                /// Parity expected or not in RX frame
                PARITY: u1,
                reserved0: u1,
                /// SoF expected or not in RX frames
                SOF: u1,
                reserved1: u1,
                /// CRC mode for incoming frames
                CRCMODERX: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
            }), base_address + 0x0);

            /// address: 0x40005004
            /// Size of last incoming frame
            pub const AMOUNT = @intToPtr(*volatile Mmio(32, packed struct {
                /// Number of bits in the last byte in the frame, if less than 8 (including CRC, but
                /// excluding parity and SoF/EoF framing).
                RXDATABITS: u3,
                /// Number of complete bytes received in the frame (including CRC, but excluding
                /// parity and SoF/EoF framing)
                RXDATABYTES: u9,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
            }), base_address + 0x4);
        };
    };
    /// GPIO Tasks and Events
    pub const GPIOTE = struct {
        pub const base_address = 0x40006000;

        /// address: 0x40006000
        /// Description collection[0]: Task for writing to pin specified in CONFIG[0].PSEL.
        /// Action on pin is configured in CONFIG[0].POLARITY.
        pub const TASKS_OUT = @intToPtr(*volatile [8]u32, base_address + 0x0);

        /// address: 0x40006030
        /// Description collection[0]: Task for writing to pin specified in CONFIG[0].PSEL.
        /// Action on pin is to set it high.
        pub const TASKS_SET = @intToPtr(*volatile [8]u32, base_address + 0x30);

        /// address: 0x40006060
        /// Description collection[0]: Task for writing to pin specified in CONFIG[0].PSEL.
        /// Action on pin is to set it low.
        pub const TASKS_CLR = @intToPtr(*volatile [8]u32, base_address + 0x60);

        /// address: 0x40006100
        /// Description collection[0]: Event generated from pin specified in CONFIG[0].PSEL
        pub const EVENTS_IN = @intToPtr(*volatile [8]u32, base_address + 0x100);

        /// address: 0x4000617c
        /// Event generated from multiple input GPIO pins with SENSE mechanism enabled
        pub const EVENTS_PORT = @intToPtr(*volatile u32, base_address + 0x17c);

        /// address: 0x40006304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for IN[0] event
            IN0: u1,
            /// Write '1' to Enable interrupt for IN[1] event
            IN1: u1,
            /// Write '1' to Enable interrupt for IN[2] event
            IN2: u1,
            /// Write '1' to Enable interrupt for IN[3] event
            IN3: u1,
            /// Write '1' to Enable interrupt for IN[4] event
            IN4: u1,
            /// Write '1' to Enable interrupt for IN[5] event
            IN5: u1,
            /// Write '1' to Enable interrupt for IN[6] event
            IN6: u1,
            /// Write '1' to Enable interrupt for IN[7] event
            IN7: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// Write '1' to Enable interrupt for PORT event
            PORT: u1,
        }), base_address + 0x304);

        /// address: 0x40006308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for IN[0] event
            IN0: u1,
            /// Write '1' to Disable interrupt for IN[1] event
            IN1: u1,
            /// Write '1' to Disable interrupt for IN[2] event
            IN2: u1,
            /// Write '1' to Disable interrupt for IN[3] event
            IN3: u1,
            /// Write '1' to Disable interrupt for IN[4] event
            IN4: u1,
            /// Write '1' to Disable interrupt for IN[5] event
            IN5: u1,
            /// Write '1' to Disable interrupt for IN[6] event
            IN6: u1,
            /// Write '1' to Disable interrupt for IN[7] event
            IN7: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// Write '1' to Disable interrupt for PORT event
            PORT: u1,
        }), base_address + 0x308);

        /// address: 0x40006510
        /// Description collection[0]: Configuration for OUT[n], SET[n] and CLR[n] tasks and
        /// IN[n] event
        pub const CONFIG = @intToPtr(*volatile [8]Mmio(32, packed struct {
            /// Mode
            MODE: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event
            PSEL: u5,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// When In task mode: Operation to be performed on output when OUT[n] task is
            /// triggered. When In event mode: Operation on input that shall trigger IN[n]
            /// event.
            POLARITY: u2,
            reserved9: u1,
            reserved10: u1,
            /// When in task mode: Initial value of the output when the GPIOTE channel is
            /// configured. When in event mode: No effect.
            OUTINIT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x510);
    };
    /// Analog to Digital Converter
    pub const SAADC = struct {
        pub const base_address = 0x40007000;

        /// address: 0x40007000
        /// Start the ADC and prepare the result buffer in RAM
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40007004
        /// Take one ADC sample, if scan is enabled all channels are sampled
        pub const TASKS_SAMPLE = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40007008
        /// Stop the ADC and terminate any on-going conversion
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4000700c
        /// Starts offset auto-calibration
        pub const TASKS_CALIBRATEOFFSET = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x40007100
        /// The ADC has started
        pub const EVENTS_STARTED = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x40007104
        /// The ADC has filled up the Result buffer
        pub const EVENTS_END = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40007108
        /// A conversion task has been completed. Depending on the mode, multiple
        /// conversions might be needed for a result to be transferred to RAM.
        pub const EVENTS_DONE = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x4000710c
        /// A result is ready to get transferred to RAM.
        pub const EVENTS_RESULTDONE = @intToPtr(*volatile u32, base_address + 0x10c);

        /// address: 0x40007110
        /// Calibration is complete
        pub const EVENTS_CALIBRATEDONE = @intToPtr(*volatile u32, base_address + 0x110);

        /// address: 0x40007114
        /// The ADC has stopped
        pub const EVENTS_STOPPED = @intToPtr(*volatile u32, base_address + 0x114);

        /// address: 0x40007300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable interrupt for STARTED event
            STARTED: u1,
            /// Enable or disable interrupt for END event
            END: u1,
            /// Enable or disable interrupt for DONE event
            DONE: u1,
            /// Enable or disable interrupt for RESULTDONE event
            RESULTDONE: u1,
            /// Enable or disable interrupt for CALIBRATEDONE event
            CALIBRATEDONE: u1,
            /// Enable or disable interrupt for STOPPED event
            STOPPED: u1,
            /// Enable or disable interrupt for CH[0].LIMITH event
            CH0LIMITH: u1,
            /// Enable or disable interrupt for CH[0].LIMITL event
            CH0LIMITL: u1,
            /// Enable or disable interrupt for CH[1].LIMITH event
            CH1LIMITH: u1,
            /// Enable or disable interrupt for CH[1].LIMITL event
            CH1LIMITL: u1,
            /// Enable or disable interrupt for CH[2].LIMITH event
            CH2LIMITH: u1,
            /// Enable or disable interrupt for CH[2].LIMITL event
            CH2LIMITL: u1,
            /// Enable or disable interrupt for CH[3].LIMITH event
            CH3LIMITH: u1,
            /// Enable or disable interrupt for CH[3].LIMITL event
            CH3LIMITL: u1,
            /// Enable or disable interrupt for CH[4].LIMITH event
            CH4LIMITH: u1,
            /// Enable or disable interrupt for CH[4].LIMITL event
            CH4LIMITL: u1,
            /// Enable or disable interrupt for CH[5].LIMITH event
            CH5LIMITH: u1,
            /// Enable or disable interrupt for CH[5].LIMITL event
            CH5LIMITL: u1,
            /// Enable or disable interrupt for CH[6].LIMITH event
            CH6LIMITH: u1,
            /// Enable or disable interrupt for CH[6].LIMITL event
            CH6LIMITL: u1,
            /// Enable or disable interrupt for CH[7].LIMITH event
            CH7LIMITH: u1,
            /// Enable or disable interrupt for CH[7].LIMITL event
            CH7LIMITL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x300);

        /// address: 0x40007304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for STARTED event
            STARTED: u1,
            /// Write '1' to Enable interrupt for END event
            END: u1,
            /// Write '1' to Enable interrupt for DONE event
            DONE: u1,
            /// Write '1' to Enable interrupt for RESULTDONE event
            RESULTDONE: u1,
            /// Write '1' to Enable interrupt for CALIBRATEDONE event
            CALIBRATEDONE: u1,
            /// Write '1' to Enable interrupt for STOPPED event
            STOPPED: u1,
            /// Write '1' to Enable interrupt for CH[0].LIMITH event
            CH0LIMITH: u1,
            /// Write '1' to Enable interrupt for CH[0].LIMITL event
            CH0LIMITL: u1,
            /// Write '1' to Enable interrupt for CH[1].LIMITH event
            CH1LIMITH: u1,
            /// Write '1' to Enable interrupt for CH[1].LIMITL event
            CH1LIMITL: u1,
            /// Write '1' to Enable interrupt for CH[2].LIMITH event
            CH2LIMITH: u1,
            /// Write '1' to Enable interrupt for CH[2].LIMITL event
            CH2LIMITL: u1,
            /// Write '1' to Enable interrupt for CH[3].LIMITH event
            CH3LIMITH: u1,
            /// Write '1' to Enable interrupt for CH[3].LIMITL event
            CH3LIMITL: u1,
            /// Write '1' to Enable interrupt for CH[4].LIMITH event
            CH4LIMITH: u1,
            /// Write '1' to Enable interrupt for CH[4].LIMITL event
            CH4LIMITL: u1,
            /// Write '1' to Enable interrupt for CH[5].LIMITH event
            CH5LIMITH: u1,
            /// Write '1' to Enable interrupt for CH[5].LIMITL event
            CH5LIMITL: u1,
            /// Write '1' to Enable interrupt for CH[6].LIMITH event
            CH6LIMITH: u1,
            /// Write '1' to Enable interrupt for CH[6].LIMITL event
            CH6LIMITL: u1,
            /// Write '1' to Enable interrupt for CH[7].LIMITH event
            CH7LIMITH: u1,
            /// Write '1' to Enable interrupt for CH[7].LIMITL event
            CH7LIMITL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x304);

        /// address: 0x40007308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for STARTED event
            STARTED: u1,
            /// Write '1' to Disable interrupt for END event
            END: u1,
            /// Write '1' to Disable interrupt for DONE event
            DONE: u1,
            /// Write '1' to Disable interrupt for RESULTDONE event
            RESULTDONE: u1,
            /// Write '1' to Disable interrupt for CALIBRATEDONE event
            CALIBRATEDONE: u1,
            /// Write '1' to Disable interrupt for STOPPED event
            STOPPED: u1,
            /// Write '1' to Disable interrupt for CH[0].LIMITH event
            CH0LIMITH: u1,
            /// Write '1' to Disable interrupt for CH[0].LIMITL event
            CH0LIMITL: u1,
            /// Write '1' to Disable interrupt for CH[1].LIMITH event
            CH1LIMITH: u1,
            /// Write '1' to Disable interrupt for CH[1].LIMITL event
            CH1LIMITL: u1,
            /// Write '1' to Disable interrupt for CH[2].LIMITH event
            CH2LIMITH: u1,
            /// Write '1' to Disable interrupt for CH[2].LIMITL event
            CH2LIMITL: u1,
            /// Write '1' to Disable interrupt for CH[3].LIMITH event
            CH3LIMITH: u1,
            /// Write '1' to Disable interrupt for CH[3].LIMITL event
            CH3LIMITL: u1,
            /// Write '1' to Disable interrupt for CH[4].LIMITH event
            CH4LIMITH: u1,
            /// Write '1' to Disable interrupt for CH[4].LIMITL event
            CH4LIMITL: u1,
            /// Write '1' to Disable interrupt for CH[5].LIMITH event
            CH5LIMITH: u1,
            /// Write '1' to Disable interrupt for CH[5].LIMITL event
            CH5LIMITL: u1,
            /// Write '1' to Disable interrupt for CH[6].LIMITH event
            CH6LIMITH: u1,
            /// Write '1' to Disable interrupt for CH[6].LIMITL event
            CH6LIMITL: u1,
            /// Write '1' to Disable interrupt for CH[7].LIMITH event
            CH7LIMITH: u1,
            /// Write '1' to Disable interrupt for CH[7].LIMITL event
            CH7LIMITL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x308);

        /// address: 0x40007400
        /// Status
        pub const STATUS = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x400);

        /// address: 0x40007500
        /// Enable or disable ADC
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x500);

        /// address: 0x400075f0
        /// Resolution configuration
        pub const RESOLUTION = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set the resolution
            VAL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x5f0);

        /// address: 0x400075f4
        /// Oversampling configuration. OVERSAMPLE should not be combined with SCAN. The
        /// RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher
        /// RESOLUTION should be used.
        pub const OVERSAMPLE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x5f4);

        /// address: 0x400075f8
        /// Controls normal or continuous sample rate
        pub const SAMPLERATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture and compare value. Sample rate is 16 MHz/CC
            CC: u11,
            reserved0: u1,
            /// Select mode for sample rate control
            MODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x5f8);

        pub const EVENTS_CH = @ptrCast(*volatile [8]packed struct {
            /// Description cluster[0]: Last results is equal or above CH[0].LIMIT.HIGH
            LIMITH: u32,

            /// Description cluster[0]: Last results is equal or below CH[0].LIMIT.LOW
            LIMITL: u32,
        }, base_address + 0x118);

        pub const CH = @ptrCast(*volatile [8]packed struct {
            /// Description cluster[0]: Input positive pin selection for CH[0]
            PSELP: MmioInt(32, u5),

            /// Description cluster[0]: Input negative pin selection for CH[0]
            PSELN: MmioInt(32, u5),

            /// Description cluster[0]: Input configuration for CH[0]
            CONFIG: Mmio(32, packed struct {
                /// Positive channel resistor control
                RESP: u2,
                reserved0: u1,
                reserved1: u1,
                /// Negative channel resistor control
                RESN: u2,
                reserved2: u1,
                reserved3: u1,
                /// Gain control
                GAIN: u3,
                reserved4: u1,
                /// Reference control
                REFSEL: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                /// Acquisition time, the time the ADC uses to sample the input voltage
                TACQ: u3,
                reserved8: u1,
                /// Enable differential mode
                MODE: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                /// Enable burst mode
                BURST: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }),

            /// Description cluster[0]: High/low limits for event monitoring a channel
            LIMIT: Mmio(32, packed struct {
                /// Low level limit
                LOW: u16,
                /// High level limit
                HIGH: u16,
            }),
        }, base_address + 0x510);

        /// RESULT EasyDMA channel
        pub const RESULT = struct {

            /// address: 0x40007000
            /// Data pointer
            pub const PTR = @intToPtr(*volatile u32, base_address + 0x0);

            /// address: 0x40007004
            /// Maximum number of buffer words to transfer
            pub const MAXCNT = @intToPtr(*volatile MmioInt(32, u15), base_address + 0x4);

            /// address: 0x40007008
            /// Number of buffer words transferred since last START
            pub const AMOUNT = @intToPtr(*volatile MmioInt(32, u15), base_address + 0x8);
        };
    };
    /// Timer/Counter 0
    pub const TIMER0 = struct {
        pub const base_address = 0x40008000;

        /// address: 0x40008000
        /// Start Timer
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40008004
        /// Stop Timer
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40008008
        /// Increment Timer (Counter mode only)
        pub const TASKS_COUNT = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4000800c
        /// Clear time
        pub const TASKS_CLEAR = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x40008010
        /// Deprecated register - Shut down timer
        pub const TASKS_SHUTDOWN = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40008040
        /// Description collection[0]: Capture Timer value to CC[0] register
        pub const TASKS_CAPTURE = @intToPtr(*volatile [6]u32, base_address + 0x40);

        /// address: 0x40008140
        /// Description collection[0]: Compare event on CC[0] match
        pub const EVENTS_COMPARE = @intToPtr(*volatile [6]u32, base_address + 0x140);

        /// address: 0x40008200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Shortcut between COMPARE[0] event and CLEAR task
            COMPARE0_CLEAR: u1,
            /// Shortcut between COMPARE[1] event and CLEAR task
            COMPARE1_CLEAR: u1,
            /// Shortcut between COMPARE[2] event and CLEAR task
            COMPARE2_CLEAR: u1,
            /// Shortcut between COMPARE[3] event and CLEAR task
            COMPARE3_CLEAR: u1,
            /// Shortcut between COMPARE[4] event and CLEAR task
            COMPARE4_CLEAR: u1,
            /// Shortcut between COMPARE[5] event and CLEAR task
            COMPARE5_CLEAR: u1,
            reserved0: u1,
            reserved1: u1,
            /// Shortcut between COMPARE[0] event and STOP task
            COMPARE0_STOP: u1,
            /// Shortcut between COMPARE[1] event and STOP task
            COMPARE1_STOP: u1,
            /// Shortcut between COMPARE[2] event and STOP task
            COMPARE2_STOP: u1,
            /// Shortcut between COMPARE[3] event and STOP task
            COMPARE3_STOP: u1,
            /// Shortcut between COMPARE[4] event and STOP task
            COMPARE4_STOP: u1,
            /// Shortcut between COMPARE[5] event and STOP task
            COMPARE5_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x200);

        /// address: 0x40008304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Write '1' to Enable interrupt for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Enable interrupt for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Enable interrupt for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Enable interrupt for COMPARE[3] event
            COMPARE3: u1,
            /// Write '1' to Enable interrupt for COMPARE[4] event
            COMPARE4: u1,
            /// Write '1' to Enable interrupt for COMPARE[5] event
            COMPARE5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x304);

        /// address: 0x40008308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Write '1' to Disable interrupt for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Disable interrupt for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Disable interrupt for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Disable interrupt for COMPARE[3] event
            COMPARE3: u1,
            /// Write '1' to Disable interrupt for COMPARE[4] event
            COMPARE4: u1,
            /// Write '1' to Disable interrupt for COMPARE[5] event
            COMPARE5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x308);

        /// address: 0x40008504
        /// Timer mode selection
        pub const MODE = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x504);

        /// address: 0x40008508
        /// Configure the number of bits used by the TIMER
        pub const BITMODE = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x508);

        /// address: 0x40008510
        /// Timer prescaler register
        pub const PRESCALER = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x510);

        /// address: 0x40008540
        /// Description collection[0]: Capture/Compare register 0
        pub const CC = @intToPtr(*volatile [6]u32, base_address + 0x540);
    };
    /// Timer/Counter 1
    pub const TIMER1 = struct {
        pub const base_address = 0x40009000;

        /// address: 0x40009000
        /// Start Timer
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40009004
        /// Stop Timer
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40009008
        /// Increment Timer (Counter mode only)
        pub const TASKS_COUNT = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4000900c
        /// Clear time
        pub const TASKS_CLEAR = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x40009010
        /// Deprecated register - Shut down timer
        pub const TASKS_SHUTDOWN = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40009040
        /// Description collection[0]: Capture Timer value to CC[0] register
        pub const TASKS_CAPTURE = @intToPtr(*volatile [6]u32, base_address + 0x40);

        /// address: 0x40009140
        /// Description collection[0]: Compare event on CC[0] match
        pub const EVENTS_COMPARE = @intToPtr(*volatile [6]u32, base_address + 0x140);

        /// address: 0x40009200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Shortcut between COMPARE[0] event and CLEAR task
            COMPARE0_CLEAR: u1,
            /// Shortcut between COMPARE[1] event and CLEAR task
            COMPARE1_CLEAR: u1,
            /// Shortcut between COMPARE[2] event and CLEAR task
            COMPARE2_CLEAR: u1,
            /// Shortcut between COMPARE[3] event and CLEAR task
            COMPARE3_CLEAR: u1,
            /// Shortcut between COMPARE[4] event and CLEAR task
            COMPARE4_CLEAR: u1,
            /// Shortcut between COMPARE[5] event and CLEAR task
            COMPARE5_CLEAR: u1,
            reserved0: u1,
            reserved1: u1,
            /// Shortcut between COMPARE[0] event and STOP task
            COMPARE0_STOP: u1,
            /// Shortcut between COMPARE[1] event and STOP task
            COMPARE1_STOP: u1,
            /// Shortcut between COMPARE[2] event and STOP task
            COMPARE2_STOP: u1,
            /// Shortcut between COMPARE[3] event and STOP task
            COMPARE3_STOP: u1,
            /// Shortcut between COMPARE[4] event and STOP task
            COMPARE4_STOP: u1,
            /// Shortcut between COMPARE[5] event and STOP task
            COMPARE5_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x200);

        /// address: 0x40009304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Write '1' to Enable interrupt for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Enable interrupt for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Enable interrupt for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Enable interrupt for COMPARE[3] event
            COMPARE3: u1,
            /// Write '1' to Enable interrupt for COMPARE[4] event
            COMPARE4: u1,
            /// Write '1' to Enable interrupt for COMPARE[5] event
            COMPARE5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x304);

        /// address: 0x40009308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Write '1' to Disable interrupt for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Disable interrupt for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Disable interrupt for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Disable interrupt for COMPARE[3] event
            COMPARE3: u1,
            /// Write '1' to Disable interrupt for COMPARE[4] event
            COMPARE4: u1,
            /// Write '1' to Disable interrupt for COMPARE[5] event
            COMPARE5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x308);

        /// address: 0x40009504
        /// Timer mode selection
        pub const MODE = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x504);

        /// address: 0x40009508
        /// Configure the number of bits used by the TIMER
        pub const BITMODE = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x508);

        /// address: 0x40009510
        /// Timer prescaler register
        pub const PRESCALER = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x510);

        /// address: 0x40009540
        /// Description collection[0]: Capture/Compare register 0
        pub const CC = @intToPtr(*volatile [6]u32, base_address + 0x540);
    };
    /// Timer/Counter 2
    pub const TIMER2 = struct {
        pub const base_address = 0x4000a000;

        /// address: 0x4000a000
        /// Start Timer
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x4000a004
        /// Stop Timer
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x4000a008
        /// Increment Timer (Counter mode only)
        pub const TASKS_COUNT = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4000a00c
        /// Clear time
        pub const TASKS_CLEAR = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x4000a010
        /// Deprecated register - Shut down timer
        pub const TASKS_SHUTDOWN = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x4000a040
        /// Description collection[0]: Capture Timer value to CC[0] register
        pub const TASKS_CAPTURE = @intToPtr(*volatile [6]u32, base_address + 0x40);

        /// address: 0x4000a140
        /// Description collection[0]: Compare event on CC[0] match
        pub const EVENTS_COMPARE = @intToPtr(*volatile [6]u32, base_address + 0x140);

        /// address: 0x4000a200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Shortcut between COMPARE[0] event and CLEAR task
            COMPARE0_CLEAR: u1,
            /// Shortcut between COMPARE[1] event and CLEAR task
            COMPARE1_CLEAR: u1,
            /// Shortcut between COMPARE[2] event and CLEAR task
            COMPARE2_CLEAR: u1,
            /// Shortcut between COMPARE[3] event and CLEAR task
            COMPARE3_CLEAR: u1,
            /// Shortcut between COMPARE[4] event and CLEAR task
            COMPARE4_CLEAR: u1,
            /// Shortcut between COMPARE[5] event and CLEAR task
            COMPARE5_CLEAR: u1,
            reserved0: u1,
            reserved1: u1,
            /// Shortcut between COMPARE[0] event and STOP task
            COMPARE0_STOP: u1,
            /// Shortcut between COMPARE[1] event and STOP task
            COMPARE1_STOP: u1,
            /// Shortcut between COMPARE[2] event and STOP task
            COMPARE2_STOP: u1,
            /// Shortcut between COMPARE[3] event and STOP task
            COMPARE3_STOP: u1,
            /// Shortcut between COMPARE[4] event and STOP task
            COMPARE4_STOP: u1,
            /// Shortcut between COMPARE[5] event and STOP task
            COMPARE5_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x200);

        /// address: 0x4000a304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Write '1' to Enable interrupt for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Enable interrupt for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Enable interrupt for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Enable interrupt for COMPARE[3] event
            COMPARE3: u1,
            /// Write '1' to Enable interrupt for COMPARE[4] event
            COMPARE4: u1,
            /// Write '1' to Enable interrupt for COMPARE[5] event
            COMPARE5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x304);

        /// address: 0x4000a308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Write '1' to Disable interrupt for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Disable interrupt for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Disable interrupt for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Disable interrupt for COMPARE[3] event
            COMPARE3: u1,
            /// Write '1' to Disable interrupt for COMPARE[4] event
            COMPARE4: u1,
            /// Write '1' to Disable interrupt for COMPARE[5] event
            COMPARE5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x308);

        /// address: 0x4000a504
        /// Timer mode selection
        pub const MODE = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x504);

        /// address: 0x4000a508
        /// Configure the number of bits used by the TIMER
        pub const BITMODE = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x508);

        /// address: 0x4000a510
        /// Timer prescaler register
        pub const PRESCALER = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x510);

        /// address: 0x4000a540
        /// Description collection[0]: Capture/Compare register 0
        pub const CC = @intToPtr(*volatile [6]u32, base_address + 0x540);
    };
    /// Real time counter 0
    pub const RTC0 = struct {
        pub const base_address = 0x4000b000;

        /// address: 0x4000b000
        /// Start RTC COUNTER
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x4000b004
        /// Stop RTC COUNTER
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x4000b008
        /// Clear RTC COUNTER
        pub const TASKS_CLEAR = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4000b00c
        /// Set COUNTER to 0xFFFFF0
        pub const TASKS_TRIGOVRFLW = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x4000b100
        /// Event on COUNTER increment
        pub const EVENTS_TICK = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x4000b104
        /// Event on COUNTER overflow
        pub const EVENTS_OVRFLW = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x4000b140
        /// Description collection[0]: Compare event on CC[0] match
        pub const EVENTS_COMPARE = @intToPtr(*volatile [4]u32, base_address + 0x140);

        /// address: 0x4000b304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for TICK event
            TICK: u1,
            /// Write '1' to Enable interrupt for OVRFLW event
            OVRFLW: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Write '1' to Enable interrupt for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Enable interrupt for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Enable interrupt for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Enable interrupt for COMPARE[3] event
            COMPARE3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x304);

        /// address: 0x4000b308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for TICK event
            TICK: u1,
            /// Write '1' to Disable interrupt for OVRFLW event
            OVRFLW: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Write '1' to Disable interrupt for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Disable interrupt for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Disable interrupt for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Disable interrupt for COMPARE[3] event
            COMPARE3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x308);

        /// address: 0x4000b340
        /// Enable or disable event routing
        pub const EVTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable event routing for TICK event
            TICK: u1,
            /// Enable or disable event routing for OVRFLW event
            OVRFLW: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Enable or disable event routing for COMPARE[0] event
            COMPARE0: u1,
            /// Enable or disable event routing for COMPARE[1] event
            COMPARE1: u1,
            /// Enable or disable event routing for COMPARE[2] event
            COMPARE2: u1,
            /// Enable or disable event routing for COMPARE[3] event
            COMPARE3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x340);

        /// address: 0x4000b344
        /// Enable event routing
        pub const EVTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable event routing for TICK event
            TICK: u1,
            /// Write '1' to Enable event routing for OVRFLW event
            OVRFLW: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Write '1' to Enable event routing for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Enable event routing for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Enable event routing for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Enable event routing for COMPARE[3] event
            COMPARE3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x344);

        /// address: 0x4000b348
        /// Disable event routing
        pub const EVTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable event routing for TICK event
            TICK: u1,
            /// Write '1' to Disable event routing for OVRFLW event
            OVRFLW: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Write '1' to Disable event routing for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Disable event routing for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Disable event routing for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Disable event routing for COMPARE[3] event
            COMPARE3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x348);

        /// address: 0x4000b504
        /// Current COUNTER value
        pub const COUNTER = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x504);

        /// address: 0x4000b508
        /// 12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must be written
        /// when RTC is stopped
        pub const PRESCALER = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x508);

        /// address: 0x4000b540
        /// Description collection[0]: Compare register 0
        pub const CC = @intToPtr(*volatile [4]Mmio(32, packed struct {
            /// Compare value
            COMPARE: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x540);
    };
    /// Temperature Sensor
    pub const TEMP = struct {
        pub const base_address = 0x4000c000;

        /// address: 0x4000c000
        /// Start temperature measurement
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x4000c004
        /// Stop temperature measurement
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x4000c100
        /// Temperature measurement complete, data ready
        pub const EVENTS_DATARDY = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x4000c304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for DATARDY event
            DATARDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x304);

        /// address: 0x4000c308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for DATARDY event
            DATARDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x308);

        /// address: 0x4000c508
        /// Temperature in degC (0.25deg steps)
        pub const TEMP = @intToPtr(*volatile u32, base_address + 0x508);

        /// address: 0x4000c520
        /// Slope of 1st piece wise linear function
        pub const A0 = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x520);

        /// address: 0x4000c524
        /// Slope of 2nd piece wise linear function
        pub const A1 = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x524);

        /// address: 0x4000c528
        /// Slope of 3rd piece wise linear function
        pub const A2 = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x528);

        /// address: 0x4000c52c
        /// Slope of 4th piece wise linear function
        pub const A3 = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x52c);

        /// address: 0x4000c530
        /// Slope of 5th piece wise linear function
        pub const A4 = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x530);

        /// address: 0x4000c534
        /// Slope of 6th piece wise linear function
        pub const A5 = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x534);

        /// address: 0x4000c540
        /// y-intercept of 1st piece wise linear function
        pub const B0 = @intToPtr(*volatile MmioInt(32, u14), base_address + 0x540);

        /// address: 0x4000c544
        /// y-intercept of 2nd piece wise linear function
        pub const B1 = @intToPtr(*volatile MmioInt(32, u14), base_address + 0x544);

        /// address: 0x4000c548
        /// y-intercept of 3rd piece wise linear function
        pub const B2 = @intToPtr(*volatile MmioInt(32, u14), base_address + 0x548);

        /// address: 0x4000c54c
        /// y-intercept of 4th piece wise linear function
        pub const B3 = @intToPtr(*volatile MmioInt(32, u14), base_address + 0x54c);

        /// address: 0x4000c550
        /// y-intercept of 5th piece wise linear function
        pub const B4 = @intToPtr(*volatile MmioInt(32, u14), base_address + 0x550);

        /// address: 0x4000c554
        /// y-intercept of 6th piece wise linear function
        pub const B5 = @intToPtr(*volatile MmioInt(32, u14), base_address + 0x554);

        /// address: 0x4000c560
        /// End point of 1st piece wise linear function
        pub const T0 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x560);

        /// address: 0x4000c564
        /// End point of 2nd piece wise linear function
        pub const T1 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x564);

        /// address: 0x4000c568
        /// End point of 3rd piece wise linear function
        pub const T2 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x568);

        /// address: 0x4000c56c
        /// End point of 4th piece wise linear function
        pub const T3 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x56c);

        /// address: 0x4000c570
        /// End point of 5th piece wise linear function
        pub const T4 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x570);
    };
    /// Random Number Generator
    pub const RNG = struct {
        pub const base_address = 0x4000d000;

        /// address: 0x4000d000
        /// Task starting the random number generator
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x4000d004
        /// Task stopping the random number generator
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x4000d100
        /// Event being generated for every new random number written to the VALUE register
        pub const EVENTS_VALRDY = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x4000d200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Shortcut between VALRDY event and STOP task
            VALRDY_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x200);

        /// address: 0x4000d304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for VALRDY event
            VALRDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x304);

        /// address: 0x4000d308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for VALRDY event
            VALRDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x308);

        /// address: 0x4000d504
        /// Configuration register
        pub const CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bias correction
            DERCEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x504);

        /// address: 0x4000d508
        /// Output random number
        pub const VALUE = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x508);
    };
    /// AES ECB Mode Encryption
    pub const ECB = struct {
        pub const base_address = 0x4000e000;

        /// address: 0x4000e000
        /// Start ECB block encrypt
        pub const TASKS_STARTECB = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x4000e004
        /// Abort a possible executing ECB operation
        pub const TASKS_STOPECB = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x4000e100
        /// ECB block encrypt complete
        pub const EVENTS_ENDECB = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x4000e104
        /// ECB block encrypt aborted because of a STOPECB task or due to an error
        pub const EVENTS_ERRORECB = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x4000e304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for ENDECB event
            ENDECB: u1,
            /// Write '1' to Enable interrupt for ERRORECB event
            ERRORECB: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x304);

        /// address: 0x4000e308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for ENDECB event
            ENDECB: u1,
            /// Write '1' to Disable interrupt for ERRORECB event
            ERRORECB: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x308);

        /// address: 0x4000e504
        /// ECB block encrypt memory pointers
        pub const ECBDATAPTR = @intToPtr(*volatile u32, base_address + 0x504);
    };
    /// AES CCM Mode Encryption
    pub const CCM = struct {
        pub const base_address = 0x4000f000;

        /// address: 0x4000f000
        /// Start generation of key-stream. This operation will stop by itself when
        /// completed.
        pub const TASKS_KSGEN = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x4000f004
        /// Start encryption/decryption. This operation will stop by itself when completed.
        pub const TASKS_CRYPT = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x4000f008
        /// Stop encryption/decryption
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4000f100
        /// Key-stream generation complete
        pub const EVENTS_ENDKSGEN = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x4000f104
        /// Encrypt/decrypt complete
        pub const EVENTS_ENDCRYPT = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x4000f108
        /// CCM error event
        pub const EVENTS_ERROR = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x4000f200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Shortcut between ENDKSGEN event and CRYPT task
            ENDKSGEN_CRYPT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x200);

        /// address: 0x4000f304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for ENDKSGEN event
            ENDKSGEN: u1,
            /// Write '1' to Enable interrupt for ENDCRYPT event
            ENDCRYPT: u1,
            /// Write '1' to Enable interrupt for ERROR event
            ERROR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x304);

        /// address: 0x4000f308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for ENDKSGEN event
            ENDKSGEN: u1,
            /// Write '1' to Disable interrupt for ENDCRYPT event
            ENDCRYPT: u1,
            /// Write '1' to Disable interrupt for ERROR event
            ERROR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x308);

        /// address: 0x4000f400
        /// MIC check result
        pub const MICSTATUS = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x400);

        /// address: 0x4000f500
        /// Enable
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x500);

        /// address: 0x4000f504
        /// Operation mode
        pub const MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// The mode of operation to be used
            MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// Data rate that the CCM shall run in synch with
            DATARATE: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// Packet length configuration
            LENGTH: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x504);

        /// address: 0x4000f508
        /// Pointer to data structure holding AES key and NONCE vector
        pub const CNFPTR = @intToPtr(*volatile u32, base_address + 0x508);

        /// address: 0x4000f50c
        /// Input pointer
        pub const INPTR = @intToPtr(*volatile u32, base_address + 0x50c);

        /// address: 0x4000f510
        /// Output pointer
        pub const OUTPTR = @intToPtr(*volatile u32, base_address + 0x510);

        /// address: 0x4000f514
        /// Pointer to data area used for temporary storage
        pub const SCRATCHPTR = @intToPtr(*volatile u32, base_address + 0x514);
    };
    /// Accelerated Address Resolver
    pub const AAR = struct {
        pub const base_address = 0x4000f000;

        /// address: 0x4000f000
        /// Start resolving addresses based on IRKs specified in the IRK data structure
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x4000f008
        /// Stop resolving addresses
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4000f100
        /// Address resolution procedure complete
        pub const EVENTS_END = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x4000f104
        /// Address resolved
        pub const EVENTS_RESOLVED = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x4000f108
        /// Address not resolved
        pub const EVENTS_NOTRESOLVED = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x4000f304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for END event
            END: u1,
            /// Write '1' to Enable interrupt for RESOLVED event
            RESOLVED: u1,
            /// Write '1' to Enable interrupt for NOTRESOLVED event
            NOTRESOLVED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x304);

        /// address: 0x4000f308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for END event
            END: u1,
            /// Write '1' to Disable interrupt for RESOLVED event
            RESOLVED: u1,
            /// Write '1' to Disable interrupt for NOTRESOLVED event
            NOTRESOLVED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x308);

        /// address: 0x4000f400
        /// Resolution status
        pub const STATUS = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x400);

        /// address: 0x4000f500
        /// Enable AAR
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x500);

        /// address: 0x4000f504
        /// Number of IRKs
        pub const NIRK = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x504);

        /// address: 0x4000f508
        /// Pointer to IRK data structure
        pub const IRKPTR = @intToPtr(*volatile u32, base_address + 0x508);

        /// address: 0x4000f510
        /// Pointer to the resolvable address
        pub const ADDRPTR = @intToPtr(*volatile u32, base_address + 0x510);

        /// address: 0x4000f514
        /// Pointer to data area used for temporary storage
        pub const SCRATCHPTR = @intToPtr(*volatile u32, base_address + 0x514);
    };
    /// Watchdog Timer
    pub const WDT = struct {
        pub const base_address = 0x40010000;

        /// address: 0x40010000
        /// Start the watchdog
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40010100
        /// Watchdog timeout
        pub const EVENTS_TIMEOUT = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x40010304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for TIMEOUT event
            TIMEOUT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x304);

        /// address: 0x40010308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for TIMEOUT event
            TIMEOUT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x308);

        /// address: 0x40010400
        /// Run status
        pub const RUNSTATUS = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x400);

        /// address: 0x40010404
        /// Request status
        pub const REQSTATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Request status for RR[0] register
            RR0: u1,
            /// Request status for RR[1] register
            RR1: u1,
            /// Request status for RR[2] register
            RR2: u1,
            /// Request status for RR[3] register
            RR3: u1,
            /// Request status for RR[4] register
            RR4: u1,
            /// Request status for RR[5] register
            RR5: u1,
            /// Request status for RR[6] register
            RR6: u1,
            /// Request status for RR[7] register
            RR7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x404);

        /// address: 0x40010504
        /// Counter reload value
        pub const CRV = @intToPtr(*volatile u32, base_address + 0x504);

        /// address: 0x40010508
        /// Enable register for reload request registers
        pub const RREN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable RR[0] register
            RR0: u1,
            /// Enable or disable RR[1] register
            RR1: u1,
            /// Enable or disable RR[2] register
            RR2: u1,
            /// Enable or disable RR[3] register
            RR3: u1,
            /// Enable or disable RR[4] register
            RR4: u1,
            /// Enable or disable RR[5] register
            RR5: u1,
            /// Enable or disable RR[6] register
            RR6: u1,
            /// Enable or disable RR[7] register
            RR7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x508);

        /// address: 0x4001050c
        /// Configuration register
        pub const CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Configure the watchdog to either be paused, or kept running, while the CPU is
            /// sleeping
            SLEEP: u1,
            reserved0: u1,
            reserved1: u1,
            /// Configure the watchdog to either be paused, or kept running, while the CPU is
            /// halted by the debugger
            HALT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x50c);

        /// address: 0x40010600
        /// Description collection[0]: Reload request 0
        pub const RR = @intToPtr(*volatile [8]u32, base_address + 0x600);
    };
    /// Real time counter 1
    pub const RTC1 = struct {
        pub const base_address = 0x40011000;

        /// address: 0x40011000
        /// Start RTC COUNTER
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40011004
        /// Stop RTC COUNTER
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40011008
        /// Clear RTC COUNTER
        pub const TASKS_CLEAR = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4001100c
        /// Set COUNTER to 0xFFFFF0
        pub const TASKS_TRIGOVRFLW = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x40011100
        /// Event on COUNTER increment
        pub const EVENTS_TICK = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x40011104
        /// Event on COUNTER overflow
        pub const EVENTS_OVRFLW = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40011140
        /// Description collection[0]: Compare event on CC[0] match
        pub const EVENTS_COMPARE = @intToPtr(*volatile [4]u32, base_address + 0x140);

        /// address: 0x40011304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for TICK event
            TICK: u1,
            /// Write '1' to Enable interrupt for OVRFLW event
            OVRFLW: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Write '1' to Enable interrupt for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Enable interrupt for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Enable interrupt for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Enable interrupt for COMPARE[3] event
            COMPARE3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x304);

        /// address: 0x40011308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for TICK event
            TICK: u1,
            /// Write '1' to Disable interrupt for OVRFLW event
            OVRFLW: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Write '1' to Disable interrupt for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Disable interrupt for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Disable interrupt for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Disable interrupt for COMPARE[3] event
            COMPARE3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x308);

        /// address: 0x40011340
        /// Enable or disable event routing
        pub const EVTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable event routing for TICK event
            TICK: u1,
            /// Enable or disable event routing for OVRFLW event
            OVRFLW: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Enable or disable event routing for COMPARE[0] event
            COMPARE0: u1,
            /// Enable or disable event routing for COMPARE[1] event
            COMPARE1: u1,
            /// Enable or disable event routing for COMPARE[2] event
            COMPARE2: u1,
            /// Enable or disable event routing for COMPARE[3] event
            COMPARE3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x340);

        /// address: 0x40011344
        /// Enable event routing
        pub const EVTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable event routing for TICK event
            TICK: u1,
            /// Write '1' to Enable event routing for OVRFLW event
            OVRFLW: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Write '1' to Enable event routing for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Enable event routing for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Enable event routing for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Enable event routing for COMPARE[3] event
            COMPARE3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x344);

        /// address: 0x40011348
        /// Disable event routing
        pub const EVTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable event routing for TICK event
            TICK: u1,
            /// Write '1' to Disable event routing for OVRFLW event
            OVRFLW: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Write '1' to Disable event routing for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Disable event routing for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Disable event routing for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Disable event routing for COMPARE[3] event
            COMPARE3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x348);

        /// address: 0x40011504
        /// Current COUNTER value
        pub const COUNTER = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x504);

        /// address: 0x40011508
        /// 12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must be written
        /// when RTC is stopped
        pub const PRESCALER = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x508);

        /// address: 0x40011540
        /// Description collection[0]: Compare register 0
        pub const CC = @intToPtr(*volatile [4]Mmio(32, packed struct {
            /// Compare value
            COMPARE: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x540);
    };
    /// Quadrature Decoder
    pub const QDEC = struct {
        pub const base_address = 0x40012000;

        /// address: 0x40012000
        /// Task starting the quadrature decoder
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40012004
        /// Task stopping the quadrature decoder
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40012008
        /// Read and clear ACC and ACCDBL
        pub const TASKS_READCLRACC = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4001200c
        /// Read and clear ACC
        pub const TASKS_RDCLRACC = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x40012010
        /// Read and clear ACCDBL
        pub const TASKS_RDCLRDBL = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40012100
        /// Event being generated for every new sample value written to the SAMPLE register
        pub const EVENTS_SAMPLERDY = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x40012104
        /// Non-null report ready
        pub const EVENTS_REPORTRDY = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40012108
        /// ACC or ACCDBL register overflow
        pub const EVENTS_ACCOF = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x4001210c
        /// Double displacement(s) detected
        pub const EVENTS_DBLRDY = @intToPtr(*volatile u32, base_address + 0x10c);

        /// address: 0x40012110
        /// QDEC has been stopped
        pub const EVENTS_STOPPED = @intToPtr(*volatile u32, base_address + 0x110);

        /// address: 0x40012200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Shortcut between REPORTRDY event and READCLRACC task
            REPORTRDY_READCLRACC: u1,
            /// Shortcut between SAMPLERDY event and STOP task
            SAMPLERDY_STOP: u1,
            /// Shortcut between REPORTRDY event and RDCLRACC task
            REPORTRDY_RDCLRACC: u1,
            /// Shortcut between REPORTRDY event and STOP task
            REPORTRDY_STOP: u1,
            /// Shortcut between DBLRDY event and RDCLRDBL task
            DBLRDY_RDCLRDBL: u1,
            /// Shortcut between DBLRDY event and STOP task
            DBLRDY_STOP: u1,
            /// Shortcut between SAMPLERDY event and READCLRACC task
            SAMPLERDY_READCLRACC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x200);

        /// address: 0x40012304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for SAMPLERDY event
            SAMPLERDY: u1,
            /// Write '1' to Enable interrupt for REPORTRDY event
            REPORTRDY: u1,
            /// Write '1' to Enable interrupt for ACCOF event
            ACCOF: u1,
            /// Write '1' to Enable interrupt for DBLRDY event
            DBLRDY: u1,
            /// Write '1' to Enable interrupt for STOPPED event
            STOPPED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x304);

        /// address: 0x40012308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for SAMPLERDY event
            SAMPLERDY: u1,
            /// Write '1' to Disable interrupt for REPORTRDY event
            REPORTRDY: u1,
            /// Write '1' to Disable interrupt for ACCOF event
            ACCOF: u1,
            /// Write '1' to Disable interrupt for DBLRDY event
            DBLRDY: u1,
            /// Write '1' to Disable interrupt for STOPPED event
            STOPPED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x308);

        /// address: 0x40012500
        /// Enable the quadrature decoder
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x500);

        /// address: 0x40012504
        /// LED output pin polarity
        pub const LEDPOL = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x504);

        /// address: 0x40012508
        /// Sample period
        pub const SAMPLEPER = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x508);

        /// address: 0x4001250c
        /// Motion sample value
        pub const SAMPLE = @intToPtr(*volatile u32, base_address + 0x50c);

        /// address: 0x40012510
        /// Number of samples to be taken before REPORTRDY and DBLRDY events can be
        /// generated
        pub const REPORTPER = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x510);

        /// address: 0x40012514
        /// Register accumulating the valid transitions
        pub const ACC = @intToPtr(*volatile u32, base_address + 0x514);

        /// address: 0x40012518
        /// Snapshot of the ACC register, updated by the READCLRACC or RDCLRACC task
        pub const ACCREAD = @intToPtr(*volatile u32, base_address + 0x518);

        /// address: 0x40012528
        /// Enable input debounce filters
        pub const DBFEN = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x528);

        /// address: 0x40012540
        /// Time period the LED is switched ON prior to sampling
        pub const LEDPRE = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x540);

        /// address: 0x40012544
        /// Register accumulating the number of detected double transitions
        pub const ACCDBL = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x544);

        /// address: 0x40012548
        /// Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task
        pub const ACCDBLREAD = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x548);

        pub const PSEL = struct {

            /// address: 0x40012000
            /// Pin select for LED signal
            pub const LED = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x0);

            /// address: 0x40012004
            /// Pin select for A signal
            pub const A = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x4);

            /// address: 0x40012008
            /// Pin select for B signal
            pub const B = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x8);
        };
    };
    /// Comparator
    pub const COMP = struct {
        pub const base_address = 0x40013000;

        /// address: 0x40013000
        /// Start comparator
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40013004
        /// Stop comparator
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40013008
        /// Sample comparator value
        pub const TASKS_SAMPLE = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x40013100
        /// COMP is ready and output is valid
        pub const EVENTS_READY = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x40013104
        /// Downward crossing
        pub const EVENTS_DOWN = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40013108
        /// Upward crossing
        pub const EVENTS_UP = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x4001310c
        /// Downward or upward crossing
        pub const EVENTS_CROSS = @intToPtr(*volatile u32, base_address + 0x10c);

        /// address: 0x40013200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Shortcut between READY event and SAMPLE task
            READY_SAMPLE: u1,
            /// Shortcut between READY event and STOP task
            READY_STOP: u1,
            /// Shortcut between DOWN event and STOP task
            DOWN_STOP: u1,
            /// Shortcut between UP event and STOP task
            UP_STOP: u1,
            /// Shortcut between CROSS event and STOP task
            CROSS_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x200);

        /// address: 0x40013300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable interrupt for READY event
            READY: u1,
            /// Enable or disable interrupt for DOWN event
            DOWN: u1,
            /// Enable or disable interrupt for UP event
            UP: u1,
            /// Enable or disable interrupt for CROSS event
            CROSS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x300);

        /// address: 0x40013304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for READY event
            READY: u1,
            /// Write '1' to Enable interrupt for DOWN event
            DOWN: u1,
            /// Write '1' to Enable interrupt for UP event
            UP: u1,
            /// Write '1' to Enable interrupt for CROSS event
            CROSS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x304);

        /// address: 0x40013308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for READY event
            READY: u1,
            /// Write '1' to Disable interrupt for DOWN event
            DOWN: u1,
            /// Write '1' to Disable interrupt for UP event
            UP: u1,
            /// Write '1' to Disable interrupt for CROSS event
            CROSS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x308);

        /// address: 0x40013400
        /// Compare result
        pub const RESULT = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x400);

        /// address: 0x40013500
        /// COMP enable
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x500);

        /// address: 0x40013504
        /// Pin select
        pub const PSEL = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x504);

        /// address: 0x40013508
        /// Reference source select for single-ended mode
        pub const REFSEL = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x508);

        /// address: 0x4001350c
        /// External reference select
        pub const EXTREFSEL = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x50c);

        /// address: 0x40013530
        /// Threshold configuration for hysteresis unit
        pub const TH = @intToPtr(*volatile Mmio(32, packed struct {
            /// VDOWN = (THDOWN+1)/64*VREF
            THDOWN: u6,
            reserved0: u1,
            reserved1: u1,
            /// VUP = (THUP+1)/64*VREF
            THUP: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x530);

        /// address: 0x40013534
        /// Mode configuration
        pub const MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Speed and power modes
            SP: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Main operation modes
            MAIN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x534);

        /// address: 0x40013538
        /// Comparator hysteresis enable
        pub const HYST = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x538);

        /// address: 0x4001353c
        /// Current source select on analog input
        pub const ISOURCE = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x53c);
    };
    /// Low Power Comparator
    pub const LPCOMP = struct {
        pub const base_address = 0x40013000;

        /// address: 0x40013000
        /// Start comparator
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40013004
        /// Stop comparator
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40013008
        /// Sample comparator value
        pub const TASKS_SAMPLE = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x40013100
        /// LPCOMP is ready and output is valid
        pub const EVENTS_READY = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x40013104
        /// Downward crossing
        pub const EVENTS_DOWN = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40013108
        /// Upward crossing
        pub const EVENTS_UP = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x4001310c
        /// Downward or upward crossing
        pub const EVENTS_CROSS = @intToPtr(*volatile u32, base_address + 0x10c);

        /// address: 0x40013200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Shortcut between READY event and SAMPLE task
            READY_SAMPLE: u1,
            /// Shortcut between READY event and STOP task
            READY_STOP: u1,
            /// Shortcut between DOWN event and STOP task
            DOWN_STOP: u1,
            /// Shortcut between UP event and STOP task
            UP_STOP: u1,
            /// Shortcut between CROSS event and STOP task
            CROSS_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x200);

        /// address: 0x40013304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for READY event
            READY: u1,
            /// Write '1' to Enable interrupt for DOWN event
            DOWN: u1,
            /// Write '1' to Enable interrupt for UP event
            UP: u1,
            /// Write '1' to Enable interrupt for CROSS event
            CROSS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x304);

        /// address: 0x40013308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for READY event
            READY: u1,
            /// Write '1' to Disable interrupt for DOWN event
            DOWN: u1,
            /// Write '1' to Disable interrupt for UP event
            UP: u1,
            /// Write '1' to Disable interrupt for CROSS event
            CROSS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x308);

        /// address: 0x40013400
        /// Compare result
        pub const RESULT = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x400);

        /// address: 0x40013500
        /// Enable LPCOMP
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x500);

        /// address: 0x40013504
        /// Input pin select
        pub const PSEL = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x504);

        /// address: 0x40013508
        /// Reference select
        pub const REFSEL = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x508);

        /// address: 0x4001350c
        /// External reference select
        pub const EXTREFSEL = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x50c);

        /// address: 0x40013520
        /// Analog detect configuration
        pub const ANADETECT = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x520);

        /// address: 0x40013538
        /// Comparator hysteresis enable
        pub const HYST = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x538);
    };
    /// Software interrupt 0
    pub const SWI0 = struct {
        pub const base_address = 0x40014000;

        /// address: 0x40014000
        /// Unused.
        pub const UNUSED = @intToPtr(*volatile u32, base_address + 0x0);
    };
    /// Event Generator Unit 0
    pub const EGU0 = struct {
        pub const base_address = 0x40014000;

        /// address: 0x40014000
        /// Description collection[0]: Trigger 0 for triggering the corresponding
        /// TRIGGERED[0] event
        pub const TASKS_TRIGGER = @intToPtr(*volatile [16]u32, base_address + 0x0);

        /// address: 0x40014100
        /// Description collection[0]: Event number 0 generated by triggering the
        /// corresponding TRIGGER[0] task
        pub const EVENTS_TRIGGERED = @intToPtr(*volatile [16]u32, base_address + 0x100);

        /// address: 0x40014300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable interrupt for TRIGGERED[0] event
            TRIGGERED0: u1,
            /// Enable or disable interrupt for TRIGGERED[1] event
            TRIGGERED1: u1,
            /// Enable or disable interrupt for TRIGGERED[2] event
            TRIGGERED2: u1,
            /// Enable or disable interrupt for TRIGGERED[3] event
            TRIGGERED3: u1,
            /// Enable or disable interrupt for TRIGGERED[4] event
            TRIGGERED4: u1,
            /// Enable or disable interrupt for TRIGGERED[5] event
            TRIGGERED5: u1,
            /// Enable or disable interrupt for TRIGGERED[6] event
            TRIGGERED6: u1,
            /// Enable or disable interrupt for TRIGGERED[7] event
            TRIGGERED7: u1,
            /// Enable or disable interrupt for TRIGGERED[8] event
            TRIGGERED8: u1,
            /// Enable or disable interrupt for TRIGGERED[9] event
            TRIGGERED9: u1,
            /// Enable or disable interrupt for TRIGGERED[10] event
            TRIGGERED10: u1,
            /// Enable or disable interrupt for TRIGGERED[11] event
            TRIGGERED11: u1,
            /// Enable or disable interrupt for TRIGGERED[12] event
            TRIGGERED12: u1,
            /// Enable or disable interrupt for TRIGGERED[13] event
            TRIGGERED13: u1,
            /// Enable or disable interrupt for TRIGGERED[14] event
            TRIGGERED14: u1,
            /// Enable or disable interrupt for TRIGGERED[15] event
            TRIGGERED15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x300);

        /// address: 0x40014304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for TRIGGERED[0] event
            TRIGGERED0: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[1] event
            TRIGGERED1: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[2] event
            TRIGGERED2: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[3] event
            TRIGGERED3: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[4] event
            TRIGGERED4: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[5] event
            TRIGGERED5: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[6] event
            TRIGGERED6: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[7] event
            TRIGGERED7: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[8] event
            TRIGGERED8: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[9] event
            TRIGGERED9: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[10] event
            TRIGGERED10: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[11] event
            TRIGGERED11: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[12] event
            TRIGGERED12: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[13] event
            TRIGGERED13: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[14] event
            TRIGGERED14: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[15] event
            TRIGGERED15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x304);

        /// address: 0x40014308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for TRIGGERED[0] event
            TRIGGERED0: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[1] event
            TRIGGERED1: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[2] event
            TRIGGERED2: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[3] event
            TRIGGERED3: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[4] event
            TRIGGERED4: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[5] event
            TRIGGERED5: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[6] event
            TRIGGERED6: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[7] event
            TRIGGERED7: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[8] event
            TRIGGERED8: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[9] event
            TRIGGERED9: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[10] event
            TRIGGERED10: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[11] event
            TRIGGERED11: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[12] event
            TRIGGERED12: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[13] event
            TRIGGERED13: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[14] event
            TRIGGERED14: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[15] event
            TRIGGERED15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x308);
    };
    /// Software interrupt 1
    pub const SWI1 = struct {
        pub const base_address = 0x40015000;

        /// address: 0x40015000
        /// Unused.
        pub const UNUSED = @intToPtr(*volatile u32, base_address + 0x0);
    };
    /// Event Generator Unit 1
    pub const EGU1 = struct {
        pub const base_address = 0x40015000;

        /// address: 0x40015000
        /// Description collection[0]: Trigger 0 for triggering the corresponding
        /// TRIGGERED[0] event
        pub const TASKS_TRIGGER = @intToPtr(*volatile [16]u32, base_address + 0x0);

        /// address: 0x40015100
        /// Description collection[0]: Event number 0 generated by triggering the
        /// corresponding TRIGGER[0] task
        pub const EVENTS_TRIGGERED = @intToPtr(*volatile [16]u32, base_address + 0x100);

        /// address: 0x40015300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable interrupt for TRIGGERED[0] event
            TRIGGERED0: u1,
            /// Enable or disable interrupt for TRIGGERED[1] event
            TRIGGERED1: u1,
            /// Enable or disable interrupt for TRIGGERED[2] event
            TRIGGERED2: u1,
            /// Enable or disable interrupt for TRIGGERED[3] event
            TRIGGERED3: u1,
            /// Enable or disable interrupt for TRIGGERED[4] event
            TRIGGERED4: u1,
            /// Enable or disable interrupt for TRIGGERED[5] event
            TRIGGERED5: u1,
            /// Enable or disable interrupt for TRIGGERED[6] event
            TRIGGERED6: u1,
            /// Enable or disable interrupt for TRIGGERED[7] event
            TRIGGERED7: u1,
            /// Enable or disable interrupt for TRIGGERED[8] event
            TRIGGERED8: u1,
            /// Enable or disable interrupt for TRIGGERED[9] event
            TRIGGERED9: u1,
            /// Enable or disable interrupt for TRIGGERED[10] event
            TRIGGERED10: u1,
            /// Enable or disable interrupt for TRIGGERED[11] event
            TRIGGERED11: u1,
            /// Enable or disable interrupt for TRIGGERED[12] event
            TRIGGERED12: u1,
            /// Enable or disable interrupt for TRIGGERED[13] event
            TRIGGERED13: u1,
            /// Enable or disable interrupt for TRIGGERED[14] event
            TRIGGERED14: u1,
            /// Enable or disable interrupt for TRIGGERED[15] event
            TRIGGERED15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x300);

        /// address: 0x40015304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for TRIGGERED[0] event
            TRIGGERED0: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[1] event
            TRIGGERED1: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[2] event
            TRIGGERED2: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[3] event
            TRIGGERED3: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[4] event
            TRIGGERED4: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[5] event
            TRIGGERED5: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[6] event
            TRIGGERED6: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[7] event
            TRIGGERED7: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[8] event
            TRIGGERED8: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[9] event
            TRIGGERED9: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[10] event
            TRIGGERED10: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[11] event
            TRIGGERED11: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[12] event
            TRIGGERED12: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[13] event
            TRIGGERED13: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[14] event
            TRIGGERED14: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[15] event
            TRIGGERED15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x304);

        /// address: 0x40015308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for TRIGGERED[0] event
            TRIGGERED0: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[1] event
            TRIGGERED1: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[2] event
            TRIGGERED2: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[3] event
            TRIGGERED3: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[4] event
            TRIGGERED4: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[5] event
            TRIGGERED5: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[6] event
            TRIGGERED6: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[7] event
            TRIGGERED7: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[8] event
            TRIGGERED8: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[9] event
            TRIGGERED9: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[10] event
            TRIGGERED10: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[11] event
            TRIGGERED11: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[12] event
            TRIGGERED12: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[13] event
            TRIGGERED13: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[14] event
            TRIGGERED14: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[15] event
            TRIGGERED15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x308);
    };
    /// Software interrupt 2
    pub const SWI2 = struct {
        pub const base_address = 0x40016000;

        /// address: 0x40016000
        /// Unused.
        pub const UNUSED = @intToPtr(*volatile u32, base_address + 0x0);
    };
    /// Event Generator Unit 2
    pub const EGU2 = struct {
        pub const base_address = 0x40016000;

        /// address: 0x40016000
        /// Description collection[0]: Trigger 0 for triggering the corresponding
        /// TRIGGERED[0] event
        pub const TASKS_TRIGGER = @intToPtr(*volatile [16]u32, base_address + 0x0);

        /// address: 0x40016100
        /// Description collection[0]: Event number 0 generated by triggering the
        /// corresponding TRIGGER[0] task
        pub const EVENTS_TRIGGERED = @intToPtr(*volatile [16]u32, base_address + 0x100);

        /// address: 0x40016300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable interrupt for TRIGGERED[0] event
            TRIGGERED0: u1,
            /// Enable or disable interrupt for TRIGGERED[1] event
            TRIGGERED1: u1,
            /// Enable or disable interrupt for TRIGGERED[2] event
            TRIGGERED2: u1,
            /// Enable or disable interrupt for TRIGGERED[3] event
            TRIGGERED3: u1,
            /// Enable or disable interrupt for TRIGGERED[4] event
            TRIGGERED4: u1,
            /// Enable or disable interrupt for TRIGGERED[5] event
            TRIGGERED5: u1,
            /// Enable or disable interrupt for TRIGGERED[6] event
            TRIGGERED6: u1,
            /// Enable or disable interrupt for TRIGGERED[7] event
            TRIGGERED7: u1,
            /// Enable or disable interrupt for TRIGGERED[8] event
            TRIGGERED8: u1,
            /// Enable or disable interrupt for TRIGGERED[9] event
            TRIGGERED9: u1,
            /// Enable or disable interrupt for TRIGGERED[10] event
            TRIGGERED10: u1,
            /// Enable or disable interrupt for TRIGGERED[11] event
            TRIGGERED11: u1,
            /// Enable or disable interrupt for TRIGGERED[12] event
            TRIGGERED12: u1,
            /// Enable or disable interrupt for TRIGGERED[13] event
            TRIGGERED13: u1,
            /// Enable or disable interrupt for TRIGGERED[14] event
            TRIGGERED14: u1,
            /// Enable or disable interrupt for TRIGGERED[15] event
            TRIGGERED15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x300);

        /// address: 0x40016304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for TRIGGERED[0] event
            TRIGGERED0: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[1] event
            TRIGGERED1: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[2] event
            TRIGGERED2: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[3] event
            TRIGGERED3: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[4] event
            TRIGGERED4: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[5] event
            TRIGGERED5: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[6] event
            TRIGGERED6: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[7] event
            TRIGGERED7: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[8] event
            TRIGGERED8: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[9] event
            TRIGGERED9: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[10] event
            TRIGGERED10: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[11] event
            TRIGGERED11: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[12] event
            TRIGGERED12: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[13] event
            TRIGGERED13: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[14] event
            TRIGGERED14: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[15] event
            TRIGGERED15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x304);

        /// address: 0x40016308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for TRIGGERED[0] event
            TRIGGERED0: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[1] event
            TRIGGERED1: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[2] event
            TRIGGERED2: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[3] event
            TRIGGERED3: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[4] event
            TRIGGERED4: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[5] event
            TRIGGERED5: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[6] event
            TRIGGERED6: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[7] event
            TRIGGERED7: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[8] event
            TRIGGERED8: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[9] event
            TRIGGERED9: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[10] event
            TRIGGERED10: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[11] event
            TRIGGERED11: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[12] event
            TRIGGERED12: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[13] event
            TRIGGERED13: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[14] event
            TRIGGERED14: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[15] event
            TRIGGERED15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x308);
    };
    /// Software interrupt 3
    pub const SWI3 = struct {
        pub const base_address = 0x40017000;

        /// address: 0x40017000
        /// Unused.
        pub const UNUSED = @intToPtr(*volatile u32, base_address + 0x0);
    };
    /// Event Generator Unit 3
    pub const EGU3 = struct {
        pub const base_address = 0x40017000;

        /// address: 0x40017000
        /// Description collection[0]: Trigger 0 for triggering the corresponding
        /// TRIGGERED[0] event
        pub const TASKS_TRIGGER = @intToPtr(*volatile [16]u32, base_address + 0x0);

        /// address: 0x40017100
        /// Description collection[0]: Event number 0 generated by triggering the
        /// corresponding TRIGGER[0] task
        pub const EVENTS_TRIGGERED = @intToPtr(*volatile [16]u32, base_address + 0x100);

        /// address: 0x40017300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable interrupt for TRIGGERED[0] event
            TRIGGERED0: u1,
            /// Enable or disable interrupt for TRIGGERED[1] event
            TRIGGERED1: u1,
            /// Enable or disable interrupt for TRIGGERED[2] event
            TRIGGERED2: u1,
            /// Enable or disable interrupt for TRIGGERED[3] event
            TRIGGERED3: u1,
            /// Enable or disable interrupt for TRIGGERED[4] event
            TRIGGERED4: u1,
            /// Enable or disable interrupt for TRIGGERED[5] event
            TRIGGERED5: u1,
            /// Enable or disable interrupt for TRIGGERED[6] event
            TRIGGERED6: u1,
            /// Enable or disable interrupt for TRIGGERED[7] event
            TRIGGERED7: u1,
            /// Enable or disable interrupt for TRIGGERED[8] event
            TRIGGERED8: u1,
            /// Enable or disable interrupt for TRIGGERED[9] event
            TRIGGERED9: u1,
            /// Enable or disable interrupt for TRIGGERED[10] event
            TRIGGERED10: u1,
            /// Enable or disable interrupt for TRIGGERED[11] event
            TRIGGERED11: u1,
            /// Enable or disable interrupt for TRIGGERED[12] event
            TRIGGERED12: u1,
            /// Enable or disable interrupt for TRIGGERED[13] event
            TRIGGERED13: u1,
            /// Enable or disable interrupt for TRIGGERED[14] event
            TRIGGERED14: u1,
            /// Enable or disable interrupt for TRIGGERED[15] event
            TRIGGERED15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x300);

        /// address: 0x40017304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for TRIGGERED[0] event
            TRIGGERED0: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[1] event
            TRIGGERED1: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[2] event
            TRIGGERED2: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[3] event
            TRIGGERED3: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[4] event
            TRIGGERED4: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[5] event
            TRIGGERED5: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[6] event
            TRIGGERED6: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[7] event
            TRIGGERED7: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[8] event
            TRIGGERED8: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[9] event
            TRIGGERED9: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[10] event
            TRIGGERED10: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[11] event
            TRIGGERED11: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[12] event
            TRIGGERED12: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[13] event
            TRIGGERED13: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[14] event
            TRIGGERED14: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[15] event
            TRIGGERED15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x304);

        /// address: 0x40017308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for TRIGGERED[0] event
            TRIGGERED0: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[1] event
            TRIGGERED1: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[2] event
            TRIGGERED2: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[3] event
            TRIGGERED3: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[4] event
            TRIGGERED4: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[5] event
            TRIGGERED5: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[6] event
            TRIGGERED6: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[7] event
            TRIGGERED7: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[8] event
            TRIGGERED8: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[9] event
            TRIGGERED9: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[10] event
            TRIGGERED10: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[11] event
            TRIGGERED11: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[12] event
            TRIGGERED12: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[13] event
            TRIGGERED13: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[14] event
            TRIGGERED14: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[15] event
            TRIGGERED15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x308);
    };
    /// Software interrupt 4
    pub const SWI4 = struct {
        pub const base_address = 0x40018000;

        /// address: 0x40018000
        /// Unused.
        pub const UNUSED = @intToPtr(*volatile u32, base_address + 0x0);
    };
    /// Event Generator Unit 4
    pub const EGU4 = struct {
        pub const base_address = 0x40018000;

        /// address: 0x40018000
        /// Description collection[0]: Trigger 0 for triggering the corresponding
        /// TRIGGERED[0] event
        pub const TASKS_TRIGGER = @intToPtr(*volatile [16]u32, base_address + 0x0);

        /// address: 0x40018100
        /// Description collection[0]: Event number 0 generated by triggering the
        /// corresponding TRIGGER[0] task
        pub const EVENTS_TRIGGERED = @intToPtr(*volatile [16]u32, base_address + 0x100);

        /// address: 0x40018300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable interrupt for TRIGGERED[0] event
            TRIGGERED0: u1,
            /// Enable or disable interrupt for TRIGGERED[1] event
            TRIGGERED1: u1,
            /// Enable or disable interrupt for TRIGGERED[2] event
            TRIGGERED2: u1,
            /// Enable or disable interrupt for TRIGGERED[3] event
            TRIGGERED3: u1,
            /// Enable or disable interrupt for TRIGGERED[4] event
            TRIGGERED4: u1,
            /// Enable or disable interrupt for TRIGGERED[5] event
            TRIGGERED5: u1,
            /// Enable or disable interrupt for TRIGGERED[6] event
            TRIGGERED6: u1,
            /// Enable or disable interrupt for TRIGGERED[7] event
            TRIGGERED7: u1,
            /// Enable or disable interrupt for TRIGGERED[8] event
            TRIGGERED8: u1,
            /// Enable or disable interrupt for TRIGGERED[9] event
            TRIGGERED9: u1,
            /// Enable or disable interrupt for TRIGGERED[10] event
            TRIGGERED10: u1,
            /// Enable or disable interrupt for TRIGGERED[11] event
            TRIGGERED11: u1,
            /// Enable or disable interrupt for TRIGGERED[12] event
            TRIGGERED12: u1,
            /// Enable or disable interrupt for TRIGGERED[13] event
            TRIGGERED13: u1,
            /// Enable or disable interrupt for TRIGGERED[14] event
            TRIGGERED14: u1,
            /// Enable or disable interrupt for TRIGGERED[15] event
            TRIGGERED15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x300);

        /// address: 0x40018304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for TRIGGERED[0] event
            TRIGGERED0: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[1] event
            TRIGGERED1: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[2] event
            TRIGGERED2: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[3] event
            TRIGGERED3: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[4] event
            TRIGGERED4: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[5] event
            TRIGGERED5: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[6] event
            TRIGGERED6: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[7] event
            TRIGGERED7: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[8] event
            TRIGGERED8: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[9] event
            TRIGGERED9: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[10] event
            TRIGGERED10: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[11] event
            TRIGGERED11: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[12] event
            TRIGGERED12: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[13] event
            TRIGGERED13: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[14] event
            TRIGGERED14: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[15] event
            TRIGGERED15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x304);

        /// address: 0x40018308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for TRIGGERED[0] event
            TRIGGERED0: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[1] event
            TRIGGERED1: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[2] event
            TRIGGERED2: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[3] event
            TRIGGERED3: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[4] event
            TRIGGERED4: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[5] event
            TRIGGERED5: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[6] event
            TRIGGERED6: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[7] event
            TRIGGERED7: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[8] event
            TRIGGERED8: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[9] event
            TRIGGERED9: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[10] event
            TRIGGERED10: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[11] event
            TRIGGERED11: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[12] event
            TRIGGERED12: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[13] event
            TRIGGERED13: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[14] event
            TRIGGERED14: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[15] event
            TRIGGERED15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x308);
    };
    /// Software interrupt 5
    pub const SWI5 = struct {
        pub const base_address = 0x40019000;

        /// address: 0x40019000
        /// Unused.
        pub const UNUSED = @intToPtr(*volatile u32, base_address + 0x0);
    };
    /// Event Generator Unit 5
    pub const EGU5 = struct {
        pub const base_address = 0x40019000;

        /// address: 0x40019000
        /// Description collection[0]: Trigger 0 for triggering the corresponding
        /// TRIGGERED[0] event
        pub const TASKS_TRIGGER = @intToPtr(*volatile [16]u32, base_address + 0x0);

        /// address: 0x40019100
        /// Description collection[0]: Event number 0 generated by triggering the
        /// corresponding TRIGGER[0] task
        pub const EVENTS_TRIGGERED = @intToPtr(*volatile [16]u32, base_address + 0x100);

        /// address: 0x40019300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable interrupt for TRIGGERED[0] event
            TRIGGERED0: u1,
            /// Enable or disable interrupt for TRIGGERED[1] event
            TRIGGERED1: u1,
            /// Enable or disable interrupt for TRIGGERED[2] event
            TRIGGERED2: u1,
            /// Enable or disable interrupt for TRIGGERED[3] event
            TRIGGERED3: u1,
            /// Enable or disable interrupt for TRIGGERED[4] event
            TRIGGERED4: u1,
            /// Enable or disable interrupt for TRIGGERED[5] event
            TRIGGERED5: u1,
            /// Enable or disable interrupt for TRIGGERED[6] event
            TRIGGERED6: u1,
            /// Enable or disable interrupt for TRIGGERED[7] event
            TRIGGERED7: u1,
            /// Enable or disable interrupt for TRIGGERED[8] event
            TRIGGERED8: u1,
            /// Enable or disable interrupt for TRIGGERED[9] event
            TRIGGERED9: u1,
            /// Enable or disable interrupt for TRIGGERED[10] event
            TRIGGERED10: u1,
            /// Enable or disable interrupt for TRIGGERED[11] event
            TRIGGERED11: u1,
            /// Enable or disable interrupt for TRIGGERED[12] event
            TRIGGERED12: u1,
            /// Enable or disable interrupt for TRIGGERED[13] event
            TRIGGERED13: u1,
            /// Enable or disable interrupt for TRIGGERED[14] event
            TRIGGERED14: u1,
            /// Enable or disable interrupt for TRIGGERED[15] event
            TRIGGERED15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x300);

        /// address: 0x40019304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for TRIGGERED[0] event
            TRIGGERED0: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[1] event
            TRIGGERED1: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[2] event
            TRIGGERED2: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[3] event
            TRIGGERED3: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[4] event
            TRIGGERED4: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[5] event
            TRIGGERED5: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[6] event
            TRIGGERED6: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[7] event
            TRIGGERED7: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[8] event
            TRIGGERED8: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[9] event
            TRIGGERED9: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[10] event
            TRIGGERED10: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[11] event
            TRIGGERED11: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[12] event
            TRIGGERED12: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[13] event
            TRIGGERED13: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[14] event
            TRIGGERED14: u1,
            /// Write '1' to Enable interrupt for TRIGGERED[15] event
            TRIGGERED15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x304);

        /// address: 0x40019308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for TRIGGERED[0] event
            TRIGGERED0: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[1] event
            TRIGGERED1: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[2] event
            TRIGGERED2: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[3] event
            TRIGGERED3: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[4] event
            TRIGGERED4: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[5] event
            TRIGGERED5: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[6] event
            TRIGGERED6: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[7] event
            TRIGGERED7: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[8] event
            TRIGGERED8: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[9] event
            TRIGGERED9: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[10] event
            TRIGGERED10: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[11] event
            TRIGGERED11: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[12] event
            TRIGGERED12: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[13] event
            TRIGGERED13: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[14] event
            TRIGGERED14: u1,
            /// Write '1' to Disable interrupt for TRIGGERED[15] event
            TRIGGERED15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x308);
    };
    /// Timer/Counter 3
    pub const TIMER3 = struct {
        pub const base_address = 0x4001a000;

        /// address: 0x4001a000
        /// Start Timer
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x4001a004
        /// Stop Timer
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x4001a008
        /// Increment Timer (Counter mode only)
        pub const TASKS_COUNT = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4001a00c
        /// Clear time
        pub const TASKS_CLEAR = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x4001a010
        /// Deprecated register - Shut down timer
        pub const TASKS_SHUTDOWN = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x4001a040
        /// Description collection[0]: Capture Timer value to CC[0] register
        pub const TASKS_CAPTURE = @intToPtr(*volatile [6]u32, base_address + 0x40);

        /// address: 0x4001a140
        /// Description collection[0]: Compare event on CC[0] match
        pub const EVENTS_COMPARE = @intToPtr(*volatile [6]u32, base_address + 0x140);

        /// address: 0x4001a200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Shortcut between COMPARE[0] event and CLEAR task
            COMPARE0_CLEAR: u1,
            /// Shortcut between COMPARE[1] event and CLEAR task
            COMPARE1_CLEAR: u1,
            /// Shortcut between COMPARE[2] event and CLEAR task
            COMPARE2_CLEAR: u1,
            /// Shortcut between COMPARE[3] event and CLEAR task
            COMPARE3_CLEAR: u1,
            /// Shortcut between COMPARE[4] event and CLEAR task
            COMPARE4_CLEAR: u1,
            /// Shortcut between COMPARE[5] event and CLEAR task
            COMPARE5_CLEAR: u1,
            reserved0: u1,
            reserved1: u1,
            /// Shortcut between COMPARE[0] event and STOP task
            COMPARE0_STOP: u1,
            /// Shortcut between COMPARE[1] event and STOP task
            COMPARE1_STOP: u1,
            /// Shortcut between COMPARE[2] event and STOP task
            COMPARE2_STOP: u1,
            /// Shortcut between COMPARE[3] event and STOP task
            COMPARE3_STOP: u1,
            /// Shortcut between COMPARE[4] event and STOP task
            COMPARE4_STOP: u1,
            /// Shortcut between COMPARE[5] event and STOP task
            COMPARE5_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x200);

        /// address: 0x4001a304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Write '1' to Enable interrupt for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Enable interrupt for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Enable interrupt for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Enable interrupt for COMPARE[3] event
            COMPARE3: u1,
            /// Write '1' to Enable interrupt for COMPARE[4] event
            COMPARE4: u1,
            /// Write '1' to Enable interrupt for COMPARE[5] event
            COMPARE5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x304);

        /// address: 0x4001a308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Write '1' to Disable interrupt for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Disable interrupt for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Disable interrupt for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Disable interrupt for COMPARE[3] event
            COMPARE3: u1,
            /// Write '1' to Disable interrupt for COMPARE[4] event
            COMPARE4: u1,
            /// Write '1' to Disable interrupt for COMPARE[5] event
            COMPARE5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x308);

        /// address: 0x4001a504
        /// Timer mode selection
        pub const MODE = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x504);

        /// address: 0x4001a508
        /// Configure the number of bits used by the TIMER
        pub const BITMODE = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x508);

        /// address: 0x4001a510
        /// Timer prescaler register
        pub const PRESCALER = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x510);

        /// address: 0x4001a540
        /// Description collection[0]: Capture/Compare register 0
        pub const CC = @intToPtr(*volatile [6]u32, base_address + 0x540);
    };
    /// Timer/Counter 4
    pub const TIMER4 = struct {
        pub const base_address = 0x4001b000;

        /// address: 0x4001b000
        /// Start Timer
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x4001b004
        /// Stop Timer
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x4001b008
        /// Increment Timer (Counter mode only)
        pub const TASKS_COUNT = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4001b00c
        /// Clear time
        pub const TASKS_CLEAR = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x4001b010
        /// Deprecated register - Shut down timer
        pub const TASKS_SHUTDOWN = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x4001b040
        /// Description collection[0]: Capture Timer value to CC[0] register
        pub const TASKS_CAPTURE = @intToPtr(*volatile [6]u32, base_address + 0x40);

        /// address: 0x4001b140
        /// Description collection[0]: Compare event on CC[0] match
        pub const EVENTS_COMPARE = @intToPtr(*volatile [6]u32, base_address + 0x140);

        /// address: 0x4001b200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Shortcut between COMPARE[0] event and CLEAR task
            COMPARE0_CLEAR: u1,
            /// Shortcut between COMPARE[1] event and CLEAR task
            COMPARE1_CLEAR: u1,
            /// Shortcut between COMPARE[2] event and CLEAR task
            COMPARE2_CLEAR: u1,
            /// Shortcut between COMPARE[3] event and CLEAR task
            COMPARE3_CLEAR: u1,
            /// Shortcut between COMPARE[4] event and CLEAR task
            COMPARE4_CLEAR: u1,
            /// Shortcut between COMPARE[5] event and CLEAR task
            COMPARE5_CLEAR: u1,
            reserved0: u1,
            reserved1: u1,
            /// Shortcut between COMPARE[0] event and STOP task
            COMPARE0_STOP: u1,
            /// Shortcut between COMPARE[1] event and STOP task
            COMPARE1_STOP: u1,
            /// Shortcut between COMPARE[2] event and STOP task
            COMPARE2_STOP: u1,
            /// Shortcut between COMPARE[3] event and STOP task
            COMPARE3_STOP: u1,
            /// Shortcut between COMPARE[4] event and STOP task
            COMPARE4_STOP: u1,
            /// Shortcut between COMPARE[5] event and STOP task
            COMPARE5_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x200);

        /// address: 0x4001b304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Write '1' to Enable interrupt for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Enable interrupt for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Enable interrupt for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Enable interrupt for COMPARE[3] event
            COMPARE3: u1,
            /// Write '1' to Enable interrupt for COMPARE[4] event
            COMPARE4: u1,
            /// Write '1' to Enable interrupt for COMPARE[5] event
            COMPARE5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x304);

        /// address: 0x4001b308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Write '1' to Disable interrupt for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Disable interrupt for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Disable interrupt for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Disable interrupt for COMPARE[3] event
            COMPARE3: u1,
            /// Write '1' to Disable interrupt for COMPARE[4] event
            COMPARE4: u1,
            /// Write '1' to Disable interrupt for COMPARE[5] event
            COMPARE5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x308);

        /// address: 0x4001b504
        /// Timer mode selection
        pub const MODE = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x504);

        /// address: 0x4001b508
        /// Configure the number of bits used by the TIMER
        pub const BITMODE = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x508);

        /// address: 0x4001b510
        /// Timer prescaler register
        pub const PRESCALER = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x510);

        /// address: 0x4001b540
        /// Description collection[0]: Capture/Compare register 0
        pub const CC = @intToPtr(*volatile [6]u32, base_address + 0x540);
    };
    /// Pulse Width Modulation Unit 0
    pub const PWM0 = struct {
        pub const base_address = 0x4001c000;

        /// address: 0x4001c004
        /// Stops PWM pulse generation on all channels at the end of current PWM period, and
        /// stops sequence playback
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x4001c008
        /// Description collection[0]: Loads the first PWM value on all enabled channels
        /// from sequence 0, and starts playing that sequence at the rate defined in
        /// SEQ[0]REFRESH and/or DECODER.MODE. Causes PWM generation to start it was not
        /// running.
        pub const TASKS_SEQSTART = @intToPtr(*volatile [2]u32, base_address + 0x8);

        /// address: 0x4001c010
        /// Steps by one value in the current sequence on all enabled channels if
        /// DECODER.MODE=NextStep. Does not cause PWM generation to start it was not
        /// running.
        pub const TASKS_NEXTSTEP = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x4001c104
        /// Response to STOP task, emitted when PWM pulses are no longer generated
        pub const EVENTS_STOPPED = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x4001c108
        /// Description collection[0]: First PWM period started on sequence 0
        pub const EVENTS_SEQSTARTED = @intToPtr(*volatile [2]u32, base_address + 0x108);

        /// address: 0x4001c110
        /// Description collection[0]: Emitted at end of every sequence 0, when last value
        /// from RAM has been applied to wave counter
        pub const EVENTS_SEQEND = @intToPtr(*volatile [2]u32, base_address + 0x110);

        /// address: 0x4001c118
        /// Emitted at the end of each PWM period
        pub const EVENTS_PWMPERIODEND = @intToPtr(*volatile u32, base_address + 0x118);

        /// address: 0x4001c11c
        /// Concatenated sequences have been played the amount of times defined in LOOP.CNT
        pub const EVENTS_LOOPSDONE = @intToPtr(*volatile u32, base_address + 0x11c);

        /// address: 0x4001c200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Shortcut between SEQEND[0] event and STOP task
            SEQEND0_STOP: u1,
            /// Shortcut between SEQEND[1] event and STOP task
            SEQEND1_STOP: u1,
            /// Shortcut between LOOPSDONE event and SEQSTART[0] task
            LOOPSDONE_SEQSTART0: u1,
            /// Shortcut between LOOPSDONE event and SEQSTART[1] task
            LOOPSDONE_SEQSTART1: u1,
            /// Shortcut between LOOPSDONE event and STOP task
            LOOPSDONE_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x200);

        /// address: 0x4001c300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Enable or disable interrupt for STOPPED event
            STOPPED: u1,
            /// Enable or disable interrupt for SEQSTARTED[0] event
            SEQSTARTED0: u1,
            /// Enable or disable interrupt for SEQSTARTED[1] event
            SEQSTARTED1: u1,
            /// Enable or disable interrupt for SEQEND[0] event
            SEQEND0: u1,
            /// Enable or disable interrupt for SEQEND[1] event
            SEQEND1: u1,
            /// Enable or disable interrupt for PWMPERIODEND event
            PWMPERIODEND: u1,
            /// Enable or disable interrupt for LOOPSDONE event
            LOOPSDONE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x300);

        /// address: 0x4001c304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Enable interrupt for STOPPED event
            STOPPED: u1,
            /// Write '1' to Enable interrupt for SEQSTARTED[0] event
            SEQSTARTED0: u1,
            /// Write '1' to Enable interrupt for SEQSTARTED[1] event
            SEQSTARTED1: u1,
            /// Write '1' to Enable interrupt for SEQEND[0] event
            SEQEND0: u1,
            /// Write '1' to Enable interrupt for SEQEND[1] event
            SEQEND1: u1,
            /// Write '1' to Enable interrupt for PWMPERIODEND event
            PWMPERIODEND: u1,
            /// Write '1' to Enable interrupt for LOOPSDONE event
            LOOPSDONE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x304);

        /// address: 0x4001c308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Disable interrupt for STOPPED event
            STOPPED: u1,
            /// Write '1' to Disable interrupt for SEQSTARTED[0] event
            SEQSTARTED0: u1,
            /// Write '1' to Disable interrupt for SEQSTARTED[1] event
            SEQSTARTED1: u1,
            /// Write '1' to Disable interrupt for SEQEND[0] event
            SEQEND0: u1,
            /// Write '1' to Disable interrupt for SEQEND[1] event
            SEQEND1: u1,
            /// Write '1' to Disable interrupt for PWMPERIODEND event
            PWMPERIODEND: u1,
            /// Write '1' to Disable interrupt for LOOPSDONE event
            LOOPSDONE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x308);

        /// address: 0x4001c500
        /// PWM module enable register
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x500);

        /// address: 0x4001c504
        /// Selects operating mode of the wave counter
        pub const MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Selects up or up and down as wave counter mode
            UPDOWN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x504);

        /// address: 0x4001c508
        /// Value up to which the pulse generator counter counts
        pub const COUNTERTOP = @intToPtr(*volatile MmioInt(32, u15), base_address + 0x508);

        /// address: 0x4001c50c
        /// Configuration for PWM_CLK
        pub const PRESCALER = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x50c);

        /// address: 0x4001c510
        /// Configuration of the decoder
        pub const DECODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// How a sequence is read from RAM and spread to the compare register
            LOAD: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Selects source for advancing the active sequence
            MODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x510);

        /// address: 0x4001c514
        /// Amount of playback of a loop
        pub const LOOP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Amount of playback of pattern cycles
            CNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x514);

        pub const SEQ = @ptrCast(*volatile [2]packed struct {
            /// Description cluster[0]: Beginning address in Data RAM of this sequence
            PTR: u32,

            /// Description cluster[0]: Amount of values (duty cycles) in this sequence
            CNT: MmioInt(32, u15),

            /// Description cluster[0]: Amount of additional PWM periods between samples loaded
            /// into compare register
            REFRESH: Mmio(32, packed struct {
                /// Amount of additional PWM periods between samples loaded into compare register
                /// (load every REFRESH.CNT+1 PWM periods)
                CNT: u24,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }),

            /// Description cluster[0]: Time added after the sequence
            ENDDELAY: Mmio(32, packed struct {
                /// Time added after the sequence in PWM periods
                CNT: u24,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }),
            padding0: u32,
            padding1: u32,
            padding2: u32,
            padding3: u32,
        }, base_address + 0x520);

        pub const PSEL = struct {

            /// address: 0x4001c000
            /// Description collection[0]: Output pin select for PWM channel 0
            pub const OUT = @intToPtr(*volatile [4]Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x0);
        };
    };
    /// Pulse Density Modulation (Digital Microphone) Interface
    pub const PDM = struct {
        pub const base_address = 0x4001d000;

        /// address: 0x4001d000
        /// Starts continuous PDM transfer
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x4001d004
        /// Stops PDM transfer
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x4001d100
        /// PDM transfer has started
        pub const EVENTS_STARTED = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x4001d104
        /// PDM transfer has finished
        pub const EVENTS_STOPPED = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x4001d108
        /// The PDM has written the last sample specified by SAMPLE.MAXCNT (or the last
        /// sample after a STOP task has been received) to Data RAM
        pub const EVENTS_END = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x4001d300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable interrupt for STARTED event
            STARTED: u1,
            /// Enable or disable interrupt for STOPPED event
            STOPPED: u1,
            /// Enable or disable interrupt for END event
            END: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x300);

        /// address: 0x4001d304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for STARTED event
            STARTED: u1,
            /// Write '1' to Enable interrupt for STOPPED event
            STOPPED: u1,
            /// Write '1' to Enable interrupt for END event
            END: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x304);

        /// address: 0x4001d308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for STARTED event
            STARTED: u1,
            /// Write '1' to Disable interrupt for STOPPED event
            STOPPED: u1,
            /// Write '1' to Disable interrupt for END event
            END: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x308);

        /// address: 0x4001d500
        /// PDM module enable register
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x500);

        /// address: 0x4001d504
        /// PDM clock generator control
        pub const PDMCLKCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// PDM_CLK frequency
            FREQ: u32,
        }), base_address + 0x504);

        /// address: 0x4001d508
        /// Defines the routing of the connected PDM microphones' signals
        pub const MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Mono or stereo operation
            OPERATION: u1,
            /// Defines on which PDM_CLK edge Left (or mono) is sampled
            EDGE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x508);

        /// address: 0x4001d518
        /// Left output gain adjustment
        pub const GAINL = @intToPtr(*volatile MmioInt(32, u7), base_address + 0x518);

        /// address: 0x4001d51c
        /// Right output gain adjustment
        pub const GAINR = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x51c);

        pub const PSEL = struct {

            /// address: 0x4001d000
            /// Pin number configuration for PDM CLK signal
            pub const CLK = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x0);

            /// address: 0x4001d004
            /// Pin number configuration for PDM DIN signal
            pub const DIN = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x4);
        };

        pub const SAMPLE = struct {

            /// address: 0x4001d000
            /// RAM address pointer to write samples to with EasyDMA
            pub const PTR = @intToPtr(*volatile Mmio(32, packed struct {
                /// Address to write PDM samples to over DMA
                SAMPLEPTR: u32,
            }), base_address + 0x0);

            /// address: 0x4001d004
            /// Number of samples to allocate memory for in EasyDMA mode
            pub const MAXCNT = @intToPtr(*volatile Mmio(32, packed struct {
                /// Length of DMA RAM allocation in number of samples
                BUFFSIZE: u15,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
            }), base_address + 0x4);
        };
    };
    /// Non Volatile Memory Controller
    pub const NVMC = struct {
        pub const base_address = 0x4001e000;

        /// address: 0x4001e400
        /// Ready flag
        pub const READY = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x400);

        /// address: 0x4001e504
        /// Configuration register
        pub const CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Program memory access mode. It is strongly recommended to only activate erase
            /// and write modes when they are actively used. Enabling write or erase will
            /// invalidate the cache and keep it invalidated.
            WEN: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x504);

        /// address: 0x4001e508
        /// Register for erasing a page in Code area
        pub const ERASEPAGE = @intToPtr(*volatile u32, base_address + 0x508);

        /// address: 0x4001e508
        /// Deprecated register - Register for erasing a page in Code area. Equivalent to
        /// ERASEPAGE.
        pub const ERASEPCR1 = @intToPtr(*volatile u32, base_address + 0x508);

        /// address: 0x4001e50c
        /// Register for erasing all non-volatile user memory
        pub const ERASEALL = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x50c);

        /// address: 0x4001e510
        /// Deprecated register - Register for erasing a page in Code area. Equivalent to
        /// ERASEPAGE.
        pub const ERASEPCR0 = @intToPtr(*volatile u32, base_address + 0x510);

        /// address: 0x4001e514
        /// Register for erasing User Information Configuration Registers
        pub const ERASEUICR = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x514);

        /// address: 0x4001e540
        /// I-Code cache configuration register.
        pub const ICACHECNF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Cache enable
            CACHEEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Cache profiling enable
            CACHEPROFEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x540);

        /// address: 0x4001e548
        /// I-Code cache hit counter.
        pub const IHIT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of cache hits
            HITS: u32,
        }), base_address + 0x548);

        /// address: 0x4001e54c
        /// I-Code cache miss counter.
        pub const IMISS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of cache misses
            MISSES: u32,
        }), base_address + 0x54c);
    };
    /// Programmable Peripheral Interconnect
    pub const PPI = struct {
        pub const base_address = 0x4001f000;

        /// address: 0x4001f500
        /// Channel enable register
        pub const CHEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable channel 0
            CH0: u1,
            /// Enable or disable channel 1
            CH1: u1,
            /// Enable or disable channel 2
            CH2: u1,
            /// Enable or disable channel 3
            CH3: u1,
            /// Enable or disable channel 4
            CH4: u1,
            /// Enable or disable channel 5
            CH5: u1,
            /// Enable or disable channel 6
            CH6: u1,
            /// Enable or disable channel 7
            CH7: u1,
            /// Enable or disable channel 8
            CH8: u1,
            /// Enable or disable channel 9
            CH9: u1,
            /// Enable or disable channel 10
            CH10: u1,
            /// Enable or disable channel 11
            CH11: u1,
            /// Enable or disable channel 12
            CH12: u1,
            /// Enable or disable channel 13
            CH13: u1,
            /// Enable or disable channel 14
            CH14: u1,
            /// Enable or disable channel 15
            CH15: u1,
            /// Enable or disable channel 16
            CH16: u1,
            /// Enable or disable channel 17
            CH17: u1,
            /// Enable or disable channel 18
            CH18: u1,
            /// Enable or disable channel 19
            CH19: u1,
            /// Enable or disable channel 20
            CH20: u1,
            /// Enable or disable channel 21
            CH21: u1,
            /// Enable or disable channel 22
            CH22: u1,
            /// Enable or disable channel 23
            CH23: u1,
            /// Enable or disable channel 24
            CH24: u1,
            /// Enable or disable channel 25
            CH25: u1,
            /// Enable or disable channel 26
            CH26: u1,
            /// Enable or disable channel 27
            CH27: u1,
            /// Enable or disable channel 28
            CH28: u1,
            /// Enable or disable channel 29
            CH29: u1,
            /// Enable or disable channel 30
            CH30: u1,
            /// Enable or disable channel 31
            CH31: u1,
        }), base_address + 0x500);

        /// address: 0x4001f504
        /// Channel enable set register
        pub const CHENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 0 enable set register. Writing '0' has no effect
            CH0: u1,
            /// Channel 1 enable set register. Writing '0' has no effect
            CH1: u1,
            /// Channel 2 enable set register. Writing '0' has no effect
            CH2: u1,
            /// Channel 3 enable set register. Writing '0' has no effect
            CH3: u1,
            /// Channel 4 enable set register. Writing '0' has no effect
            CH4: u1,
            /// Channel 5 enable set register. Writing '0' has no effect
            CH5: u1,
            /// Channel 6 enable set register. Writing '0' has no effect
            CH6: u1,
            /// Channel 7 enable set register. Writing '0' has no effect
            CH7: u1,
            /// Channel 8 enable set register. Writing '0' has no effect
            CH8: u1,
            /// Channel 9 enable set register. Writing '0' has no effect
            CH9: u1,
            /// Channel 10 enable set register. Writing '0' has no effect
            CH10: u1,
            /// Channel 11 enable set register. Writing '0' has no effect
            CH11: u1,
            /// Channel 12 enable set register. Writing '0' has no effect
            CH12: u1,
            /// Channel 13 enable set register. Writing '0' has no effect
            CH13: u1,
            /// Channel 14 enable set register. Writing '0' has no effect
            CH14: u1,
            /// Channel 15 enable set register. Writing '0' has no effect
            CH15: u1,
            /// Channel 16 enable set register. Writing '0' has no effect
            CH16: u1,
            /// Channel 17 enable set register. Writing '0' has no effect
            CH17: u1,
            /// Channel 18 enable set register. Writing '0' has no effect
            CH18: u1,
            /// Channel 19 enable set register. Writing '0' has no effect
            CH19: u1,
            /// Channel 20 enable set register. Writing '0' has no effect
            CH20: u1,
            /// Channel 21 enable set register. Writing '0' has no effect
            CH21: u1,
            /// Channel 22 enable set register. Writing '0' has no effect
            CH22: u1,
            /// Channel 23 enable set register. Writing '0' has no effect
            CH23: u1,
            /// Channel 24 enable set register. Writing '0' has no effect
            CH24: u1,
            /// Channel 25 enable set register. Writing '0' has no effect
            CH25: u1,
            /// Channel 26 enable set register. Writing '0' has no effect
            CH26: u1,
            /// Channel 27 enable set register. Writing '0' has no effect
            CH27: u1,
            /// Channel 28 enable set register. Writing '0' has no effect
            CH28: u1,
            /// Channel 29 enable set register. Writing '0' has no effect
            CH29: u1,
            /// Channel 30 enable set register. Writing '0' has no effect
            CH30: u1,
            /// Channel 31 enable set register. Writing '0' has no effect
            CH31: u1,
        }), base_address + 0x504);

        /// address: 0x4001f508
        /// Channel enable clear register
        pub const CHENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 0 enable clear register. Writing '0' has no effect
            CH0: u1,
            /// Channel 1 enable clear register. Writing '0' has no effect
            CH1: u1,
            /// Channel 2 enable clear register. Writing '0' has no effect
            CH2: u1,
            /// Channel 3 enable clear register. Writing '0' has no effect
            CH3: u1,
            /// Channel 4 enable clear register. Writing '0' has no effect
            CH4: u1,
            /// Channel 5 enable clear register. Writing '0' has no effect
            CH5: u1,
            /// Channel 6 enable clear register. Writing '0' has no effect
            CH6: u1,
            /// Channel 7 enable clear register. Writing '0' has no effect
            CH7: u1,
            /// Channel 8 enable clear register. Writing '0' has no effect
            CH8: u1,
            /// Channel 9 enable clear register. Writing '0' has no effect
            CH9: u1,
            /// Channel 10 enable clear register. Writing '0' has no effect
            CH10: u1,
            /// Channel 11 enable clear register. Writing '0' has no effect
            CH11: u1,
            /// Channel 12 enable clear register. Writing '0' has no effect
            CH12: u1,
            /// Channel 13 enable clear register. Writing '0' has no effect
            CH13: u1,
            /// Channel 14 enable clear register. Writing '0' has no effect
            CH14: u1,
            /// Channel 15 enable clear register. Writing '0' has no effect
            CH15: u1,
            /// Channel 16 enable clear register. Writing '0' has no effect
            CH16: u1,
            /// Channel 17 enable clear register. Writing '0' has no effect
            CH17: u1,
            /// Channel 18 enable clear register. Writing '0' has no effect
            CH18: u1,
            /// Channel 19 enable clear register. Writing '0' has no effect
            CH19: u1,
            /// Channel 20 enable clear register. Writing '0' has no effect
            CH20: u1,
            /// Channel 21 enable clear register. Writing '0' has no effect
            CH21: u1,
            /// Channel 22 enable clear register. Writing '0' has no effect
            CH22: u1,
            /// Channel 23 enable clear register. Writing '0' has no effect
            CH23: u1,
            /// Channel 24 enable clear register. Writing '0' has no effect
            CH24: u1,
            /// Channel 25 enable clear register. Writing '0' has no effect
            CH25: u1,
            /// Channel 26 enable clear register. Writing '0' has no effect
            CH26: u1,
            /// Channel 27 enable clear register. Writing '0' has no effect
            CH27: u1,
            /// Channel 28 enable clear register. Writing '0' has no effect
            CH28: u1,
            /// Channel 29 enable clear register. Writing '0' has no effect
            CH29: u1,
            /// Channel 30 enable clear register. Writing '0' has no effect
            CH30: u1,
            /// Channel 31 enable clear register. Writing '0' has no effect
            CH31: u1,
        }), base_address + 0x508);

        /// address: 0x4001f800
        /// Description collection[0]: Channel group 0
        pub const CHG = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Include or exclude channel 0
            CH0: u1,
            /// Include or exclude channel 1
            CH1: u1,
            /// Include or exclude channel 2
            CH2: u1,
            /// Include or exclude channel 3
            CH3: u1,
            /// Include or exclude channel 4
            CH4: u1,
            /// Include or exclude channel 5
            CH5: u1,
            /// Include or exclude channel 6
            CH6: u1,
            /// Include or exclude channel 7
            CH7: u1,
            /// Include or exclude channel 8
            CH8: u1,
            /// Include or exclude channel 9
            CH9: u1,
            /// Include or exclude channel 10
            CH10: u1,
            /// Include or exclude channel 11
            CH11: u1,
            /// Include or exclude channel 12
            CH12: u1,
            /// Include or exclude channel 13
            CH13: u1,
            /// Include or exclude channel 14
            CH14: u1,
            /// Include or exclude channel 15
            CH15: u1,
            /// Include or exclude channel 16
            CH16: u1,
            /// Include or exclude channel 17
            CH17: u1,
            /// Include or exclude channel 18
            CH18: u1,
            /// Include or exclude channel 19
            CH19: u1,
            /// Include or exclude channel 20
            CH20: u1,
            /// Include or exclude channel 21
            CH21: u1,
            /// Include or exclude channel 22
            CH22: u1,
            /// Include or exclude channel 23
            CH23: u1,
            /// Include or exclude channel 24
            CH24: u1,
            /// Include or exclude channel 25
            CH25: u1,
            /// Include or exclude channel 26
            CH26: u1,
            /// Include or exclude channel 27
            CH27: u1,
            /// Include or exclude channel 28
            CH28: u1,
            /// Include or exclude channel 29
            CH29: u1,
            /// Include or exclude channel 30
            CH30: u1,
            /// Include or exclude channel 31
            CH31: u1,
        }), base_address + 0x800);

        /// Channel group tasks
        pub const TASKS_CHG = @ptrCast(*volatile [6]packed struct {
            /// Description cluster[0]: Enable channel group 0
            EN: u32,

            /// Description cluster[0]: Disable channel group 0
            DIS: u32,
        }, base_address + 0x0);

        /// PPI Channel
        pub const CH = @ptrCast(*volatile [20]packed struct {
            /// Description cluster[0]: Channel 0 event end-point
            EEP: u32,

            /// Description cluster[0]: Channel 0 task end-point
            TEP: u32,
        }, base_address + 0x510);

        /// Fork
        pub const FORK = @ptrCast(*volatile [32]packed struct {
            /// Description cluster[0]: Channel 0 task end-point
            TEP: u32,
        }, base_address + 0x910);
    };
    /// Memory Watch Unit
    pub const MWU = struct {
        pub const base_address = 0x40020000;

        /// address: 0x40020300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable interrupt for REGION[0].WA event
            REGION0WA: u1,
            /// Enable or disable interrupt for REGION[0].RA event
            REGION0RA: u1,
            /// Enable or disable interrupt for REGION[1].WA event
            REGION1WA: u1,
            /// Enable or disable interrupt for REGION[1].RA event
            REGION1RA: u1,
            /// Enable or disable interrupt for REGION[2].WA event
            REGION2WA: u1,
            /// Enable or disable interrupt for REGION[2].RA event
            REGION2RA: u1,
            /// Enable or disable interrupt for REGION[3].WA event
            REGION3WA: u1,
            /// Enable or disable interrupt for REGION[3].RA event
            REGION3RA: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Enable or disable interrupt for PREGION[0].WA event
            PREGION0WA: u1,
            /// Enable or disable interrupt for PREGION[0].RA event
            PREGION0RA: u1,
            /// Enable or disable interrupt for PREGION[1].WA event
            PREGION1WA: u1,
            /// Enable or disable interrupt for PREGION[1].RA event
            PREGION1RA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x300);

        /// address: 0x40020304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for REGION[0].WA event
            REGION0WA: u1,
            /// Write '1' to Enable interrupt for REGION[0].RA event
            REGION0RA: u1,
            /// Write '1' to Enable interrupt for REGION[1].WA event
            REGION1WA: u1,
            /// Write '1' to Enable interrupt for REGION[1].RA event
            REGION1RA: u1,
            /// Write '1' to Enable interrupt for REGION[2].WA event
            REGION2WA: u1,
            /// Write '1' to Enable interrupt for REGION[2].RA event
            REGION2RA: u1,
            /// Write '1' to Enable interrupt for REGION[3].WA event
            REGION3WA: u1,
            /// Write '1' to Enable interrupt for REGION[3].RA event
            REGION3RA: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Write '1' to Enable interrupt for PREGION[0].WA event
            PREGION0WA: u1,
            /// Write '1' to Enable interrupt for PREGION[0].RA event
            PREGION0RA: u1,
            /// Write '1' to Enable interrupt for PREGION[1].WA event
            PREGION1WA: u1,
            /// Write '1' to Enable interrupt for PREGION[1].RA event
            PREGION1RA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x304);

        /// address: 0x40020308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for REGION[0].WA event
            REGION0WA: u1,
            /// Write '1' to Disable interrupt for REGION[0].RA event
            REGION0RA: u1,
            /// Write '1' to Disable interrupt for REGION[1].WA event
            REGION1WA: u1,
            /// Write '1' to Disable interrupt for REGION[1].RA event
            REGION1RA: u1,
            /// Write '1' to Disable interrupt for REGION[2].WA event
            REGION2WA: u1,
            /// Write '1' to Disable interrupt for REGION[2].RA event
            REGION2RA: u1,
            /// Write '1' to Disable interrupt for REGION[3].WA event
            REGION3WA: u1,
            /// Write '1' to Disable interrupt for REGION[3].RA event
            REGION3RA: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Write '1' to Disable interrupt for PREGION[0].WA event
            PREGION0WA: u1,
            /// Write '1' to Disable interrupt for PREGION[0].RA event
            PREGION0RA: u1,
            /// Write '1' to Disable interrupt for PREGION[1].WA event
            PREGION1WA: u1,
            /// Write '1' to Disable interrupt for PREGION[1].RA event
            PREGION1RA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x308);

        /// address: 0x40020320
        /// Enable or disable non-maskable interrupt
        pub const NMIEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable non-maskable interrupt for REGION[0].WA event
            REGION0WA: u1,
            /// Enable or disable non-maskable interrupt for REGION[0].RA event
            REGION0RA: u1,
            /// Enable or disable non-maskable interrupt for REGION[1].WA event
            REGION1WA: u1,
            /// Enable or disable non-maskable interrupt for REGION[1].RA event
            REGION1RA: u1,
            /// Enable or disable non-maskable interrupt for REGION[2].WA event
            REGION2WA: u1,
            /// Enable or disable non-maskable interrupt for REGION[2].RA event
            REGION2RA: u1,
            /// Enable or disable non-maskable interrupt for REGION[3].WA event
            REGION3WA: u1,
            /// Enable or disable non-maskable interrupt for REGION[3].RA event
            REGION3RA: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Enable or disable non-maskable interrupt for PREGION[0].WA event
            PREGION0WA: u1,
            /// Enable or disable non-maskable interrupt for PREGION[0].RA event
            PREGION0RA: u1,
            /// Enable or disable non-maskable interrupt for PREGION[1].WA event
            PREGION1WA: u1,
            /// Enable or disable non-maskable interrupt for PREGION[1].RA event
            PREGION1RA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x320);

        /// address: 0x40020324
        /// Enable non-maskable interrupt
        pub const NMIENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable non-maskable interrupt for REGION[0].WA event
            REGION0WA: u1,
            /// Write '1' to Enable non-maskable interrupt for REGION[0].RA event
            REGION0RA: u1,
            /// Write '1' to Enable non-maskable interrupt for REGION[1].WA event
            REGION1WA: u1,
            /// Write '1' to Enable non-maskable interrupt for REGION[1].RA event
            REGION1RA: u1,
            /// Write '1' to Enable non-maskable interrupt for REGION[2].WA event
            REGION2WA: u1,
            /// Write '1' to Enable non-maskable interrupt for REGION[2].RA event
            REGION2RA: u1,
            /// Write '1' to Enable non-maskable interrupt for REGION[3].WA event
            REGION3WA: u1,
            /// Write '1' to Enable non-maskable interrupt for REGION[3].RA event
            REGION3RA: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Write '1' to Enable non-maskable interrupt for PREGION[0].WA event
            PREGION0WA: u1,
            /// Write '1' to Enable non-maskable interrupt for PREGION[0].RA event
            PREGION0RA: u1,
            /// Write '1' to Enable non-maskable interrupt for PREGION[1].WA event
            PREGION1WA: u1,
            /// Write '1' to Enable non-maskable interrupt for PREGION[1].RA event
            PREGION1RA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x324);

        /// address: 0x40020328
        /// Disable non-maskable interrupt
        pub const NMIENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable non-maskable interrupt for REGION[0].WA event
            REGION0WA: u1,
            /// Write '1' to Disable non-maskable interrupt for REGION[0].RA event
            REGION0RA: u1,
            /// Write '1' to Disable non-maskable interrupt for REGION[1].WA event
            REGION1WA: u1,
            /// Write '1' to Disable non-maskable interrupt for REGION[1].RA event
            REGION1RA: u1,
            /// Write '1' to Disable non-maskable interrupt for REGION[2].WA event
            REGION2WA: u1,
            /// Write '1' to Disable non-maskable interrupt for REGION[2].RA event
            REGION2RA: u1,
            /// Write '1' to Disable non-maskable interrupt for REGION[3].WA event
            REGION3WA: u1,
            /// Write '1' to Disable non-maskable interrupt for REGION[3].RA event
            REGION3RA: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Write '1' to Disable non-maskable interrupt for PREGION[0].WA event
            PREGION0WA: u1,
            /// Write '1' to Disable non-maskable interrupt for PREGION[0].RA event
            PREGION0RA: u1,
            /// Write '1' to Disable non-maskable interrupt for PREGION[1].WA event
            PREGION1WA: u1,
            /// Write '1' to Disable non-maskable interrupt for PREGION[1].RA event
            PREGION1RA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x328);

        /// address: 0x40020510
        /// Enable/disable regions watch
        pub const REGIONEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable/disable write access watch in region[0]
            RGN0WA: u1,
            /// Enable/disable read access watch in region[0]
            RGN0RA: u1,
            /// Enable/disable write access watch in region[1]
            RGN1WA: u1,
            /// Enable/disable read access watch in region[1]
            RGN1RA: u1,
            /// Enable/disable write access watch in region[2]
            RGN2WA: u1,
            /// Enable/disable read access watch in region[2]
            RGN2RA: u1,
            /// Enable/disable write access watch in region[3]
            RGN3WA: u1,
            /// Enable/disable read access watch in region[3]
            RGN3RA: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Enable/disable write access watch in PREGION[0]
            PRGN0WA: u1,
            /// Enable/disable read access watch in PREGION[0]
            PRGN0RA: u1,
            /// Enable/disable write access watch in PREGION[1]
            PRGN1WA: u1,
            /// Enable/disable read access watch in PREGION[1]
            PRGN1RA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x510);

        /// address: 0x40020514
        /// Enable regions watch
        pub const REGIONENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable write access watch in region[0]
            RGN0WA: u1,
            /// Enable read access watch in region[0]
            RGN0RA: u1,
            /// Enable write access watch in region[1]
            RGN1WA: u1,
            /// Enable read access watch in region[1]
            RGN1RA: u1,
            /// Enable write access watch in region[2]
            RGN2WA: u1,
            /// Enable read access watch in region[2]
            RGN2RA: u1,
            /// Enable write access watch in region[3]
            RGN3WA: u1,
            /// Enable read access watch in region[3]
            RGN3RA: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Enable write access watch in PREGION[0]
            PRGN0WA: u1,
            /// Enable read access watch in PREGION[0]
            PRGN0RA: u1,
            /// Enable write access watch in PREGION[1]
            PRGN1WA: u1,
            /// Enable read access watch in PREGION[1]
            PRGN1RA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x514);

        /// address: 0x40020518
        /// Disable regions watch
        pub const REGIONENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Disable write access watch in region[0]
            RGN0WA: u1,
            /// Disable read access watch in region[0]
            RGN0RA: u1,
            /// Disable write access watch in region[1]
            RGN1WA: u1,
            /// Disable read access watch in region[1]
            RGN1RA: u1,
            /// Disable write access watch in region[2]
            RGN2WA: u1,
            /// Disable read access watch in region[2]
            RGN2RA: u1,
            /// Disable write access watch in region[3]
            RGN3WA: u1,
            /// Disable read access watch in region[3]
            RGN3RA: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Disable write access watch in PREGION[0]
            PRGN0WA: u1,
            /// Disable read access watch in PREGION[0]
            PRGN0RA: u1,
            /// Disable write access watch in PREGION[1]
            PRGN1WA: u1,
            /// Disable read access watch in PREGION[1]
            PRGN1RA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x518);

        pub const EVENTS_REGION = @ptrCast(*volatile [4]packed struct {
            /// Description cluster[0]: Write access to region 0 detected
            WA: u32,

            /// Description cluster[0]: Read access to region 0 detected
            RA: u32,
        }, base_address + 0x100);

        pub const EVENTS_PREGION = @ptrCast(*volatile [2]packed struct {
            /// Description cluster[0]: Write access to peripheral region 0 detected
            WA: u32,

            /// Description cluster[0]: Read access to peripheral region 0 detected
            RA: u32,
        }, base_address + 0x160);

        pub const PERREGION = @ptrCast(*volatile [2]packed struct {
            /// Description cluster[0]: Source of event/interrupt in region 0, write access
            /// detected while corresponding subregion was enabled for watching
            SUBSTATWA: Mmio(32, packed struct {
                /// Subregion 0 in region 0 (write '1' to clear)
                SR0: u1,
                /// Subregion 1 in region 0 (write '1' to clear)
                SR1: u1,
                /// Subregion 2 in region 0 (write '1' to clear)
                SR2: u1,
                /// Subregion 3 in region 0 (write '1' to clear)
                SR3: u1,
                /// Subregion 4 in region 0 (write '1' to clear)
                SR4: u1,
                /// Subregion 5 in region 0 (write '1' to clear)
                SR5: u1,
                /// Subregion 6 in region 0 (write '1' to clear)
                SR6: u1,
                /// Subregion 7 in region 0 (write '1' to clear)
                SR7: u1,
                /// Subregion 8 in region 0 (write '1' to clear)
                SR8: u1,
                /// Subregion 9 in region 0 (write '1' to clear)
                SR9: u1,
                /// Subregion 10 in region 0 (write '1' to clear)
                SR10: u1,
                /// Subregion 11 in region 0 (write '1' to clear)
                SR11: u1,
                /// Subregion 12 in region 0 (write '1' to clear)
                SR12: u1,
                /// Subregion 13 in region 0 (write '1' to clear)
                SR13: u1,
                /// Subregion 14 in region 0 (write '1' to clear)
                SR14: u1,
                /// Subregion 15 in region 0 (write '1' to clear)
                SR15: u1,
                /// Subregion 16 in region 0 (write '1' to clear)
                SR16: u1,
                /// Subregion 17 in region 0 (write '1' to clear)
                SR17: u1,
                /// Subregion 18 in region 0 (write '1' to clear)
                SR18: u1,
                /// Subregion 19 in region 0 (write '1' to clear)
                SR19: u1,
                /// Subregion 20 in region 0 (write '1' to clear)
                SR20: u1,
                /// Subregion 21 in region 0 (write '1' to clear)
                SR21: u1,
                /// Subregion 22 in region 0 (write '1' to clear)
                SR22: u1,
                /// Subregion 23 in region 0 (write '1' to clear)
                SR23: u1,
                /// Subregion 24 in region 0 (write '1' to clear)
                SR24: u1,
                /// Subregion 25 in region 0 (write '1' to clear)
                SR25: u1,
                /// Subregion 26 in region 0 (write '1' to clear)
                SR26: u1,
                /// Subregion 27 in region 0 (write '1' to clear)
                SR27: u1,
                /// Subregion 28 in region 0 (write '1' to clear)
                SR28: u1,
                /// Subregion 29 in region 0 (write '1' to clear)
                SR29: u1,
                /// Subregion 30 in region 0 (write '1' to clear)
                SR30: u1,
                /// Subregion 31 in region 0 (write '1' to clear)
                SR31: u1,
            }),

            /// Description cluster[0]: Source of event/interrupt in region 0, read access
            /// detected while corresponding subregion was enabled for watching
            SUBSTATRA: Mmio(32, packed struct {
                /// Subregion 0 in region 0 (write '1' to clear)
                SR0: u1,
                /// Subregion 1 in region 0 (write '1' to clear)
                SR1: u1,
                /// Subregion 2 in region 0 (write '1' to clear)
                SR2: u1,
                /// Subregion 3 in region 0 (write '1' to clear)
                SR3: u1,
                /// Subregion 4 in region 0 (write '1' to clear)
                SR4: u1,
                /// Subregion 5 in region 0 (write '1' to clear)
                SR5: u1,
                /// Subregion 6 in region 0 (write '1' to clear)
                SR6: u1,
                /// Subregion 7 in region 0 (write '1' to clear)
                SR7: u1,
                /// Subregion 8 in region 0 (write '1' to clear)
                SR8: u1,
                /// Subregion 9 in region 0 (write '1' to clear)
                SR9: u1,
                /// Subregion 10 in region 0 (write '1' to clear)
                SR10: u1,
                /// Subregion 11 in region 0 (write '1' to clear)
                SR11: u1,
                /// Subregion 12 in region 0 (write '1' to clear)
                SR12: u1,
                /// Subregion 13 in region 0 (write '1' to clear)
                SR13: u1,
                /// Subregion 14 in region 0 (write '1' to clear)
                SR14: u1,
                /// Subregion 15 in region 0 (write '1' to clear)
                SR15: u1,
                /// Subregion 16 in region 0 (write '1' to clear)
                SR16: u1,
                /// Subregion 17 in region 0 (write '1' to clear)
                SR17: u1,
                /// Subregion 18 in region 0 (write '1' to clear)
                SR18: u1,
                /// Subregion 19 in region 0 (write '1' to clear)
                SR19: u1,
                /// Subregion 20 in region 0 (write '1' to clear)
                SR20: u1,
                /// Subregion 21 in region 0 (write '1' to clear)
                SR21: u1,
                /// Subregion 22 in region 0 (write '1' to clear)
                SR22: u1,
                /// Subregion 23 in region 0 (write '1' to clear)
                SR23: u1,
                /// Subregion 24 in region 0 (write '1' to clear)
                SR24: u1,
                /// Subregion 25 in region 0 (write '1' to clear)
                SR25: u1,
                /// Subregion 26 in region 0 (write '1' to clear)
                SR26: u1,
                /// Subregion 27 in region 0 (write '1' to clear)
                SR27: u1,
                /// Subregion 28 in region 0 (write '1' to clear)
                SR28: u1,
                /// Subregion 29 in region 0 (write '1' to clear)
                SR29: u1,
                /// Subregion 30 in region 0 (write '1' to clear)
                SR30: u1,
                /// Subregion 31 in region 0 (write '1' to clear)
                SR31: u1,
            }),
        }, base_address + 0x400);

        pub const REGION = @ptrCast(*volatile [4]packed struct {
            /// Description cluster[0]: Start address for region 0
            START: u32,

            /// Description cluster[0]: End address of region 0
            END: u32,
            padding0: u32,
            padding1: u32,
        }, base_address + 0x600);

        pub const PREGION = @ptrCast(*volatile [2]packed struct {
            /// Description cluster[0]: Reserved for future use
            START: u32,

            /// Description cluster[0]: Reserved for future use
            END: u32,

            /// Description cluster[0]: Subregions of region 0
            SUBS: Mmio(32, packed struct {
                /// Include or exclude subregion 0 in region
                SR0: u1,
                /// Include or exclude subregion 1 in region
                SR1: u1,
                /// Include or exclude subregion 2 in region
                SR2: u1,
                /// Include or exclude subregion 3 in region
                SR3: u1,
                /// Include or exclude subregion 4 in region
                SR4: u1,
                /// Include or exclude subregion 5 in region
                SR5: u1,
                /// Include or exclude subregion 6 in region
                SR6: u1,
                /// Include or exclude subregion 7 in region
                SR7: u1,
                /// Include or exclude subregion 8 in region
                SR8: u1,
                /// Include or exclude subregion 9 in region
                SR9: u1,
                /// Include or exclude subregion 10 in region
                SR10: u1,
                /// Include or exclude subregion 11 in region
                SR11: u1,
                /// Include or exclude subregion 12 in region
                SR12: u1,
                /// Include or exclude subregion 13 in region
                SR13: u1,
                /// Include or exclude subregion 14 in region
                SR14: u1,
                /// Include or exclude subregion 15 in region
                SR15: u1,
                /// Include or exclude subregion 16 in region
                SR16: u1,
                /// Include or exclude subregion 17 in region
                SR17: u1,
                /// Include or exclude subregion 18 in region
                SR18: u1,
                /// Include or exclude subregion 19 in region
                SR19: u1,
                /// Include or exclude subregion 20 in region
                SR20: u1,
                /// Include or exclude subregion 21 in region
                SR21: u1,
                /// Include or exclude subregion 22 in region
                SR22: u1,
                /// Include or exclude subregion 23 in region
                SR23: u1,
                /// Include or exclude subregion 24 in region
                SR24: u1,
                /// Include or exclude subregion 25 in region
                SR25: u1,
                /// Include or exclude subregion 26 in region
                SR26: u1,
                /// Include or exclude subregion 27 in region
                SR27: u1,
                /// Include or exclude subregion 28 in region
                SR28: u1,
                /// Include or exclude subregion 29 in region
                SR29: u1,
                /// Include or exclude subregion 30 in region
                SR30: u1,
                /// Include or exclude subregion 31 in region
                SR31: u1,
            }),
            padding0: u32,
        }, base_address + 0x6c0);
    };
    /// Pulse Width Modulation Unit 1
    pub const PWM1 = struct {
        pub const base_address = 0x40021000;

        /// address: 0x40021004
        /// Stops PWM pulse generation on all channels at the end of current PWM period, and
        /// stops sequence playback
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40021008
        /// Description collection[0]: Loads the first PWM value on all enabled channels
        /// from sequence 0, and starts playing that sequence at the rate defined in
        /// SEQ[0]REFRESH and/or DECODER.MODE. Causes PWM generation to start it was not
        /// running.
        pub const TASKS_SEQSTART = @intToPtr(*volatile [2]u32, base_address + 0x8);

        /// address: 0x40021010
        /// Steps by one value in the current sequence on all enabled channels if
        /// DECODER.MODE=NextStep. Does not cause PWM generation to start it was not
        /// running.
        pub const TASKS_NEXTSTEP = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40021104
        /// Response to STOP task, emitted when PWM pulses are no longer generated
        pub const EVENTS_STOPPED = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40021108
        /// Description collection[0]: First PWM period started on sequence 0
        pub const EVENTS_SEQSTARTED = @intToPtr(*volatile [2]u32, base_address + 0x108);

        /// address: 0x40021110
        /// Description collection[0]: Emitted at end of every sequence 0, when last value
        /// from RAM has been applied to wave counter
        pub const EVENTS_SEQEND = @intToPtr(*volatile [2]u32, base_address + 0x110);

        /// address: 0x40021118
        /// Emitted at the end of each PWM period
        pub const EVENTS_PWMPERIODEND = @intToPtr(*volatile u32, base_address + 0x118);

        /// address: 0x4002111c
        /// Concatenated sequences have been played the amount of times defined in LOOP.CNT
        pub const EVENTS_LOOPSDONE = @intToPtr(*volatile u32, base_address + 0x11c);

        /// address: 0x40021200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Shortcut between SEQEND[0] event and STOP task
            SEQEND0_STOP: u1,
            /// Shortcut between SEQEND[1] event and STOP task
            SEQEND1_STOP: u1,
            /// Shortcut between LOOPSDONE event and SEQSTART[0] task
            LOOPSDONE_SEQSTART0: u1,
            /// Shortcut between LOOPSDONE event and SEQSTART[1] task
            LOOPSDONE_SEQSTART1: u1,
            /// Shortcut between LOOPSDONE event and STOP task
            LOOPSDONE_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x200);

        /// address: 0x40021300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Enable or disable interrupt for STOPPED event
            STOPPED: u1,
            /// Enable or disable interrupt for SEQSTARTED[0] event
            SEQSTARTED0: u1,
            /// Enable or disable interrupt for SEQSTARTED[1] event
            SEQSTARTED1: u1,
            /// Enable or disable interrupt for SEQEND[0] event
            SEQEND0: u1,
            /// Enable or disable interrupt for SEQEND[1] event
            SEQEND1: u1,
            /// Enable or disable interrupt for PWMPERIODEND event
            PWMPERIODEND: u1,
            /// Enable or disable interrupt for LOOPSDONE event
            LOOPSDONE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x300);

        /// address: 0x40021304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Enable interrupt for STOPPED event
            STOPPED: u1,
            /// Write '1' to Enable interrupt for SEQSTARTED[0] event
            SEQSTARTED0: u1,
            /// Write '1' to Enable interrupt for SEQSTARTED[1] event
            SEQSTARTED1: u1,
            /// Write '1' to Enable interrupt for SEQEND[0] event
            SEQEND0: u1,
            /// Write '1' to Enable interrupt for SEQEND[1] event
            SEQEND1: u1,
            /// Write '1' to Enable interrupt for PWMPERIODEND event
            PWMPERIODEND: u1,
            /// Write '1' to Enable interrupt for LOOPSDONE event
            LOOPSDONE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x304);

        /// address: 0x40021308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Disable interrupt for STOPPED event
            STOPPED: u1,
            /// Write '1' to Disable interrupt for SEQSTARTED[0] event
            SEQSTARTED0: u1,
            /// Write '1' to Disable interrupt for SEQSTARTED[1] event
            SEQSTARTED1: u1,
            /// Write '1' to Disable interrupt for SEQEND[0] event
            SEQEND0: u1,
            /// Write '1' to Disable interrupt for SEQEND[1] event
            SEQEND1: u1,
            /// Write '1' to Disable interrupt for PWMPERIODEND event
            PWMPERIODEND: u1,
            /// Write '1' to Disable interrupt for LOOPSDONE event
            LOOPSDONE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x308);

        /// address: 0x40021500
        /// PWM module enable register
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x500);

        /// address: 0x40021504
        /// Selects operating mode of the wave counter
        pub const MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Selects up or up and down as wave counter mode
            UPDOWN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x504);

        /// address: 0x40021508
        /// Value up to which the pulse generator counter counts
        pub const COUNTERTOP = @intToPtr(*volatile MmioInt(32, u15), base_address + 0x508);

        /// address: 0x4002150c
        /// Configuration for PWM_CLK
        pub const PRESCALER = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x50c);

        /// address: 0x40021510
        /// Configuration of the decoder
        pub const DECODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// How a sequence is read from RAM and spread to the compare register
            LOAD: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Selects source for advancing the active sequence
            MODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x510);

        /// address: 0x40021514
        /// Amount of playback of a loop
        pub const LOOP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Amount of playback of pattern cycles
            CNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x514);
    };
    /// Pulse Width Modulation Unit 2
    pub const PWM2 = struct {
        pub const base_address = 0x40022000;

        /// address: 0x40022004
        /// Stops PWM pulse generation on all channels at the end of current PWM period, and
        /// stops sequence playback
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40022008
        /// Description collection[0]: Loads the first PWM value on all enabled channels
        /// from sequence 0, and starts playing that sequence at the rate defined in
        /// SEQ[0]REFRESH and/or DECODER.MODE. Causes PWM generation to start it was not
        /// running.
        pub const TASKS_SEQSTART = @intToPtr(*volatile [2]u32, base_address + 0x8);

        /// address: 0x40022010
        /// Steps by one value in the current sequence on all enabled channels if
        /// DECODER.MODE=NextStep. Does not cause PWM generation to start it was not
        /// running.
        pub const TASKS_NEXTSTEP = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40022104
        /// Response to STOP task, emitted when PWM pulses are no longer generated
        pub const EVENTS_STOPPED = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40022108
        /// Description collection[0]: First PWM period started on sequence 0
        pub const EVENTS_SEQSTARTED = @intToPtr(*volatile [2]u32, base_address + 0x108);

        /// address: 0x40022110
        /// Description collection[0]: Emitted at end of every sequence 0, when last value
        /// from RAM has been applied to wave counter
        pub const EVENTS_SEQEND = @intToPtr(*volatile [2]u32, base_address + 0x110);

        /// address: 0x40022118
        /// Emitted at the end of each PWM period
        pub const EVENTS_PWMPERIODEND = @intToPtr(*volatile u32, base_address + 0x118);

        /// address: 0x4002211c
        /// Concatenated sequences have been played the amount of times defined in LOOP.CNT
        pub const EVENTS_LOOPSDONE = @intToPtr(*volatile u32, base_address + 0x11c);

        /// address: 0x40022200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Shortcut between SEQEND[0] event and STOP task
            SEQEND0_STOP: u1,
            /// Shortcut between SEQEND[1] event and STOP task
            SEQEND1_STOP: u1,
            /// Shortcut between LOOPSDONE event and SEQSTART[0] task
            LOOPSDONE_SEQSTART0: u1,
            /// Shortcut between LOOPSDONE event and SEQSTART[1] task
            LOOPSDONE_SEQSTART1: u1,
            /// Shortcut between LOOPSDONE event and STOP task
            LOOPSDONE_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x200);

        /// address: 0x40022300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Enable or disable interrupt for STOPPED event
            STOPPED: u1,
            /// Enable or disable interrupt for SEQSTARTED[0] event
            SEQSTARTED0: u1,
            /// Enable or disable interrupt for SEQSTARTED[1] event
            SEQSTARTED1: u1,
            /// Enable or disable interrupt for SEQEND[0] event
            SEQEND0: u1,
            /// Enable or disable interrupt for SEQEND[1] event
            SEQEND1: u1,
            /// Enable or disable interrupt for PWMPERIODEND event
            PWMPERIODEND: u1,
            /// Enable or disable interrupt for LOOPSDONE event
            LOOPSDONE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x300);

        /// address: 0x40022304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Enable interrupt for STOPPED event
            STOPPED: u1,
            /// Write '1' to Enable interrupt for SEQSTARTED[0] event
            SEQSTARTED0: u1,
            /// Write '1' to Enable interrupt for SEQSTARTED[1] event
            SEQSTARTED1: u1,
            /// Write '1' to Enable interrupt for SEQEND[0] event
            SEQEND0: u1,
            /// Write '1' to Enable interrupt for SEQEND[1] event
            SEQEND1: u1,
            /// Write '1' to Enable interrupt for PWMPERIODEND event
            PWMPERIODEND: u1,
            /// Write '1' to Enable interrupt for LOOPSDONE event
            LOOPSDONE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x304);

        /// address: 0x40022308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Disable interrupt for STOPPED event
            STOPPED: u1,
            /// Write '1' to Disable interrupt for SEQSTARTED[0] event
            SEQSTARTED0: u1,
            /// Write '1' to Disable interrupt for SEQSTARTED[1] event
            SEQSTARTED1: u1,
            /// Write '1' to Disable interrupt for SEQEND[0] event
            SEQEND0: u1,
            /// Write '1' to Disable interrupt for SEQEND[1] event
            SEQEND1: u1,
            /// Write '1' to Disable interrupt for PWMPERIODEND event
            PWMPERIODEND: u1,
            /// Write '1' to Disable interrupt for LOOPSDONE event
            LOOPSDONE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x308);

        /// address: 0x40022500
        /// PWM module enable register
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x500);

        /// address: 0x40022504
        /// Selects operating mode of the wave counter
        pub const MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Selects up or up and down as wave counter mode
            UPDOWN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x504);

        /// address: 0x40022508
        /// Value up to which the pulse generator counter counts
        pub const COUNTERTOP = @intToPtr(*volatile MmioInt(32, u15), base_address + 0x508);

        /// address: 0x4002250c
        /// Configuration for PWM_CLK
        pub const PRESCALER = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x50c);

        /// address: 0x40022510
        /// Configuration of the decoder
        pub const DECODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// How a sequence is read from RAM and spread to the compare register
            LOAD: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Selects source for advancing the active sequence
            MODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x510);

        /// address: 0x40022514
        /// Amount of playback of a loop
        pub const LOOP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Amount of playback of pattern cycles
            CNT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x514);
    };
    /// Serial Peripheral Interface Master with EasyDMA 2
    pub const SPIM2 = struct {
        pub const base_address = 0x40023000;

        /// address: 0x40023010
        /// Start SPI transaction
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40023014
        /// Stop SPI transaction
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x4002301c
        /// Suspend SPI transaction
        pub const TASKS_SUSPEND = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x40023020
        /// Resume SPI transaction
        pub const TASKS_RESUME = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x40023104
        /// SPI transaction has stopped
        pub const EVENTS_STOPPED = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40023110
        /// End of RXD buffer reached
        pub const EVENTS_ENDRX = @intToPtr(*volatile u32, base_address + 0x110);

        /// address: 0x40023118
        /// End of RXD buffer and TXD buffer reached
        pub const EVENTS_END = @intToPtr(*volatile u32, base_address + 0x118);

        /// address: 0x40023120
        /// End of TXD buffer reached
        pub const EVENTS_ENDTX = @intToPtr(*volatile u32, base_address + 0x120);

        /// address: 0x4002314c
        /// Transaction started
        pub const EVENTS_STARTED = @intToPtr(*volatile u32, base_address + 0x14c);

        /// address: 0x40023200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Shortcut between END event and START task
            END_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x200);

        /// address: 0x40023304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Enable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            /// Write '1' to Enable interrupt for ENDRX event
            ENDRX: u1,
            reserved3: u1,
            /// Write '1' to Enable interrupt for END event
            END: u1,
            reserved4: u1,
            /// Write '1' to Enable interrupt for ENDTX event
            ENDTX: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// Write '1' to Enable interrupt for STARTED event
            STARTED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x304);

        /// address: 0x40023308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Disable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            /// Write '1' to Disable interrupt for ENDRX event
            ENDRX: u1,
            reserved3: u1,
            /// Write '1' to Disable interrupt for END event
            END: u1,
            reserved4: u1,
            /// Write '1' to Disable interrupt for ENDTX event
            ENDTX: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// Write '1' to Disable interrupt for STARTED event
            STARTED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x308);

        /// address: 0x40023500
        /// Enable SPIM
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x500);

        /// address: 0x40023524
        /// SPI frequency. Accuracy depends on the HFCLK source selected.
        pub const FREQUENCY = @intToPtr(*volatile u32, base_address + 0x524);

        /// address: 0x40023554
        /// Configuration register
        pub const CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bit order
            ORDER: u1,
            /// Serial clock (SCK) phase
            CPHA: u1,
            /// Serial clock (SCK) polarity
            CPOL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x554);

        /// address: 0x400235c0
        /// Over-read character. Character clocked out in case and over-read of the TXD
        /// buffer.
        pub const ORC = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x5c0);
    };
    /// SPI Slave 2
    pub const SPIS2 = struct {
        pub const base_address = 0x40023000;

        /// address: 0x40023024
        /// Acquire SPI semaphore
        pub const TASKS_ACQUIRE = @intToPtr(*volatile u32, base_address + 0x24);

        /// address: 0x40023028
        /// Release SPI semaphore, enabling the SPI slave to acquire it
        pub const TASKS_RELEASE = @intToPtr(*volatile u32, base_address + 0x28);

        /// address: 0x40023104
        /// Granted transaction completed
        pub const EVENTS_END = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40023110
        /// End of RXD buffer reached
        pub const EVENTS_ENDRX = @intToPtr(*volatile u32, base_address + 0x110);

        /// address: 0x40023128
        /// Semaphore acquired
        pub const EVENTS_ACQUIRED = @intToPtr(*volatile u32, base_address + 0x128);

        /// address: 0x40023200
        /// Shortcut register
        pub const SHORTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Shortcut between END event and ACQUIRE task
            END_ACQUIRE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x200);

        /// address: 0x40023304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Enable interrupt for END event
            END: u1,
            reserved1: u1,
            reserved2: u1,
            /// Write '1' to Enable interrupt for ENDRX event
            ENDRX: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Write '1' to Enable interrupt for ACQUIRED event
            ACQUIRED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x304);

        /// address: 0x40023308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Disable interrupt for END event
            END: u1,
            reserved1: u1,
            reserved2: u1,
            /// Write '1' to Disable interrupt for ENDRX event
            ENDRX: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Write '1' to Disable interrupt for ACQUIRED event
            ACQUIRED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x308);

        /// address: 0x40023400
        /// Semaphore status register
        pub const SEMSTAT = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x400);

        /// address: 0x40023440
        /// Status from last transaction
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX buffer over-read detected, and prevented
            OVERREAD: u1,
            /// RX buffer overflow detected, and prevented
            OVERFLOW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x440);

        /// address: 0x40023500
        /// Enable SPI slave
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x500);

        /// address: 0x40023554
        /// Configuration register
        pub const CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bit order
            ORDER: u1,
            /// Serial clock (SCK) phase
            CPHA: u1,
            /// Serial clock (SCK) polarity
            CPOL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x554);

        /// address: 0x4002355c
        /// Default character. Character clocked out in case of an ignored transaction.
        pub const DEF = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x55c);

        /// address: 0x400235c0
        /// Over-read character
        pub const ORC = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x5c0);
    };
    /// Serial Peripheral Interface 2
    pub const SPI2 = struct {
        pub const base_address = 0x40023000;

        /// address: 0x40023108
        /// TXD byte sent and RXD byte received
        pub const EVENTS_READY = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x40023304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Write '1' to Enable interrupt for READY event
            READY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x304);

        /// address: 0x40023308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Write '1' to Disable interrupt for READY event
            READY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x308);

        /// address: 0x40023500
        /// Enable SPI
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x500);

        /// address: 0x40023518
        /// RXD register
        pub const RXD = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x518);

        /// address: 0x4002351c
        /// TXD register
        pub const TXD = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x51c);

        /// address: 0x40023524
        /// SPI frequency
        pub const FREQUENCY = @intToPtr(*volatile u32, base_address + 0x524);

        /// address: 0x40023554
        /// Configuration register
        pub const CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bit order
            ORDER: u1,
            /// Serial clock (SCK) phase
            CPHA: u1,
            /// Serial clock (SCK) polarity
            CPOL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x554);
    };
    /// Real time counter 2
    pub const RTC2 = struct {
        pub const base_address = 0x40024000;

        /// address: 0x40024000
        /// Start RTC COUNTER
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40024004
        /// Stop RTC COUNTER
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40024008
        /// Clear RTC COUNTER
        pub const TASKS_CLEAR = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4002400c
        /// Set COUNTER to 0xFFFFF0
        pub const TASKS_TRIGOVRFLW = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x40024100
        /// Event on COUNTER increment
        pub const EVENTS_TICK = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x40024104
        /// Event on COUNTER overflow
        pub const EVENTS_OVRFLW = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40024140
        /// Description collection[0]: Compare event on CC[0] match
        pub const EVENTS_COMPARE = @intToPtr(*volatile [4]u32, base_address + 0x140);

        /// address: 0x40024304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable interrupt for TICK event
            TICK: u1,
            /// Write '1' to Enable interrupt for OVRFLW event
            OVRFLW: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Write '1' to Enable interrupt for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Enable interrupt for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Enable interrupt for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Enable interrupt for COMPARE[3] event
            COMPARE3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x304);

        /// address: 0x40024308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable interrupt for TICK event
            TICK: u1,
            /// Write '1' to Disable interrupt for OVRFLW event
            OVRFLW: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Write '1' to Disable interrupt for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Disable interrupt for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Disable interrupt for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Disable interrupt for COMPARE[3] event
            COMPARE3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x308);

        /// address: 0x40024340
        /// Enable or disable event routing
        pub const EVTEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable or disable event routing for TICK event
            TICK: u1,
            /// Enable or disable event routing for OVRFLW event
            OVRFLW: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Enable or disable event routing for COMPARE[0] event
            COMPARE0: u1,
            /// Enable or disable event routing for COMPARE[1] event
            COMPARE1: u1,
            /// Enable or disable event routing for COMPARE[2] event
            COMPARE2: u1,
            /// Enable or disable event routing for COMPARE[3] event
            COMPARE3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x340);

        /// address: 0x40024344
        /// Enable event routing
        pub const EVTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Enable event routing for TICK event
            TICK: u1,
            /// Write '1' to Enable event routing for OVRFLW event
            OVRFLW: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Write '1' to Enable event routing for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Enable event routing for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Enable event routing for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Enable event routing for COMPARE[3] event
            COMPARE3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x344);

        /// address: 0x40024348
        /// Disable event routing
        pub const EVTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write '1' to Disable event routing for TICK event
            TICK: u1,
            /// Write '1' to Disable event routing for OVRFLW event
            OVRFLW: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Write '1' to Disable event routing for COMPARE[0] event
            COMPARE0: u1,
            /// Write '1' to Disable event routing for COMPARE[1] event
            COMPARE1: u1,
            /// Write '1' to Disable event routing for COMPARE[2] event
            COMPARE2: u1,
            /// Write '1' to Disable event routing for COMPARE[3] event
            COMPARE3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x348);

        /// address: 0x40024504
        /// Current COUNTER value
        pub const COUNTER = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x504);

        /// address: 0x40024508
        /// 12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must be written
        /// when RTC is stopped
        pub const PRESCALER = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x508);

        /// address: 0x40024540
        /// Description collection[0]: Compare register 0
        pub const CC = @intToPtr(*volatile [4]Mmio(32, packed struct {
            /// Compare value
            COMPARE: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x540);
    };
    /// Inter-IC Sound
    pub const I2S = struct {
        pub const base_address = 0x40025000;

        /// address: 0x40025000
        /// Starts continuous I2S transfer. Also starts MCK generator when this is enabled.
        pub const TASKS_START = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40025004
        /// Stops I2S transfer. Also stops MCK generator. Triggering this task will cause
        /// the {event:STOPPED} event to be generated.
        pub const TASKS_STOP = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40025104
        /// The RXD.PTR register has been copied to internal double-buffers. When the I2S
        /// module is started and RX is enabled, this event will be generated for every
        /// RXTXD.MAXCNT words that are received on the SDIN pin.
        pub const EVENTS_RXPTRUPD = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x40025108
        /// I2S transfer stopped.
        pub const EVENTS_STOPPED = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x40025114
        /// The TDX.PTR register has been copied to internal double-buffers. When the I2S
        /// module is started and TX is enabled, this event will be generated for every
        /// RXTXD.MAXCNT words that are sent on the SDOUT pin.
        pub const EVENTS_TXPTRUPD = @intToPtr(*volatile u32, base_address + 0x114);

        /// address: 0x40025300
        /// Enable or disable interrupt
        pub const INTEN = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Enable or disable interrupt for RXPTRUPD event
            RXPTRUPD: u1,
            /// Enable or disable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            /// Enable or disable interrupt for TXPTRUPD event
            TXPTRUPD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x300);

        /// address: 0x40025304
        /// Enable interrupt
        pub const INTENSET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Enable interrupt for RXPTRUPD event
            RXPTRUPD: u1,
            /// Write '1' to Enable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            /// Write '1' to Enable interrupt for TXPTRUPD event
            TXPTRUPD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x304);

        /// address: 0x40025308
        /// Disable interrupt
        pub const INTENCLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Write '1' to Disable interrupt for RXPTRUPD event
            RXPTRUPD: u1,
            /// Write '1' to Disable interrupt for STOPPED event
            STOPPED: u1,
            reserved1: u1,
            reserved2: u1,
            /// Write '1' to Disable interrupt for TXPTRUPD event
            TXPTRUPD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x308);

        /// address: 0x40025500
        /// Enable I2S module.
        pub const ENABLE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x500);

        pub const CONFIG = struct {

            /// address: 0x40025000
            /// I2S mode.
            pub const MODE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x0);

            /// address: 0x40025004
            /// Reception (RX) enable.
            pub const RXEN = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x4);

            /// address: 0x40025008
            /// Transmission (TX) enable.
            pub const TXEN = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x8);

            /// address: 0x4002500c
            /// Master clock generator enable.
            pub const MCKEN = @intToPtr(*volatile MmioInt(32, u1), base_address + 0xc);

            /// address: 0x40025010
            /// Master clock generator frequency.
            pub const MCKFREQ = @intToPtr(*volatile u32, base_address + 0x10);

            /// address: 0x40025014
            /// MCK / LRCK ratio.
            pub const RATIO = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x14);

            /// address: 0x40025018
            /// Sample width.
            pub const SWIDTH = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x18);

            /// address: 0x4002501c
            /// Alignment of sample within a frame.
            pub const ALIGN = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x1c);

            /// address: 0x40025020
            /// Frame format.
            pub const FORMAT = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x20);

            /// address: 0x40025024
            /// Enable channels.
            pub const CHANNELS = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x24);
        };

        pub const RXD = struct {

            /// address: 0x40025000
            /// Receive buffer RAM start address.
            pub const PTR = @intToPtr(*volatile u32, base_address + 0x0);
        };

        pub const TXD = struct {

            /// address: 0x40025000
            /// Transmit buffer RAM start address.
            pub const PTR = @intToPtr(*volatile u32, base_address + 0x0);
        };

        pub const RXTXD = struct {

            /// address: 0x40025000
            /// Size of RXD and TXD buffers.
            pub const MAXCNT = @intToPtr(*volatile MmioInt(32, u14), base_address + 0x0);
        };

        pub const PSEL = struct {

            /// address: 0x40025000
            /// Pin select for MCK signal.
            pub const MCK = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x0);

            /// address: 0x40025004
            /// Pin select for SCK signal.
            pub const SCK = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x4);

            /// address: 0x40025008
            /// Pin select for LRCK signal.
            pub const LRCK = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x8);

            /// address: 0x4002500c
            /// Pin select for SDIN signal.
            pub const SDIN = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0xc);

            /// address: 0x40025010
            /// Pin select for SDOUT signal.
            pub const SDOUT = @intToPtr(*volatile Mmio(32, packed struct {
                /// Pin number
                PIN: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                reserved24: u1,
                reserved25: u1,
                /// Connection
                CONNECT: u1,
            }), base_address + 0x10);
        };
    };
    /// FPU
    pub const FPU = struct {
        pub const base_address = 0x40026000;

        /// address: 0x40026000
        /// Unused.
        pub const UNUSED = @intToPtr(*volatile u32, base_address + 0x0);
    };
    /// GPIO Port 1
    pub const P0 = struct {
        pub const base_address = 0x50000000;

        /// address: 0x50000504
        /// Write GPIO port
        pub const OUT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pin 0
            PIN0: u1,
            /// Pin 1
            PIN1: u1,
            /// Pin 2
            PIN2: u1,
            /// Pin 3
            PIN3: u1,
            /// Pin 4
            PIN4: u1,
            /// Pin 5
            PIN5: u1,
            /// Pin 6
            PIN6: u1,
            /// Pin 7
            PIN7: u1,
            /// Pin 8
            PIN8: u1,
            /// Pin 9
            PIN9: u1,
            /// Pin 10
            PIN10: u1,
            /// Pin 11
            PIN11: u1,
            /// Pin 12
            PIN12: u1,
            /// Pin 13
            PIN13: u1,
            /// Pin 14
            PIN14: u1,
            /// Pin 15
            PIN15: u1,
            /// Pin 16
            PIN16: u1,
            /// Pin 17
            PIN17: u1,
            /// Pin 18
            PIN18: u1,
            /// Pin 19
            PIN19: u1,
            /// Pin 20
            PIN20: u1,
            /// Pin 21
            PIN21: u1,
            /// Pin 22
            PIN22: u1,
            /// Pin 23
            PIN23: u1,
            /// Pin 24
            PIN24: u1,
            /// Pin 25
            PIN25: u1,
            /// Pin 26
            PIN26: u1,
            /// Pin 27
            PIN27: u1,
            /// Pin 28
            PIN28: u1,
            /// Pin 29
            PIN29: u1,
            /// Pin 30
            PIN30: u1,
            /// Pin 31
            PIN31: u1,
        }), base_address + 0x504);

        /// address: 0x50000508
        /// Set individual bits in GPIO port
        pub const OUTSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pin 0
            PIN0: u1,
            /// Pin 1
            PIN1: u1,
            /// Pin 2
            PIN2: u1,
            /// Pin 3
            PIN3: u1,
            /// Pin 4
            PIN4: u1,
            /// Pin 5
            PIN5: u1,
            /// Pin 6
            PIN6: u1,
            /// Pin 7
            PIN7: u1,
            /// Pin 8
            PIN8: u1,
            /// Pin 9
            PIN9: u1,
            /// Pin 10
            PIN10: u1,
            /// Pin 11
            PIN11: u1,
            /// Pin 12
            PIN12: u1,
            /// Pin 13
            PIN13: u1,
            /// Pin 14
            PIN14: u1,
            /// Pin 15
            PIN15: u1,
            /// Pin 16
            PIN16: u1,
            /// Pin 17
            PIN17: u1,
            /// Pin 18
            PIN18: u1,
            /// Pin 19
            PIN19: u1,
            /// Pin 20
            PIN20: u1,
            /// Pin 21
            PIN21: u1,
            /// Pin 22
            PIN22: u1,
            /// Pin 23
            PIN23: u1,
            /// Pin 24
            PIN24: u1,
            /// Pin 25
            PIN25: u1,
            /// Pin 26
            PIN26: u1,
            /// Pin 27
            PIN27: u1,
            /// Pin 28
            PIN28: u1,
            /// Pin 29
            PIN29: u1,
            /// Pin 30
            PIN30: u1,
            /// Pin 31
            PIN31: u1,
        }), base_address + 0x508);

        /// address: 0x5000050c
        /// Clear individual bits in GPIO port
        pub const OUTCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pin 0
            PIN0: u1,
            /// Pin 1
            PIN1: u1,
            /// Pin 2
            PIN2: u1,
            /// Pin 3
            PIN3: u1,
            /// Pin 4
            PIN4: u1,
            /// Pin 5
            PIN5: u1,
            /// Pin 6
            PIN6: u1,
            /// Pin 7
            PIN7: u1,
            /// Pin 8
            PIN8: u1,
            /// Pin 9
            PIN9: u1,
            /// Pin 10
            PIN10: u1,
            /// Pin 11
            PIN11: u1,
            /// Pin 12
            PIN12: u1,
            /// Pin 13
            PIN13: u1,
            /// Pin 14
            PIN14: u1,
            /// Pin 15
            PIN15: u1,
            /// Pin 16
            PIN16: u1,
            /// Pin 17
            PIN17: u1,
            /// Pin 18
            PIN18: u1,
            /// Pin 19
            PIN19: u1,
            /// Pin 20
            PIN20: u1,
            /// Pin 21
            PIN21: u1,
            /// Pin 22
            PIN22: u1,
            /// Pin 23
            PIN23: u1,
            /// Pin 24
            PIN24: u1,
            /// Pin 25
            PIN25: u1,
            /// Pin 26
            PIN26: u1,
            /// Pin 27
            PIN27: u1,
            /// Pin 28
            PIN28: u1,
            /// Pin 29
            PIN29: u1,
            /// Pin 30
            PIN30: u1,
            /// Pin 31
            PIN31: u1,
        }), base_address + 0x50c);

        /// address: 0x50000510
        /// Read GPIO port
        pub const IN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pin 0
            PIN0: u1,
            /// Pin 1
            PIN1: u1,
            /// Pin 2
            PIN2: u1,
            /// Pin 3
            PIN3: u1,
            /// Pin 4
            PIN4: u1,
            /// Pin 5
            PIN5: u1,
            /// Pin 6
            PIN6: u1,
            /// Pin 7
            PIN7: u1,
            /// Pin 8
            PIN8: u1,
            /// Pin 9
            PIN9: u1,
            /// Pin 10
            PIN10: u1,
            /// Pin 11
            PIN11: u1,
            /// Pin 12
            PIN12: u1,
            /// Pin 13
            PIN13: u1,
            /// Pin 14
            PIN14: u1,
            /// Pin 15
            PIN15: u1,
            /// Pin 16
            PIN16: u1,
            /// Pin 17
            PIN17: u1,
            /// Pin 18
            PIN18: u1,
            /// Pin 19
            PIN19: u1,
            /// Pin 20
            PIN20: u1,
            /// Pin 21
            PIN21: u1,
            /// Pin 22
            PIN22: u1,
            /// Pin 23
            PIN23: u1,
            /// Pin 24
            PIN24: u1,
            /// Pin 25
            PIN25: u1,
            /// Pin 26
            PIN26: u1,
            /// Pin 27
            PIN27: u1,
            /// Pin 28
            PIN28: u1,
            /// Pin 29
            PIN29: u1,
            /// Pin 30
            PIN30: u1,
            /// Pin 31
            PIN31: u1,
        }), base_address + 0x510);

        /// address: 0x50000514
        /// Direction of GPIO pins
        pub const DIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pin 0
            PIN0: u1,
            /// Pin 1
            PIN1: u1,
            /// Pin 2
            PIN2: u1,
            /// Pin 3
            PIN3: u1,
            /// Pin 4
            PIN4: u1,
            /// Pin 5
            PIN5: u1,
            /// Pin 6
            PIN6: u1,
            /// Pin 7
            PIN7: u1,
            /// Pin 8
            PIN8: u1,
            /// Pin 9
            PIN9: u1,
            /// Pin 10
            PIN10: u1,
            /// Pin 11
            PIN11: u1,
            /// Pin 12
            PIN12: u1,
            /// Pin 13
            PIN13: u1,
            /// Pin 14
            PIN14: u1,
            /// Pin 15
            PIN15: u1,
            /// Pin 16
            PIN16: u1,
            /// Pin 17
            PIN17: u1,
            /// Pin 18
            PIN18: u1,
            /// Pin 19
            PIN19: u1,
            /// Pin 20
            PIN20: u1,
            /// Pin 21
            PIN21: u1,
            /// Pin 22
            PIN22: u1,
            /// Pin 23
            PIN23: u1,
            /// Pin 24
            PIN24: u1,
            /// Pin 25
            PIN25: u1,
            /// Pin 26
            PIN26: u1,
            /// Pin 27
            PIN27: u1,
            /// Pin 28
            PIN28: u1,
            /// Pin 29
            PIN29: u1,
            /// Pin 30
            PIN30: u1,
            /// Pin 31
            PIN31: u1,
        }), base_address + 0x514);

        /// address: 0x50000518
        /// DIR set register
        pub const DIRSET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set as output pin 0
            PIN0: u1,
            /// Set as output pin 1
            PIN1: u1,
            /// Set as output pin 2
            PIN2: u1,
            /// Set as output pin 3
            PIN3: u1,
            /// Set as output pin 4
            PIN4: u1,
            /// Set as output pin 5
            PIN5: u1,
            /// Set as output pin 6
            PIN6: u1,
            /// Set as output pin 7
            PIN7: u1,
            /// Set as output pin 8
            PIN8: u1,
            /// Set as output pin 9
            PIN9: u1,
            /// Set as output pin 10
            PIN10: u1,
            /// Set as output pin 11
            PIN11: u1,
            /// Set as output pin 12
            PIN12: u1,
            /// Set as output pin 13
            PIN13: u1,
            /// Set as output pin 14
            PIN14: u1,
            /// Set as output pin 15
            PIN15: u1,
            /// Set as output pin 16
            PIN16: u1,
            /// Set as output pin 17
            PIN17: u1,
            /// Set as output pin 18
            PIN18: u1,
            /// Set as output pin 19
            PIN19: u1,
            /// Set as output pin 20
            PIN20: u1,
            /// Set as output pin 21
            PIN21: u1,
            /// Set as output pin 22
            PIN22: u1,
            /// Set as output pin 23
            PIN23: u1,
            /// Set as output pin 24
            PIN24: u1,
            /// Set as output pin 25
            PIN25: u1,
            /// Set as output pin 26
            PIN26: u1,
            /// Set as output pin 27
            PIN27: u1,
            /// Set as output pin 28
            PIN28: u1,
            /// Set as output pin 29
            PIN29: u1,
            /// Set as output pin 30
            PIN30: u1,
            /// Set as output pin 31
            PIN31: u1,
        }), base_address + 0x518);

        /// address: 0x5000051c
        /// DIR clear register
        pub const DIRCLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set as input pin 0
            PIN0: u1,
            /// Set as input pin 1
            PIN1: u1,
            /// Set as input pin 2
            PIN2: u1,
            /// Set as input pin 3
            PIN3: u1,
            /// Set as input pin 4
            PIN4: u1,
            /// Set as input pin 5
            PIN5: u1,
            /// Set as input pin 6
            PIN6: u1,
            /// Set as input pin 7
            PIN7: u1,
            /// Set as input pin 8
            PIN8: u1,
            /// Set as input pin 9
            PIN9: u1,
            /// Set as input pin 10
            PIN10: u1,
            /// Set as input pin 11
            PIN11: u1,
            /// Set as input pin 12
            PIN12: u1,
            /// Set as input pin 13
            PIN13: u1,
            /// Set as input pin 14
            PIN14: u1,
            /// Set as input pin 15
            PIN15: u1,
            /// Set as input pin 16
            PIN16: u1,
            /// Set as input pin 17
            PIN17: u1,
            /// Set as input pin 18
            PIN18: u1,
            /// Set as input pin 19
            PIN19: u1,
            /// Set as input pin 20
            PIN20: u1,
            /// Set as input pin 21
            PIN21: u1,
            /// Set as input pin 22
            PIN22: u1,
            /// Set as input pin 23
            PIN23: u1,
            /// Set as input pin 24
            PIN24: u1,
            /// Set as input pin 25
            PIN25: u1,
            /// Set as input pin 26
            PIN26: u1,
            /// Set as input pin 27
            PIN27: u1,
            /// Set as input pin 28
            PIN28: u1,
            /// Set as input pin 29
            PIN29: u1,
            /// Set as input pin 30
            PIN30: u1,
            /// Set as input pin 31
            PIN31: u1,
        }), base_address + 0x51c);

        /// address: 0x50000520
        /// Latch register indicating what GPIO pins that have met the criteria set in the
        /// PIN_CNF[n].SENSE registers
        pub const LATCH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Status on whether PIN0 has met criteria set in PIN_CNF0.SENSE register. Write
            /// '1' to clear.
            PIN0: u1,
            /// Status on whether PIN1 has met criteria set in PIN_CNF1.SENSE register. Write
            /// '1' to clear.
            PIN1: u1,
            /// Status on whether PIN2 has met criteria set in PIN_CNF2.SENSE register. Write
            /// '1' to clear.
            PIN2: u1,
            /// Status on whether PIN3 has met criteria set in PIN_CNF3.SENSE register. Write
            /// '1' to clear.
            PIN3: u1,
            /// Status on whether PIN4 has met criteria set in PIN_CNF4.SENSE register. Write
            /// '1' to clear.
            PIN4: u1,
            /// Status on whether PIN5 has met criteria set in PIN_CNF5.SENSE register. Write
            /// '1' to clear.
            PIN5: u1,
            /// Status on whether PIN6 has met criteria set in PIN_CNF6.SENSE register. Write
            /// '1' to clear.
            PIN6: u1,
            /// Status on whether PIN7 has met criteria set in PIN_CNF7.SENSE register. Write
            /// '1' to clear.
            PIN7: u1,
            /// Status on whether PIN8 has met criteria set in PIN_CNF8.SENSE register. Write
            /// '1' to clear.
            PIN8: u1,
            /// Status on whether PIN9 has met criteria set in PIN_CNF9.SENSE register. Write
            /// '1' to clear.
            PIN9: u1,
            /// Status on whether PIN10 has met criteria set in PIN_CNF10.SENSE register. Write
            /// '1' to clear.
            PIN10: u1,
            /// Status on whether PIN11 has met criteria set in PIN_CNF11.SENSE register. Write
            /// '1' to clear.
            PIN11: u1,
            /// Status on whether PIN12 has met criteria set in PIN_CNF12.SENSE register. Write
            /// '1' to clear.
            PIN12: u1,
            /// Status on whether PIN13 has met criteria set in PIN_CNF13.SENSE register. Write
            /// '1' to clear.
            PIN13: u1,
            /// Status on whether PIN14 has met criteria set in PIN_CNF14.SENSE register. Write
            /// '1' to clear.
            PIN14: u1,
            /// Status on whether PIN15 has met criteria set in PIN_CNF15.SENSE register. Write
            /// '1' to clear.
            PIN15: u1,
            /// Status on whether PIN16 has met criteria set in PIN_CNF16.SENSE register. Write
            /// '1' to clear.
            PIN16: u1,
            /// Status on whether PIN17 has met criteria set in PIN_CNF17.SENSE register. Write
            /// '1' to clear.
            PIN17: u1,
            /// Status on whether PIN18 has met criteria set in PIN_CNF18.SENSE register. Write
            /// '1' to clear.
            PIN18: u1,
            /// Status on whether PIN19 has met criteria set in PIN_CNF19.SENSE register. Write
            /// '1' to clear.
            PIN19: u1,
            /// Status on whether PIN20 has met criteria set in PIN_CNF20.SENSE register. Write
            /// '1' to clear.
            PIN20: u1,
            /// Status on whether PIN21 has met criteria set in PIN_CNF21.SENSE register. Write
            /// '1' to clear.
            PIN21: u1,
            /// Status on whether PIN22 has met criteria set in PIN_CNF22.SENSE register. Write
            /// '1' to clear.
            PIN22: u1,
            /// Status on whether PIN23 has met criteria set in PIN_CNF23.SENSE register. Write
            /// '1' to clear.
            PIN23: u1,
            /// Status on whether PIN24 has met criteria set in PIN_CNF24.SENSE register. Write
            /// '1' to clear.
            PIN24: u1,
            /// Status on whether PIN25 has met criteria set in PIN_CNF25.SENSE register. Write
            /// '1' to clear.
            PIN25: u1,
            /// Status on whether PIN26 has met criteria set in PIN_CNF26.SENSE register. Write
            /// '1' to clear.
            PIN26: u1,
            /// Status on whether PIN27 has met criteria set in PIN_CNF27.SENSE register. Write
            /// '1' to clear.
            PIN27: u1,
            /// Status on whether PIN28 has met criteria set in PIN_CNF28.SENSE register. Write
            /// '1' to clear.
            PIN28: u1,
            /// Status on whether PIN29 has met criteria set in PIN_CNF29.SENSE register. Write
            /// '1' to clear.
            PIN29: u1,
            /// Status on whether PIN30 has met criteria set in PIN_CNF30.SENSE register. Write
            /// '1' to clear.
            PIN30: u1,
            /// Status on whether PIN31 has met criteria set in PIN_CNF31.SENSE register. Write
            /// '1' to clear.
            PIN31: u1,
        }), base_address + 0x520);

        /// address: 0x50000524
        /// Select between default DETECT signal behaviour and LDETECT mode
        pub const DETECTMODE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x524);

        /// address: 0x50000700
        /// Description collection[0]: Configuration of GPIO pins
        pub const PIN_CNF = @intToPtr(*volatile [32]Mmio(32, packed struct {
            /// Pin direction. Same physical register as DIR register
            DIR: u1,
            /// Connect or disconnect input buffer
            INPUT: u1,
            /// Pull configuration
            PULL: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Drive configuration
            DRIVE: u3,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Pin sensing mechanism
            SENSE: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x700);
    };
};

const std = @import("std");

pub fn mmio(addr: usize, comptime size: u8, comptime PackedT: type) *volatile Mmio(size, PackedT) {
    return @intToPtr(*volatile Mmio(size, PackedT), addr);
}

pub fn Mmio(comptime size: u8, comptime PackedT: type) type {
    if ((size % 8) != 0)
        @compileError("size must be divisible by 8!");

    if (!std.math.isPowerOfTwo(size / 8))
        @compileError("size must encode a power of two number of bytes!");

    const IntT = std.meta.Int(.unsigned, size);

    if (@sizeOf(PackedT) != (size / 8))
        @compileError(std.fmt.comptimePrint("IntT and PackedT must have the same size!, they are {} and {} bytes respectively", .{ size / 8, @sizeOf(PackedT) }));

    return extern struct {
        const Self = @This();

        raw: IntT,

        pub const underlying_type = PackedT;

        pub fn read(addr: *volatile Self) PackedT {
            return @bitCast(PackedT, addr.raw);
        }

        pub fn write(addr: *volatile Self, val: PackedT) void {
            // This is a workaround for a compiler bug related to miscompilation
            // If the tmp var is not used, result location will fuck things up
            var tmp = @bitCast(IntT, val);
            addr.raw = tmp;
        }

        pub fn modify(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, field.name) = @field(fields, field.name);
            }
            write(addr, val);
        }

        pub fn toggle(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, @tagName(field.default_value.?)) = !@field(val, @tagName(field.default_value.?));
            }
            write(addr, val);
        }
    };
}

pub fn MmioInt(comptime size: u8, comptime T: type) type {
    return extern struct {
        const Self = @This();

        raw: std.meta.Int(.unsigned, size),

        pub fn read(addr: *volatile Self) T {
            return @truncate(T, addr.raw);
        }

        pub fn modify(addr: *volatile Self, val: T) void {
            const Int = std.meta.Int(.unsigned, size);
            const mask = ~@as(Int, (1 << @bitSizeOf(T)) - 1);

            var tmp = addr.raw;
            addr.raw = (tmp & mask) | val;
        }
    };
}

pub fn mmioInt(addr: usize, comptime size: usize, comptime T: type) *volatile MmioInt(size, T) {
    return @intToPtr(*volatile MmioInt(size, T), addr);
}

const InterruptVector = extern union {
    C: fn () callconv(.C) void,
    Naked: fn () callconv(.Naked) void,
    // Interrupt is not supported on arm
};

const unhandled = InterruptVector{
    .C = struct {
        fn tmp() callconv(.C) noreturn {
            @panic("unhandled interrupt");
        }
    }.tmp,
};
