// this file is generated by regz
//
// device: STM32F303
// cpu: CM4

pub const VectorTable = extern struct {
    initial_stack_pointer: u32,
    Reset: InterruptVector = unhandled,
    NMI: InterruptVector = unhandled,
    HardFault: InterruptVector = unhandled,
    MemManage: InterruptVector = unhandled,
    BusFault: InterruptVector = unhandled,
    UsageFault: InterruptVector = unhandled,
    reserved0: [4]u32 = undefined,
    SVCall: InterruptVector = unhandled,
    reserved1: [2]u32 = undefined,
    PendSV: InterruptVector = unhandled,
    SysTick: InterruptVector = unhandled,
    /// Window Watchdog interrupt
    WWDG: InterruptVector = unhandled,
    /// PVD through EXTI line detection
    /// interrupt
    PVD: InterruptVector = unhandled,
    /// Tamper and TimeStamp interrupts
    TAMP_STAMP: InterruptVector = unhandled,
    /// RTC Wakeup interrupt through the EXTI
    /// line
    RTC_WKUP: InterruptVector = unhandled,
    /// Flash global interrupt
    FLASH: InterruptVector = unhandled,
    /// RCC global interrupt
    RCC: InterruptVector = unhandled,
    /// EXTI Line0 interrupt
    EXTI0: InterruptVector = unhandled,
    /// EXTI Line3 interrupt
    EXTI1: InterruptVector = unhandled,
    /// EXTI Line2 and Touch sensing
    /// interrupts
    EXTI2_TSC: InterruptVector = unhandled,
    /// EXTI Line3 interrupt
    EXTI3: InterruptVector = unhandled,
    /// EXTI Line4 interrupt
    EXTI4: InterruptVector = unhandled,
    /// DMA1 channel 1 interrupt
    DMA1_CH1: InterruptVector = unhandled,
    /// DMA1 channel 2 interrupt
    DMA1_CH2: InterruptVector = unhandled,
    /// DMA1 channel 3 interrupt
    DMA1_CH3: InterruptVector = unhandled,
    /// DMA1 channel 4 interrupt
    DMA1_CH4: InterruptVector = unhandled,
    /// DMA1 channel 5 interrupt
    DMA1_CH5: InterruptVector = unhandled,
    /// DMA1 channel 6 interrupt
    DMA1_CH6: InterruptVector = unhandled,
    /// DMA1 channel 7interrupt
    DMA1_CH7: InterruptVector = unhandled,
    /// ADC1 and ADC2 global interrupt
    ADC1_2: InterruptVector = unhandled,
    /// USB High Priority/CAN_TX
    /// interrupts
    USB_HP_CAN_TX: InterruptVector = unhandled,
    /// USB Low Priority/CAN_RX0
    /// interrupts
    USB_LP_CAN_RX0: InterruptVector = unhandled,
    /// CAN_RX1 interrupt
    CAN_RX1: InterruptVector = unhandled,
    /// CAN_SCE interrupt
    CAN_SCE: InterruptVector = unhandled,
    /// EXTI Line5 to Line9 interrupts
    EXTI9_5: InterruptVector = unhandled,
    /// TIM1 Break/TIM15 global
    /// interruts
    TIM1_BRK_TIM15: InterruptVector = unhandled,
    /// TIM1 Update/TIM16 global
    /// interrupts
    TIM1_UP_TIM16: InterruptVector = unhandled,
    /// TIM1 trigger and commutation/TIM17
    /// interrupts
    TIM1_TRG_COM_TIM17: InterruptVector = unhandled,
    /// TIM1 capture compare interrupt
    TIM1_CC: InterruptVector = unhandled,
    /// TIM2 global interrupt
    TIM2: InterruptVector = unhandled,
    /// TIM3 global interrupt
    TIM3: InterruptVector = unhandled,
    /// TIM4 global interrupt
    TIM4: InterruptVector = unhandled,
    /// I2C1 event interrupt and EXTI Line23
    /// interrupt
    I2C1_EV_EXTI23: InterruptVector = unhandled,
    /// I2C1 error interrupt
    I2C1_ER: InterruptVector = unhandled,
    /// I2C2 event interrupt & EXTI Line24
    /// interrupt
    I2C2_EV_EXTI24: InterruptVector = unhandled,
    /// I2C2 error interrupt
    I2C2_ER: InterruptVector = unhandled,
    /// SPI1 global interrupt
    SPI1: InterruptVector = unhandled,
    /// SPI2 global interrupt
    SPI2: InterruptVector = unhandled,
    /// USART1 global interrupt and EXTI Line 25
    /// interrupt
    USART1_EXTI25: InterruptVector = unhandled,
    /// USART2 global interrupt and EXTI Line 26
    /// interrupt
    USART2_EXTI26: InterruptVector = unhandled,
    /// USART3 global interrupt and EXTI Line 28
    /// interrupt
    USART3_EXTI28: InterruptVector = unhandled,
    /// EXTI Line15 to Line10 interrupts
    EXTI15_10: InterruptVector = unhandled,
    /// RTC alarm interrupt
    RTCAlarm: InterruptVector = unhandled,
    /// USB wakeup from Suspend
    USB_WKUP: InterruptVector = unhandled,
    /// TIM8 break interrupt
    TIM8_BRK: InterruptVector = unhandled,
    /// TIM8 update interrupt
    TIM8_UP: InterruptVector = unhandled,
    /// TIM8 Trigger and commutation
    /// interrupts
    TIM8_TRG_COM: InterruptVector = unhandled,
    /// TIM8 capture compare interrupt
    TIM8_CC: InterruptVector = unhandled,
    /// ADC3 global interrupt
    ADC3: InterruptVector = unhandled,
    /// FSMC global interrupt
    FMC: InterruptVector = unhandled,
    reserved2: u32 = undefined,
    reserved3: u32 = undefined,
    /// SPI3 global interrupt
    SPI3: InterruptVector = unhandled,
    /// UART4 global and EXTI Line 34
    /// interrupts
    UART4_EXTI34: InterruptVector = unhandled,
    /// UART5 global and EXTI Line 35
    /// interrupts
    UART5_EXTI35: InterruptVector = unhandled,
    /// TIM6 global and DAC12 underrun
    /// interrupts
    TIM6_DACUNDER: InterruptVector = unhandled,
    /// TIM7 global interrupt
    TIM7: InterruptVector = unhandled,
    /// DMA2 channel1 global interrupt
    DMA2_CH1: InterruptVector = unhandled,
    /// DMA2 channel2 global interrupt
    DMA2_CH2: InterruptVector = unhandled,
    /// DMA2 channel3 global interrupt
    DMA2_CH3: InterruptVector = unhandled,
    /// DMA2 channel4 global interrupt
    DMA2_CH4: InterruptVector = unhandled,
    /// DMA2 channel5 global interrupt
    DMA2_CH5: InterruptVector = unhandled,
    /// ADC4 global interrupt
    ADC4: InterruptVector = unhandled,
    reserved4: u32 = undefined,
    reserved5: u32 = undefined,
    /// COMP1 & COMP2 & COMP3 interrupts
    /// combined with EXTI Lines 21, 22 and 29
    /// interrupts
    COMP123: InterruptVector = unhandled,
    /// COMP4 & COMP5 & COMP6 interrupts
    /// combined with EXTI Lines 30, 31 and 32
    /// interrupts
    COMP456: InterruptVector = unhandled,
    /// COMP7 interrupt combined with EXTI Line 33
    /// interrupt
    COMP7: InterruptVector = unhandled,
    reserved6: u32 = undefined,
    reserved7: u32 = undefined,
    reserved8: u32 = undefined,
    reserved9: u32 = undefined,
    reserved10: u32 = undefined,
    /// I2C3 Event interrupt
    I2C3_EV: InterruptVector = unhandled,
    /// I2C3 Error interrupt
    I2C3_ER: InterruptVector = unhandled,
    /// USB High priority interrupt
    USB_HP: InterruptVector = unhandled,
    /// USB Low priority interrupt
    USB_LP: InterruptVector = unhandled,
    /// USB wakeup from Suspend and EXTI Line
    /// 18
    USB_WKUP_EXTI: InterruptVector = unhandled,
    /// TIM20 Break interrupt
    TIM20_BRK: InterruptVector = unhandled,
    /// TIM20 Upgrade interrupt
    TIM20_UP: InterruptVector = unhandled,
    /// TIM20 Trigger and Commutation
    /// interrupt
    TIM20_TRG_COM: InterruptVector = unhandled,
    /// TIM20 Capture Compare interrupt
    TIM20_CC: InterruptVector = unhandled,
    /// Floating point unit interrupt
    FPU: InterruptVector = unhandled,
    reserved11: u32 = undefined,
    reserved12: u32 = undefined,
    /// SPI4 Global interrupt
    SPI4: InterruptVector = unhandled,
};

pub const registers = struct {
    /// General-purpose I/Os
    pub const GPIOA = struct {
        pub const base_address = 0x48000000;

        /// address: 0x48000000
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x48000004
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x48000008
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4800000c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x48000010
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x48000014
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x48000018
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4800001c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Lok Key
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x48000020
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x48000024
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x48000028
        /// Port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x Reset bit y
            BR0: u1,
            /// Port x Reset bit y
            BR1: u1,
            /// Port x Reset bit y
            BR2: u1,
            /// Port x Reset bit y
            BR3: u1,
            /// Port x Reset bit y
            BR4: u1,
            /// Port x Reset bit y
            BR5: u1,
            /// Port x Reset bit y
            BR6: u1,
            /// Port x Reset bit y
            BR7: u1,
            /// Port x Reset bit y
            BR8: u1,
            /// Port x Reset bit y
            BR9: u1,
            /// Port x Reset bit y
            BR10: u1,
            /// Port x Reset bit y
            BR11: u1,
            /// Port x Reset bit y
            BR12: u1,
            /// Port x Reset bit y
            BR13: u1,
            /// Port x Reset bit y
            BR14: u1,
            /// Port x Reset bit y
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    /// General-purpose I/Os
    pub const GPIOB = struct {
        pub const base_address = 0x48000400;

        /// address: 0x48000400
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x48000404
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bit 0
            OT0: u1,
            /// Port x configuration bit 1
            OT1: u1,
            /// Port x configuration bit 2
            OT2: u1,
            /// Port x configuration bit 3
            OT3: u1,
            /// Port x configuration bit 4
            OT4: u1,
            /// Port x configuration bit 5
            OT5: u1,
            /// Port x configuration bit 6
            OT6: u1,
            /// Port x configuration bit 7
            OT7: u1,
            /// Port x configuration bit 8
            OT8: u1,
            /// Port x configuration bit 9
            OT9: u1,
            /// Port x configuration bit
            /// 10
            OT10: u1,
            /// Port x configuration bit
            /// 11
            OT11: u1,
            /// Port x configuration bit
            /// 12
            OT12: u1,
            /// Port x configuration bit
            /// 13
            OT13: u1,
            /// Port x configuration bit
            /// 14
            OT14: u1,
            /// Port x configuration bit
            /// 15
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x48000408
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4800040c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x48000410
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x48000414
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x48000418
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4800041c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Lok Key
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x48000420
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x48000424
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x48000428
        /// Port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x Reset bit y
            BR0: u1,
            /// Port x Reset bit y
            BR1: u1,
            /// Port x Reset bit y
            BR2: u1,
            /// Port x Reset bit y
            BR3: u1,
            /// Port x Reset bit y
            BR4: u1,
            /// Port x Reset bit y
            BR5: u1,
            /// Port x Reset bit y
            BR6: u1,
            /// Port x Reset bit y
            BR7: u1,
            /// Port x Reset bit y
            BR8: u1,
            /// Port x Reset bit y
            BR9: u1,
            /// Port x Reset bit y
            BR10: u1,
            /// Port x Reset bit y
            BR11: u1,
            /// Port x Reset bit y
            BR12: u1,
            /// Port x Reset bit y
            BR13: u1,
            /// Port x Reset bit y
            BR14: u1,
            /// Port x Reset bit y
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOC = struct {
        pub const base_address = 0x48000800;

        /// address: 0x48000800
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x48000804
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bit 0
            OT0: u1,
            /// Port x configuration bit 1
            OT1: u1,
            /// Port x configuration bit 2
            OT2: u1,
            /// Port x configuration bit 3
            OT3: u1,
            /// Port x configuration bit 4
            OT4: u1,
            /// Port x configuration bit 5
            OT5: u1,
            /// Port x configuration bit 6
            OT6: u1,
            /// Port x configuration bit 7
            OT7: u1,
            /// Port x configuration bit 8
            OT8: u1,
            /// Port x configuration bit 9
            OT9: u1,
            /// Port x configuration bit
            /// 10
            OT10: u1,
            /// Port x configuration bit
            /// 11
            OT11: u1,
            /// Port x configuration bit
            /// 12
            OT12: u1,
            /// Port x configuration bit
            /// 13
            OT13: u1,
            /// Port x configuration bit
            /// 14
            OT14: u1,
            /// Port x configuration bit
            /// 15
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x48000808
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4800080c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x48000810
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x48000814
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x48000818
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4800081c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Lok Key
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x48000820
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x48000824
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x48000828
        /// Port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x Reset bit y
            BR0: u1,
            /// Port x Reset bit y
            BR1: u1,
            /// Port x Reset bit y
            BR2: u1,
            /// Port x Reset bit y
            BR3: u1,
            /// Port x Reset bit y
            BR4: u1,
            /// Port x Reset bit y
            BR5: u1,
            /// Port x Reset bit y
            BR6: u1,
            /// Port x Reset bit y
            BR7: u1,
            /// Port x Reset bit y
            BR8: u1,
            /// Port x Reset bit y
            BR9: u1,
            /// Port x Reset bit y
            BR10: u1,
            /// Port x Reset bit y
            BR11: u1,
            /// Port x Reset bit y
            BR12: u1,
            /// Port x Reset bit y
            BR13: u1,
            /// Port x Reset bit y
            BR14: u1,
            /// Port x Reset bit y
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOD = struct {
        pub const base_address = 0x48000c00;

        /// address: 0x48000c00
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x48000c04
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bit 0
            OT0: u1,
            /// Port x configuration bit 1
            OT1: u1,
            /// Port x configuration bit 2
            OT2: u1,
            /// Port x configuration bit 3
            OT3: u1,
            /// Port x configuration bit 4
            OT4: u1,
            /// Port x configuration bit 5
            OT5: u1,
            /// Port x configuration bit 6
            OT6: u1,
            /// Port x configuration bit 7
            OT7: u1,
            /// Port x configuration bit 8
            OT8: u1,
            /// Port x configuration bit 9
            OT9: u1,
            /// Port x configuration bit
            /// 10
            OT10: u1,
            /// Port x configuration bit
            /// 11
            OT11: u1,
            /// Port x configuration bit
            /// 12
            OT12: u1,
            /// Port x configuration bit
            /// 13
            OT13: u1,
            /// Port x configuration bit
            /// 14
            OT14: u1,
            /// Port x configuration bit
            /// 15
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x48000c08
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x48000c0c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x48000c10
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x48000c14
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x48000c18
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x48000c1c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Lok Key
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x48000c20
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x48000c24
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x48000c28
        /// Port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x Reset bit y
            BR0: u1,
            /// Port x Reset bit y
            BR1: u1,
            /// Port x Reset bit y
            BR2: u1,
            /// Port x Reset bit y
            BR3: u1,
            /// Port x Reset bit y
            BR4: u1,
            /// Port x Reset bit y
            BR5: u1,
            /// Port x Reset bit y
            BR6: u1,
            /// Port x Reset bit y
            BR7: u1,
            /// Port x Reset bit y
            BR8: u1,
            /// Port x Reset bit y
            BR9: u1,
            /// Port x Reset bit y
            BR10: u1,
            /// Port x Reset bit y
            BR11: u1,
            /// Port x Reset bit y
            BR12: u1,
            /// Port x Reset bit y
            BR13: u1,
            /// Port x Reset bit y
            BR14: u1,
            /// Port x Reset bit y
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOE = struct {
        pub const base_address = 0x48001000;

        /// address: 0x48001000
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x48001004
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bit 0
            OT0: u1,
            /// Port x configuration bit 1
            OT1: u1,
            /// Port x configuration bit 2
            OT2: u1,
            /// Port x configuration bit 3
            OT3: u1,
            /// Port x configuration bit 4
            OT4: u1,
            /// Port x configuration bit 5
            OT5: u1,
            /// Port x configuration bit 6
            OT6: u1,
            /// Port x configuration bit 7
            OT7: u1,
            /// Port x configuration bit 8
            OT8: u1,
            /// Port x configuration bit 9
            OT9: u1,
            /// Port x configuration bit
            /// 10
            OT10: u1,
            /// Port x configuration bit
            /// 11
            OT11: u1,
            /// Port x configuration bit
            /// 12
            OT12: u1,
            /// Port x configuration bit
            /// 13
            OT13: u1,
            /// Port x configuration bit
            /// 14
            OT14: u1,
            /// Port x configuration bit
            /// 15
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x48001008
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4800100c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x48001010
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x48001014
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x48001018
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4800101c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Lok Key
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x48001020
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x48001024
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x48001028
        /// Port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x Reset bit y
            BR0: u1,
            /// Port x Reset bit y
            BR1: u1,
            /// Port x Reset bit y
            BR2: u1,
            /// Port x Reset bit y
            BR3: u1,
            /// Port x Reset bit y
            BR4: u1,
            /// Port x Reset bit y
            BR5: u1,
            /// Port x Reset bit y
            BR6: u1,
            /// Port x Reset bit y
            BR7: u1,
            /// Port x Reset bit y
            BR8: u1,
            /// Port x Reset bit y
            BR9: u1,
            /// Port x Reset bit y
            BR10: u1,
            /// Port x Reset bit y
            BR11: u1,
            /// Port x Reset bit y
            BR12: u1,
            /// Port x Reset bit y
            BR13: u1,
            /// Port x Reset bit y
            BR14: u1,
            /// Port x Reset bit y
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOF = struct {
        pub const base_address = 0x48001400;

        /// address: 0x48001400
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x48001404
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bit 0
            OT0: u1,
            /// Port x configuration bit 1
            OT1: u1,
            /// Port x configuration bit 2
            OT2: u1,
            /// Port x configuration bit 3
            OT3: u1,
            /// Port x configuration bit 4
            OT4: u1,
            /// Port x configuration bit 5
            OT5: u1,
            /// Port x configuration bit 6
            OT6: u1,
            /// Port x configuration bit 7
            OT7: u1,
            /// Port x configuration bit 8
            OT8: u1,
            /// Port x configuration bit 9
            OT9: u1,
            /// Port x configuration bit
            /// 10
            OT10: u1,
            /// Port x configuration bit
            /// 11
            OT11: u1,
            /// Port x configuration bit
            /// 12
            OT12: u1,
            /// Port x configuration bit
            /// 13
            OT13: u1,
            /// Port x configuration bit
            /// 14
            OT14: u1,
            /// Port x configuration bit
            /// 15
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x48001408
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4800140c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x48001410
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x48001414
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x48001418
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4800141c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Lok Key
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x48001420
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x48001424
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x48001428
        /// Port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x Reset bit y
            BR0: u1,
            /// Port x Reset bit y
            BR1: u1,
            /// Port x Reset bit y
            BR2: u1,
            /// Port x Reset bit y
            BR3: u1,
            /// Port x Reset bit y
            BR4: u1,
            /// Port x Reset bit y
            BR5: u1,
            /// Port x Reset bit y
            BR6: u1,
            /// Port x Reset bit y
            BR7: u1,
            /// Port x Reset bit y
            BR8: u1,
            /// Port x Reset bit y
            BR9: u1,
            /// Port x Reset bit y
            BR10: u1,
            /// Port x Reset bit y
            BR11: u1,
            /// Port x Reset bit y
            BR12: u1,
            /// Port x Reset bit y
            BR13: u1,
            /// Port x Reset bit y
            BR14: u1,
            /// Port x Reset bit y
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOG = struct {
        pub const base_address = 0x48001800;

        /// address: 0x48001800
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x48001804
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bit 0
            OT0: u1,
            /// Port x configuration bit 1
            OT1: u1,
            /// Port x configuration bit 2
            OT2: u1,
            /// Port x configuration bit 3
            OT3: u1,
            /// Port x configuration bit 4
            OT4: u1,
            /// Port x configuration bit 5
            OT5: u1,
            /// Port x configuration bit 6
            OT6: u1,
            /// Port x configuration bit 7
            OT7: u1,
            /// Port x configuration bit 8
            OT8: u1,
            /// Port x configuration bit 9
            OT9: u1,
            /// Port x configuration bit
            /// 10
            OT10: u1,
            /// Port x configuration bit
            /// 11
            OT11: u1,
            /// Port x configuration bit
            /// 12
            OT12: u1,
            /// Port x configuration bit
            /// 13
            OT13: u1,
            /// Port x configuration bit
            /// 14
            OT14: u1,
            /// Port x configuration bit
            /// 15
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x48001808
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4800180c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x48001810
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x48001814
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x48001818
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4800181c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Lok Key
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x48001820
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x48001824
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x48001828
        /// Port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x Reset bit y
            BR0: u1,
            /// Port x Reset bit y
            BR1: u1,
            /// Port x Reset bit y
            BR2: u1,
            /// Port x Reset bit y
            BR3: u1,
            /// Port x Reset bit y
            BR4: u1,
            /// Port x Reset bit y
            BR5: u1,
            /// Port x Reset bit y
            BR6: u1,
            /// Port x Reset bit y
            BR7: u1,
            /// Port x Reset bit y
            BR8: u1,
            /// Port x Reset bit y
            BR9: u1,
            /// Port x Reset bit y
            BR10: u1,
            /// Port x Reset bit y
            BR11: u1,
            /// Port x Reset bit y
            BR12: u1,
            /// Port x Reset bit y
            BR13: u1,
            /// Port x Reset bit y
            BR14: u1,
            /// Port x Reset bit y
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOH = struct {
        pub const base_address = 0x48001c00;

        /// address: 0x48001c00
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x48001c04
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bit 0
            OT0: u1,
            /// Port x configuration bit 1
            OT1: u1,
            /// Port x configuration bit 2
            OT2: u1,
            /// Port x configuration bit 3
            OT3: u1,
            /// Port x configuration bit 4
            OT4: u1,
            /// Port x configuration bit 5
            OT5: u1,
            /// Port x configuration bit 6
            OT6: u1,
            /// Port x configuration bit 7
            OT7: u1,
            /// Port x configuration bit 8
            OT8: u1,
            /// Port x configuration bit 9
            OT9: u1,
            /// Port x configuration bit
            /// 10
            OT10: u1,
            /// Port x configuration bit
            /// 11
            OT11: u1,
            /// Port x configuration bit
            /// 12
            OT12: u1,
            /// Port x configuration bit
            /// 13
            OT13: u1,
            /// Port x configuration bit
            /// 14
            OT14: u1,
            /// Port x configuration bit
            /// 15
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x48001c08
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x48001c0c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x48001c10
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x48001c14
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x48001c18
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x48001c1c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Lok Key
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x48001c20
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x48001c24
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);

        /// address: 0x48001c28
        /// Port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x Reset bit y
            BR0: u1,
            /// Port x Reset bit y
            BR1: u1,
            /// Port x Reset bit y
            BR2: u1,
            /// Port x Reset bit y
            BR3: u1,
            /// Port x Reset bit y
            BR4: u1,
            /// Port x Reset bit y
            BR5: u1,
            /// Port x Reset bit y
            BR6: u1,
            /// Port x Reset bit y
            BR7: u1,
            /// Port x Reset bit y
            BR8: u1,
            /// Port x Reset bit y
            BR9: u1,
            /// Port x Reset bit y
            BR10: u1,
            /// Port x Reset bit y
            BR11: u1,
            /// Port x Reset bit y
            BR12: u1,
            /// Port x Reset bit y
            BR13: u1,
            /// Port x Reset bit y
            BR14: u1,
            /// Port x Reset bit y
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    /// Touch sensing controller
    pub const TSC = struct {
        pub const base_address = 0x40024000;

        /// address: 0x40024000
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Touch sensing controller
            /// enable
            TSCE: u1,
            /// Start a new acquisition
            START: u1,
            /// Acquisition mode
            AM: u1,
            /// Synchronization pin
            /// polarity
            SYNCPOL: u1,
            /// I/O Default mode
            IODEF: u1,
            /// Max count value
            MCV: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// pulse generator prescaler
            PGPSC: u3,
            /// Spread spectrum prescaler
            SSPSC: u1,
            /// Spread spectrum enable
            SSE: u1,
            /// Spread spectrum deviation
            SSD: u7,
            /// Charge transfer pulse low
            CTPL: u4,
            /// Charge transfer pulse high
            CTPH: u4,
        }), base_address + 0x0);

        /// address: 0x40024004
        /// interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of acquisition interrupt
            /// enable
            EOAIE: u1,
            /// Max count error interrupt
            /// enable
            MCEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x4);

        /// address: 0x40024008
        /// interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of acquisition interrupt
            /// clear
            EOAIC: u1,
            /// Max count error interrupt
            /// clear
            MCEIC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x8);

        /// address: 0x4002400c
        /// interrupt status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of acquisition flag
            EOAF: u1,
            /// Max count error flag
            MCEF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x40024010
        /// I/O hysteresis control
        /// register
        pub const IOHCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// G1_IO1 Schmitt trigger hysteresis
            /// mode
            G1_IO1: u1,
            /// G1_IO2 Schmitt trigger hysteresis
            /// mode
            G1_IO2: u1,
            /// G1_IO3 Schmitt trigger hysteresis
            /// mode
            G1_IO3: u1,
            /// G1_IO4 Schmitt trigger hysteresis
            /// mode
            G1_IO4: u1,
            /// G2_IO1 Schmitt trigger hysteresis
            /// mode
            G2_IO1: u1,
            /// G2_IO2 Schmitt trigger hysteresis
            /// mode
            G2_IO2: u1,
            /// G2_IO3 Schmitt trigger hysteresis
            /// mode
            G2_IO3: u1,
            /// G2_IO4 Schmitt trigger hysteresis
            /// mode
            G2_IO4: u1,
            /// G3_IO1 Schmitt trigger hysteresis
            /// mode
            G3_IO1: u1,
            /// G3_IO2 Schmitt trigger hysteresis
            /// mode
            G3_IO2: u1,
            /// G3_IO3 Schmitt trigger hysteresis
            /// mode
            G3_IO3: u1,
            /// G3_IO4 Schmitt trigger hysteresis
            /// mode
            G3_IO4: u1,
            /// G4_IO1 Schmitt trigger hysteresis
            /// mode
            G4_IO1: u1,
            /// G4_IO2 Schmitt trigger hysteresis
            /// mode
            G4_IO2: u1,
            /// G4_IO3 Schmitt trigger hysteresis
            /// mode
            G4_IO3: u1,
            /// G4_IO4 Schmitt trigger hysteresis
            /// mode
            G4_IO4: u1,
            /// G5_IO1 Schmitt trigger hysteresis
            /// mode
            G5_IO1: u1,
            /// G5_IO2 Schmitt trigger hysteresis
            /// mode
            G5_IO2: u1,
            /// G5_IO3 Schmitt trigger hysteresis
            /// mode
            G5_IO3: u1,
            /// G5_IO4 Schmitt trigger hysteresis
            /// mode
            G5_IO4: u1,
            /// G6_IO1 Schmitt trigger hysteresis
            /// mode
            G6_IO1: u1,
            /// G6_IO2 Schmitt trigger hysteresis
            /// mode
            G6_IO2: u1,
            /// G6_IO3 Schmitt trigger hysteresis
            /// mode
            G6_IO3: u1,
            /// G6_IO4 Schmitt trigger hysteresis
            /// mode
            G6_IO4: u1,
            /// G7_IO1 Schmitt trigger hysteresis
            /// mode
            G7_IO1: u1,
            /// G7_IO2 Schmitt trigger hysteresis
            /// mode
            G7_IO2: u1,
            /// G7_IO3 Schmitt trigger hysteresis
            /// mode
            G7_IO3: u1,
            /// G7_IO4 Schmitt trigger hysteresis
            /// mode
            G7_IO4: u1,
            /// G8_IO1 Schmitt trigger hysteresis
            /// mode
            G8_IO1: u1,
            /// G8_IO2 Schmitt trigger hysteresis
            /// mode
            G8_IO2: u1,
            /// G8_IO3 Schmitt trigger hysteresis
            /// mode
            G8_IO3: u1,
            /// G8_IO4 Schmitt trigger hysteresis
            /// mode
            G8_IO4: u1,
        }), base_address + 0x10);

        /// address: 0x40024018
        /// I/O analog switch control
        /// register
        pub const IOASCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// G1_IO1 analog switch
            /// enable
            G1_IO1: u1,
            /// G1_IO2 analog switch
            /// enable
            G1_IO2: u1,
            /// G1_IO3 analog switch
            /// enable
            G1_IO3: u1,
            /// G1_IO4 analog switch
            /// enable
            G1_IO4: u1,
            /// G2_IO1 analog switch
            /// enable
            G2_IO1: u1,
            /// G2_IO2 analog switch
            /// enable
            G2_IO2: u1,
            /// G2_IO3 analog switch
            /// enable
            G2_IO3: u1,
            /// G2_IO4 analog switch
            /// enable
            G2_IO4: u1,
            /// G3_IO1 analog switch
            /// enable
            G3_IO1: u1,
            /// G3_IO2 analog switch
            /// enable
            G3_IO2: u1,
            /// G3_IO3 analog switch
            /// enable
            G3_IO3: u1,
            /// G3_IO4 analog switch
            /// enable
            G3_IO4: u1,
            /// G4_IO1 analog switch
            /// enable
            G4_IO1: u1,
            /// G4_IO2 analog switch
            /// enable
            G4_IO2: u1,
            /// G4_IO3 analog switch
            /// enable
            G4_IO3: u1,
            /// G4_IO4 analog switch
            /// enable
            G4_IO4: u1,
            /// G5_IO1 analog switch
            /// enable
            G5_IO1: u1,
            /// G5_IO2 analog switch
            /// enable
            G5_IO2: u1,
            /// G5_IO3 analog switch
            /// enable
            G5_IO3: u1,
            /// G5_IO4 analog switch
            /// enable
            G5_IO4: u1,
            /// G6_IO1 analog switch
            /// enable
            G6_IO1: u1,
            /// G6_IO2 analog switch
            /// enable
            G6_IO2: u1,
            /// G6_IO3 analog switch
            /// enable
            G6_IO3: u1,
            /// G6_IO4 analog switch
            /// enable
            G6_IO4: u1,
            /// G7_IO1 analog switch
            /// enable
            G7_IO1: u1,
            /// G7_IO2 analog switch
            /// enable
            G7_IO2: u1,
            /// G7_IO3 analog switch
            /// enable
            G7_IO3: u1,
            /// G7_IO4 analog switch
            /// enable
            G7_IO4: u1,
            /// G8_IO1 analog switch
            /// enable
            G8_IO1: u1,
            /// G8_IO2 analog switch
            /// enable
            G8_IO2: u1,
            /// G8_IO3 analog switch
            /// enable
            G8_IO3: u1,
            /// G8_IO4 analog switch
            /// enable
            G8_IO4: u1,
        }), base_address + 0x18);

        /// address: 0x40024020
        /// I/O sampling control register
        pub const IOSCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// G1_IO1 sampling mode
            G1_IO1: u1,
            /// G1_IO2 sampling mode
            G1_IO2: u1,
            /// G1_IO3 sampling mode
            G1_IO3: u1,
            /// G1_IO4 sampling mode
            G1_IO4: u1,
            /// G2_IO1 sampling mode
            G2_IO1: u1,
            /// G2_IO2 sampling mode
            G2_IO2: u1,
            /// G2_IO3 sampling mode
            G2_IO3: u1,
            /// G2_IO4 sampling mode
            G2_IO4: u1,
            /// G3_IO1 sampling mode
            G3_IO1: u1,
            /// G3_IO2 sampling mode
            G3_IO2: u1,
            /// G3_IO3 sampling mode
            G3_IO3: u1,
            /// G3_IO4 sampling mode
            G3_IO4: u1,
            /// G4_IO1 sampling mode
            G4_IO1: u1,
            /// G4_IO2 sampling mode
            G4_IO2: u1,
            /// G4_IO3 sampling mode
            G4_IO3: u1,
            /// G4_IO4 sampling mode
            G4_IO4: u1,
            /// G5_IO1 sampling mode
            G5_IO1: u1,
            /// G5_IO2 sampling mode
            G5_IO2: u1,
            /// G5_IO3 sampling mode
            G5_IO3: u1,
            /// G5_IO4 sampling mode
            G5_IO4: u1,
            /// G6_IO1 sampling mode
            G6_IO1: u1,
            /// G6_IO2 sampling mode
            G6_IO2: u1,
            /// G6_IO3 sampling mode
            G6_IO3: u1,
            /// G6_IO4 sampling mode
            G6_IO4: u1,
            /// G7_IO1 sampling mode
            G7_IO1: u1,
            /// G7_IO2 sampling mode
            G7_IO2: u1,
            /// G7_IO3 sampling mode
            G7_IO3: u1,
            /// G7_IO4 sampling mode
            G7_IO4: u1,
            /// G8_IO1 sampling mode
            G8_IO1: u1,
            /// G8_IO2 sampling mode
            G8_IO2: u1,
            /// G8_IO3 sampling mode
            G8_IO3: u1,
            /// G8_IO4 sampling mode
            G8_IO4: u1,
        }), base_address + 0x20);

        /// address: 0x40024028
        /// I/O channel control register
        pub const IOCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// G1_IO1 channel mode
            G1_IO1: u1,
            /// G1_IO2 channel mode
            G1_IO2: u1,
            /// G1_IO3 channel mode
            G1_IO3: u1,
            /// G1_IO4 channel mode
            G1_IO4: u1,
            /// G2_IO1 channel mode
            G2_IO1: u1,
            /// G2_IO2 channel mode
            G2_IO2: u1,
            /// G2_IO3 channel mode
            G2_IO3: u1,
            /// G2_IO4 channel mode
            G2_IO4: u1,
            /// G3_IO1 channel mode
            G3_IO1: u1,
            /// G3_IO2 channel mode
            G3_IO2: u1,
            /// G3_IO3 channel mode
            G3_IO3: u1,
            /// G3_IO4 channel mode
            G3_IO4: u1,
            /// G4_IO1 channel mode
            G4_IO1: u1,
            /// G4_IO2 channel mode
            G4_IO2: u1,
            /// G4_IO3 channel mode
            G4_IO3: u1,
            /// G4_IO4 channel mode
            G4_IO4: u1,
            /// G5_IO1 channel mode
            G5_IO1: u1,
            /// G5_IO2 channel mode
            G5_IO2: u1,
            /// G5_IO3 channel mode
            G5_IO3: u1,
            /// G5_IO4 channel mode
            G5_IO4: u1,
            /// G6_IO1 channel mode
            G6_IO1: u1,
            /// G6_IO2 channel mode
            G6_IO2: u1,
            /// G6_IO3 channel mode
            G6_IO3: u1,
            /// G6_IO4 channel mode
            G6_IO4: u1,
            /// G7_IO1 channel mode
            G7_IO1: u1,
            /// G7_IO2 channel mode
            G7_IO2: u1,
            /// G7_IO3 channel mode
            G7_IO3: u1,
            /// G7_IO4 channel mode
            G7_IO4: u1,
            /// G8_IO1 channel mode
            G8_IO1: u1,
            /// G8_IO2 channel mode
            G8_IO2: u1,
            /// G8_IO3 channel mode
            G8_IO3: u1,
            /// G8_IO4 channel mode
            G8_IO4: u1,
        }), base_address + 0x28);

        /// address: 0x40024030
        /// I/O group control status
        /// register
        pub const IOGCSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog I/O group x enable
            G1E: u1,
            /// Analog I/O group x enable
            G2E: u1,
            /// Analog I/O group x enable
            G3E: u1,
            /// Analog I/O group x enable
            G4E: u1,
            /// Analog I/O group x enable
            G5E: u1,
            /// Analog I/O group x enable
            G6E: u1,
            /// Analog I/O group x enable
            G7E: u1,
            /// Analog I/O group x enable
            G8E: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Analog I/O group x status
            G1S: u1,
            /// Analog I/O group x status
            G2S: u1,
            /// Analog I/O group x status
            G3S: u1,
            /// Analog I/O group x status
            G4S: u1,
            /// Analog I/O group x status
            G5S: u1,
            /// Analog I/O group x status
            G6S: u1,
            /// Analog I/O group x status
            G7S: u1,
            /// Analog I/O group x status
            G8S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x30);

        /// address: 0x40024034
        /// I/O group x counter register
        pub const IOG1CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value
            CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x34);

        /// address: 0x40024038
        /// I/O group x counter register
        pub const IOG2CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value
            CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x38);

        /// address: 0x4002403c
        /// I/O group x counter register
        pub const IOG3CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value
            CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x3c);

        /// address: 0x40024040
        /// I/O group x counter register
        pub const IOG4CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value
            CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x40);

        /// address: 0x40024044
        /// I/O group x counter register
        pub const IOG5CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value
            CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x44);

        /// address: 0x40024048
        /// I/O group x counter register
        pub const IOG6CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value
            CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x48);

        /// address: 0x4002404c
        /// I/O group x counter register
        pub const IOG7CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value
            CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x4c);

        /// address: 0x40024050
        /// I/O group x counter register
        pub const IOG8CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value
            CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x50);
    };
    /// cyclic redundancy check calculation
    /// unit
    pub const CRC = struct {
        pub const base_address = 0x40023000;

        /// address: 0x40023000
        /// Data register
        pub const DR = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40023004
        /// Independent data register
        pub const IDR = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x4);

        /// address: 0x40023008
        /// Control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// reset bit
            RESET: u1,
            reserved0: u1,
            reserved1: u1,
            /// Polynomial size
            POLYSIZE: u2,
            /// Reverse input data
            REV_IN: u2,
            /// Reverse output data
            REV_OUT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x40023010
        /// Initial CRC value
        pub const INIT = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40023014
        /// CRC polynomial
        pub const POL = @intToPtr(*volatile u32, base_address + 0x14);
    };
    /// Flash
    pub const Flash = struct {
        pub const base_address = 0x40022000;

        /// address: 0x40022000
        /// Flash access control register
        pub const ACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LATENCY
            LATENCY: u3,
            reserved0: u1,
            /// PRFTBE
            PRFTBE: u1,
            /// PRFTBS
            PRFTBS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x0);

        /// address: 0x40022004
        /// Flash key register
        pub const KEYR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Flash Key
            FKEYR: u32,
        }), base_address + 0x4);

        /// address: 0x40022008
        /// Flash option key register
        pub const OPTKEYR = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4002200c
        /// Flash status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Busy
            BSY: u1,
            reserved0: u1,
            /// Programming error
            PGERR: u1,
            reserved1: u1,
            /// Write protection error
            WRPRT: u1,
            /// End of operation
            EOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xc);

        /// address: 0x40022010
        /// Flash control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Programming
            PG: u1,
            /// Page erase
            PER: u1,
            /// Mass erase
            MER: u1,
            reserved0: u1,
            /// Option byte programming
            OPTPG: u1,
            /// Option byte erase
            OPTER: u1,
            /// Start
            STRT: u1,
            /// Lock
            LOCK: u1,
            reserved1: u1,
            /// Option bytes write enable
            OPTWRE: u1,
            /// Error interrupt enable
            ERRIE: u1,
            reserved2: u1,
            /// End of operation interrupt
            /// enable
            EOPIE: u1,
            /// Force option byte loading
            FORCE_OPTLOAD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x10);

        /// address: 0x40022014
        /// Flash address register
        pub const AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Flash address
            FAR: u32,
        }), base_address + 0x14);

        /// address: 0x4002201c
        /// Option byte register
        pub const OBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Option byte error
            OPTERR: u1,
            /// Level 1 protection status
            LEVEL1_PROT: u1,
            /// Level 2 protection status
            LEVEL2_PROT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// WDG_SW
            WDG_SW: u1,
            /// nRST_STOP
            nRST_STOP: u1,
            /// nRST_STDBY
            nRST_STDBY: u1,
            reserved5: u1,
            /// BOOT1
            BOOT1: u1,
            /// VDDA_MONITOR
            VDDA_MONITOR: u1,
            /// SRAM_PARITY_CHECK
            SRAM_PARITY_CHECK: u1,
            reserved6: u1,
            /// Data0
            Data0: u8,
            /// Data1
            Data1: u8,
        }), base_address + 0x1c);

        /// address: 0x40022020
        /// Write protection register
        pub const WRPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write protect
            WRP: u32,
        }), base_address + 0x20);
    };
    /// Reset and clock control
    pub const RCC = struct {
        pub const base_address = 0x40021000;

        /// address: 0x40021000
        /// Clock control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Internal High Speed clock
            /// enable
            HSION: u1,
            /// Internal High Speed clock ready
            /// flag
            HSIRDY: u1,
            reserved0: u1,
            /// Internal High Speed clock
            /// trimming
            HSITRIM: u5,
            /// Internal High Speed clock
            /// Calibration
            HSICAL: u8,
            /// External High Speed clock
            /// enable
            HSEON: u1,
            /// External High Speed clock ready
            /// flag
            HSERDY: u1,
            /// External High Speed clock
            /// Bypass
            HSEBYP: u1,
            /// Clock Security System
            /// enable
            CSSON: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// PLL enable
            PLLON: u1,
            /// PLL clock ready flag
            PLLRDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x0);

        /// address: 0x40021004
        /// Clock configuration register
        /// (RCC_CFGR)
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// System clock Switch
            SW: u2,
            /// System Clock Switch Status
            SWS: u2,
            /// AHB prescaler
            HPRE: u4,
            /// APB Low speed prescaler
            /// (APB1)
            PPRE1: u3,
            /// APB high speed prescaler
            /// (APB2)
            PPRE2: u3,
            reserved0: u1,
            /// PLL entry clock source
            PLLSRC: u2,
            /// HSE divider for PLL entry
            PLLXTPRE: u1,
            /// PLL Multiplication Factor
            PLLMUL: u4,
            /// USB prescaler
            USBPRES: u1,
            /// I2S external clock source
            /// selection
            I2SSRC: u1,
            /// Microcontroller clock
            /// output
            MCO: u3,
            reserved1: u1,
            /// Microcontroller Clock Output
            /// Flag
            MCOF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x4);

        /// address: 0x40021008
        /// Clock interrupt register
        /// (RCC_CIR)
        pub const CIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSI Ready Interrupt flag
            LSIRDYF: u1,
            /// LSE Ready Interrupt flag
            LSERDYF: u1,
            /// HSI Ready Interrupt flag
            HSIRDYF: u1,
            /// HSE Ready Interrupt flag
            HSERDYF: u1,
            /// PLL Ready Interrupt flag
            PLLRDYF: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock Security System Interrupt
            /// flag
            CSSF: u1,
            /// LSI Ready Interrupt Enable
            LSIRDYIE: u1,
            /// LSE Ready Interrupt Enable
            LSERDYIE: u1,
            /// HSI Ready Interrupt Enable
            HSIRDYIE: u1,
            /// HSE Ready Interrupt Enable
            HSERDYIE: u1,
            /// PLL Ready Interrupt Enable
            PLLRDYIE: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// LSI Ready Interrupt Clear
            LSIRDYC: u1,
            /// LSE Ready Interrupt Clear
            LSERDYC: u1,
            /// HSI Ready Interrupt Clear
            HSIRDYC: u1,
            /// HSE Ready Interrupt Clear
            HSERDYC: u1,
            /// PLL Ready Interrupt Clear
            PLLRDYC: u1,
            reserved5: u1,
            reserved6: u1,
            /// Clock security system interrupt
            /// clear
            CSSC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x8);

        /// address: 0x4002100c
        /// APB2 peripheral reset register
        /// (RCC_APB2RSTR)
        pub const APB2RSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SYSCFG and COMP reset
            SYSCFGRST: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// TIM1 timer reset
            TIM1RST: u1,
            /// SPI 1 reset
            SPI1RST: u1,
            /// TIM8 timer reset
            TIM8RST: u1,
            /// USART1 reset
            USART1RST: u1,
            reserved10: u1,
            /// TIM15 timer reset
            TIM15RST: u1,
            /// TIM16 timer reset
            TIM16RST: u1,
            /// TIM17 timer reset
            TIM17RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xc);

        /// address: 0x40021010
        /// APB1 peripheral reset register
        /// (RCC_APB1RSTR)
        pub const APB1RSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer 2 reset
            TIM2RST: u1,
            /// Timer 3 reset
            TIM3RST: u1,
            /// Timer 14 reset
            TIM4RST: u1,
            reserved0: u1,
            /// Timer 6 reset
            TIM6RST: u1,
            /// Timer 7 reset
            TIM7RST: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Window watchdog reset
            WWDGRST: u1,
            reserved6: u1,
            reserved7: u1,
            /// SPI2 reset
            SPI2RST: u1,
            /// SPI3 reset
            SPI3RST: u1,
            reserved8: u1,
            /// USART 2 reset
            USART2RST: u1,
            /// USART3 reset
            USART3RST: u1,
            /// UART 4 reset
            UART4RST: u1,
            /// UART 5 reset
            UART5RST: u1,
            /// I2C1 reset
            I2C1RST: u1,
            /// I2C2 reset
            I2C2RST: u1,
            /// USB reset
            USBRST: u1,
            reserved9: u1,
            /// CAN reset
            CANRST: u1,
            reserved10: u1,
            reserved11: u1,
            /// Power interface reset
            PWRRST: u1,
            /// DAC interface reset
            DACRST: u1,
            /// I2C3 reset
            I2C3RST: u1,
            padding0: u1,
        }), base_address + 0x10);

        /// address: 0x40021014
        /// AHB Peripheral Clock enable register
        /// (RCC_AHBENR)
        pub const AHBENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA1 clock enable
            DMAEN: u1,
            /// DMA2 clock enable
            DMA2EN: u1,
            /// SRAM interface clock
            /// enable
            SRAMEN: u1,
            reserved0: u1,
            /// FLITF clock enable
            FLITFEN: u1,
            /// FMC clock enable
            FMCEN: u1,
            /// CRC clock enable
            CRCEN: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// IO port H clock enable
            IOPHEN: u1,
            /// I/O port A clock enable
            IOPAEN: u1,
            /// I/O port B clock enable
            IOPBEN: u1,
            /// I/O port C clock enable
            IOPCEN: u1,
            /// I/O port D clock enable
            IOPDEN: u1,
            /// I/O port E clock enable
            IOPEEN: u1,
            /// I/O port F clock enable
            IOPFEN: u1,
            /// I/O port G clock enable
            IOPGEN: u1,
            /// Touch sensing controller clock
            /// enable
            TSCEN: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// ADC1 and ADC2 clock enable
            ADC12EN: u1,
            /// ADC3 and ADC4 clock enable
            ADC34EN: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x14);

        /// address: 0x40021018
        /// APB2 peripheral clock enable register
        /// (RCC_APB2ENR)
        pub const APB2ENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SYSCFG clock enable
            SYSCFGEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// TIM1 Timer clock enable
            TIM1EN: u1,
            /// SPI 1 clock enable
            SPI1EN: u1,
            /// TIM8 Timer clock enable
            TIM8EN: u1,
            /// USART1 clock enable
            USART1EN: u1,
            reserved10: u1,
            /// TIM15 timer clock enable
            TIM15EN: u1,
            /// TIM16 timer clock enable
            TIM16EN: u1,
            /// TIM17 timer clock enable
            TIM17EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x18);

        /// address: 0x4002101c
        /// APB1 peripheral clock enable register
        /// (RCC_APB1ENR)
        pub const APB1ENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer 2 clock enable
            TIM2EN: u1,
            /// Timer 3 clock enable
            TIM3EN: u1,
            /// Timer 4 clock enable
            TIM4EN: u1,
            reserved0: u1,
            /// Timer 6 clock enable
            TIM6EN: u1,
            /// Timer 7 clock enable
            TIM7EN: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Window watchdog clock
            /// enable
            WWDGEN: u1,
            reserved6: u1,
            reserved7: u1,
            /// SPI 2 clock enable
            SPI2EN: u1,
            /// SPI 3 clock enable
            SPI3EN: u1,
            reserved8: u1,
            /// USART 2 clock enable
            USART2EN: u1,
            /// USART 3 clock enable
            USART3EN: u1,
            /// USART 4 clock enable
            USART4EN: u1,
            /// USART 5 clock enable
            USART5EN: u1,
            /// I2C 1 clock enable
            I2C1EN: u1,
            /// I2C 2 clock enable
            I2C2EN: u1,
            /// USB clock enable
            USBEN: u1,
            reserved9: u1,
            /// CAN clock enable
            CANEN: u1,
            /// DAC2 interface clock
            /// enable
            DAC2EN: u1,
            reserved10: u1,
            /// Power interface clock
            /// enable
            PWREN: u1,
            /// DAC interface clock enable
            DACEN: u1,
            /// I2C3 clock enable
            I2C3EN: u1,
            padding0: u1,
        }), base_address + 0x1c);

        /// address: 0x40021020
        /// Backup domain control register
        /// (RCC_BDCR)
        pub const BDCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// External Low Speed oscillator
            /// enable
            LSEON: u1,
            /// External Low Speed oscillator
            /// ready
            LSERDY: u1,
            /// External Low Speed oscillator
            /// bypass
            LSEBYP: u1,
            /// LSE oscillator drive
            /// capability
            LSEDRV: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// RTC clock source selection
            RTCSEL: u2,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// RTC clock enable
            RTCEN: u1,
            /// Backup domain software
            /// reset
            BDRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x20);

        /// address: 0x40021024
        /// Control/status register
        /// (RCC_CSR)
        pub const CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Internal low speed oscillator
            /// enable
            LSION: u1,
            /// Internal low speed oscillator
            /// ready
            LSIRDY: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// Remove reset flag
            RMVF: u1,
            /// Option byte loader reset
            /// flag
            OBLRSTF: u1,
            /// PIN reset flag
            PINRSTF: u1,
            /// POR/PDR reset flag
            PORRSTF: u1,
            /// Software reset flag
            SFTRSTF: u1,
            /// Independent watchdog reset
            /// flag
            IWDGRSTF: u1,
            /// Window watchdog reset flag
            WWDGRSTF: u1,
            /// Low-power reset flag
            LPWRRSTF: u1,
        }), base_address + 0x24);

        /// address: 0x40021028
        /// AHB peripheral reset register
        pub const AHBRSTR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// FMC reset
            FMCRST: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// I/O port H reset
            IOPHRST: u1,
            /// I/O port A reset
            IOPARST: u1,
            /// I/O port B reset
            IOPBRST: u1,
            /// I/O port C reset
            IOPCRST: u1,
            /// I/O port D reset
            IOPDRST: u1,
            /// I/O port E reset
            IOPERST: u1,
            /// I/O port F reset
            IOPFRST: u1,
            /// Touch sensing controller
            /// reset
            IOPGRST: u1,
            /// Touch sensing controller
            /// reset
            TSCRST: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// ADC1 and ADC2 reset
            ADC12RST: u1,
            /// ADC3 and ADC4 reset
            ADC34RST: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x28);

        /// address: 0x4002102c
        /// Clock configuration register 2
        pub const CFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PREDIV division factor
            PREDIV: u4,
            /// ADC1 and ADC2 prescaler
            ADC12PRES: u5,
            /// ADC3 and ADC4 prescaler
            ADC34PRES: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x2c);

        /// address: 0x40021030
        /// Clock configuration register 3
        pub const CFGR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART1 clock source
            /// selection
            USART1SW: u2,
            reserved0: u1,
            reserved1: u1,
            /// I2C1 clock source
            /// selection
            I2C1SW: u1,
            /// I2C2 clock source
            /// selection
            I2C2SW: u1,
            /// I2C3 clock source
            /// selection
            I2C3SW: u1,
            reserved2: u1,
            /// Timer1 clock source
            /// selection
            TIM1SW: u1,
            /// Timer8 clock source
            /// selection
            TIM8SW: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// USART2 clock source
            /// selection
            USART2SW: u2,
            /// USART3 clock source
            /// selection
            USART3SW: u2,
            /// UART4 clock source
            /// selection
            UART4SW: u2,
            /// UART5 clock source
            /// selection
            UART5SW: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x30);
    };
    /// DMA controller 1
    pub const DMA1 = struct {
        pub const base_address = 0x40020000;

        /// address: 0x40020000
        /// DMA interrupt status register
        /// (DMA_ISR)
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 1 Global interrupt
            /// flag
            GIF1: u1,
            /// Channel 1 Transfer Complete
            /// flag
            TCIF1: u1,
            /// Channel 1 Half Transfer Complete
            /// flag
            HTIF1: u1,
            /// Channel 1 Transfer Error
            /// flag
            TEIF1: u1,
            /// Channel 2 Global interrupt
            /// flag
            GIF2: u1,
            /// Channel 2 Transfer Complete
            /// flag
            TCIF2: u1,
            /// Channel 2 Half Transfer Complete
            /// flag
            HTIF2: u1,
            /// Channel 2 Transfer Error
            /// flag
            TEIF2: u1,
            /// Channel 3 Global interrupt
            /// flag
            GIF3: u1,
            /// Channel 3 Transfer Complete
            /// flag
            TCIF3: u1,
            /// Channel 3 Half Transfer Complete
            /// flag
            HTIF3: u1,
            /// Channel 3 Transfer Error
            /// flag
            TEIF3: u1,
            /// Channel 4 Global interrupt
            /// flag
            GIF4: u1,
            /// Channel 4 Transfer Complete
            /// flag
            TCIF4: u1,
            /// Channel 4 Half Transfer Complete
            /// flag
            HTIF4: u1,
            /// Channel 4 Transfer Error
            /// flag
            TEIF4: u1,
            /// Channel 5 Global interrupt
            /// flag
            GIF5: u1,
            /// Channel 5 Transfer Complete
            /// flag
            TCIF5: u1,
            /// Channel 5 Half Transfer Complete
            /// flag
            HTIF5: u1,
            /// Channel 5 Transfer Error
            /// flag
            TEIF5: u1,
            /// Channel 6 Global interrupt
            /// flag
            GIF6: u1,
            /// Channel 6 Transfer Complete
            /// flag
            TCIF6: u1,
            /// Channel 6 Half Transfer Complete
            /// flag
            HTIF6: u1,
            /// Channel 6 Transfer Error
            /// flag
            TEIF6: u1,
            /// Channel 7 Global interrupt
            /// flag
            GIF7: u1,
            /// Channel 7 Transfer Complete
            /// flag
            TCIF7: u1,
            /// Channel 7 Half Transfer Complete
            /// flag
            HTIF7: u1,
            /// Channel 7 Transfer Error
            /// flag
            TEIF7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x40020004
        /// DMA interrupt flag clear register
        /// (DMA_IFCR)
        pub const IFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 1 Global interrupt
            /// clear
            CGIF1: u1,
            /// Channel 1 Transfer Complete
            /// clear
            CTCIF1: u1,
            /// Channel 1 Half Transfer
            /// clear
            CHTIF1: u1,
            /// Channel 1 Transfer Error
            /// clear
            CTEIF1: u1,
            /// Channel 2 Global interrupt
            /// clear
            CGIF2: u1,
            /// Channel 2 Transfer Complete
            /// clear
            CTCIF2: u1,
            /// Channel 2 Half Transfer
            /// clear
            CHTIF2: u1,
            /// Channel 2 Transfer Error
            /// clear
            CTEIF2: u1,
            /// Channel 3 Global interrupt
            /// clear
            CGIF3: u1,
            /// Channel 3 Transfer Complete
            /// clear
            CTCIF3: u1,
            /// Channel 3 Half Transfer
            /// clear
            CHTIF3: u1,
            /// Channel 3 Transfer Error
            /// clear
            CTEIF3: u1,
            /// Channel 4 Global interrupt
            /// clear
            CGIF4: u1,
            /// Channel 4 Transfer Complete
            /// clear
            CTCIF4: u1,
            /// Channel 4 Half Transfer
            /// clear
            CHTIF4: u1,
            /// Channel 4 Transfer Error
            /// clear
            CTEIF4: u1,
            /// Channel 5 Global interrupt
            /// clear
            CGIF5: u1,
            /// Channel 5 Transfer Complete
            /// clear
            CTCIF5: u1,
            /// Channel 5 Half Transfer
            /// clear
            CHTIF5: u1,
            /// Channel 5 Transfer Error
            /// clear
            CTEIF5: u1,
            /// Channel 6 Global interrupt
            /// clear
            CGIF6: u1,
            /// Channel 6 Transfer Complete
            /// clear
            CTCIF6: u1,
            /// Channel 6 Half Transfer
            /// clear
            CHTIF6: u1,
            /// Channel 6 Transfer Error
            /// clear
            CTEIF6: u1,
            /// Channel 7 Global interrupt
            /// clear
            CGIF7: u1,
            /// Channel 7 Transfer Complete
            /// clear
            CTCIF7: u1,
            /// Channel 7 Half Transfer
            /// clear
            CHTIF7: u1,
            /// Channel 7 Transfer Error
            /// clear
            CTEIF7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x4);

        /// address: 0x40020008
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x8);

        /// address: 0x4002000c
        /// DMA channel 1 number of data
        /// register
        pub const CNDTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40020010
        /// DMA channel 1 peripheral address
        /// register
        pub const CPAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x10);

        /// address: 0x40020014
        /// DMA channel 1 memory address
        /// register
        pub const CMAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x14);

        /// address: 0x4002001c
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x1c);

        /// address: 0x40020020
        /// DMA channel 2 number of data
        /// register
        pub const CNDTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40020024
        /// DMA channel 2 peripheral address
        /// register
        pub const CPAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x24);

        /// address: 0x40020028
        /// DMA channel 2 memory address
        /// register
        pub const CMAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x28);

        /// address: 0x40020030
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x30);

        /// address: 0x40020034
        /// DMA channel 3 number of data
        /// register
        pub const CNDTR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40020038
        /// DMA channel 3 peripheral address
        /// register
        pub const CPAR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x38);

        /// address: 0x4002003c
        /// DMA channel 3 memory address
        /// register
        pub const CMAR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x3c);

        /// address: 0x40020044
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x44);

        /// address: 0x40020048
        /// DMA channel 4 number of data
        /// register
        pub const CNDTR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4002004c
        /// DMA channel 4 peripheral address
        /// register
        pub const CPAR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x4c);

        /// address: 0x40020050
        /// DMA channel 4 memory address
        /// register
        pub const CMAR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x50);

        /// address: 0x40020058
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x58);

        /// address: 0x4002005c
        /// DMA channel 5 number of data
        /// register
        pub const CNDTR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x40020060
        /// DMA channel 5 peripheral address
        /// register
        pub const CPAR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x60);

        /// address: 0x40020064
        /// DMA channel 5 memory address
        /// register
        pub const CMAR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x64);

        /// address: 0x4002006c
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x6c);

        /// address: 0x40020070
        /// DMA channel 6 number of data
        /// register
        pub const CNDTR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x70);

        /// address: 0x40020074
        /// DMA channel 6 peripheral address
        /// register
        pub const CPAR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x74);

        /// address: 0x40020078
        /// DMA channel 6 memory address
        /// register
        pub const CMAR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x78);

        /// address: 0x40020080
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x80);

        /// address: 0x40020084
        /// DMA channel 7 number of data
        /// register
        pub const CNDTR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x40020088
        /// DMA channel 7 peripheral address
        /// register
        pub const CPAR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x88);

        /// address: 0x4002008c
        /// DMA channel 7 memory address
        /// register
        pub const CMAR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x8c);
    };
    pub const DMA2 = struct {
        pub const base_address = 0x40020400;

        /// address: 0x40020400
        /// DMA interrupt status register
        /// (DMA_ISR)
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 1 Global interrupt
            /// flag
            GIF1: u1,
            /// Channel 1 Transfer Complete
            /// flag
            TCIF1: u1,
            /// Channel 1 Half Transfer Complete
            /// flag
            HTIF1: u1,
            /// Channel 1 Transfer Error
            /// flag
            TEIF1: u1,
            /// Channel 2 Global interrupt
            /// flag
            GIF2: u1,
            /// Channel 2 Transfer Complete
            /// flag
            TCIF2: u1,
            /// Channel 2 Half Transfer Complete
            /// flag
            HTIF2: u1,
            /// Channel 2 Transfer Error
            /// flag
            TEIF2: u1,
            /// Channel 3 Global interrupt
            /// flag
            GIF3: u1,
            /// Channel 3 Transfer Complete
            /// flag
            TCIF3: u1,
            /// Channel 3 Half Transfer Complete
            /// flag
            HTIF3: u1,
            /// Channel 3 Transfer Error
            /// flag
            TEIF3: u1,
            /// Channel 4 Global interrupt
            /// flag
            GIF4: u1,
            /// Channel 4 Transfer Complete
            /// flag
            TCIF4: u1,
            /// Channel 4 Half Transfer Complete
            /// flag
            HTIF4: u1,
            /// Channel 4 Transfer Error
            /// flag
            TEIF4: u1,
            /// Channel 5 Global interrupt
            /// flag
            GIF5: u1,
            /// Channel 5 Transfer Complete
            /// flag
            TCIF5: u1,
            /// Channel 5 Half Transfer Complete
            /// flag
            HTIF5: u1,
            /// Channel 5 Transfer Error
            /// flag
            TEIF5: u1,
            /// Channel 6 Global interrupt
            /// flag
            GIF6: u1,
            /// Channel 6 Transfer Complete
            /// flag
            TCIF6: u1,
            /// Channel 6 Half Transfer Complete
            /// flag
            HTIF6: u1,
            /// Channel 6 Transfer Error
            /// flag
            TEIF6: u1,
            /// Channel 7 Global interrupt
            /// flag
            GIF7: u1,
            /// Channel 7 Transfer Complete
            /// flag
            TCIF7: u1,
            /// Channel 7 Half Transfer Complete
            /// flag
            HTIF7: u1,
            /// Channel 7 Transfer Error
            /// flag
            TEIF7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x40020404
        /// DMA interrupt flag clear register
        /// (DMA_IFCR)
        pub const IFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 1 Global interrupt
            /// clear
            CGIF1: u1,
            /// Channel 1 Transfer Complete
            /// clear
            CTCIF1: u1,
            /// Channel 1 Half Transfer
            /// clear
            CHTIF1: u1,
            /// Channel 1 Transfer Error
            /// clear
            CTEIF1: u1,
            /// Channel 2 Global interrupt
            /// clear
            CGIF2: u1,
            /// Channel 2 Transfer Complete
            /// clear
            CTCIF2: u1,
            /// Channel 2 Half Transfer
            /// clear
            CHTIF2: u1,
            /// Channel 2 Transfer Error
            /// clear
            CTEIF2: u1,
            /// Channel 3 Global interrupt
            /// clear
            CGIF3: u1,
            /// Channel 3 Transfer Complete
            /// clear
            CTCIF3: u1,
            /// Channel 3 Half Transfer
            /// clear
            CHTIF3: u1,
            /// Channel 3 Transfer Error
            /// clear
            CTEIF3: u1,
            /// Channel 4 Global interrupt
            /// clear
            CGIF4: u1,
            /// Channel 4 Transfer Complete
            /// clear
            CTCIF4: u1,
            /// Channel 4 Half Transfer
            /// clear
            CHTIF4: u1,
            /// Channel 4 Transfer Error
            /// clear
            CTEIF4: u1,
            /// Channel 5 Global interrupt
            /// clear
            CGIF5: u1,
            /// Channel 5 Transfer Complete
            /// clear
            CTCIF5: u1,
            /// Channel 5 Half Transfer
            /// clear
            CHTIF5: u1,
            /// Channel 5 Transfer Error
            /// clear
            CTEIF5: u1,
            /// Channel 6 Global interrupt
            /// clear
            CGIF6: u1,
            /// Channel 6 Transfer Complete
            /// clear
            CTCIF6: u1,
            /// Channel 6 Half Transfer
            /// clear
            CHTIF6: u1,
            /// Channel 6 Transfer Error
            /// clear
            CTEIF6: u1,
            /// Channel 7 Global interrupt
            /// clear
            CGIF7: u1,
            /// Channel 7 Transfer Complete
            /// clear
            CTCIF7: u1,
            /// Channel 7 Half Transfer
            /// clear
            CHTIF7: u1,
            /// Channel 7 Transfer Error
            /// clear
            CTEIF7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x4);

        /// address: 0x40020408
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x8);

        /// address: 0x4002040c
        /// DMA channel 1 number of data
        /// register
        pub const CNDTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40020410
        /// DMA channel 1 peripheral address
        /// register
        pub const CPAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x10);

        /// address: 0x40020414
        /// DMA channel 1 memory address
        /// register
        pub const CMAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x14);

        /// address: 0x4002041c
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x1c);

        /// address: 0x40020420
        /// DMA channel 2 number of data
        /// register
        pub const CNDTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40020424
        /// DMA channel 2 peripheral address
        /// register
        pub const CPAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x24);

        /// address: 0x40020428
        /// DMA channel 2 memory address
        /// register
        pub const CMAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x28);

        /// address: 0x40020430
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x30);

        /// address: 0x40020434
        /// DMA channel 3 number of data
        /// register
        pub const CNDTR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40020438
        /// DMA channel 3 peripheral address
        /// register
        pub const CPAR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x38);

        /// address: 0x4002043c
        /// DMA channel 3 memory address
        /// register
        pub const CMAR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x3c);

        /// address: 0x40020444
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x44);

        /// address: 0x40020448
        /// DMA channel 4 number of data
        /// register
        pub const CNDTR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4002044c
        /// DMA channel 4 peripheral address
        /// register
        pub const CPAR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x4c);

        /// address: 0x40020450
        /// DMA channel 4 memory address
        /// register
        pub const CMAR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x50);

        /// address: 0x40020458
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x58);

        /// address: 0x4002045c
        /// DMA channel 5 number of data
        /// register
        pub const CNDTR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x40020460
        /// DMA channel 5 peripheral address
        /// register
        pub const CPAR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x60);

        /// address: 0x40020464
        /// DMA channel 5 memory address
        /// register
        pub const CMAR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x64);

        /// address: 0x4002046c
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x6c);

        /// address: 0x40020470
        /// DMA channel 6 number of data
        /// register
        pub const CNDTR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x70);

        /// address: 0x40020474
        /// DMA channel 6 peripheral address
        /// register
        pub const CPAR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x74);

        /// address: 0x40020478
        /// DMA channel 6 memory address
        /// register
        pub const CMAR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x78);

        /// address: 0x40020480
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x80);

        /// address: 0x40020484
        /// DMA channel 7 number of data
        /// register
        pub const CNDTR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x40020488
        /// DMA channel 7 peripheral address
        /// register
        pub const CPAR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x88);

        /// address: 0x4002048c
        /// DMA channel 7 memory address
        /// register
        pub const CMAR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x8c);
    };
    /// General purpose timer
    pub const TIM2 = struct {
        pub const base_address = 0x40000000;

        /// address: 0x40000000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            reserved0: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40000004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40000008
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            /// OCREF clear selection
            OCCS: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            /// Slave mode selection bit3
            SMS_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x8);

        /// address: 0x4000000c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40000010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40000014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            reserved0: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40000018
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output compare 1 mode
            OC1M: u3,
            /// Output compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output compare 2 mode
            OC2M: u3,
            /// Output compare 2 clear
            /// enable
            OC2CE: u1,
            /// Output compare 1 mode bit
            /// 3
            OC1M_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Output compare 2 mode bit
            /// 3
            OC2M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x18);

        /// address: 0x40000018
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PSC: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000001c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            O24CE: u1,
            /// Output compare 3 mode bit3
            OC3M_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Output compare 4 mode bit3
            OC4M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1c);

        /// address: 0x4000001c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000020
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            reserved2: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            reserved3: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40000024
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low counter value
            CNTL: u16,
            /// High counter value
            CNTH: u15,
            /// if IUFREMAP=0 than CNT with read write
            /// access else UIFCPY with read only
            /// access
            CNT_or_UIFCPY: u1,
        }), base_address + 0x24);

        /// address: 0x40000028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000002c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Auto-reload value
            ARRL: u16,
            /// High Auto-reload value
            ARRH: u16,
        }), base_address + 0x2c);

        /// address: 0x40000034
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 1
            /// value
            CCR1L: u16,
            /// High Capture/Compare 1 value (on
            /// TIM2)
            CCR1H: u16,
        }), base_address + 0x34);

        /// address: 0x40000038
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 2
            /// value
            CCR2L: u16,
            /// High Capture/Compare 2 value (on
            /// TIM2)
            CCR2H: u16,
        }), base_address + 0x38);

        /// address: 0x4000003c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR3L: u16,
            /// High Capture/Compare value (on
            /// TIM2)
            CCR3H: u16,
        }), base_address + 0x3c);

        /// address: 0x40000040
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR4L: u16,
            /// High Capture/Compare value (on
            /// TIM2)
            CCR4H: u16,
        }), base_address + 0x40);

        /// address: 0x40000048
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4000004c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);
    };
    pub const TIM3 = struct {
        pub const base_address = 0x40000400;

        /// address: 0x40000400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            reserved0: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40000404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40000408
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            /// OCREF clear selection
            OCCS: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            /// Slave mode selection bit3
            SMS_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x8);

        /// address: 0x4000040c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40000410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40000414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            reserved0: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40000418
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output compare 1 mode
            OC1M: u3,
            /// Output compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output compare 2 mode
            OC2M: u3,
            /// Output compare 2 clear
            /// enable
            OC2CE: u1,
            /// Output compare 1 mode bit
            /// 3
            OC1M_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Output compare 2 mode bit
            /// 3
            OC2M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x18);

        /// address: 0x40000418
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PSC: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000041c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            O24CE: u1,
            /// Output compare 3 mode bit3
            OC3M_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Output compare 4 mode bit3
            OC4M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1c);

        /// address: 0x4000041c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000420
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            reserved2: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            reserved3: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40000424
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low counter value
            CNTL: u16,
            /// High counter value
            CNTH: u15,
            /// if IUFREMAP=0 than CNT with read write
            /// access else UIFCPY with read only
            /// access
            CNT_or_UIFCPY: u1,
        }), base_address + 0x24);

        /// address: 0x40000428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000042c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Auto-reload value
            ARRL: u16,
            /// High Auto-reload value
            ARRH: u16,
        }), base_address + 0x2c);

        /// address: 0x40000434
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 1
            /// value
            CCR1L: u16,
            /// High Capture/Compare 1 value (on
            /// TIM2)
            CCR1H: u16,
        }), base_address + 0x34);

        /// address: 0x40000438
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 2
            /// value
            CCR2L: u16,
            /// High Capture/Compare 2 value (on
            /// TIM2)
            CCR2H: u16,
        }), base_address + 0x38);

        /// address: 0x4000043c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR3L: u16,
            /// High Capture/Compare value (on
            /// TIM2)
            CCR3H: u16,
        }), base_address + 0x3c);

        /// address: 0x40000440
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR4L: u16,
            /// High Capture/Compare value (on
            /// TIM2)
            CCR4H: u16,
        }), base_address + 0x40);

        /// address: 0x40000448
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4000044c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);
    };
    pub const TIM4 = struct {
        pub const base_address = 0x40000800;

        /// address: 0x40000800
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            reserved0: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40000804
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40000808
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            /// OCREF clear selection
            OCCS: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            /// Slave mode selection bit3
            SMS_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x8);

        /// address: 0x4000080c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40000810
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40000814
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            reserved0: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40000818
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output compare 1 mode
            OC1M: u3,
            /// Output compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output compare 2 mode
            OC2M: u3,
            /// Output compare 2 clear
            /// enable
            OC2CE: u1,
            /// Output compare 1 mode bit
            /// 3
            OC1M_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Output compare 2 mode bit
            /// 3
            OC2M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x18);

        /// address: 0x40000818
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PSC: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000081c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            O24CE: u1,
            /// Output compare 3 mode bit3
            OC3M_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Output compare 4 mode bit3
            OC4M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1c);

        /// address: 0x4000081c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000820
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            reserved2: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            reserved3: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40000824
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low counter value
            CNTL: u16,
            /// High counter value
            CNTH: u15,
            /// if IUFREMAP=0 than CNT with read write
            /// access else UIFCPY with read only
            /// access
            CNT_or_UIFCPY: u1,
        }), base_address + 0x24);

        /// address: 0x40000828
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000082c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Auto-reload value
            ARRL: u16,
            /// High Auto-reload value
            ARRH: u16,
        }), base_address + 0x2c);

        /// address: 0x40000834
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 1
            /// value
            CCR1L: u16,
            /// High Capture/Compare 1 value (on
            /// TIM2)
            CCR1H: u16,
        }), base_address + 0x34);

        /// address: 0x40000838
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 2
            /// value
            CCR2L: u16,
            /// High Capture/Compare 2 value (on
            /// TIM2)
            CCR2H: u16,
        }), base_address + 0x38);

        /// address: 0x4000083c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR3L: u16,
            /// High Capture/Compare value (on
            /// TIM2)
            CCR3H: u16,
        }), base_address + 0x3c);

        /// address: 0x40000840
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR4L: u16,
            /// High Capture/Compare value (on
            /// TIM2)
            CCR4H: u16,
        }), base_address + 0x40);

        /// address: 0x40000848
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4000084c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);
    };
    /// General purpose timers
    pub const TIM15 = struct {
        pub const base_address = 0x40014000;

        /// address: 0x40014000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            reserved3: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40014004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded
            /// control
            CCPC: u1,
            reserved0: u1,
            /// Capture/compare control update
            /// selection
            CCUS: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            /// Output Idle state 1
            OIS1: u1,
            /// Output Idle state 1
            OIS1N: u1,
            /// Output Idle state 2
            OIS2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x4);

        /// address: 0x40014008
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Slave mode selection bit 3
            SMS_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x8);

        /// address: 0x4001400c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// COM interrupt enable
            COMIE: u1,
            /// Trigger interrupt enable
            TIE: u1,
            /// Break interrupt enable
            BIE: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            reserved2: u1,
            reserved3: u1,
            /// COM DMA request enable
            COMDE: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40014010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            reserved0: u1,
            reserved1: u1,
            /// COM interrupt flag
            COMIF: u1,
            /// Trigger interrupt flag
            TIF: u1,
            /// Break interrupt flag
            BIF: u1,
            reserved2: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x10);

        /// address: 0x40014014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            reserved0: u1,
            reserved1: u1,
            /// Capture/Compare control update
            /// generation
            COMG: u1,
            /// Trigger generation
            TG: u1,
            /// Break generation
            BG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x40014018
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            reserved0: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output Compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output Compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output Compare 2 mode
            OC2M: u3,
            reserved1: u1,
            /// Output Compare 1 mode bit
            /// 3
            OC1M_3: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Output Compare 2 mode bit
            /// 3
            OC2M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x18);

        /// address: 0x40014018
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PSC: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40014020
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            /// Capture/Compare 1 complementary output
            /// enable
            CC1NE: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved0: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40014024
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// counter value
            CNT: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// UIF copy
            UIFCPY: u1,
        }), base_address + 0x24);

        /// address: 0x40014028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001402c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40014030
        /// repetition counter register
        pub const RCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x30);

        /// address: 0x40014034
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40014038
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);

        /// address: 0x40014044
        /// break and dead-time register
        pub const BDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8,
            /// Lock configuration
            LOCK: u2,
            /// Off-state selection for Idle
            /// mode
            OSSI: u1,
            /// Off-state selection for Run
            /// mode
            OSSR: u1,
            /// Break enable
            BKE: u1,
            /// Break polarity
            BKP: u1,
            /// Automatic output enable
            AOE: u1,
            /// Main output enable
            MOE: u1,
            /// Break filter
            BKF: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x44);

        /// address: 0x40014048
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4001404c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);
    };
    /// General-purpose-timers
    pub const TIM16 = struct {
        pub const base_address = 0x40014400;

        /// address: 0x40014400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            reserved3: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40014404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded
            /// control
            CCPC: u1,
            reserved0: u1,
            /// Capture/compare control update
            /// selection
            CCUS: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Output Idle state 1
            OIS1: u1,
            /// Output Idle state 1
            OIS1N: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x4);

        /// address: 0x4001440c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// COM interrupt enable
            COMIE: u1,
            /// Trigger interrupt enable
            TIE: u1,
            /// Break interrupt enable
            BIE: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// COM DMA request enable
            COMDE: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40014410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// COM interrupt flag
            COMIF: u1,
            /// Trigger interrupt flag
            TIF: u1,
            /// Break interrupt flag
            BIF: u1,
            reserved3: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x10);

        /// address: 0x40014414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare control update
            /// generation
            COMG: u1,
            /// Trigger generation
            TG: u1,
            /// Break generation
            BG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x40014418
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Output Compare 1 mode
            OC1M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);

        /// address: 0x40014418
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x40014420
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            /// Capture/Compare 1 complementary output
            /// enable
            CC1NE: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x20);

        /// address: 0x40014424
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// counter value
            CNT: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// UIF Copy
            UIFCPY: u1,
        }), base_address + 0x24);

        /// address: 0x40014428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001442c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40014430
        /// repetition counter register
        pub const RCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x30);

        /// address: 0x40014434
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40014444
        /// break and dead-time register
        pub const BDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8,
            /// Lock configuration
            LOCK: u2,
            /// Off-state selection for Idle
            /// mode
            OSSI: u1,
            /// Off-state selection for Run
            /// mode
            OSSR: u1,
            /// Break enable
            BKE: u1,
            /// Break polarity
            BKP: u1,
            /// Automatic output enable
            AOE: u1,
            /// Main output enable
            MOE: u1,
            /// Break filter
            BKF: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x44);

        /// address: 0x40014448
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4001444c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40014450
        /// option register
        pub const OR = @intToPtr(*volatile u32, base_address + 0x50);
    };
    /// General purpose timer
    pub const TIM17 = struct {
        pub const base_address = 0x40014800;

        /// address: 0x40014800
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            reserved3: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40014804
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded
            /// control
            CCPC: u1,
            reserved0: u1,
            /// Capture/compare control update
            /// selection
            CCUS: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Output Idle state 1
            OIS1: u1,
            /// Output Idle state 1
            OIS1N: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x4);

        /// address: 0x4001480c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// COM interrupt enable
            COMIE: u1,
            /// Trigger interrupt enable
            TIE: u1,
            /// Break interrupt enable
            BIE: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// COM DMA request enable
            COMDE: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40014810
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// COM interrupt flag
            COMIF: u1,
            /// Trigger interrupt flag
            TIF: u1,
            /// Break interrupt flag
            BIF: u1,
            reserved3: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x10);

        /// address: 0x40014814
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare control update
            /// generation
            COMG: u1,
            /// Trigger generation
            TG: u1,
            /// Break generation
            BG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x40014818
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Output Compare 1 mode
            OC1M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);

        /// address: 0x40014818
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x40014820
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            /// Capture/Compare 1 complementary output
            /// enable
            CC1NE: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x20);

        /// address: 0x40014824
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// counter value
            CNT: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// UIF Copy
            UIFCPY: u1,
        }), base_address + 0x24);

        /// address: 0x40014828
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001482c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40014830
        /// repetition counter register
        pub const RCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x30);

        /// address: 0x40014834
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40014844
        /// break and dead-time register
        pub const BDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8,
            /// Lock configuration
            LOCK: u2,
            /// Off-state selection for Idle
            /// mode
            OSSI: u1,
            /// Off-state selection for Run
            /// mode
            OSSR: u1,
            /// Break enable
            BKE: u1,
            /// Break polarity
            BKP: u1,
            /// Automatic output enable
            AOE: u1,
            /// Main output enable
            MOE: u1,
            /// Break filter
            BKF: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x44);

        /// address: 0x40014848
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4001484c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);
    };
    /// Universal synchronous asynchronous receiver
    /// transmitter
    pub const USART1 = struct {
        pub const base_address = 0x40013800;

        /// address: 0x40013800
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// Driver Enable deassertion
            /// time
            DEDT: u5,
            /// Driver Enable assertion
            /// time
            DEAT: u5,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x40013804
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            DATAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// Auto baud rate mode
            ABRMOD: u2,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0: u4,
            /// Address of the USART node
            ADD4: u4,
        }), base_address + 0x4);

        /// address: 0x40013808
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// IrDA mode enable
            IREN: u1,
            /// IrDA low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4001380c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// fraction of USARTDIV
            DIV_Fraction: u4,
            /// mantissa of USARTDIV
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40013810
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40013814
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40013818
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4001381c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error
            PE: u1,
            /// Framing error
            FE: u1,
            /// Noise detected flag
            NF: u1,
            /// Overrun error
            ORE: u1,
            /// Idle line detected
            IDLE: u1,
            /// Read data register not
            /// empty
            RXNE: u1,
            /// Transmission complete
            TC: u1,
            /// Transmit data register
            /// empty
            TXE: u1,
            /// LIN break detection flag
            LBDF: u1,
            /// CTS interrupt flag
            CTSIF: u1,
            /// CTS flag
            CTS: u1,
            /// Receiver timeout
            RTOF: u1,
            /// End of block flag
            EOBF: u1,
            reserved0: u1,
            /// Auto baud rate error
            ABRE: u1,
            /// Auto baud rate flag
            ABRF: u1,
            /// Busy flag
            BUSY: u1,
            /// character match flag
            CMF: u1,
            /// Send break flag
            SBKF: u1,
            /// Receiver wakeup from Mute
            /// mode
            RWU: u1,
            /// Wakeup from Stop mode flag
            WUF: u1,
            /// Transmit enable acknowledge
            /// flag
            TEACK: u1,
            /// Receive enable acknowledge
            /// flag
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40013820
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of timeout clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40013824
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40013828
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };
    pub const USART2 = struct {
        pub const base_address = 0x40004400;

        /// address: 0x40004400
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// Driver Enable deassertion
            /// time
            DEDT: u5,
            /// Driver Enable assertion
            /// time
            DEAT: u5,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x40004404
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            DATAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// Auto baud rate mode
            ABRMOD: u2,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0: u4,
            /// Address of the USART node
            ADD4: u4,
        }), base_address + 0x4);

        /// address: 0x40004408
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// IrDA mode enable
            IREN: u1,
            /// IrDA low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4000440c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// fraction of USARTDIV
            DIV_Fraction: u4,
            /// mantissa of USARTDIV
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40004410
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40004414
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40004418
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4000441c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error
            PE: u1,
            /// Framing error
            FE: u1,
            /// Noise detected flag
            NF: u1,
            /// Overrun error
            ORE: u1,
            /// Idle line detected
            IDLE: u1,
            /// Read data register not
            /// empty
            RXNE: u1,
            /// Transmission complete
            TC: u1,
            /// Transmit data register
            /// empty
            TXE: u1,
            /// LIN break detection flag
            LBDF: u1,
            /// CTS interrupt flag
            CTSIF: u1,
            /// CTS flag
            CTS: u1,
            /// Receiver timeout
            RTOF: u1,
            /// End of block flag
            EOBF: u1,
            reserved0: u1,
            /// Auto baud rate error
            ABRE: u1,
            /// Auto baud rate flag
            ABRF: u1,
            /// Busy flag
            BUSY: u1,
            /// character match flag
            CMF: u1,
            /// Send break flag
            SBKF: u1,
            /// Receiver wakeup from Mute
            /// mode
            RWU: u1,
            /// Wakeup from Stop mode flag
            WUF: u1,
            /// Transmit enable acknowledge
            /// flag
            TEACK: u1,
            /// Receive enable acknowledge
            /// flag
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40004420
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of timeout clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40004424
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40004428
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };
    pub const USART3 = struct {
        pub const base_address = 0x40004800;

        /// address: 0x40004800
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// Driver Enable deassertion
            /// time
            DEDT: u5,
            /// Driver Enable assertion
            /// time
            DEAT: u5,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x40004804
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            DATAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// Auto baud rate mode
            ABRMOD: u2,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0: u4,
            /// Address of the USART node
            ADD4: u4,
        }), base_address + 0x4);

        /// address: 0x40004808
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// IrDA mode enable
            IREN: u1,
            /// IrDA low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4000480c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// fraction of USARTDIV
            DIV_Fraction: u4,
            /// mantissa of USARTDIV
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40004810
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40004814
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40004818
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4000481c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error
            PE: u1,
            /// Framing error
            FE: u1,
            /// Noise detected flag
            NF: u1,
            /// Overrun error
            ORE: u1,
            /// Idle line detected
            IDLE: u1,
            /// Read data register not
            /// empty
            RXNE: u1,
            /// Transmission complete
            TC: u1,
            /// Transmit data register
            /// empty
            TXE: u1,
            /// LIN break detection flag
            LBDF: u1,
            /// CTS interrupt flag
            CTSIF: u1,
            /// CTS flag
            CTS: u1,
            /// Receiver timeout
            RTOF: u1,
            /// End of block flag
            EOBF: u1,
            reserved0: u1,
            /// Auto baud rate error
            ABRE: u1,
            /// Auto baud rate flag
            ABRF: u1,
            /// Busy flag
            BUSY: u1,
            /// character match flag
            CMF: u1,
            /// Send break flag
            SBKF: u1,
            /// Receiver wakeup from Mute
            /// mode
            RWU: u1,
            /// Wakeup from Stop mode flag
            WUF: u1,
            /// Transmit enable acknowledge
            /// flag
            TEACK: u1,
            /// Receive enable acknowledge
            /// flag
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40004820
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of timeout clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40004824
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40004828
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };
    pub const UART4 = struct {
        pub const base_address = 0x40004c00;

        /// address: 0x40004c00
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// Driver Enable deassertion
            /// time
            DEDT: u5,
            /// Driver Enable assertion
            /// time
            DEAT: u5,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x40004c04
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            DATAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// Auto baud rate mode
            ABRMOD: u2,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0: u4,
            /// Address of the USART node
            ADD4: u4,
        }), base_address + 0x4);

        /// address: 0x40004c08
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// IrDA mode enable
            IREN: u1,
            /// IrDA low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x40004c0c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// fraction of USARTDIV
            DIV_Fraction: u4,
            /// mantissa of USARTDIV
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40004c10
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40004c14
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40004c18
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x40004c1c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error
            PE: u1,
            /// Framing error
            FE: u1,
            /// Noise detected flag
            NF: u1,
            /// Overrun error
            ORE: u1,
            /// Idle line detected
            IDLE: u1,
            /// Read data register not
            /// empty
            RXNE: u1,
            /// Transmission complete
            TC: u1,
            /// Transmit data register
            /// empty
            TXE: u1,
            /// LIN break detection flag
            LBDF: u1,
            /// CTS interrupt flag
            CTSIF: u1,
            /// CTS flag
            CTS: u1,
            /// Receiver timeout
            RTOF: u1,
            /// End of block flag
            EOBF: u1,
            reserved0: u1,
            /// Auto baud rate error
            ABRE: u1,
            /// Auto baud rate flag
            ABRF: u1,
            /// Busy flag
            BUSY: u1,
            /// character match flag
            CMF: u1,
            /// Send break flag
            SBKF: u1,
            /// Receiver wakeup from Mute
            /// mode
            RWU: u1,
            /// Wakeup from Stop mode flag
            WUF: u1,
            /// Transmit enable acknowledge
            /// flag
            TEACK: u1,
            /// Receive enable acknowledge
            /// flag
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40004c20
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of timeout clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40004c24
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40004c28
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };
    pub const UART5 = struct {
        pub const base_address = 0x40005000;

        /// address: 0x40005000
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// Driver Enable deassertion
            /// time
            DEDT: u5,
            /// Driver Enable assertion
            /// time
            DEAT: u5,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x40005004
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            DATAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// Auto baud rate mode
            ABRMOD: u2,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0: u4,
            /// Address of the USART node
            ADD4: u4,
        }), base_address + 0x4);

        /// address: 0x40005008
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// IrDA mode enable
            IREN: u1,
            /// IrDA low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4000500c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// fraction of USARTDIV
            DIV_Fraction: u4,
            /// mantissa of USARTDIV
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40005010
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40005014
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40005018
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4000501c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error
            PE: u1,
            /// Framing error
            FE: u1,
            /// Noise detected flag
            NF: u1,
            /// Overrun error
            ORE: u1,
            /// Idle line detected
            IDLE: u1,
            /// Read data register not
            /// empty
            RXNE: u1,
            /// Transmission complete
            TC: u1,
            /// Transmit data register
            /// empty
            TXE: u1,
            /// LIN break detection flag
            LBDF: u1,
            /// CTS interrupt flag
            CTSIF: u1,
            /// CTS flag
            CTS: u1,
            /// Receiver timeout
            RTOF: u1,
            /// End of block flag
            EOBF: u1,
            reserved0: u1,
            /// Auto baud rate error
            ABRE: u1,
            /// Auto baud rate flag
            ABRF: u1,
            /// Busy flag
            BUSY: u1,
            /// character match flag
            CMF: u1,
            /// Send break flag
            SBKF: u1,
            /// Receiver wakeup from Mute
            /// mode
            RWU: u1,
            /// Wakeup from Stop mode flag
            WUF: u1,
            /// Transmit enable acknowledge
            /// flag
            TEACK: u1,
            /// Receive enable acknowledge
            /// flag
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40005020
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of timeout clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40005024
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40005028
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };
    /// Serial peripheral interface/Inter-IC
    /// sound
    pub const SPI1 = struct {
        pub const base_address = 0x40013000;

        /// address: 0x40013000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// CRC length
            CRCL: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40013004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            /// NSS pulse management
            NSSP: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            /// Data size
            DS: u4,
            /// FIFO reception threshold
            FRXTH: u1,
            /// Last DMA transfer for
            /// reception
            LDMA_RX: u1,
            /// Last DMA transfer for
            /// transmission
            LDMA_TX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40013008
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// TI frame format error
            TIFRFE: u1,
            /// FIFO reception level
            FRLVL: u2,
            /// FIFO transmission level
            FTLVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x4001300c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40013010
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40013014
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40013018
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4001301c
        /// I2S configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Steady state clock
            /// polarity
            CKPOL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S Enable
            I2SE: u1,
            /// I2S mode selection
            I2SMOD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40013020
        /// I2S prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S Linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };
    pub const SPI2 = struct {
        pub const base_address = 0x40003800;

        /// address: 0x40003800
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// CRC length
            CRCL: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40003804
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            /// NSS pulse management
            NSSP: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            /// Data size
            DS: u4,
            /// FIFO reception threshold
            FRXTH: u1,
            /// Last DMA transfer for
            /// reception
            LDMA_RX: u1,
            /// Last DMA transfer for
            /// transmission
            LDMA_TX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40003808
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// TI frame format error
            TIFRFE: u1,
            /// FIFO reception level
            FRLVL: u2,
            /// FIFO transmission level
            FTLVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x4000380c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40003810
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40003814
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40003818
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000381c
        /// I2S configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Steady state clock
            /// polarity
            CKPOL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S Enable
            I2SE: u1,
            /// I2S mode selection
            I2SMOD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40003820
        /// I2S prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S Linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };
    pub const SPI3 = struct {
        pub const base_address = 0x40003c00;

        /// address: 0x40003c00
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// CRC length
            CRCL: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40003c04
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            /// NSS pulse management
            NSSP: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            /// Data size
            DS: u4,
            /// FIFO reception threshold
            FRXTH: u1,
            /// Last DMA transfer for
            /// reception
            LDMA_RX: u1,
            /// Last DMA transfer for
            /// transmission
            LDMA_TX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40003c08
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// TI frame format error
            TIFRFE: u1,
            /// FIFO reception level
            FRLVL: u2,
            /// FIFO transmission level
            FTLVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x40003c0c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40003c10
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40003c14
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40003c18
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40003c1c
        /// I2S configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Steady state clock
            /// polarity
            CKPOL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S Enable
            I2SE: u1,
            /// I2S mode selection
            I2SMOD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40003c20
        /// I2S prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S Linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };
    pub const I2S2ext = struct {
        pub const base_address = 0x40003400;

        /// address: 0x40003400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// CRC length
            CRCL: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40003404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            /// NSS pulse management
            NSSP: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            /// Data size
            DS: u4,
            /// FIFO reception threshold
            FRXTH: u1,
            /// Last DMA transfer for
            /// reception
            LDMA_RX: u1,
            /// Last DMA transfer for
            /// transmission
            LDMA_TX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40003408
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// TI frame format error
            TIFRFE: u1,
            /// FIFO reception level
            FRLVL: u2,
            /// FIFO transmission level
            FTLVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x4000340c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40003410
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40003414
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40003418
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000341c
        /// I2S configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Steady state clock
            /// polarity
            CKPOL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S Enable
            I2SE: u1,
            /// I2S mode selection
            I2SMOD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40003420
        /// I2S prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S Linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };
    pub const I2S3ext = struct {
        pub const base_address = 0x40004000;

        /// address: 0x40004000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// CRC length
            CRCL: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40004004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            /// NSS pulse management
            NSSP: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            /// Data size
            DS: u4,
            /// FIFO reception threshold
            FRXTH: u1,
            /// Last DMA transfer for
            /// reception
            LDMA_RX: u1,
            /// Last DMA transfer for
            /// transmission
            LDMA_TX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40004008
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// TI frame format error
            TIFRFE: u1,
            /// FIFO reception level
            FRLVL: u2,
            /// FIFO transmission level
            FTLVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x4000400c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40004010
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40004014
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40004018
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000401c
        /// I2S configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Steady state clock
            /// polarity
            CKPOL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S Enable
            I2SE: u1,
            /// I2S mode selection
            I2SMOD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40004020
        /// I2S prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S Linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };
    pub const SPI4 = struct {
        pub const base_address = 0x40013c00;

        /// address: 0x40013c00
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// CRC length
            CRCL: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40013c04
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            /// NSS pulse management
            NSSP: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            /// Data size
            DS: u4,
            /// FIFO reception threshold
            FRXTH: u1,
            /// Last DMA transfer for
            /// reception
            LDMA_RX: u1,
            /// Last DMA transfer for
            /// transmission
            LDMA_TX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40013c08
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// TI frame format error
            TIFRFE: u1,
            /// FIFO reception level
            FRLVL: u2,
            /// FIFO transmission level
            FTLVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x40013c0c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40013c10
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40013c14
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40013c18
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40013c1c
        /// I2S configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Steady state clock
            /// polarity
            CKPOL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S Enable
            I2SE: u1,
            /// I2S mode selection
            I2SMOD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40013c20
        /// I2S prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S Linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };
    /// External interrupt/event
    /// controller
    pub const EXTI = struct {
        pub const base_address = 0x40010400;

        /// address: 0x40010400
        /// Interrupt mask register
        pub const IMR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt Mask on line 0
            MR0: u1,
            /// Interrupt Mask on line 1
            MR1: u1,
            /// Interrupt Mask on line 2
            MR2: u1,
            /// Interrupt Mask on line 3
            MR3: u1,
            /// Interrupt Mask on line 4
            MR4: u1,
            /// Interrupt Mask on line 5
            MR5: u1,
            /// Interrupt Mask on line 6
            MR6: u1,
            /// Interrupt Mask on line 7
            MR7: u1,
            /// Interrupt Mask on line 8
            MR8: u1,
            /// Interrupt Mask on line 9
            MR9: u1,
            /// Interrupt Mask on line 10
            MR10: u1,
            /// Interrupt Mask on line 11
            MR11: u1,
            /// Interrupt Mask on line 12
            MR12: u1,
            /// Interrupt Mask on line 13
            MR13: u1,
            /// Interrupt Mask on line 14
            MR14: u1,
            /// Interrupt Mask on line 15
            MR15: u1,
            /// Interrupt Mask on line 16
            MR16: u1,
            /// Interrupt Mask on line 17
            MR17: u1,
            /// Interrupt Mask on line 18
            MR18: u1,
            /// Interrupt Mask on line 19
            MR19: u1,
            /// Interrupt Mask on line 20
            MR20: u1,
            /// Interrupt Mask on line 21
            MR21: u1,
            /// Interrupt Mask on line 22
            MR22: u1,
            /// Interrupt Mask on line 23
            MR23: u1,
            /// Interrupt Mask on line 24
            MR24: u1,
            /// Interrupt Mask on line 25
            MR25: u1,
            /// Interrupt Mask on line 26
            MR26: u1,
            /// Interrupt Mask on line 27
            MR27: u1,
            /// Interrupt Mask on line 28
            MR28: u1,
            /// Interrupt Mask on line 29
            MR29: u1,
            /// Interrupt Mask on line 30
            MR30: u1,
            /// Interrupt Mask on line 31
            MR31: u1,
        }), base_address + 0x0);

        /// address: 0x40010404
        /// Event mask register
        pub const EMR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Event Mask on line 0
            MR0: u1,
            /// Event Mask on line 1
            MR1: u1,
            /// Event Mask on line 2
            MR2: u1,
            /// Event Mask on line 3
            MR3: u1,
            /// Event Mask on line 4
            MR4: u1,
            /// Event Mask on line 5
            MR5: u1,
            /// Event Mask on line 6
            MR6: u1,
            /// Event Mask on line 7
            MR7: u1,
            /// Event Mask on line 8
            MR8: u1,
            /// Event Mask on line 9
            MR9: u1,
            /// Event Mask on line 10
            MR10: u1,
            /// Event Mask on line 11
            MR11: u1,
            /// Event Mask on line 12
            MR12: u1,
            /// Event Mask on line 13
            MR13: u1,
            /// Event Mask on line 14
            MR14: u1,
            /// Event Mask on line 15
            MR15: u1,
            /// Event Mask on line 16
            MR16: u1,
            /// Event Mask on line 17
            MR17: u1,
            /// Event Mask on line 18
            MR18: u1,
            /// Event Mask on line 19
            MR19: u1,
            /// Event Mask on line 20
            MR20: u1,
            /// Event Mask on line 21
            MR21: u1,
            /// Event Mask on line 22
            MR22: u1,
            /// Event Mask on line 23
            MR23: u1,
            /// Event Mask on line 24
            MR24: u1,
            /// Event Mask on line 25
            MR25: u1,
            /// Event Mask on line 26
            MR26: u1,
            /// Event Mask on line 27
            MR27: u1,
            /// Event Mask on line 28
            MR28: u1,
            /// Event Mask on line 29
            MR29: u1,
            /// Event Mask on line 30
            MR30: u1,
            /// Event Mask on line 31
            MR31: u1,
        }), base_address + 0x4);

        /// address: 0x40010408
        /// Rising Trigger selection
        /// register
        pub const RTSR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rising trigger event configuration of
            /// line 0
            TR0: u1,
            /// Rising trigger event configuration of
            /// line 1
            TR1: u1,
            /// Rising trigger event configuration of
            /// line 2
            TR2: u1,
            /// Rising trigger event configuration of
            /// line 3
            TR3: u1,
            /// Rising trigger event configuration of
            /// line 4
            TR4: u1,
            /// Rising trigger event configuration of
            /// line 5
            TR5: u1,
            /// Rising trigger event configuration of
            /// line 6
            TR6: u1,
            /// Rising trigger event configuration of
            /// line 7
            TR7: u1,
            /// Rising trigger event configuration of
            /// line 8
            TR8: u1,
            /// Rising trigger event configuration of
            /// line 9
            TR9: u1,
            /// Rising trigger event configuration of
            /// line 10
            TR10: u1,
            /// Rising trigger event configuration of
            /// line 11
            TR11: u1,
            /// Rising trigger event configuration of
            /// line 12
            TR12: u1,
            /// Rising trigger event configuration of
            /// line 13
            TR13: u1,
            /// Rising trigger event configuration of
            /// line 14
            TR14: u1,
            /// Rising trigger event configuration of
            /// line 15
            TR15: u1,
            /// Rising trigger event configuration of
            /// line 16
            TR16: u1,
            /// Rising trigger event configuration of
            /// line 17
            TR17: u1,
            /// Rising trigger event configuration of
            /// line 18
            TR18: u1,
            /// Rising trigger event configuration of
            /// line 19
            TR19: u1,
            /// Rising trigger event configuration of
            /// line 20
            TR20: u1,
            /// Rising trigger event configuration of
            /// line 21
            TR21: u1,
            /// Rising trigger event configuration of
            /// line 22
            TR22: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Rising trigger event configuration of
            /// line 29
            TR29: u1,
            /// Rising trigger event configuration of
            /// line 30
            TR30: u1,
            /// Rising trigger event configuration of
            /// line 31
            TR31: u1,
        }), base_address + 0x8);

        /// address: 0x4001040c
        /// Falling Trigger selection
        /// register
        pub const FTSR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Falling trigger event configuration of
            /// line 0
            TR0: u1,
            /// Falling trigger event configuration of
            /// line 1
            TR1: u1,
            /// Falling trigger event configuration of
            /// line 2
            TR2: u1,
            /// Falling trigger event configuration of
            /// line 3
            TR3: u1,
            /// Falling trigger event configuration of
            /// line 4
            TR4: u1,
            /// Falling trigger event configuration of
            /// line 5
            TR5: u1,
            /// Falling trigger event configuration of
            /// line 6
            TR6: u1,
            /// Falling trigger event configuration of
            /// line 7
            TR7: u1,
            /// Falling trigger event configuration of
            /// line 8
            TR8: u1,
            /// Falling trigger event configuration of
            /// line 9
            TR9: u1,
            /// Falling trigger event configuration of
            /// line 10
            TR10: u1,
            /// Falling trigger event configuration of
            /// line 11
            TR11: u1,
            /// Falling trigger event configuration of
            /// line 12
            TR12: u1,
            /// Falling trigger event configuration of
            /// line 13
            TR13: u1,
            /// Falling trigger event configuration of
            /// line 14
            TR14: u1,
            /// Falling trigger event configuration of
            /// line 15
            TR15: u1,
            /// Falling trigger event configuration of
            /// line 16
            TR16: u1,
            /// Falling trigger event configuration of
            /// line 17
            TR17: u1,
            /// Falling trigger event configuration of
            /// line 18
            TR18: u1,
            /// Falling trigger event configuration of
            /// line 19
            TR19: u1,
            /// Falling trigger event configuration of
            /// line 20
            TR20: u1,
            /// Falling trigger event configuration of
            /// line 21
            TR21: u1,
            /// Falling trigger event configuration of
            /// line 22
            TR22: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Falling trigger event configuration of
            /// line 29
            TR29: u1,
            /// Falling trigger event configuration of
            /// line 30.
            TR30: u1,
            /// Falling trigger event configuration of
            /// line 31
            TR31: u1,
        }), base_address + 0xc);

        /// address: 0x40010410
        /// Software interrupt event
        /// register
        pub const SWIER1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Interrupt on line
            /// 0
            SWIER0: u1,
            /// Software Interrupt on line
            /// 1
            SWIER1: u1,
            /// Software Interrupt on line
            /// 2
            SWIER2: u1,
            /// Software Interrupt on line
            /// 3
            SWIER3: u1,
            /// Software Interrupt on line
            /// 4
            SWIER4: u1,
            /// Software Interrupt on line
            /// 5
            SWIER5: u1,
            /// Software Interrupt on line
            /// 6
            SWIER6: u1,
            /// Software Interrupt on line
            /// 7
            SWIER7: u1,
            /// Software Interrupt on line
            /// 8
            SWIER8: u1,
            /// Software Interrupt on line
            /// 9
            SWIER9: u1,
            /// Software Interrupt on line
            /// 10
            SWIER10: u1,
            /// Software Interrupt on line
            /// 11
            SWIER11: u1,
            /// Software Interrupt on line
            /// 12
            SWIER12: u1,
            /// Software Interrupt on line
            /// 13
            SWIER13: u1,
            /// Software Interrupt on line
            /// 14
            SWIER14: u1,
            /// Software Interrupt on line
            /// 15
            SWIER15: u1,
            /// Software Interrupt on line
            /// 16
            SWIER16: u1,
            /// Software Interrupt on line
            /// 17
            SWIER17: u1,
            /// Software Interrupt on line
            /// 18
            SWIER18: u1,
            /// Software Interrupt on line
            /// 19
            SWIER19: u1,
            /// Software Interrupt on line
            /// 20
            SWIER20: u1,
            /// Software Interrupt on line
            /// 21
            SWIER21: u1,
            /// Software Interrupt on line
            /// 22
            SWIER22: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Software Interrupt on line
            /// 29
            SWIER29: u1,
            /// Software Interrupt on line
            /// 309
            SWIER30: u1,
            /// Software Interrupt on line
            /// 319
            SWIER31: u1,
        }), base_address + 0x10);

        /// address: 0x40010414
        /// Pending register
        pub const PR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pending bit 0
            PR0: u1,
            /// Pending bit 1
            PR1: u1,
            /// Pending bit 2
            PR2: u1,
            /// Pending bit 3
            PR3: u1,
            /// Pending bit 4
            PR4: u1,
            /// Pending bit 5
            PR5: u1,
            /// Pending bit 6
            PR6: u1,
            /// Pending bit 7
            PR7: u1,
            /// Pending bit 8
            PR8: u1,
            /// Pending bit 9
            PR9: u1,
            /// Pending bit 10
            PR10: u1,
            /// Pending bit 11
            PR11: u1,
            /// Pending bit 12
            PR12: u1,
            /// Pending bit 13
            PR13: u1,
            /// Pending bit 14
            PR14: u1,
            /// Pending bit 15
            PR15: u1,
            /// Pending bit 16
            PR16: u1,
            /// Pending bit 17
            PR17: u1,
            /// Pending bit 18
            PR18: u1,
            /// Pending bit 19
            PR19: u1,
            /// Pending bit 20
            PR20: u1,
            /// Pending bit 21
            PR21: u1,
            /// Pending bit 22
            PR22: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Pending bit 29
            PR29: u1,
            /// Pending bit 30
            PR30: u1,
            /// Pending bit 31
            PR31: u1,
        }), base_address + 0x14);

        /// address: 0x40010418
        /// Interrupt mask register
        pub const IMR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt Mask on external/internal line
            /// 32
            MR32: u1,
            /// Interrupt Mask on external/internal line
            /// 33
            MR33: u1,
            /// Interrupt Mask on external/internal line
            /// 34
            MR34: u1,
            /// Interrupt Mask on external/internal line
            /// 35
            MR35: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x18);

        /// address: 0x4001041c
        /// Event mask register
        pub const EMR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Event mask on external/internal line
            /// 32
            MR32: u1,
            /// Event mask on external/internal line
            /// 33
            MR33: u1,
            /// Event mask on external/internal line
            /// 34
            MR34: u1,
            /// Event mask on external/internal line
            /// 35
            MR35: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x1c);

        /// address: 0x40010420
        /// Rising Trigger selection
        /// register
        pub const RTSR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rising trigger event configuration bit
            /// of line 32
            TR32: u1,
            /// Rising trigger event configuration bit
            /// of line 33
            TR33: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x20);

        /// address: 0x40010424
        /// Falling Trigger selection
        /// register
        pub const FTSR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Falling trigger event configuration bit
            /// of line 32
            TR32: u1,
            /// Falling trigger event configuration bit
            /// of line 33
            TR33: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x24);

        /// address: 0x40010428
        /// Software interrupt event
        /// register
        pub const SWIER2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software interrupt on line
            /// 32
            SWIER32: u1,
            /// Software interrupt on line
            /// 33
            SWIER33: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x28);

        /// address: 0x4001042c
        /// Pending register
        pub const PR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pending bit on line 32
            PR32: u1,
            /// Pending bit on line 33
            PR33: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x2c);
    };
    /// Power control
    pub const PWR = struct {
        pub const base_address = 0x40007000;

        /// address: 0x40007000
        /// power control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low-power deep sleep
            LPDS: u1,
            /// Power down deepsleep
            PDDS: u1,
            /// Clear wakeup flag
            CWUF: u1,
            /// Clear standby flag
            CSBF: u1,
            /// Power voltage detector
            /// enable
            PVDE: u1,
            /// PVD level selection
            PLS: u3,
            /// Disable backup domain write
            /// protection
            DBP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x0);

        /// address: 0x40007004
        /// power control/status register
        pub const CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup flag
            WUF: u1,
            /// Standby flag
            SBF: u1,
            /// PVD output
            PVDO: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Enable WKUP1 pin
            EWUP1: u1,
            /// Enable WKUP2 pin
            EWUP2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x4);
    };
    /// Controller area network
    pub const CAN = struct {
        pub const base_address = 0x40006400;

        /// address: 0x40006400
        /// master control register
        pub const MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INRQ
            INRQ: u1,
            /// SLEEP
            SLEEP: u1,
            /// TXFP
            TXFP: u1,
            /// RFLM
            RFLM: u1,
            /// NART
            NART: u1,
            /// AWUM
            AWUM: u1,
            /// ABOM
            ABOM: u1,
            /// TTCM
            TTCM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// RESET
            RESET: u1,
            /// DBF
            DBF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x0);

        /// address: 0x40006404
        /// master status register
        pub const MSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INAK
            INAK: u1,
            /// SLAK
            SLAK: u1,
            /// ERRI
            ERRI: u1,
            /// WKUI
            WKUI: u1,
            /// SLAKI
            SLAKI: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// TXM
            TXM: u1,
            /// RXM
            RXM: u1,
            /// SAMP
            SAMP: u1,
            /// RX
            RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x4);

        /// address: 0x40006408
        /// transmit status register
        pub const TSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RQCP0
            RQCP0: u1,
            /// TXOK0
            TXOK0: u1,
            /// ALST0
            ALST0: u1,
            /// TERR0
            TERR0: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// ABRQ0
            ABRQ0: u1,
            /// RQCP1
            RQCP1: u1,
            /// TXOK1
            TXOK1: u1,
            /// ALST1
            ALST1: u1,
            /// TERR1
            TERR1: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// ABRQ1
            ABRQ1: u1,
            /// RQCP2
            RQCP2: u1,
            /// TXOK2
            TXOK2: u1,
            /// ALST2
            ALST2: u1,
            /// TERR2
            TERR2: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// ABRQ2
            ABRQ2: u1,
            /// CODE
            CODE: u2,
            /// Lowest priority flag for mailbox
            /// 0
            TME0: u1,
            /// Lowest priority flag for mailbox
            /// 1
            TME1: u1,
            /// Lowest priority flag for mailbox
            /// 2
            TME2: u1,
            /// Lowest priority flag for mailbox
            /// 0
            LOW0: u1,
            /// Lowest priority flag for mailbox
            /// 1
            LOW1: u1,
            /// Lowest priority flag for mailbox
            /// 2
            LOW2: u1,
        }), base_address + 0x8);

        /// address: 0x4000640c
        /// receive FIFO 0 register
        pub const RF0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// FMP0
            FMP0: u2,
            reserved0: u1,
            /// FULL0
            FULL0: u1,
            /// FOVR0
            FOVR0: u1,
            /// RFOM0
            RFOM0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xc);

        /// address: 0x40006410
        /// receive FIFO 1 register
        pub const RF1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// FMP1
            FMP1: u2,
            reserved0: u1,
            /// FULL1
            FULL1: u1,
            /// FOVR1
            FOVR1: u1,
            /// RFOM1
            RFOM1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x10);

        /// address: 0x40006414
        /// interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// TMEIE
            TMEIE: u1,
            /// FMPIE0
            FMPIE0: u1,
            /// FFIE0
            FFIE0: u1,
            /// FOVIE0
            FOVIE0: u1,
            /// FMPIE1
            FMPIE1: u1,
            /// FFIE1
            FFIE1: u1,
            /// FOVIE1
            FOVIE1: u1,
            reserved0: u1,
            /// EWGIE
            EWGIE: u1,
            /// EPVIE
            EPVIE: u1,
            /// BOFIE
            BOFIE: u1,
            /// LECIE
            LECIE: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// ERRIE
            ERRIE: u1,
            /// WKUIE
            WKUIE: u1,
            /// SLKIE
            SLKIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x14);

        /// address: 0x40006418
        /// error status register
        pub const ESR = @intToPtr(*volatile Mmio(32, packed struct {
            /// EWGF
            EWGF: u1,
            /// EPVF
            EPVF: u1,
            /// BOFF
            BOFF: u1,
            reserved0: u1,
            /// LEC
            LEC: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// TEC
            TEC: u8,
            /// REC
            REC: u8,
        }), base_address + 0x18);

        /// address: 0x4000641c
        /// bit timing register
        pub const BTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRP
            BRP: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// TS1
            TS1: u4,
            /// TS2
            TS2: u3,
            reserved6: u1,
            /// SJW
            SJW: u2,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// LBKM
            LBKM: u1,
            /// SILM
            SILM: u1,
        }), base_address + 0x1c);

        /// address: 0x40006580
        /// TX mailbox identifier register
        pub const TI0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXRQ
            TXRQ: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x180);

        /// address: 0x40006584
        /// mailbox data length control and time stamp
        /// register
        pub const TDT0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TGT
            TGT: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIME
            TIME: u16,
        }), base_address + 0x184);

        /// address: 0x40006588
        /// mailbox data low register
        pub const TDL0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x188);

        /// address: 0x4000658c
        /// mailbox data high register
        pub const TDH0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x18c);

        /// address: 0x40006590
        /// TX mailbox identifier register
        pub const TI1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXRQ
            TXRQ: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x190);

        /// address: 0x40006594
        /// mailbox data length control and time stamp
        /// register
        pub const TDT1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TGT
            TGT: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIME
            TIME: u16,
        }), base_address + 0x194);

        /// address: 0x40006598
        /// mailbox data low register
        pub const TDL1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x198);

        /// address: 0x4000659c
        /// mailbox data high register
        pub const TDH1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x19c);

        /// address: 0x400065a0
        /// TX mailbox identifier register
        pub const TI2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXRQ
            TXRQ: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x1a0);

        /// address: 0x400065a4
        /// mailbox data length control and time stamp
        /// register
        pub const TDT2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TGT
            TGT: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIME
            TIME: u16,
        }), base_address + 0x1a4);

        /// address: 0x400065a8
        /// mailbox data low register
        pub const TDL2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x1a8);

        /// address: 0x400065ac
        /// mailbox data high register
        pub const TDH2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x1ac);

        /// address: 0x400065b0
        /// receive FIFO mailbox identifier
        /// register
        pub const RI0R = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x1b0);

        /// address: 0x400065b4
        /// receive FIFO mailbox data length control and
        /// time stamp register
        pub const RDT0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// FMI
            FMI: u8,
            /// TIME
            TIME: u16,
        }), base_address + 0x1b4);

        /// address: 0x400065b8
        /// receive FIFO mailbox data low
        /// register
        pub const RDL0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x1b8);

        /// address: 0x400065bc
        /// receive FIFO mailbox data high
        /// register
        pub const RDH0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x1bc);

        /// address: 0x400065c0
        /// receive FIFO mailbox identifier
        /// register
        pub const RI1R = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x1c0);

        /// address: 0x400065c4
        /// receive FIFO mailbox data length control and
        /// time stamp register
        pub const RDT1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// FMI
            FMI: u8,
            /// TIME
            TIME: u16,
        }), base_address + 0x1c4);

        /// address: 0x400065c8
        /// receive FIFO mailbox data low
        /// register
        pub const RDL1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x1c8);

        /// address: 0x400065cc
        /// receive FIFO mailbox data high
        /// register
        pub const RDH1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x1cc);

        /// address: 0x40006600
        /// filter master register
        pub const FMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter init mode
            FINIT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// CAN2 start bank
            CAN2SB: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x200);

        /// address: 0x40006604
        /// filter mode register
        pub const FM1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter mode
            FBM0: u1,
            /// Filter mode
            FBM1: u1,
            /// Filter mode
            FBM2: u1,
            /// Filter mode
            FBM3: u1,
            /// Filter mode
            FBM4: u1,
            /// Filter mode
            FBM5: u1,
            /// Filter mode
            FBM6: u1,
            /// Filter mode
            FBM7: u1,
            /// Filter mode
            FBM8: u1,
            /// Filter mode
            FBM9: u1,
            /// Filter mode
            FBM10: u1,
            /// Filter mode
            FBM11: u1,
            /// Filter mode
            FBM12: u1,
            /// Filter mode
            FBM13: u1,
            /// Filter mode
            FBM14: u1,
            /// Filter mode
            FBM15: u1,
            /// Filter mode
            FBM16: u1,
            /// Filter mode
            FBM17: u1,
            /// Filter mode
            FBM18: u1,
            /// Filter mode
            FBM19: u1,
            /// Filter mode
            FBM20: u1,
            /// Filter mode
            FBM21: u1,
            /// Filter mode
            FBM22: u1,
            /// Filter mode
            FBM23: u1,
            /// Filter mode
            FBM24: u1,
            /// Filter mode
            FBM25: u1,
            /// Filter mode
            FBM26: u1,
            /// Filter mode
            FBM27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x204);

        /// address: 0x4000660c
        /// filter scale register
        pub const FS1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter scale configuration
            FSC0: u1,
            /// Filter scale configuration
            FSC1: u1,
            /// Filter scale configuration
            FSC2: u1,
            /// Filter scale configuration
            FSC3: u1,
            /// Filter scale configuration
            FSC4: u1,
            /// Filter scale configuration
            FSC5: u1,
            /// Filter scale configuration
            FSC6: u1,
            /// Filter scale configuration
            FSC7: u1,
            /// Filter scale configuration
            FSC8: u1,
            /// Filter scale configuration
            FSC9: u1,
            /// Filter scale configuration
            FSC10: u1,
            /// Filter scale configuration
            FSC11: u1,
            /// Filter scale configuration
            FSC12: u1,
            /// Filter scale configuration
            FSC13: u1,
            /// Filter scale configuration
            FSC14: u1,
            /// Filter scale configuration
            FSC15: u1,
            /// Filter scale configuration
            FSC16: u1,
            /// Filter scale configuration
            FSC17: u1,
            /// Filter scale configuration
            FSC18: u1,
            /// Filter scale configuration
            FSC19: u1,
            /// Filter scale configuration
            FSC20: u1,
            /// Filter scale configuration
            FSC21: u1,
            /// Filter scale configuration
            FSC22: u1,
            /// Filter scale configuration
            FSC23: u1,
            /// Filter scale configuration
            FSC24: u1,
            /// Filter scale configuration
            FSC25: u1,
            /// Filter scale configuration
            FSC26: u1,
            /// Filter scale configuration
            FSC27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20c);

        /// address: 0x40006614
        /// filter FIFO assignment
        /// register
        pub const FFA1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter FIFO assignment for filter
            /// 0
            FFA0: u1,
            /// Filter FIFO assignment for filter
            /// 1
            FFA1: u1,
            /// Filter FIFO assignment for filter
            /// 2
            FFA2: u1,
            /// Filter FIFO assignment for filter
            /// 3
            FFA3: u1,
            /// Filter FIFO assignment for filter
            /// 4
            FFA4: u1,
            /// Filter FIFO assignment for filter
            /// 5
            FFA5: u1,
            /// Filter FIFO assignment for filter
            /// 6
            FFA6: u1,
            /// Filter FIFO assignment for filter
            /// 7
            FFA7: u1,
            /// Filter FIFO assignment for filter
            /// 8
            FFA8: u1,
            /// Filter FIFO assignment for filter
            /// 9
            FFA9: u1,
            /// Filter FIFO assignment for filter
            /// 10
            FFA10: u1,
            /// Filter FIFO assignment for filter
            /// 11
            FFA11: u1,
            /// Filter FIFO assignment for filter
            /// 12
            FFA12: u1,
            /// Filter FIFO assignment for filter
            /// 13
            FFA13: u1,
            /// Filter FIFO assignment for filter
            /// 14
            FFA14: u1,
            /// Filter FIFO assignment for filter
            /// 15
            FFA15: u1,
            /// Filter FIFO assignment for filter
            /// 16
            FFA16: u1,
            /// Filter FIFO assignment for filter
            /// 17
            FFA17: u1,
            /// Filter FIFO assignment for filter
            /// 18
            FFA18: u1,
            /// Filter FIFO assignment for filter
            /// 19
            FFA19: u1,
            /// Filter FIFO assignment for filter
            /// 20
            FFA20: u1,
            /// Filter FIFO assignment for filter
            /// 21
            FFA21: u1,
            /// Filter FIFO assignment for filter
            /// 22
            FFA22: u1,
            /// Filter FIFO assignment for filter
            /// 23
            FFA23: u1,
            /// Filter FIFO assignment for filter
            /// 24
            FFA24: u1,
            /// Filter FIFO assignment for filter
            /// 25
            FFA25: u1,
            /// Filter FIFO assignment for filter
            /// 26
            FFA26: u1,
            /// Filter FIFO assignment for filter
            /// 27
            FFA27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x214);

        /// address: 0x4000661c
        /// CAN filter activation register
        pub const FA1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter active
            FACT0: u1,
            /// Filter active
            FACT1: u1,
            /// Filter active
            FACT2: u1,
            /// Filter active
            FACT3: u1,
            /// Filter active
            FACT4: u1,
            /// Filter active
            FACT5: u1,
            /// Filter active
            FACT6: u1,
            /// Filter active
            FACT7: u1,
            /// Filter active
            FACT8: u1,
            /// Filter active
            FACT9: u1,
            /// Filter active
            FACT10: u1,
            /// Filter active
            FACT11: u1,
            /// Filter active
            FACT12: u1,
            /// Filter active
            FACT13: u1,
            /// Filter active
            FACT14: u1,
            /// Filter active
            FACT15: u1,
            /// Filter active
            FACT16: u1,
            /// Filter active
            FACT17: u1,
            /// Filter active
            FACT18: u1,
            /// Filter active
            FACT19: u1,
            /// Filter active
            FACT20: u1,
            /// Filter active
            FACT21: u1,
            /// Filter active
            FACT22: u1,
            /// Filter active
            FACT23: u1,
            /// Filter active
            FACT24: u1,
            /// Filter active
            FACT25: u1,
            /// Filter active
            FACT26: u1,
            /// Filter active
            FACT27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x21c);

        /// address: 0x40006640
        /// Filter bank 0 register 1
        pub const F0R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x240);

        /// address: 0x40006644
        /// Filter bank 0 register 2
        pub const F0R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x244);

        /// address: 0x40006648
        /// Filter bank 1 register 1
        pub const F1R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x248);

        /// address: 0x4000664c
        /// Filter bank 1 register 2
        pub const F1R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x24c);

        /// address: 0x40006650
        /// Filter bank 2 register 1
        pub const F2R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x250);

        /// address: 0x40006654
        /// Filter bank 2 register 2
        pub const F2R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x254);

        /// address: 0x40006658
        /// Filter bank 3 register 1
        pub const F3R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x258);

        /// address: 0x4000665c
        /// Filter bank 3 register 2
        pub const F3R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x25c);

        /// address: 0x40006660
        /// Filter bank 4 register 1
        pub const F4R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x260);

        /// address: 0x40006664
        /// Filter bank 4 register 2
        pub const F4R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x264);

        /// address: 0x40006668
        /// Filter bank 5 register 1
        pub const F5R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x268);

        /// address: 0x4000666c
        /// Filter bank 5 register 2
        pub const F5R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x26c);

        /// address: 0x40006670
        /// Filter bank 6 register 1
        pub const F6R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x270);

        /// address: 0x40006674
        /// Filter bank 6 register 2
        pub const F6R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x274);

        /// address: 0x40006678
        /// Filter bank 7 register 1
        pub const F7R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x278);

        /// address: 0x4000667c
        /// Filter bank 7 register 2
        pub const F7R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x27c);

        /// address: 0x40006680
        /// Filter bank 8 register 1
        pub const F8R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x280);

        /// address: 0x40006684
        /// Filter bank 8 register 2
        pub const F8R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x284);

        /// address: 0x40006688
        /// Filter bank 9 register 1
        pub const F9R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x288);

        /// address: 0x4000668c
        /// Filter bank 9 register 2
        pub const F9R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x28c);

        /// address: 0x40006690
        /// Filter bank 10 register 1
        pub const F10R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x290);

        /// address: 0x40006694
        /// Filter bank 10 register 2
        pub const F10R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x294);

        /// address: 0x40006698
        /// Filter bank 11 register 1
        pub const F11R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x298);

        /// address: 0x4000669c
        /// Filter bank 11 register 2
        pub const F11R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x29c);

        /// address: 0x400066a0
        /// Filter bank 4 register 1
        pub const F12R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2a0);

        /// address: 0x400066a4
        /// Filter bank 12 register 2
        pub const F12R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2a4);

        /// address: 0x400066a8
        /// Filter bank 13 register 1
        pub const F13R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2a8);

        /// address: 0x400066ac
        /// Filter bank 13 register 2
        pub const F13R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2ac);

        /// address: 0x400066b0
        /// Filter bank 14 register 1
        pub const F14R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2b0);

        /// address: 0x400066b4
        /// Filter bank 14 register 2
        pub const F14R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2b4);

        /// address: 0x400066b8
        /// Filter bank 15 register 1
        pub const F15R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2b8);

        /// address: 0x400066bc
        /// Filter bank 15 register 2
        pub const F15R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2bc);

        /// address: 0x400066c0
        /// Filter bank 16 register 1
        pub const F16R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2c0);

        /// address: 0x400066c4
        /// Filter bank 16 register 2
        pub const F16R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2c4);

        /// address: 0x400066c8
        /// Filter bank 17 register 1
        pub const F17R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2c8);

        /// address: 0x400066cc
        /// Filter bank 17 register 2
        pub const F17R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2cc);

        /// address: 0x400066d0
        /// Filter bank 18 register 1
        pub const F18R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2d0);

        /// address: 0x400066d4
        /// Filter bank 18 register 2
        pub const F18R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2d4);

        /// address: 0x400066d8
        /// Filter bank 19 register 1
        pub const F19R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2d8);

        /// address: 0x400066dc
        /// Filter bank 19 register 2
        pub const F19R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2dc);

        /// address: 0x400066e0
        /// Filter bank 20 register 1
        pub const F20R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2e0);

        /// address: 0x400066e4
        /// Filter bank 20 register 2
        pub const F20R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2e4);

        /// address: 0x400066e8
        /// Filter bank 21 register 1
        pub const F21R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2e8);

        /// address: 0x400066ec
        /// Filter bank 21 register 2
        pub const F21R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2ec);

        /// address: 0x400066f0
        /// Filter bank 22 register 1
        pub const F22R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2f0);

        /// address: 0x400066f4
        /// Filter bank 22 register 2
        pub const F22R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2f4);

        /// address: 0x400066f8
        /// Filter bank 23 register 1
        pub const F23R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2f8);

        /// address: 0x400066fc
        /// Filter bank 23 register 2
        pub const F23R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2fc);

        /// address: 0x40006700
        /// Filter bank 24 register 1
        pub const F24R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x300);

        /// address: 0x40006704
        /// Filter bank 24 register 2
        pub const F24R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x304);

        /// address: 0x40006708
        /// Filter bank 25 register 1
        pub const F25R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x308);

        /// address: 0x4000670c
        /// Filter bank 25 register 2
        pub const F25R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x30c);

        /// address: 0x40006710
        /// Filter bank 26 register 1
        pub const F26R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x310);

        /// address: 0x40006714
        /// Filter bank 26 register 2
        pub const F26R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x314);

        /// address: 0x40006718
        /// Filter bank 27 register 1
        pub const F27R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x318);

        /// address: 0x4000671c
        /// Filter bank 27 register 2
        pub const F27R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x31c);
    };
    /// Universal serial bus full-speed device
    /// interface
    pub const USB_FS = struct {
        pub const base_address = 0x40005c00;

        /// address: 0x40005c00
        /// endpoint 0 register
        pub const USB_EP0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40005c04
        /// endpoint 1 register
        pub const USB_EP1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x40005c08
        /// endpoint 2 register
        pub const USB_EP2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x40005c0c
        /// endpoint 3 register
        pub const USB_EP3R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40005c10
        /// endpoint 4 register
        pub const USB_EP4R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40005c14
        /// endpoint 5 register
        pub const USB_EP5R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40005c18
        /// endpoint 6 register
        pub const USB_EP6R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40005c1c
        /// endpoint 7 register
        pub const USB_EP7R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40005c40
        /// control register
        pub const USB_CNTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Force USB Reset
            FRES: u1,
            /// Power down
            PDWN: u1,
            /// Low-power mode
            LPMODE: u1,
            /// Force suspend
            FSUSP: u1,
            /// Resume request
            RESUME: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Expected start of frame interrupt
            /// mask
            ESOFM: u1,
            /// Start of frame interrupt
            /// mask
            SOFM: u1,
            /// USB reset interrupt mask
            RESETM: u1,
            /// Suspend mode interrupt
            /// mask
            SUSPM: u1,
            /// Wakeup interrupt mask
            WKUPM: u1,
            /// Error interrupt mask
            ERRM: u1,
            /// Packet memory area over / underrun
            /// interrupt mask
            PMAOVRM: u1,
            /// Correct transfer interrupt
            /// mask
            CTRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x40005c44
        /// interrupt status register
        pub const ISTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint Identifier
            EP_ID: u4,
            /// Direction of transaction
            DIR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Expected start frame
            ESOF: u1,
            /// start of frame
            SOF: u1,
            /// reset request
            RESET: u1,
            /// Suspend mode request
            SUSP: u1,
            /// Wakeup
            WKUP: u1,
            /// Error
            ERR: u1,
            /// Packet memory area over /
            /// underrun
            PMAOVR: u1,
            /// Correct transfer
            CTR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);

        /// address: 0x40005c48
        /// frame number register
        pub const FNR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame number
            FN: u11,
            /// Lost SOF
            LSOF: u2,
            /// Locked
            LCK: u1,
            /// Receive data - line status
            RXDM: u1,
            /// Receive data + line status
            RXDP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x40005c4c
        /// device address
        pub const DADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADD: u1,
            /// Device address
            ADD1: u1,
            /// Device address
            ADD2: u1,
            /// Device address
            ADD3: u1,
            /// Device address
            ADD4: u1,
            /// Device address
            ADD5: u1,
            /// Device address
            ADD6: u1,
            /// Enable function
            EF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4c);

        /// address: 0x40005c50
        /// Buffer table address
        pub const BTABLE = @intToPtr(*volatile MmioInt(32, u13), base_address + 0x50);
    };
    /// Inter-integrated circuit
    pub const I2C1 = struct {
        pub const base_address = 0x40005400;

        /// address: 0x40005400
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1,
            /// TX Interrupt enable
            TXIE: u1,
            /// RX Interrupt enable
            RXIE: u1,
            /// Address match interrupt enable (slave
            /// only)
            ADDRIE: u1,
            /// Not acknowledge received interrupt
            /// enable
            NACKIE: u1,
            /// STOP detection Interrupt
            /// enable
            STOPIE: u1,
            /// Transfer Complete interrupt
            /// enable
            TCIE: u1,
            /// Error interrupts enable
            ERRIE: u1,
            /// Digital noise filter
            DNF: u4,
            /// Analog noise filter OFF
            ANFOFF: u1,
            /// Software reset
            SWRST: u1,
            /// DMA transmission requests
            /// enable
            TXDMAEN: u1,
            /// DMA reception requests
            /// enable
            RXDMAEN: u1,
            /// Slave byte control
            SBC: u1,
            /// Clock stretching disable
            NOSTRETCH: u1,
            /// Wakeup from STOP enable
            WUPEN: u1,
            /// General call enable
            GCEN: u1,
            /// SMBus Host address enable
            SMBHEN: u1,
            /// SMBus Device Default address
            /// enable
            SMBDEN: u1,
            /// SMBUS alert enable
            ALERTEN: u1,
            /// PEC enable
            PECEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40005404
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave address bit 0 (master
            /// mode)
            SADD0: u1,
            /// Slave address bit 7:1 (master
            /// mode)
            SADD1: u7,
            /// Slave address bit 9:8 (master
            /// mode)
            SADD8: u2,
            /// Transfer direction (master
            /// mode)
            RD_WRN: u1,
            /// 10-bit addressing mode (master
            /// mode)
            ADD10: u1,
            /// 10-bit address header only read
            /// direction (master receiver mode)
            HEAD10R: u1,
            /// Start generation
            START: u1,
            /// Stop generation (master
            /// mode)
            STOP: u1,
            /// NACK generation (slave
            /// mode)
            NACK: u1,
            /// Number of bytes
            NBYTES: u8,
            /// NBYTES reload mode
            RELOAD: u1,
            /// Automatic end mode (master
            /// mode)
            AUTOEND: u1,
            /// Packet error checking byte
            PECBYTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40005408
        /// Own address register 1
        pub const OAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interface address
            OA1_0: u1,
            /// Interface address
            OA1_1: u7,
            /// Interface address
            OA1_8: u2,
            /// Own Address 1 10-bit mode
            OA1MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Own Address 1 enable
            OA1EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000540c
        /// Own address register 2
        pub const OAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Interface address
            OA2: u7,
            /// Own Address 2 masks
            OA2MSK: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Own Address 2 enable
            OA2EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40005410
        /// Timing register
        pub const TIMINGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCL low period (master
            /// mode)
            SCLL: u8,
            /// SCL high period (master
            /// mode)
            SCLH: u8,
            /// Data hold time
            SDADEL: u4,
            /// Data setup time
            SCLDEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Timing prescaler
            PRESC: u4,
        }), base_address + 0x10);

        /// address: 0x40005414
        /// Status register 1
        pub const TIMEOUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bus timeout A
            TIMEOUTA: u12,
            /// Idle clock timeout
            /// detection
            TIDLE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock timeout enable
            TIMOUTEN: u1,
            /// Bus timeout B
            TIMEOUTB: u12,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extended clock timeout
            /// enable
            TEXTEN: u1,
        }), base_address + 0x14);

        /// address: 0x40005418
        /// Interrupt and Status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data register empty
            /// (transmitters)
            TXE: u1,
            /// Transmit interrupt status
            /// (transmitters)
            TXIS: u1,
            /// Receive data register not empty
            /// (receivers)
            RXNE: u1,
            /// Address matched (slave
            /// mode)
            ADDR: u1,
            /// Not acknowledge received
            /// flag
            NACKF: u1,
            /// Stop detection flag
            STOPF: u1,
            /// Transfer Complete (master
            /// mode)
            TC: u1,
            /// Transfer Complete Reload
            TCR: u1,
            /// Bus error
            BERR: u1,
            /// Arbitration lost
            ARLO: u1,
            /// Overrun/Underrun (slave
            /// mode)
            OVR: u1,
            /// PEC Error in reception
            PECERR: u1,
            /// Timeout or t_low detection
            /// flag
            TIMEOUT: u1,
            /// SMBus alert
            ALERT: u1,
            reserved0: u1,
            /// Bus busy
            BUSY: u1,
            /// Transfer direction (Slave
            /// mode)
            DIR: u1,
            /// Address match code (Slave
            /// mode)
            ADDCODE: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0x4000541c
        /// Interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Address Matched flag clear
            ADDRCF: u1,
            /// Not Acknowledge flag clear
            NACKCF: u1,
            /// Stop detection flag clear
            STOPCF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Bus error flag clear
            BERRCF: u1,
            /// Arbitration lost flag
            /// clear
            ARLOCF: u1,
            /// Overrun/Underrun flag
            /// clear
            OVRCF: u1,
            /// PEC Error flag clear
            PECCF: u1,
            /// Timeout detection flag
            /// clear
            TIMOUTCF: u1,
            /// Alert flag clear
            ALERTCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1c);

        /// address: 0x40005420
        /// PEC register
        pub const PECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet error checking
            /// register
            PEC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40005424
        /// Receive data register
        pub const RXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit receive data
            RXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40005428
        /// Transmit data register
        pub const TXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit transmit data
            TXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x28);
    };
    pub const I2C2 = struct {
        pub const base_address = 0x40005800;

        /// address: 0x40005800
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1,
            /// TX Interrupt enable
            TXIE: u1,
            /// RX Interrupt enable
            RXIE: u1,
            /// Address match interrupt enable (slave
            /// only)
            ADDRIE: u1,
            /// Not acknowledge received interrupt
            /// enable
            NACKIE: u1,
            /// STOP detection Interrupt
            /// enable
            STOPIE: u1,
            /// Transfer Complete interrupt
            /// enable
            TCIE: u1,
            /// Error interrupts enable
            ERRIE: u1,
            /// Digital noise filter
            DNF: u4,
            /// Analog noise filter OFF
            ANFOFF: u1,
            /// Software reset
            SWRST: u1,
            /// DMA transmission requests
            /// enable
            TXDMAEN: u1,
            /// DMA reception requests
            /// enable
            RXDMAEN: u1,
            /// Slave byte control
            SBC: u1,
            /// Clock stretching disable
            NOSTRETCH: u1,
            /// Wakeup from STOP enable
            WUPEN: u1,
            /// General call enable
            GCEN: u1,
            /// SMBus Host address enable
            SMBHEN: u1,
            /// SMBus Device Default address
            /// enable
            SMBDEN: u1,
            /// SMBUS alert enable
            ALERTEN: u1,
            /// PEC enable
            PECEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40005804
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave address bit 0 (master
            /// mode)
            SADD0: u1,
            /// Slave address bit 7:1 (master
            /// mode)
            SADD1: u7,
            /// Slave address bit 9:8 (master
            /// mode)
            SADD8: u2,
            /// Transfer direction (master
            /// mode)
            RD_WRN: u1,
            /// 10-bit addressing mode (master
            /// mode)
            ADD10: u1,
            /// 10-bit address header only read
            /// direction (master receiver mode)
            HEAD10R: u1,
            /// Start generation
            START: u1,
            /// Stop generation (master
            /// mode)
            STOP: u1,
            /// NACK generation (slave
            /// mode)
            NACK: u1,
            /// Number of bytes
            NBYTES: u8,
            /// NBYTES reload mode
            RELOAD: u1,
            /// Automatic end mode (master
            /// mode)
            AUTOEND: u1,
            /// Packet error checking byte
            PECBYTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40005808
        /// Own address register 1
        pub const OAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interface address
            OA1_0: u1,
            /// Interface address
            OA1_1: u7,
            /// Interface address
            OA1_8: u2,
            /// Own Address 1 10-bit mode
            OA1MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Own Address 1 enable
            OA1EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000580c
        /// Own address register 2
        pub const OAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Interface address
            OA2: u7,
            /// Own Address 2 masks
            OA2MSK: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Own Address 2 enable
            OA2EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40005810
        /// Timing register
        pub const TIMINGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCL low period (master
            /// mode)
            SCLL: u8,
            /// SCL high period (master
            /// mode)
            SCLH: u8,
            /// Data hold time
            SDADEL: u4,
            /// Data setup time
            SCLDEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Timing prescaler
            PRESC: u4,
        }), base_address + 0x10);

        /// address: 0x40005814
        /// Status register 1
        pub const TIMEOUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bus timeout A
            TIMEOUTA: u12,
            /// Idle clock timeout
            /// detection
            TIDLE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock timeout enable
            TIMOUTEN: u1,
            /// Bus timeout B
            TIMEOUTB: u12,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extended clock timeout
            /// enable
            TEXTEN: u1,
        }), base_address + 0x14);

        /// address: 0x40005818
        /// Interrupt and Status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data register empty
            /// (transmitters)
            TXE: u1,
            /// Transmit interrupt status
            /// (transmitters)
            TXIS: u1,
            /// Receive data register not empty
            /// (receivers)
            RXNE: u1,
            /// Address matched (slave
            /// mode)
            ADDR: u1,
            /// Not acknowledge received
            /// flag
            NACKF: u1,
            /// Stop detection flag
            STOPF: u1,
            /// Transfer Complete (master
            /// mode)
            TC: u1,
            /// Transfer Complete Reload
            TCR: u1,
            /// Bus error
            BERR: u1,
            /// Arbitration lost
            ARLO: u1,
            /// Overrun/Underrun (slave
            /// mode)
            OVR: u1,
            /// PEC Error in reception
            PECERR: u1,
            /// Timeout or t_low detection
            /// flag
            TIMEOUT: u1,
            /// SMBus alert
            ALERT: u1,
            reserved0: u1,
            /// Bus busy
            BUSY: u1,
            /// Transfer direction (Slave
            /// mode)
            DIR: u1,
            /// Address match code (Slave
            /// mode)
            ADDCODE: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0x4000581c
        /// Interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Address Matched flag clear
            ADDRCF: u1,
            /// Not Acknowledge flag clear
            NACKCF: u1,
            /// Stop detection flag clear
            STOPCF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Bus error flag clear
            BERRCF: u1,
            /// Arbitration lost flag
            /// clear
            ARLOCF: u1,
            /// Overrun/Underrun flag
            /// clear
            OVRCF: u1,
            /// PEC Error flag clear
            PECCF: u1,
            /// Timeout detection flag
            /// clear
            TIMOUTCF: u1,
            /// Alert flag clear
            ALERTCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1c);

        /// address: 0x40005820
        /// PEC register
        pub const PECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet error checking
            /// register
            PEC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40005824
        /// Receive data register
        pub const RXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit receive data
            RXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40005828
        /// Transmit data register
        pub const TXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit transmit data
            TXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x28);
    };
    pub const I2C3 = struct {
        pub const base_address = 0x40007800;

        /// address: 0x40007800
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1,
            /// TX Interrupt enable
            TXIE: u1,
            /// RX Interrupt enable
            RXIE: u1,
            /// Address match interrupt enable (slave
            /// only)
            ADDRIE: u1,
            /// Not acknowledge received interrupt
            /// enable
            NACKIE: u1,
            /// STOP detection Interrupt
            /// enable
            STOPIE: u1,
            /// Transfer Complete interrupt
            /// enable
            TCIE: u1,
            /// Error interrupts enable
            ERRIE: u1,
            /// Digital noise filter
            DNF: u4,
            /// Analog noise filter OFF
            ANFOFF: u1,
            /// Software reset
            SWRST: u1,
            /// DMA transmission requests
            /// enable
            TXDMAEN: u1,
            /// DMA reception requests
            /// enable
            RXDMAEN: u1,
            /// Slave byte control
            SBC: u1,
            /// Clock stretching disable
            NOSTRETCH: u1,
            /// Wakeup from STOP enable
            WUPEN: u1,
            /// General call enable
            GCEN: u1,
            /// SMBus Host address enable
            SMBHEN: u1,
            /// SMBus Device Default address
            /// enable
            SMBDEN: u1,
            /// SMBUS alert enable
            ALERTEN: u1,
            /// PEC enable
            PECEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40007804
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave address bit 0 (master
            /// mode)
            SADD0: u1,
            /// Slave address bit 7:1 (master
            /// mode)
            SADD1: u7,
            /// Slave address bit 9:8 (master
            /// mode)
            SADD8: u2,
            /// Transfer direction (master
            /// mode)
            RD_WRN: u1,
            /// 10-bit addressing mode (master
            /// mode)
            ADD10: u1,
            /// 10-bit address header only read
            /// direction (master receiver mode)
            HEAD10R: u1,
            /// Start generation
            START: u1,
            /// Stop generation (master
            /// mode)
            STOP: u1,
            /// NACK generation (slave
            /// mode)
            NACK: u1,
            /// Number of bytes
            NBYTES: u8,
            /// NBYTES reload mode
            RELOAD: u1,
            /// Automatic end mode (master
            /// mode)
            AUTOEND: u1,
            /// Packet error checking byte
            PECBYTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40007808
        /// Own address register 1
        pub const OAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interface address
            OA1_0: u1,
            /// Interface address
            OA1_1: u7,
            /// Interface address
            OA1_8: u2,
            /// Own Address 1 10-bit mode
            OA1MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Own Address 1 enable
            OA1EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000780c
        /// Own address register 2
        pub const OAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Interface address
            OA2: u7,
            /// Own Address 2 masks
            OA2MSK: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Own Address 2 enable
            OA2EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40007810
        /// Timing register
        pub const TIMINGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCL low period (master
            /// mode)
            SCLL: u8,
            /// SCL high period (master
            /// mode)
            SCLH: u8,
            /// Data hold time
            SDADEL: u4,
            /// Data setup time
            SCLDEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Timing prescaler
            PRESC: u4,
        }), base_address + 0x10);

        /// address: 0x40007814
        /// Status register 1
        pub const TIMEOUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bus timeout A
            TIMEOUTA: u12,
            /// Idle clock timeout
            /// detection
            TIDLE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock timeout enable
            TIMOUTEN: u1,
            /// Bus timeout B
            TIMEOUTB: u12,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extended clock timeout
            /// enable
            TEXTEN: u1,
        }), base_address + 0x14);

        /// address: 0x40007818
        /// Interrupt and Status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data register empty
            /// (transmitters)
            TXE: u1,
            /// Transmit interrupt status
            /// (transmitters)
            TXIS: u1,
            /// Receive data register not empty
            /// (receivers)
            RXNE: u1,
            /// Address matched (slave
            /// mode)
            ADDR: u1,
            /// Not acknowledge received
            /// flag
            NACKF: u1,
            /// Stop detection flag
            STOPF: u1,
            /// Transfer Complete (master
            /// mode)
            TC: u1,
            /// Transfer Complete Reload
            TCR: u1,
            /// Bus error
            BERR: u1,
            /// Arbitration lost
            ARLO: u1,
            /// Overrun/Underrun (slave
            /// mode)
            OVR: u1,
            /// PEC Error in reception
            PECERR: u1,
            /// Timeout or t_low detection
            /// flag
            TIMEOUT: u1,
            /// SMBus alert
            ALERT: u1,
            reserved0: u1,
            /// Bus busy
            BUSY: u1,
            /// Transfer direction (Slave
            /// mode)
            DIR: u1,
            /// Address match code (Slave
            /// mode)
            ADDCODE: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0x4000781c
        /// Interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Address Matched flag clear
            ADDRCF: u1,
            /// Not Acknowledge flag clear
            NACKCF: u1,
            /// Stop detection flag clear
            STOPCF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Bus error flag clear
            BERRCF: u1,
            /// Arbitration lost flag
            /// clear
            ARLOCF: u1,
            /// Overrun/Underrun flag
            /// clear
            OVRCF: u1,
            /// PEC Error flag clear
            PECCF: u1,
            /// Timeout detection flag
            /// clear
            TIMOUTCF: u1,
            /// Alert flag clear
            ALERTCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1c);

        /// address: 0x40007820
        /// PEC register
        pub const PECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet error checking
            /// register
            PEC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40007824
        /// Receive data register
        pub const RXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit receive data
            RXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40007828
        /// Transmit data register
        pub const TXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit transmit data
            TXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x28);
    };
    /// Independent watchdog
    pub const IWDG = struct {
        pub const base_address = 0x40003000;

        /// address: 0x40003000
        /// Key register
        pub const KR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Key value
            KEY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40003004
        /// Prescaler register
        pub const PR = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x4);

        /// address: 0x40003008
        /// Reload register
        pub const RLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog counter reload
            /// value
            RL: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x8);

        /// address: 0x4000300c
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog prescaler value
            /// update
            PVU: u1,
            /// Watchdog counter reload value
            /// update
            RVU: u1,
            /// Watchdog counter window value
            /// update
            WVU: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xc);

        /// address: 0x40003010
        /// Window register
        pub const WINR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog counter window
            /// value
            WIN: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x10);
    };
    /// Window watchdog
    pub const WWDG = struct {
        pub const base_address = 0x40002c00;

        /// address: 0x40002c00
        /// Control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7-bit counter
            T: u7,
            /// Activation bit
            WDGA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40002c04
        /// Configuration register
        pub const CFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7-bit window value
            W: u7,
            /// Timer base
            WDGTB: u2,
            /// Early wakeup interrupt
            EWI: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x4);

        /// address: 0x40002c08
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Early wakeup interrupt
            /// flag
            EWIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x8);
    };
    /// Real-time clock
    pub const RTC = struct {
        pub const base_address = 0x40002800;

        /// address: 0x40002800
        /// time register
        pub const TR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4,
            /// Second tens in BCD format
            ST: u3,
            reserved0: u1,
            /// Minute units in BCD format
            MNU: u4,
            /// Minute tens in BCD format
            MNT: u3,
            reserved1: u1,
            /// Hour units in BCD format
            HU: u4,
            /// Hour tens in BCD format
            HT: u2,
            /// AM/PM notation
            PM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x0);

        /// address: 0x40002804
        /// date register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Date units in BCD format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            reserved0: u1,
            reserved1: u1,
            /// Month units in BCD format
            MU: u4,
            /// Month tens in BCD format
            MT: u1,
            /// Week day units
            WDU: u3,
            /// Year units in BCD format
            YU: u4,
            /// Year tens in BCD format
            YT: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40002808
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup clock selection
            WCKSEL: u3,
            /// Time-stamp event active
            /// edge
            TSEDGE: u1,
            /// Reference clock detection enable (50 or
            /// 60 Hz)
            REFCKON: u1,
            /// Bypass the shadow
            /// registers
            BYPSHAD: u1,
            /// Hour format
            FMT: u1,
            reserved0: u1,
            /// Alarm A enable
            ALRAE: u1,
            /// Alarm B enable
            ALRBE: u1,
            /// Wakeup timer enable
            WUTE: u1,
            /// Time stamp enable
            TSE: u1,
            /// Alarm A interrupt enable
            ALRAIE: u1,
            /// Alarm B interrupt enable
            ALRBIE: u1,
            /// Wakeup timer interrupt
            /// enable
            WUTIE: u1,
            /// Time-stamp interrupt
            /// enable
            TSIE: u1,
            /// Add 1 hour (summer time
            /// change)
            ADD1H: u1,
            /// Subtract 1 hour (winter time
            /// change)
            SUB1H: u1,
            /// Backup
            BKP: u1,
            /// Calibration output
            /// selection
            COSEL: u1,
            /// Output polarity
            POL: u1,
            /// Output selection
            OSEL: u2,
            /// Calibration output enable
            COE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x8);

        /// address: 0x4000280c
        /// initialization and status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alarm A write flag
            ALRAWF: u1,
            /// Alarm B write flag
            ALRBWF: u1,
            /// Wakeup timer write flag
            WUTWF: u1,
            /// Shift operation pending
            SHPF: u1,
            /// Initialization status flag
            INITS: u1,
            /// Registers synchronization
            /// flag
            RSF: u1,
            /// Initialization flag
            INITF: u1,
            /// Initialization mode
            INIT: u1,
            /// Alarm A flag
            ALRAF: u1,
            /// Alarm B flag
            ALRBF: u1,
            /// Wakeup timer flag
            WUTF: u1,
            /// Time-stamp flag
            TSF: u1,
            /// Time-stamp overflow flag
            TSOVF: u1,
            /// Tamper detection flag
            TAMP1F: u1,
            /// RTC_TAMP2 detection flag
            TAMP2F: u1,
            /// RTC_TAMP3 detection flag
            TAMP3F: u1,
            /// Recalibration pending Flag
            RECALPF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xc);

        /// address: 0x40002810
        /// prescaler register
        pub const PRER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Synchronous prescaler
            /// factor
            PREDIV_S: u15,
            reserved0: u1,
            /// Asynchronous prescaler
            /// factor
            PREDIV_A: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x10);

        /// address: 0x40002814
        /// wakeup timer register
        pub const WUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup auto-reload value
            /// bits
            WUT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x4000281c
        /// alarm A register
        pub const ALRMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4,
            /// Second tens in BCD format
            ST: u3,
            /// Alarm A seconds mask
            MSK1: u1,
            /// Minute units in BCD format
            MNU: u4,
            /// Minute tens in BCD format
            MNT: u3,
            /// Alarm A minutes mask
            MSK2: u1,
            /// Hour units in BCD format
            HU: u4,
            /// Hour tens in BCD format
            HT: u2,
            /// AM/PM notation
            PM: u1,
            /// Alarm A hours mask
            MSK3: u1,
            /// Date units or day in BCD
            /// format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            /// Week day selection
            WDSEL: u1,
            /// Alarm A date mask
            MSK4: u1,
        }), base_address + 0x1c);

        /// address: 0x40002820
        /// alarm B register
        pub const ALRMBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4,
            /// Second tens in BCD format
            ST: u3,
            /// Alarm B seconds mask
            MSK1: u1,
            /// Minute units in BCD format
            MNU: u4,
            /// Minute tens in BCD format
            MNT: u3,
            /// Alarm B minutes mask
            MSK2: u1,
            /// Hour units in BCD format
            HU: u4,
            /// Hour tens in BCD format
            HT: u2,
            /// AM/PM notation
            PM: u1,
            /// Alarm B hours mask
            MSK3: u1,
            /// Date units or day in BCD
            /// format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            /// Week day selection
            WDSEL: u1,
            /// Alarm B date mask
            MSK4: u1,
        }), base_address + 0x20);

        /// address: 0x40002824
        /// write protection register
        pub const WPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write protection key
            KEY: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40002828
        /// sub second register
        pub const SSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub second value
            SS: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x4000282c
        /// shift control register
        pub const SHIFTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Subtract a fraction of a
            /// second
            SUBFS: u15,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Add one second
            ADD1S: u1,
        }), base_address + 0x2c);

        /// address: 0x40002830
        /// time stamp time register
        pub const TSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4,
            /// Second tens in BCD format
            ST: u3,
            reserved0: u1,
            /// Minute units in BCD format
            MNU: u4,
            /// Minute tens in BCD format
            MNT: u3,
            reserved1: u1,
            /// Hour units in BCD format
            HU: u4,
            /// Hour tens in BCD format
            HT: u2,
            /// AM/PM notation
            PM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x30);

        /// address: 0x40002834
        /// time stamp date register
        pub const TSDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Date units in BCD format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            reserved0: u1,
            reserved1: u1,
            /// Month units in BCD format
            MU: u4,
            /// Month tens in BCD format
            MT: u1,
            /// Week day units
            WDU: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40002838
        /// timestamp sub second register
        pub const TSSSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub second value
            SS: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x38);

        /// address: 0x4000283c
        /// calibration register
        pub const CALR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Calibration minus
            CALM: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Use a 16-second calibration cycle
            /// period
            CALW16: u1,
            /// Use an 8-second calibration cycle
            /// period
            CALW8: u1,
            /// Increase frequency of RTC by 488.5
            /// ppm
            CALP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x3c);

        /// address: 0x40002840
        /// tamper and alternate function configuration
        /// register
        pub const TAFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tamper 1 detection enable
            TAMP1E: u1,
            /// Active level for tamper 1
            TAMP1TRG: u1,
            /// Tamper interrupt enable
            TAMPIE: u1,
            /// Tamper 2 detection enable
            TAMP2E: u1,
            /// Active level for tamper 2
            TAMP2TRG: u1,
            /// Tamper 3 detection enable
            TAMP3E: u1,
            /// Active level for tamper 3
            TAMP3TRG: u1,
            /// Activate timestamp on tamper detection
            /// event
            TAMPTS: u1,
            /// Tamper sampling frequency
            TAMPFREQ: u3,
            /// Tamper filter count
            TAMPFLT: u2,
            /// Tamper precharge duration
            TAMPPRCH: u2,
            /// TAMPER pull-up disable
            TAMPPUDIS: u1,
            reserved0: u1,
            reserved1: u1,
            /// PC13 value
            PC13VALUE: u1,
            /// PC13 mode
            PC13MODE: u1,
            /// PC14 value
            PC14VALUE: u1,
            /// PC 14 mode
            PC14MODE: u1,
            /// PC15 value
            PC15VALUE: u1,
            /// PC15 mode
            PC15MODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x40002844
        /// alarm A sub second register
        pub const ALRMASSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub seconds value
            SS: u15,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Mask the most-significant bits starting
            /// at this bit
            MASKSS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x44);

        /// address: 0x40002848
        /// alarm B sub second register
        pub const ALRMBSSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub seconds value
            SS: u15,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Mask the most-significant bits starting
            /// at this bit
            MASKSS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x48);

        /// address: 0x40002850
        /// backup register
        pub const BKP0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x50);

        /// address: 0x40002854
        /// backup register
        pub const BKP1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x54);

        /// address: 0x40002858
        /// backup register
        pub const BKP2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x58);

        /// address: 0x4000285c
        /// backup register
        pub const BKP3R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x5c);

        /// address: 0x40002860
        /// backup register
        pub const BKP4R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x60);

        /// address: 0x40002864
        /// backup register
        pub const BKP5R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x64);

        /// address: 0x40002868
        /// backup register
        pub const BKP6R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x68);

        /// address: 0x4000286c
        /// backup register
        pub const BKP7R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x6c);

        /// address: 0x40002870
        /// backup register
        pub const BKP8R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x70);

        /// address: 0x40002874
        /// backup register
        pub const BKP9R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x74);

        /// address: 0x40002878
        /// backup register
        pub const BKP10R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x78);

        /// address: 0x4000287c
        /// backup register
        pub const BKP11R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x7c);

        /// address: 0x40002880
        /// backup register
        pub const BKP12R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x80);

        /// address: 0x40002884
        /// backup register
        pub const BKP13R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x84);

        /// address: 0x40002888
        /// backup register
        pub const BKP14R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x88);

        /// address: 0x4000288c
        /// backup register
        pub const BKP15R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x8c);

        /// address: 0x40002890
        /// backup register
        pub const BKP16R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x90);

        /// address: 0x40002894
        /// backup register
        pub const BKP17R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x94);

        /// address: 0x40002898
        /// backup register
        pub const BKP18R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x98);

        /// address: 0x4000289c
        /// backup register
        pub const BKP19R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x9c);

        /// address: 0x400028a0
        /// backup register
        pub const BKP20R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xa0);

        /// address: 0x400028a4
        /// backup register
        pub const BKP21R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xa4);

        /// address: 0x400028a8
        /// backup register
        pub const BKP22R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xa8);

        /// address: 0x400028ac
        /// backup register
        pub const BKP23R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xac);

        /// address: 0x400028b0
        /// backup register
        pub const BKP24R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xb0);

        /// address: 0x400028b4
        /// backup register
        pub const BKP25R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xb4);

        /// address: 0x400028b8
        /// backup register
        pub const BKP26R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xb8);

        /// address: 0x400028bc
        /// backup register
        pub const BKP27R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xbc);

        /// address: 0x400028c0
        /// backup register
        pub const BKP28R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xc0);

        /// address: 0x400028c4
        /// backup register
        pub const BKP29R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xc4);

        /// address: 0x400028c8
        /// backup register
        pub const BKP30R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xc8);

        /// address: 0x400028cc
        /// backup register
        pub const BKP31R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xcc);
    };
    /// Basic timers
    pub const TIM6 = struct {
        pub const base_address = 0x40001000;

        /// address: 0x40001000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40001004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode selection
            MMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x4000100c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Update DMA request enable
            UDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0xc);

        /// address: 0x40001010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x10);

        /// address: 0x40001014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x14);

        /// address: 0x40001024
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low counter value
            CNT: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// UIF Copy
            UIFCPY: u1,
        }), base_address + 0x24);

        /// address: 0x40001028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000102c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);
    };
    pub const TIM7 = struct {
        pub const base_address = 0x40001400;

        /// address: 0x40001400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40001404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode selection
            MMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x4000140c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Update DMA request enable
            UDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0xc);

        /// address: 0x40001410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x10);

        /// address: 0x40001414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x14);

        /// address: 0x40001424
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low counter value
            CNT: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// UIF Copy
            UIFCPY: u1,
        }), base_address + 0x24);

        /// address: 0x40001428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000142c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);
    };
    /// Digital-to-analog converter
    pub const DAC = struct {
        pub const base_address = 0x40007400;

        /// address: 0x40007400
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 enable
            EN1: u1,
            /// DAC channel1 output buffer
            /// disable
            BOFF1: u1,
            /// DAC channel1 trigger
            /// enable
            TEN1: u1,
            /// DAC channel1 trigger
            /// selection
            TSEL1: u3,
            /// DAC channel1 noise/triangle wave
            /// generation enable
            WAVE1: u2,
            /// DAC channel1 mask/amplitude
            /// selector
            MAMP1: u4,
            /// DAC channel1 DMA enable
            DMAEN1: u1,
            /// DAC channel1 DMA Underrun Interrupt
            /// enable
            DMAUDRIE1: u1,
            reserved0: u1,
            reserved1: u1,
            /// DAC channel2 enable
            EN2: u1,
            /// DAC channel2 output buffer
            /// disable
            BOFF2: u1,
            /// DAC channel2 trigger
            /// enable
            TEN2: u1,
            /// DAC channel2 trigger
            /// selection
            TSEL2: u3,
            /// DAC channel2 noise/triangle wave
            /// generation enable
            WAVE2: u2,
            /// DAC channel2 mask/amplitude
            /// selector
            MAMP2: u4,
            /// DAC channel2 DMA enable
            DMAEN2: u1,
            /// DAC channel2 DMA underrun interrupt
            /// enable
            DMAUDRIE2: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x0);

        /// address: 0x40007404
        /// software trigger register
        pub const SWTRIGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 software
            /// trigger
            SWTRIG1: u1,
            /// DAC channel2 software
            /// trigger
            SWTRIG2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x4);

        /// address: 0x40007408
        /// channel1 12-bit right-aligned data holding
        /// register
        pub const DHR12R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 12-bit right-aligned
            /// data
            DACC1DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x8);

        /// address: 0x4000740c
        /// channel1 12-bit left aligned data holding
        /// register
        pub const DHR12L1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC channel1 12-bit left-aligned
            /// data
            DACC1DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40007410
        /// channel1 8-bit right aligned data holding
        /// register
        pub const DHR8R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 8-bit right-aligned
            /// data
            DACC1DHR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x40007414
        /// channel2 12-bit right aligned data holding
        /// register
        pub const DHR12R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel2 12-bit right-aligned
            /// data
            DACC2DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x14);

        /// address: 0x40007418
        /// channel2 12-bit left aligned data holding
        /// register
        pub const DHR12L2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC channel2 12-bit left-aligned
            /// data
            DACC2DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000741c
        /// channel2 8-bit right-aligned data holding
        /// register
        pub const DHR8R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel2 8-bit right-aligned
            /// data
            DACC2DHR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x40007420
        /// Dual DAC 12-bit right-aligned data holding
        /// register
        pub const DHR12RD = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 12-bit right-aligned
            /// data
            DACC1DHR: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC channel2 12-bit right-aligned
            /// data
            DACC2DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20);

        /// address: 0x40007424
        /// DUAL DAC 12-bit left aligned data holding
        /// register
        pub const DHR12LD = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC channel1 12-bit left-aligned
            /// data
            DACC1DHR: u12,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// DAC channel2 12-bit left-aligned
            /// data
            DACC2DHR: u12,
        }), base_address + 0x24);

        /// address: 0x40007428
        /// DUAL DAC 8-bit right aligned data holding
        /// register
        pub const DHR8RD = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 8-bit right-aligned
            /// data
            DACC1DHR: u8,
            /// DAC channel2 8-bit right-aligned
            /// data
            DACC2DHR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x4000742c
        /// channel1 data output register
        pub const DOR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 data output
            DACC1DOR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x2c);

        /// address: 0x40007430
        /// channel2 data output register
        pub const DOR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel2 data output
            DACC2DOR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x30);

        /// address: 0x40007434
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// DAC channel1 DMA underrun
            /// flag
            DMAUDR1: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            /// DAC channel2 DMA underrun
            /// flag
            DMAUDR2: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x34);
    };
    /// Debug support
    pub const DBGMCU = struct {
        pub const base_address = 0xe0042000;

        /// address: 0xe0042000
        /// MCU Device ID Code Register
        pub const IDCODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device Identifier
            DEV_ID: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Revision Identifier
            REV_ID: u16,
        }), base_address + 0x0);

        /// address: 0xe0042004
        /// Debug MCU Configuration
        /// Register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Debug Sleep mode
            DBG_SLEEP: u1,
            /// Debug Stop Mode
            DBG_STOP: u1,
            /// Debug Standby Mode
            DBG_STANDBY: u1,
            reserved0: u1,
            reserved1: u1,
            /// Trace pin assignment
            /// control
            TRACE_IOEN: u1,
            /// Trace pin assignment
            /// control
            TRACE_MODE: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0xe0042008
        /// APB Low Freeze Register
        pub const APB1FZ = @intToPtr(*volatile Mmio(32, packed struct {
            /// Debug Timer 2 stopped when Core is
            /// halted
            DBG_TIM2_STOP: u1,
            /// Debug Timer 3 stopped when Core is
            /// halted
            DBG_TIM3_STOP: u1,
            /// Debug Timer 4 stopped when Core is
            /// halted
            DBG_TIM4_STOP: u1,
            /// Debug Timer 5 stopped when Core is
            /// halted
            DBG_TIM5_STOP: u1,
            /// Debug Timer 6 stopped when Core is
            /// halted
            DBG_TIM6_STOP: u1,
            /// Debug Timer 7 stopped when Core is
            /// halted
            DBG_TIM7_STOP: u1,
            /// Debug Timer 12 stopped when Core is
            /// halted
            DBG_TIM12_STOP: u1,
            /// Debug Timer 13 stopped when Core is
            /// halted
            DBG_TIM13_STOP: u1,
            /// Debug Timer 14 stopped when Core is
            /// halted
            DBG_TIMER14_STOP: u1,
            /// Debug Timer 18 stopped when Core is
            /// halted
            DBG_TIM18_STOP: u1,
            /// Debug RTC stopped when Core is
            /// halted
            DBG_RTC_STOP: u1,
            /// Debug Window Wachdog stopped when Core
            /// is halted
            DBG_WWDG_STOP: u1,
            /// Debug Independent Wachdog stopped when
            /// Core is halted
            DBG_IWDG_STOP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// SMBUS timeout mode stopped when Core is
            /// halted
            I2C1_SMBUS_TIMEOUT: u1,
            /// SMBUS timeout mode stopped when Core is
            /// halted
            I2C2_SMBUS_TIMEOUT: u1,
            reserved8: u1,
            reserved9: u1,
            /// Debug CAN stopped when core is
            /// halted
            DBG_CAN_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x8);

        /// address: 0xe004200c
        /// APB High Freeze Register
        pub const APB2FZ = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Debug Timer 15 stopped when Core is
            /// halted
            DBG_TIM15_STOP: u1,
            /// Debug Timer 16 stopped when Core is
            /// halted
            DBG_TIM16_STOP: u1,
            /// Debug Timer 17 stopped when Core is
            /// halted
            DBG_TIM17_STO: u1,
            /// Debug Timer 19 stopped when Core is
            /// halted
            DBG_TIM19_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xc);
    };
    /// Advanced timer
    pub const TIM1 = struct {
        pub const base_address = 0x40012c00;

        /// address: 0x40012c00
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            reserved0: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40012c04
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded
            /// control
            CCPC: u1,
            reserved0: u1,
            /// Capture/compare control update
            /// selection
            CCUS: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            /// Output Idle state 1
            OIS1: u1,
            /// Output Idle state 1
            OIS1N: u1,
            /// Output Idle state 2
            OIS2: u1,
            /// Output Idle state 2
            OIS2N: u1,
            /// Output Idle state 3
            OIS3: u1,
            /// Output Idle state 3
            OIS3N: u1,
            /// Output Idle state 4
            OIS4: u1,
            reserved1: u1,
            /// Output Idle state 5
            OIS5: u1,
            reserved2: u1,
            /// Output Idle state 6
            OIS6: u1,
            reserved3: u1,
            /// Master mode selection 2
            MMS2: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40012c08
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            /// OCREF clear selection
            OCCS: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            /// Slave mode selection bit 3
            SMS3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x8);

        /// address: 0x40012c0c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            /// COM interrupt enable
            COMIE: u1,
            /// Trigger interrupt enable
            TIE: u1,
            /// Break interrupt enable
            BIE: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            /// COM DMA request enable
            COMDE: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40012c10
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            /// COM interrupt flag
            COMIF: u1,
            /// Trigger interrupt flag
            TIF: u1,
            /// Break interrupt flag
            BIF: u1,
            /// Break 2 interrupt flag
            B2IF: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 5 interrupt
            /// flag
            C5IF: u1,
            /// Capture/Compare 6 interrupt
            /// flag
            C6IF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x10);

        /// address: 0x40012c14
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            /// Capture/Compare control update
            /// generation
            COMG: u1,
            /// Trigger generation
            TG: u1,
            /// Break generation
            BG: u1,
            /// Break 2 generation
            B2G: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x14);

        /// address: 0x40012c18
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            /// Output Compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output Compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output Compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output Compare 2 mode
            OC2M: u3,
            /// Output Compare 2 clear
            /// enable
            OC2CE: u1,
            /// Output Compare 1 mode bit
            /// 3
            OC1M_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Output Compare 2 mode bit
            /// 3
            OC2M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x18);

        /// address: 0x40012c18
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PCS: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PCS: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40012c1c
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            OC4CE: u1,
            /// Output Compare 3 mode bit
            /// 3
            OC3M_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Output Compare 4 mode bit
            /// 3
            OC4M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1c);

        /// address: 0x40012c1c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40012c20
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            /// Capture/Compare 1 complementary output
            /// enable
            CC1NE: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            /// Capture/Compare 2 complementary output
            /// enable
            CC2NE: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            /// Capture/Compare 3 complementary output
            /// enable
            CC3NE: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            reserved0: u1,
            /// Capture/Compare 4 output
            /// Polarity
            CC4NP: u1,
            /// Capture/Compare 5 output
            /// enable
            CC5E: u1,
            /// Capture/Compare 5 output
            /// Polarity
            CC5P: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 6 output
            /// enable
            CC6E: u1,
            /// Capture/Compare 6 output
            /// Polarity
            CC6P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x20);

        /// address: 0x40012c24
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// counter value
            CNT: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// UIF copy
            UIFCPY: u1,
        }), base_address + 0x24);

        /// address: 0x40012c28
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x40012c2c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40012c30
        /// repetition counter register
        pub const RCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x30);

        /// address: 0x40012c34
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40012c38
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);

        /// address: 0x40012c3c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x3c);

        /// address: 0x40012c40
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x40);

        /// address: 0x40012c44
        /// break and dead-time register
        pub const BDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8,
            /// Lock configuration
            LOCK: u2,
            /// Off-state selection for Idle
            /// mode
            OSSI: u1,
            /// Off-state selection for Run
            /// mode
            OSSR: u1,
            /// Break enable
            BKE: u1,
            /// Break polarity
            BKP: u1,
            /// Automatic output enable
            AOE: u1,
            /// Main output enable
            MOE: u1,
            /// Break filter
            BKF: u4,
            /// Break 2 filter
            BK2F: u4,
            /// Break 2 enable
            BK2E: u1,
            /// Break 2 polarity
            BK2P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x44);

        /// address: 0x40012c48
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x40012c4c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40012c54
        /// capture/compare mode register 3 (output
        /// mode)
        pub const CCMR3_Output = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Output compare 5 fast
            /// enable
            OC5FE: u1,
            /// Output compare 5 preload
            /// enable
            OC5PE: u1,
            /// Output compare 5 mode
            OC5M: u3,
            /// Output compare 5 clear
            /// enable
            OC5CE: u1,
            reserved2: u1,
            reserved3: u1,
            /// Output compare 6 fast
            /// enable
            OC6FE: u1,
            /// Output compare 6 preload
            /// enable
            OC6PE: u1,
            /// Output compare 6 mode
            OC6M: u3,
            /// Output compare 6 clear
            /// enable
            OC6CE: u1,
            /// Outout Compare 5 mode bit
            /// 3
            OC5M_3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Outout Compare 6 mode bit
            /// 3
            OC6M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x54);

        /// address: 0x40012c58
        /// capture/compare register 5
        pub const CCR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 5 value
            CCR5: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Group Channel 5 and Channel
            /// 1
            GC5C1: u1,
            /// Group Channel 5 and Channel
            /// 2
            GC5C2: u1,
            /// Group Channel 5 and Channel
            /// 3
            GC5C3: u1,
        }), base_address + 0x58);

        /// address: 0x40012c5c
        /// capture/compare register 6
        pub const CCR6 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x5c);

        /// address: 0x40012c60
        /// option registers
        pub const OR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM1_ETR_ADC1 remapping
            /// capability
            TIM1_ETR_ADC1_RMP: u2,
            /// TIM1_ETR_ADC4 remapping
            /// capability
            TIM1_ETR_ADC4_RMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x60);
    };
    pub const TIM20 = struct {
        pub const base_address = 0x40015000;

        /// address: 0x40015000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            reserved0: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40015004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded
            /// control
            CCPC: u1,
            reserved0: u1,
            /// Capture/compare control update
            /// selection
            CCUS: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            /// Output Idle state 1
            OIS1: u1,
            /// Output Idle state 1
            OIS1N: u1,
            /// Output Idle state 2
            OIS2: u1,
            /// Output Idle state 2
            OIS2N: u1,
            /// Output Idle state 3
            OIS3: u1,
            /// Output Idle state 3
            OIS3N: u1,
            /// Output Idle state 4
            OIS4: u1,
            reserved1: u1,
            /// Output Idle state 5
            OIS5: u1,
            reserved2: u1,
            /// Output Idle state 6
            OIS6: u1,
            reserved3: u1,
            /// Master mode selection 2
            MMS2: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40015008
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            /// OCREF clear selection
            OCCS: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            /// Slave mode selection bit 3
            SMS3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x8);

        /// address: 0x4001500c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            /// COM interrupt enable
            COMIE: u1,
            /// Trigger interrupt enable
            TIE: u1,
            /// Break interrupt enable
            BIE: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            /// COM DMA request enable
            COMDE: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40015010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            /// COM interrupt flag
            COMIF: u1,
            /// Trigger interrupt flag
            TIF: u1,
            /// Break interrupt flag
            BIF: u1,
            /// Break 2 interrupt flag
            B2IF: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 5 interrupt
            /// flag
            C5IF: u1,
            /// Capture/Compare 6 interrupt
            /// flag
            C6IF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x10);

        /// address: 0x40015014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            /// Capture/Compare control update
            /// generation
            COMG: u1,
            /// Trigger generation
            TG: u1,
            /// Break generation
            BG: u1,
            /// Break 2 generation
            B2G: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x14);

        /// address: 0x40015018
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            /// Output Compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output Compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output Compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output Compare 2 mode
            OC2M: u3,
            /// Output Compare 2 clear
            /// enable
            OC2CE: u1,
            /// Output Compare 1 mode bit
            /// 3
            OC1M_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Output Compare 2 mode bit
            /// 3
            OC2M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x18);

        /// address: 0x40015018
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PCS: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PCS: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4001501c
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            OC4CE: u1,
            /// Output Compare 3 mode bit
            /// 3
            OC3M_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Output Compare 4 mode bit
            /// 3
            OC4M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1c);

        /// address: 0x4001501c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40015020
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            /// Capture/Compare 1 complementary output
            /// enable
            CC1NE: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            /// Capture/Compare 2 complementary output
            /// enable
            CC2NE: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            /// Capture/Compare 3 complementary output
            /// enable
            CC3NE: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            reserved0: u1,
            /// Capture/Compare 4 output
            /// Polarity
            CC4NP: u1,
            /// Capture/Compare 5 output
            /// enable
            CC5E: u1,
            /// Capture/Compare 5 output
            /// Polarity
            CC5P: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 6 output
            /// enable
            CC6E: u1,
            /// Capture/Compare 6 output
            /// Polarity
            CC6P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x20);

        /// address: 0x40015024
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// counter value
            CNT: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// UIF copy
            UIFCPY: u1,
        }), base_address + 0x24);

        /// address: 0x40015028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001502c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40015030
        /// repetition counter register
        pub const RCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x30);

        /// address: 0x40015034
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40015038
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);

        /// address: 0x4001503c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x3c);

        /// address: 0x40015040
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x40);

        /// address: 0x40015044
        /// break and dead-time register
        pub const BDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8,
            /// Lock configuration
            LOCK: u2,
            /// Off-state selection for Idle
            /// mode
            OSSI: u1,
            /// Off-state selection for Run
            /// mode
            OSSR: u1,
            /// Break enable
            BKE: u1,
            /// Break polarity
            BKP: u1,
            /// Automatic output enable
            AOE: u1,
            /// Main output enable
            MOE: u1,
            /// Break filter
            BKF: u4,
            /// Break 2 filter
            BK2F: u4,
            /// Break 2 enable
            BK2E: u1,
            /// Break 2 polarity
            BK2P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x44);

        /// address: 0x40015048
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4001504c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40015054
        /// capture/compare mode register 3 (output
        /// mode)
        pub const CCMR3_Output = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Output compare 5 fast
            /// enable
            OC5FE: u1,
            /// Output compare 5 preload
            /// enable
            OC5PE: u1,
            /// Output compare 5 mode
            OC5M: u3,
            /// Output compare 5 clear
            /// enable
            OC5CE: u1,
            reserved2: u1,
            reserved3: u1,
            /// Output compare 6 fast
            /// enable
            OC6FE: u1,
            /// Output compare 6 preload
            /// enable
            OC6PE: u1,
            /// Output compare 6 mode
            OC6M: u3,
            /// Output compare 6 clear
            /// enable
            OC6CE: u1,
            /// Outout Compare 5 mode bit
            /// 3
            OC5M_3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Outout Compare 6 mode bit
            /// 3
            OC6M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x54);

        /// address: 0x40015058
        /// capture/compare register 5
        pub const CCR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 5 value
            CCR5: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Group Channel 5 and Channel
            /// 1
            GC5C1: u1,
            /// Group Channel 5 and Channel
            /// 2
            GC5C2: u1,
            /// Group Channel 5 and Channel
            /// 3
            GC5C3: u1,
        }), base_address + 0x58);

        /// address: 0x4001505c
        /// capture/compare register 6
        pub const CCR6 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x5c);

        /// address: 0x40015060
        /// option registers
        pub const OR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM1_ETR_ADC1 remapping
            /// capability
            TIM1_ETR_ADC1_RMP: u2,
            /// TIM1_ETR_ADC4 remapping
            /// capability
            TIM1_ETR_ADC4_RMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x60);
    };
    /// Advanced-timers
    pub const TIM8 = struct {
        pub const base_address = 0x40013400;

        /// address: 0x40013400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            reserved0: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40013404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded
            /// control
            CCPC: u1,
            reserved0: u1,
            /// Capture/compare control update
            /// selection
            CCUS: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            /// Output Idle state 1
            OIS1: u1,
            /// Output Idle state 1
            OIS1N: u1,
            /// Output Idle state 2
            OIS2: u1,
            /// Output Idle state 2
            OIS2N: u1,
            /// Output Idle state 3
            OIS3: u1,
            /// Output Idle state 3
            OIS3N: u1,
            /// Output Idle state 4
            OIS4: u1,
            reserved1: u1,
            /// Output Idle state 5
            OIS5: u1,
            reserved2: u1,
            /// Output Idle state 6
            OIS6: u1,
            reserved3: u1,
            /// Master mode selection 2
            MMS2: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40013408
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            /// OCREF clear selection
            OCCS: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            /// Slave mode selection bit 3
            SMS3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x8);

        /// address: 0x4001340c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            /// COM interrupt enable
            COMIE: u1,
            /// Trigger interrupt enable
            TIE: u1,
            /// Break interrupt enable
            BIE: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            /// COM DMA request enable
            COMDE: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40013410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            /// COM interrupt flag
            COMIF: u1,
            /// Trigger interrupt flag
            TIF: u1,
            /// Break interrupt flag
            BIF: u1,
            /// Break 2 interrupt flag
            B2IF: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 5 interrupt
            /// flag
            C5IF: u1,
            /// Capture/Compare 6 interrupt
            /// flag
            C6IF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x10);

        /// address: 0x40013414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            /// Capture/Compare control update
            /// generation
            COMG: u1,
            /// Trigger generation
            TG: u1,
            /// Break generation
            BG: u1,
            /// Break 2 generation
            B2G: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x14);

        /// address: 0x40013418
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            /// Output Compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output Compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output Compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output Compare 2 mode
            OC2M: u3,
            /// Output Compare 2 clear
            /// enable
            OC2CE: u1,
            /// Output Compare 1 mode bit
            /// 3
            OC1M_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Output Compare 2 mode bit
            /// 3
            OC2M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x18);

        /// address: 0x40013418
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PCS: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PCS: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4001341c
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            OC4CE: u1,
            /// Output Compare 3 mode bit
            /// 3
            OC3M_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Output Compare 4 mode bit
            /// 3
            OC4M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1c);

        /// address: 0x4001341c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40013420
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            /// Capture/Compare 1 complementary output
            /// enable
            CC1NE: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            /// Capture/Compare 2 complementary output
            /// enable
            CC2NE: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            /// Capture/Compare 3 complementary output
            /// enable
            CC3NE: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            reserved0: u1,
            /// Capture/Compare 4 output
            /// Polarity
            CC4NP: u1,
            /// Capture/Compare 5 output
            /// enable
            CC5E: u1,
            /// Capture/Compare 5 output
            /// Polarity
            CC5P: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 6 output
            /// enable
            CC6E: u1,
            /// Capture/Compare 6 output
            /// Polarity
            CC6P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x20);

        /// address: 0x40013424
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// counter value
            CNT: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// UIF copy
            UIFCPY: u1,
        }), base_address + 0x24);

        /// address: 0x40013428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001342c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40013430
        /// repetition counter register
        pub const RCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x30);

        /// address: 0x40013434
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40013438
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);

        /// address: 0x4001343c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x3c);

        /// address: 0x40013440
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x40);

        /// address: 0x40013444
        /// break and dead-time register
        pub const BDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8,
            /// Lock configuration
            LOCK: u2,
            /// Off-state selection for Idle
            /// mode
            OSSI: u1,
            /// Off-state selection for Run
            /// mode
            OSSR: u1,
            /// Break enable
            BKE: u1,
            /// Break polarity
            BKP: u1,
            /// Automatic output enable
            AOE: u1,
            /// Main output enable
            MOE: u1,
            /// Break filter
            BKF: u4,
            /// Break 2 filter
            BK2F: u4,
            /// Break 2 enable
            BK2E: u1,
            /// Break 2 polarity
            BK2P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x44);

        /// address: 0x40013448
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4001344c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40013454
        /// capture/compare mode register 3 (output
        /// mode)
        pub const CCMR3_Output = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Output compare 5 fast
            /// enable
            OC5FE: u1,
            /// Output compare 5 preload
            /// enable
            OC5PE: u1,
            /// Output compare 5 mode
            OC5M: u3,
            /// Output compare 5 clear
            /// enable
            OC5CE: u1,
            reserved2: u1,
            reserved3: u1,
            /// Output compare 6 fast
            /// enable
            OC6FE: u1,
            /// Output compare 6 preload
            /// enable
            OC6PE: u1,
            /// Output compare 6 mode
            OC6M: u3,
            /// Output compare 6 clear
            /// enable
            OC6CE: u1,
            /// Outout Compare 5 mode bit
            /// 3
            OC5M_3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Outout Compare 6 mode bit
            /// 3
            OC6M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x54);

        /// address: 0x40013458
        /// capture/compare register 5
        pub const CCR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 5 value
            CCR5: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Group Channel 5 and Channel
            /// 1
            GC5C1: u1,
            /// Group Channel 5 and Channel
            /// 2
            GC5C2: u1,
            /// Group Channel 5 and Channel
            /// 3
            GC5C3: u1,
        }), base_address + 0x58);

        /// address: 0x4001345c
        /// capture/compare register 6
        pub const CCR6 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x5c);

        /// address: 0x40013460
        /// option registers
        pub const OR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM8_ETR_ADC2 remapping
            /// capability
            TIM8_ETR_ADC2_RMP: u2,
            /// TIM8_ETR_ADC3 remapping
            /// capability
            TIM8_ETR_ADC3_RMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x60);
    };
    /// Analog-to-Digital Converter
    pub const ADC1 = struct {
        pub const base_address = 0x50000000;

        /// address: 0x50000000
        /// interrupt and status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADRDY
            ADRDY: u1,
            /// EOSMP
            EOSMP: u1,
            /// EOC
            EOC: u1,
            /// EOS
            EOS: u1,
            /// OVR
            OVR: u1,
            /// JEOC
            JEOC: u1,
            /// JEOS
            JEOS: u1,
            /// AWD1
            AWD1: u1,
            /// AWD2
            AWD2: u1,
            /// AWD3
            AWD3: u1,
            /// JQOVF
            JQOVF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x0);

        /// address: 0x50000004
        /// interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADRDYIE
            ADRDYIE: u1,
            /// EOSMPIE
            EOSMPIE: u1,
            /// EOCIE
            EOCIE: u1,
            /// EOSIE
            EOSIE: u1,
            /// OVRIE
            OVRIE: u1,
            /// JEOCIE
            JEOCIE: u1,
            /// JEOSIE
            JEOSIE: u1,
            /// AWD1IE
            AWD1IE: u1,
            /// AWD2IE
            AWD2IE: u1,
            /// AWD3IE
            AWD3IE: u1,
            /// JQOVFIE
            JQOVFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x4);

        /// address: 0x50000008
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADEN
            ADEN: u1,
            /// ADDIS
            ADDIS: u1,
            /// ADSTART
            ADSTART: u1,
            /// JADSTART
            JADSTART: u1,
            /// ADSTP
            ADSTP: u1,
            /// JADSTP
            JADSTP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// ADVREGEN
            ADVREGEN: u1,
            /// DEEPPWD
            DEEPPWD: u1,
            /// ADCALDIF
            ADCALDIF: u1,
            /// ADCAL
            ADCAL: u1,
        }), base_address + 0x8);

        /// address: 0x5000000c
        /// configuration register
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMAEN
            DMAEN: u1,
            /// DMACFG
            DMACFG: u1,
            reserved0: u1,
            /// RES
            RES: u2,
            /// ALIGN
            ALIGN: u1,
            /// EXTSEL
            EXTSEL: u4,
            /// EXTEN
            EXTEN: u2,
            /// OVRMOD
            OVRMOD: u1,
            /// CONT
            CONT: u1,
            /// AUTDLY
            AUTDLY: u1,
            /// AUTOFF
            AUTOFF: u1,
            /// DISCEN
            DISCEN: u1,
            /// DISCNUM
            DISCNUM: u3,
            /// JDISCEN
            JDISCEN: u1,
            /// JQM
            JQM: u1,
            /// AWD1SGL
            AWD1SGL: u1,
            /// AWD1EN
            AWD1EN: u1,
            /// JAWD1EN
            JAWD1EN: u1,
            /// JAUTO
            JAUTO: u1,
            /// AWDCH1CH
            AWDCH1CH: u5,
            padding0: u1,
        }), base_address + 0xc);

        /// address: 0x50000014
        /// sample time register 1
        pub const SMPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// SMP1
            SMP1: u3,
            /// SMP2
            SMP2: u3,
            /// SMP3
            SMP3: u3,
            /// SMP4
            SMP4: u3,
            /// SMP5
            SMP5: u3,
            /// SMP6
            SMP6: u3,
            /// SMP7
            SMP7: u3,
            /// SMP8
            SMP8: u3,
            /// SMP9
            SMP9: u3,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x14);

        /// address: 0x50000018
        /// sample time register 2
        pub const SMPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SMP10
            SMP10: u3,
            /// SMP11
            SMP11: u3,
            /// SMP12
            SMP12: u3,
            /// SMP13
            SMP13: u3,
            /// SMP14
            SMP14: u3,
            /// SMP15
            SMP15: u3,
            /// SMP16
            SMP16: u3,
            /// SMP17
            SMP17: u3,
            /// SMP18
            SMP18: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x18);

        /// address: 0x50000020
        /// watchdog threshold register 1
        pub const TR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT1
            LT1: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// HT1
            HT1: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20);

        /// address: 0x50000024
        /// watchdog threshold register
        pub const TR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT2
            LT2: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// HT2
            HT2: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x24);

        /// address: 0x50000028
        /// watchdog threshold register 3
        pub const TR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT3
            LT3: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// HT3
            HT3: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x28);

        /// address: 0x50000030
        /// regular sequence register 1
        pub const SQR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// L3
            L3: u4,
            reserved0: u1,
            reserved1: u1,
            /// SQ1
            SQ1: u5,
            reserved2: u1,
            /// SQ2
            SQ2: u5,
            reserved3: u1,
            /// SQ3
            SQ3: u5,
            reserved4: u1,
            /// SQ4
            SQ4: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x30);

        /// address: 0x50000034
        /// regular sequence register 2
        pub const SQR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ5
            SQ5: u5,
            reserved0: u1,
            /// SQ6
            SQ6: u5,
            reserved1: u1,
            /// SQ7
            SQ7: u5,
            reserved2: u1,
            /// SQ8
            SQ8: u5,
            reserved3: u1,
            /// SQ9
            SQ9: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x34);

        /// address: 0x50000038
        /// regular sequence register 3
        pub const SQR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ10
            SQ10: u5,
            reserved0: u1,
            /// SQ11
            SQ11: u5,
            reserved1: u1,
            /// SQ12
            SQ12: u5,
            reserved2: u1,
            /// SQ13
            SQ13: u5,
            reserved3: u1,
            /// SQ14
            SQ14: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x38);

        /// address: 0x5000003c
        /// regular sequence register 4
        pub const SQR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ15
            SQ15: u5,
            reserved0: u1,
            /// SQ16
            SQ16: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x3c);

        /// address: 0x50000040
        /// regular Data Register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// regularDATA
            regularDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x5000004c
        /// injected sequence register
        pub const JSQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// JL
            JL: u2,
            /// JEXTSEL
            JEXTSEL: u4,
            /// JEXTEN
            JEXTEN: u2,
            /// JSQ1
            JSQ1: u5,
            reserved0: u1,
            /// JSQ2
            JSQ2: u5,
            reserved1: u1,
            /// JSQ3
            JSQ3: u5,
            reserved2: u1,
            /// JSQ4
            JSQ4: u5,
            padding0: u1,
        }), base_address + 0x4c);

        /// address: 0x50000060
        /// offset register 1
        pub const OFR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET1
            OFFSET1: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET1_CH
            OFFSET1_CH: u5,
            /// OFFSET1_EN
            OFFSET1_EN: u1,
        }), base_address + 0x60);

        /// address: 0x50000064
        /// offset register 2
        pub const OFR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET2
            OFFSET2: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET2_CH
            OFFSET2_CH: u5,
            /// OFFSET2_EN
            OFFSET2_EN: u1,
        }), base_address + 0x64);

        /// address: 0x50000068
        /// offset register 3
        pub const OFR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET3
            OFFSET3: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET3_CH
            OFFSET3_CH: u5,
            /// OFFSET3_EN
            OFFSET3_EN: u1,
        }), base_address + 0x68);

        /// address: 0x5000006c
        /// offset register 4
        pub const OFR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET4
            OFFSET4: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET4_CH
            OFFSET4_CH: u5,
            /// OFFSET4_EN
            OFFSET4_EN: u1,
        }), base_address + 0x6c);

        /// address: 0x50000080
        /// injected data register 1
        pub const JDR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA1
            JDATA1: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x80);

        /// address: 0x50000084
        /// injected data register 2
        pub const JDR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA2
            JDATA2: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x50000088
        /// injected data register 3
        pub const JDR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA3
            JDATA3: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x88);

        /// address: 0x5000008c
        /// injected data register 4
        pub const JDR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA4
            JDATA4: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8c);

        /// address: 0x500000a0
        /// Analog Watchdog 2 Configuration
        /// Register
        pub const AWD2CR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// AWD2CH
            AWD2CH: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa0);

        /// address: 0x500000a4
        /// Analog Watchdog 3 Configuration
        /// Register
        pub const AWD3CR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// AWD3CH
            AWD3CH: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa4);

        /// address: 0x500000b0
        /// Differential Mode Selection Register
        /// 2
        pub const DIFSEL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Differential mode for channels 15 to
            /// 1
            DIFSEL_1_15: u15,
            /// Differential mode for channels 18 to
            /// 16
            DIFSEL_16_18: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xb0);

        /// address: 0x500000b4
        /// Calibration Factors
        pub const CALFACT = @intToPtr(*volatile Mmio(32, packed struct {
            /// CALFACT_S
            CALFACT_S: u7,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// CALFACT_D
            CALFACT_D: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0xb4);
    };
    pub const ADC2 = struct {
        pub const base_address = 0x50000100;

        /// address: 0x50000100
        /// interrupt and status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADRDY
            ADRDY: u1,
            /// EOSMP
            EOSMP: u1,
            /// EOC
            EOC: u1,
            /// EOS
            EOS: u1,
            /// OVR
            OVR: u1,
            /// JEOC
            JEOC: u1,
            /// JEOS
            JEOS: u1,
            /// AWD1
            AWD1: u1,
            /// AWD2
            AWD2: u1,
            /// AWD3
            AWD3: u1,
            /// JQOVF
            JQOVF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x0);

        /// address: 0x50000104
        /// interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADRDYIE
            ADRDYIE: u1,
            /// EOSMPIE
            EOSMPIE: u1,
            /// EOCIE
            EOCIE: u1,
            /// EOSIE
            EOSIE: u1,
            /// OVRIE
            OVRIE: u1,
            /// JEOCIE
            JEOCIE: u1,
            /// JEOSIE
            JEOSIE: u1,
            /// AWD1IE
            AWD1IE: u1,
            /// AWD2IE
            AWD2IE: u1,
            /// AWD3IE
            AWD3IE: u1,
            /// JQOVFIE
            JQOVFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x4);

        /// address: 0x50000108
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADEN
            ADEN: u1,
            /// ADDIS
            ADDIS: u1,
            /// ADSTART
            ADSTART: u1,
            /// JADSTART
            JADSTART: u1,
            /// ADSTP
            ADSTP: u1,
            /// JADSTP
            JADSTP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// ADVREGEN
            ADVREGEN: u1,
            /// DEEPPWD
            DEEPPWD: u1,
            /// ADCALDIF
            ADCALDIF: u1,
            /// ADCAL
            ADCAL: u1,
        }), base_address + 0x8);

        /// address: 0x5000010c
        /// configuration register
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMAEN
            DMAEN: u1,
            /// DMACFG
            DMACFG: u1,
            reserved0: u1,
            /// RES
            RES: u2,
            /// ALIGN
            ALIGN: u1,
            /// EXTSEL
            EXTSEL: u4,
            /// EXTEN
            EXTEN: u2,
            /// OVRMOD
            OVRMOD: u1,
            /// CONT
            CONT: u1,
            /// AUTDLY
            AUTDLY: u1,
            /// AUTOFF
            AUTOFF: u1,
            /// DISCEN
            DISCEN: u1,
            /// DISCNUM
            DISCNUM: u3,
            /// JDISCEN
            JDISCEN: u1,
            /// JQM
            JQM: u1,
            /// AWD1SGL
            AWD1SGL: u1,
            /// AWD1EN
            AWD1EN: u1,
            /// JAWD1EN
            JAWD1EN: u1,
            /// JAUTO
            JAUTO: u1,
            /// AWDCH1CH
            AWDCH1CH: u5,
            padding0: u1,
        }), base_address + 0xc);

        /// address: 0x50000114
        /// sample time register 1
        pub const SMPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// SMP1
            SMP1: u3,
            /// SMP2
            SMP2: u3,
            /// SMP3
            SMP3: u3,
            /// SMP4
            SMP4: u3,
            /// SMP5
            SMP5: u3,
            /// SMP6
            SMP6: u3,
            /// SMP7
            SMP7: u3,
            /// SMP8
            SMP8: u3,
            /// SMP9
            SMP9: u3,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x14);

        /// address: 0x50000118
        /// sample time register 2
        pub const SMPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SMP10
            SMP10: u3,
            /// SMP11
            SMP11: u3,
            /// SMP12
            SMP12: u3,
            /// SMP13
            SMP13: u3,
            /// SMP14
            SMP14: u3,
            /// SMP15
            SMP15: u3,
            /// SMP16
            SMP16: u3,
            /// SMP17
            SMP17: u3,
            /// SMP18
            SMP18: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x18);

        /// address: 0x50000120
        /// watchdog threshold register 1
        pub const TR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT1
            LT1: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// HT1
            HT1: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20);

        /// address: 0x50000124
        /// watchdog threshold register
        pub const TR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT2
            LT2: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// HT2
            HT2: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x24);

        /// address: 0x50000128
        /// watchdog threshold register 3
        pub const TR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT3
            LT3: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// HT3
            HT3: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x28);

        /// address: 0x50000130
        /// regular sequence register 1
        pub const SQR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// L3
            L3: u4,
            reserved0: u1,
            reserved1: u1,
            /// SQ1
            SQ1: u5,
            reserved2: u1,
            /// SQ2
            SQ2: u5,
            reserved3: u1,
            /// SQ3
            SQ3: u5,
            reserved4: u1,
            /// SQ4
            SQ4: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x30);

        /// address: 0x50000134
        /// regular sequence register 2
        pub const SQR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ5
            SQ5: u5,
            reserved0: u1,
            /// SQ6
            SQ6: u5,
            reserved1: u1,
            /// SQ7
            SQ7: u5,
            reserved2: u1,
            /// SQ8
            SQ8: u5,
            reserved3: u1,
            /// SQ9
            SQ9: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x34);

        /// address: 0x50000138
        /// regular sequence register 3
        pub const SQR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ10
            SQ10: u5,
            reserved0: u1,
            /// SQ11
            SQ11: u5,
            reserved1: u1,
            /// SQ12
            SQ12: u5,
            reserved2: u1,
            /// SQ13
            SQ13: u5,
            reserved3: u1,
            /// SQ14
            SQ14: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x38);

        /// address: 0x5000013c
        /// regular sequence register 4
        pub const SQR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ15
            SQ15: u5,
            reserved0: u1,
            /// SQ16
            SQ16: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x3c);

        /// address: 0x50000140
        /// regular Data Register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// regularDATA
            regularDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x5000014c
        /// injected sequence register
        pub const JSQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// JL
            JL: u2,
            /// JEXTSEL
            JEXTSEL: u4,
            /// JEXTEN
            JEXTEN: u2,
            /// JSQ1
            JSQ1: u5,
            reserved0: u1,
            /// JSQ2
            JSQ2: u5,
            reserved1: u1,
            /// JSQ3
            JSQ3: u5,
            reserved2: u1,
            /// JSQ4
            JSQ4: u5,
            padding0: u1,
        }), base_address + 0x4c);

        /// address: 0x50000160
        /// offset register 1
        pub const OFR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET1
            OFFSET1: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET1_CH
            OFFSET1_CH: u5,
            /// OFFSET1_EN
            OFFSET1_EN: u1,
        }), base_address + 0x60);

        /// address: 0x50000164
        /// offset register 2
        pub const OFR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET2
            OFFSET2: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET2_CH
            OFFSET2_CH: u5,
            /// OFFSET2_EN
            OFFSET2_EN: u1,
        }), base_address + 0x64);

        /// address: 0x50000168
        /// offset register 3
        pub const OFR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET3
            OFFSET3: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET3_CH
            OFFSET3_CH: u5,
            /// OFFSET3_EN
            OFFSET3_EN: u1,
        }), base_address + 0x68);

        /// address: 0x5000016c
        /// offset register 4
        pub const OFR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET4
            OFFSET4: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET4_CH
            OFFSET4_CH: u5,
            /// OFFSET4_EN
            OFFSET4_EN: u1,
        }), base_address + 0x6c);

        /// address: 0x50000180
        /// injected data register 1
        pub const JDR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA1
            JDATA1: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x80);

        /// address: 0x50000184
        /// injected data register 2
        pub const JDR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA2
            JDATA2: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x50000188
        /// injected data register 3
        pub const JDR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA3
            JDATA3: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x88);

        /// address: 0x5000018c
        /// injected data register 4
        pub const JDR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA4
            JDATA4: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8c);

        /// address: 0x500001a0
        /// Analog Watchdog 2 Configuration
        /// Register
        pub const AWD2CR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// AWD2CH
            AWD2CH: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa0);

        /// address: 0x500001a4
        /// Analog Watchdog 3 Configuration
        /// Register
        pub const AWD3CR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// AWD3CH
            AWD3CH: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa4);

        /// address: 0x500001b0
        /// Differential Mode Selection Register
        /// 2
        pub const DIFSEL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Differential mode for channels 15 to
            /// 1
            DIFSEL_1_15: u15,
            /// Differential mode for channels 18 to
            /// 16
            DIFSEL_16_18: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xb0);

        /// address: 0x500001b4
        /// Calibration Factors
        pub const CALFACT = @intToPtr(*volatile Mmio(32, packed struct {
            /// CALFACT_S
            CALFACT_S: u7,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// CALFACT_D
            CALFACT_D: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0xb4);
    };
    pub const ADC3 = struct {
        pub const base_address = 0x50000400;

        /// address: 0x50000400
        /// interrupt and status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADRDY
            ADRDY: u1,
            /// EOSMP
            EOSMP: u1,
            /// EOC
            EOC: u1,
            /// EOS
            EOS: u1,
            /// OVR
            OVR: u1,
            /// JEOC
            JEOC: u1,
            /// JEOS
            JEOS: u1,
            /// AWD1
            AWD1: u1,
            /// AWD2
            AWD2: u1,
            /// AWD3
            AWD3: u1,
            /// JQOVF
            JQOVF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x0);

        /// address: 0x50000404
        /// interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADRDYIE
            ADRDYIE: u1,
            /// EOSMPIE
            EOSMPIE: u1,
            /// EOCIE
            EOCIE: u1,
            /// EOSIE
            EOSIE: u1,
            /// OVRIE
            OVRIE: u1,
            /// JEOCIE
            JEOCIE: u1,
            /// JEOSIE
            JEOSIE: u1,
            /// AWD1IE
            AWD1IE: u1,
            /// AWD2IE
            AWD2IE: u1,
            /// AWD3IE
            AWD3IE: u1,
            /// JQOVFIE
            JQOVFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x4);

        /// address: 0x50000408
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADEN
            ADEN: u1,
            /// ADDIS
            ADDIS: u1,
            /// ADSTART
            ADSTART: u1,
            /// JADSTART
            JADSTART: u1,
            /// ADSTP
            ADSTP: u1,
            /// JADSTP
            JADSTP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// ADVREGEN
            ADVREGEN: u1,
            /// DEEPPWD
            DEEPPWD: u1,
            /// ADCALDIF
            ADCALDIF: u1,
            /// ADCAL
            ADCAL: u1,
        }), base_address + 0x8);

        /// address: 0x5000040c
        /// configuration register
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMAEN
            DMAEN: u1,
            /// DMACFG
            DMACFG: u1,
            reserved0: u1,
            /// RES
            RES: u2,
            /// ALIGN
            ALIGN: u1,
            /// EXTSEL
            EXTSEL: u4,
            /// EXTEN
            EXTEN: u2,
            /// OVRMOD
            OVRMOD: u1,
            /// CONT
            CONT: u1,
            /// AUTDLY
            AUTDLY: u1,
            /// AUTOFF
            AUTOFF: u1,
            /// DISCEN
            DISCEN: u1,
            /// DISCNUM
            DISCNUM: u3,
            /// JDISCEN
            JDISCEN: u1,
            /// JQM
            JQM: u1,
            /// AWD1SGL
            AWD1SGL: u1,
            /// AWD1EN
            AWD1EN: u1,
            /// JAWD1EN
            JAWD1EN: u1,
            /// JAUTO
            JAUTO: u1,
            /// AWDCH1CH
            AWDCH1CH: u5,
            padding0: u1,
        }), base_address + 0xc);

        /// address: 0x50000414
        /// sample time register 1
        pub const SMPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// SMP1
            SMP1: u3,
            /// SMP2
            SMP2: u3,
            /// SMP3
            SMP3: u3,
            /// SMP4
            SMP4: u3,
            /// SMP5
            SMP5: u3,
            /// SMP6
            SMP6: u3,
            /// SMP7
            SMP7: u3,
            /// SMP8
            SMP8: u3,
            /// SMP9
            SMP9: u3,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x14);

        /// address: 0x50000418
        /// sample time register 2
        pub const SMPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SMP10
            SMP10: u3,
            /// SMP11
            SMP11: u3,
            /// SMP12
            SMP12: u3,
            /// SMP13
            SMP13: u3,
            /// SMP14
            SMP14: u3,
            /// SMP15
            SMP15: u3,
            /// SMP16
            SMP16: u3,
            /// SMP17
            SMP17: u3,
            /// SMP18
            SMP18: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x18);

        /// address: 0x50000420
        /// watchdog threshold register 1
        pub const TR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT1
            LT1: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// HT1
            HT1: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20);

        /// address: 0x50000424
        /// watchdog threshold register
        pub const TR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT2
            LT2: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// HT2
            HT2: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x24);

        /// address: 0x50000428
        /// watchdog threshold register 3
        pub const TR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT3
            LT3: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// HT3
            HT3: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x28);

        /// address: 0x50000430
        /// regular sequence register 1
        pub const SQR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// L3
            L3: u4,
            reserved0: u1,
            reserved1: u1,
            /// SQ1
            SQ1: u5,
            reserved2: u1,
            /// SQ2
            SQ2: u5,
            reserved3: u1,
            /// SQ3
            SQ3: u5,
            reserved4: u1,
            /// SQ4
            SQ4: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x30);

        /// address: 0x50000434
        /// regular sequence register 2
        pub const SQR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ5
            SQ5: u5,
            reserved0: u1,
            /// SQ6
            SQ6: u5,
            reserved1: u1,
            /// SQ7
            SQ7: u5,
            reserved2: u1,
            /// SQ8
            SQ8: u5,
            reserved3: u1,
            /// SQ9
            SQ9: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x34);

        /// address: 0x50000438
        /// regular sequence register 3
        pub const SQR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ10
            SQ10: u5,
            reserved0: u1,
            /// SQ11
            SQ11: u5,
            reserved1: u1,
            /// SQ12
            SQ12: u5,
            reserved2: u1,
            /// SQ13
            SQ13: u5,
            reserved3: u1,
            /// SQ14
            SQ14: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x38);

        /// address: 0x5000043c
        /// regular sequence register 4
        pub const SQR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ15
            SQ15: u5,
            reserved0: u1,
            /// SQ16
            SQ16: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x3c);

        /// address: 0x50000440
        /// regular Data Register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// regularDATA
            regularDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x5000044c
        /// injected sequence register
        pub const JSQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// JL
            JL: u2,
            /// JEXTSEL
            JEXTSEL: u4,
            /// JEXTEN
            JEXTEN: u2,
            /// JSQ1
            JSQ1: u5,
            reserved0: u1,
            /// JSQ2
            JSQ2: u5,
            reserved1: u1,
            /// JSQ3
            JSQ3: u5,
            reserved2: u1,
            /// JSQ4
            JSQ4: u5,
            padding0: u1,
        }), base_address + 0x4c);

        /// address: 0x50000460
        /// offset register 1
        pub const OFR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET1
            OFFSET1: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET1_CH
            OFFSET1_CH: u5,
            /// OFFSET1_EN
            OFFSET1_EN: u1,
        }), base_address + 0x60);

        /// address: 0x50000464
        /// offset register 2
        pub const OFR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET2
            OFFSET2: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET2_CH
            OFFSET2_CH: u5,
            /// OFFSET2_EN
            OFFSET2_EN: u1,
        }), base_address + 0x64);

        /// address: 0x50000468
        /// offset register 3
        pub const OFR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET3
            OFFSET3: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET3_CH
            OFFSET3_CH: u5,
            /// OFFSET3_EN
            OFFSET3_EN: u1,
        }), base_address + 0x68);

        /// address: 0x5000046c
        /// offset register 4
        pub const OFR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET4
            OFFSET4: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET4_CH
            OFFSET4_CH: u5,
            /// OFFSET4_EN
            OFFSET4_EN: u1,
        }), base_address + 0x6c);

        /// address: 0x50000480
        /// injected data register 1
        pub const JDR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA1
            JDATA1: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x80);

        /// address: 0x50000484
        /// injected data register 2
        pub const JDR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA2
            JDATA2: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x50000488
        /// injected data register 3
        pub const JDR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA3
            JDATA3: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x88);

        /// address: 0x5000048c
        /// injected data register 4
        pub const JDR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA4
            JDATA4: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8c);

        /// address: 0x500004a0
        /// Analog Watchdog 2 Configuration
        /// Register
        pub const AWD2CR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// AWD2CH
            AWD2CH: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa0);

        /// address: 0x500004a4
        /// Analog Watchdog 3 Configuration
        /// Register
        pub const AWD3CR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// AWD3CH
            AWD3CH: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa4);

        /// address: 0x500004b0
        /// Differential Mode Selection Register
        /// 2
        pub const DIFSEL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Differential mode for channels 15 to
            /// 1
            DIFSEL_1_15: u15,
            /// Differential mode for channels 18 to
            /// 16
            DIFSEL_16_18: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xb0);

        /// address: 0x500004b4
        /// Calibration Factors
        pub const CALFACT = @intToPtr(*volatile Mmio(32, packed struct {
            /// CALFACT_S
            CALFACT_S: u7,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// CALFACT_D
            CALFACT_D: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0xb4);
    };
    pub const ADC4 = struct {
        pub const base_address = 0x50000500;

        /// address: 0x50000500
        /// interrupt and status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADRDY
            ADRDY: u1,
            /// EOSMP
            EOSMP: u1,
            /// EOC
            EOC: u1,
            /// EOS
            EOS: u1,
            /// OVR
            OVR: u1,
            /// JEOC
            JEOC: u1,
            /// JEOS
            JEOS: u1,
            /// AWD1
            AWD1: u1,
            /// AWD2
            AWD2: u1,
            /// AWD3
            AWD3: u1,
            /// JQOVF
            JQOVF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x0);

        /// address: 0x50000504
        /// interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADRDYIE
            ADRDYIE: u1,
            /// EOSMPIE
            EOSMPIE: u1,
            /// EOCIE
            EOCIE: u1,
            /// EOSIE
            EOSIE: u1,
            /// OVRIE
            OVRIE: u1,
            /// JEOCIE
            JEOCIE: u1,
            /// JEOSIE
            JEOSIE: u1,
            /// AWD1IE
            AWD1IE: u1,
            /// AWD2IE
            AWD2IE: u1,
            /// AWD3IE
            AWD3IE: u1,
            /// JQOVFIE
            JQOVFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x4);

        /// address: 0x50000508
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADEN
            ADEN: u1,
            /// ADDIS
            ADDIS: u1,
            /// ADSTART
            ADSTART: u1,
            /// JADSTART
            JADSTART: u1,
            /// ADSTP
            ADSTP: u1,
            /// JADSTP
            JADSTP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// ADVREGEN
            ADVREGEN: u1,
            /// DEEPPWD
            DEEPPWD: u1,
            /// ADCALDIF
            ADCALDIF: u1,
            /// ADCAL
            ADCAL: u1,
        }), base_address + 0x8);

        /// address: 0x5000050c
        /// configuration register
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMAEN
            DMAEN: u1,
            /// DMACFG
            DMACFG: u1,
            reserved0: u1,
            /// RES
            RES: u2,
            /// ALIGN
            ALIGN: u1,
            /// EXTSEL
            EXTSEL: u4,
            /// EXTEN
            EXTEN: u2,
            /// OVRMOD
            OVRMOD: u1,
            /// CONT
            CONT: u1,
            /// AUTDLY
            AUTDLY: u1,
            /// AUTOFF
            AUTOFF: u1,
            /// DISCEN
            DISCEN: u1,
            /// DISCNUM
            DISCNUM: u3,
            /// JDISCEN
            JDISCEN: u1,
            /// JQM
            JQM: u1,
            /// AWD1SGL
            AWD1SGL: u1,
            /// AWD1EN
            AWD1EN: u1,
            /// JAWD1EN
            JAWD1EN: u1,
            /// JAUTO
            JAUTO: u1,
            /// AWDCH1CH
            AWDCH1CH: u5,
            padding0: u1,
        }), base_address + 0xc);

        /// address: 0x50000514
        /// sample time register 1
        pub const SMPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// SMP1
            SMP1: u3,
            /// SMP2
            SMP2: u3,
            /// SMP3
            SMP3: u3,
            /// SMP4
            SMP4: u3,
            /// SMP5
            SMP5: u3,
            /// SMP6
            SMP6: u3,
            /// SMP7
            SMP7: u3,
            /// SMP8
            SMP8: u3,
            /// SMP9
            SMP9: u3,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x14);

        /// address: 0x50000518
        /// sample time register 2
        pub const SMPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SMP10
            SMP10: u3,
            /// SMP11
            SMP11: u3,
            /// SMP12
            SMP12: u3,
            /// SMP13
            SMP13: u3,
            /// SMP14
            SMP14: u3,
            /// SMP15
            SMP15: u3,
            /// SMP16
            SMP16: u3,
            /// SMP17
            SMP17: u3,
            /// SMP18
            SMP18: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x18);

        /// address: 0x50000520
        /// watchdog threshold register 1
        pub const TR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT1
            LT1: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// HT1
            HT1: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20);

        /// address: 0x50000524
        /// watchdog threshold register
        pub const TR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT2
            LT2: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// HT2
            HT2: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x24);

        /// address: 0x50000528
        /// watchdog threshold register 3
        pub const TR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT3
            LT3: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// HT3
            HT3: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x28);

        /// address: 0x50000530
        /// regular sequence register 1
        pub const SQR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// L3
            L3: u4,
            reserved0: u1,
            reserved1: u1,
            /// SQ1
            SQ1: u5,
            reserved2: u1,
            /// SQ2
            SQ2: u5,
            reserved3: u1,
            /// SQ3
            SQ3: u5,
            reserved4: u1,
            /// SQ4
            SQ4: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x30);

        /// address: 0x50000534
        /// regular sequence register 2
        pub const SQR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ5
            SQ5: u5,
            reserved0: u1,
            /// SQ6
            SQ6: u5,
            reserved1: u1,
            /// SQ7
            SQ7: u5,
            reserved2: u1,
            /// SQ8
            SQ8: u5,
            reserved3: u1,
            /// SQ9
            SQ9: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x34);

        /// address: 0x50000538
        /// regular sequence register 3
        pub const SQR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ10
            SQ10: u5,
            reserved0: u1,
            /// SQ11
            SQ11: u5,
            reserved1: u1,
            /// SQ12
            SQ12: u5,
            reserved2: u1,
            /// SQ13
            SQ13: u5,
            reserved3: u1,
            /// SQ14
            SQ14: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x38);

        /// address: 0x5000053c
        /// regular sequence register 4
        pub const SQR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ15
            SQ15: u5,
            reserved0: u1,
            /// SQ16
            SQ16: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x3c);

        /// address: 0x50000540
        /// regular Data Register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// regularDATA
            regularDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x5000054c
        /// injected sequence register
        pub const JSQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// JL
            JL: u2,
            /// JEXTSEL
            JEXTSEL: u4,
            /// JEXTEN
            JEXTEN: u2,
            /// JSQ1
            JSQ1: u5,
            reserved0: u1,
            /// JSQ2
            JSQ2: u5,
            reserved1: u1,
            /// JSQ3
            JSQ3: u5,
            reserved2: u1,
            /// JSQ4
            JSQ4: u5,
            padding0: u1,
        }), base_address + 0x4c);

        /// address: 0x50000560
        /// offset register 1
        pub const OFR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET1
            OFFSET1: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET1_CH
            OFFSET1_CH: u5,
            /// OFFSET1_EN
            OFFSET1_EN: u1,
        }), base_address + 0x60);

        /// address: 0x50000564
        /// offset register 2
        pub const OFR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET2
            OFFSET2: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET2_CH
            OFFSET2_CH: u5,
            /// OFFSET2_EN
            OFFSET2_EN: u1,
        }), base_address + 0x64);

        /// address: 0x50000568
        /// offset register 3
        pub const OFR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET3
            OFFSET3: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET3_CH
            OFFSET3_CH: u5,
            /// OFFSET3_EN
            OFFSET3_EN: u1,
        }), base_address + 0x68);

        /// address: 0x5000056c
        /// offset register 4
        pub const OFR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET4
            OFFSET4: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET4_CH
            OFFSET4_CH: u5,
            /// OFFSET4_EN
            OFFSET4_EN: u1,
        }), base_address + 0x6c);

        /// address: 0x50000580
        /// injected data register 1
        pub const JDR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA1
            JDATA1: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x80);

        /// address: 0x50000584
        /// injected data register 2
        pub const JDR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA2
            JDATA2: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x50000588
        /// injected data register 3
        pub const JDR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA3
            JDATA3: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x88);

        /// address: 0x5000058c
        /// injected data register 4
        pub const JDR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA4
            JDATA4: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8c);

        /// address: 0x500005a0
        /// Analog Watchdog 2 Configuration
        /// Register
        pub const AWD2CR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// AWD2CH
            AWD2CH: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa0);

        /// address: 0x500005a4
        /// Analog Watchdog 3 Configuration
        /// Register
        pub const AWD3CR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// AWD3CH
            AWD3CH: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa4);

        /// address: 0x500005b0
        /// Differential Mode Selection Register
        /// 2
        pub const DIFSEL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Differential mode for channels 15 to
            /// 1
            DIFSEL_1_15: u15,
            /// Differential mode for channels 18 to
            /// 16
            DIFSEL_16_18: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xb0);

        /// address: 0x500005b4
        /// Calibration Factors
        pub const CALFACT = @intToPtr(*volatile Mmio(32, packed struct {
            /// CALFACT_S
            CALFACT_S: u7,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// CALFACT_D
            CALFACT_D: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0xb4);
    };
    /// Analog-to-Digital Converter
    pub const ADC1_2 = struct {
        pub const base_address = 0x50000300;

        /// address: 0x50000300
        /// ADC Common status register
        pub const CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDRDY_MST
            ADDRDY_MST: u1,
            /// EOSMP_MST
            EOSMP_MST: u1,
            /// EOC_MST
            EOC_MST: u1,
            /// EOS_MST
            EOS_MST: u1,
            /// OVR_MST
            OVR_MST: u1,
            /// JEOC_MST
            JEOC_MST: u1,
            /// JEOS_MST
            JEOS_MST: u1,
            /// AWD1_MST
            AWD1_MST: u1,
            /// AWD2_MST
            AWD2_MST: u1,
            /// AWD3_MST
            AWD3_MST: u1,
            /// JQOVF_MST
            JQOVF_MST: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// ADRDY_SLV
            ADRDY_SLV: u1,
            /// EOSMP_SLV
            EOSMP_SLV: u1,
            /// End of regular conversion of the slave
            /// ADC
            EOC_SLV: u1,
            /// End of regular sequence flag of the
            /// slave ADC
            EOS_SLV: u1,
            /// Overrun flag of the slave
            /// ADC
            OVR_SLV: u1,
            /// End of injected conversion flag of the
            /// slave ADC
            JEOC_SLV: u1,
            /// End of injected sequence flag of the
            /// slave ADC
            JEOS_SLV: u1,
            /// Analog watchdog 1 flag of the slave
            /// ADC
            AWD1_SLV: u1,
            /// Analog watchdog 2 flag of the slave
            /// ADC
            AWD2_SLV: u1,
            /// Analog watchdog 3 flag of the slave
            /// ADC
            AWD3_SLV: u1,
            /// Injected Context Queue Overflow flag of
            /// the slave ADC
            JQOVF_SLV: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x0);

        /// address: 0x50000308
        /// ADC common control register
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Multi ADC mode selection
            MULT: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Delay between 2 sampling
            /// phases
            DELAY: u4,
            reserved3: u1,
            /// DMA configuration (for multi-ADC
            /// mode)
            DMACFG: u1,
            /// Direct memory access mode for multi ADC
            /// mode
            MDMA: u2,
            /// ADC clock mode
            CKMODE: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// VREFINT enable
            VREFEN: u1,
            /// Temperature sensor enable
            TSEN: u1,
            /// VBAT enable
            VBATEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x8);

        /// address: 0x5000030c
        /// ADC common regular data register for dual
        /// and triple modes
        pub const CDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Regular data of the master
            /// ADC
            RDATA_MST: u16,
            /// Regular data of the slave
            /// ADC
            RDATA_SLV: u16,
        }), base_address + 0xc);
    };
    pub const ADC3_4 = struct {
        pub const base_address = 0x50000700;

        /// address: 0x50000700
        /// ADC Common status register
        pub const CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDRDY_MST
            ADDRDY_MST: u1,
            /// EOSMP_MST
            EOSMP_MST: u1,
            /// EOC_MST
            EOC_MST: u1,
            /// EOS_MST
            EOS_MST: u1,
            /// OVR_MST
            OVR_MST: u1,
            /// JEOC_MST
            JEOC_MST: u1,
            /// JEOS_MST
            JEOS_MST: u1,
            /// AWD1_MST
            AWD1_MST: u1,
            /// AWD2_MST
            AWD2_MST: u1,
            /// AWD3_MST
            AWD3_MST: u1,
            /// JQOVF_MST
            JQOVF_MST: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// ADRDY_SLV
            ADRDY_SLV: u1,
            /// EOSMP_SLV
            EOSMP_SLV: u1,
            /// End of regular conversion of the slave
            /// ADC
            EOC_SLV: u1,
            /// End of regular sequence flag of the
            /// slave ADC
            EOS_SLV: u1,
            /// Overrun flag of the slave
            /// ADC
            OVR_SLV: u1,
            /// End of injected conversion flag of the
            /// slave ADC
            JEOC_SLV: u1,
            /// End of injected sequence flag of the
            /// slave ADC
            JEOS_SLV: u1,
            /// Analog watchdog 1 flag of the slave
            /// ADC
            AWD1_SLV: u1,
            /// Analog watchdog 2 flag of the slave
            /// ADC
            AWD2_SLV: u1,
            /// Analog watchdog 3 flag of the slave
            /// ADC
            AWD3_SLV: u1,
            /// Injected Context Queue Overflow flag of
            /// the slave ADC
            JQOVF_SLV: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x0);

        /// address: 0x50000708
        /// ADC common control register
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Multi ADC mode selection
            MULT: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Delay between 2 sampling
            /// phases
            DELAY: u4,
            reserved3: u1,
            /// DMA configuration (for multi-ADC
            /// mode)
            DMACFG: u1,
            /// Direct memory access mode for multi ADC
            /// mode
            MDMA: u2,
            /// ADC clock mode
            CKMODE: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// VREFINT enable
            VREFEN: u1,
            /// Temperature sensor enable
            TSEN: u1,
            /// VBAT enable
            VBATEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x8);

        /// address: 0x5000070c
        /// ADC common regular data register for dual
        /// and triple modes
        pub const CDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Regular data of the master
            /// ADC
            RDATA_MST: u16,
            /// Regular data of the slave
            /// ADC
            RDATA_SLV: u16,
        }), base_address + 0xc);
    };
    /// System configuration controller _Comparator and
    /// Operational amplifier
    pub const SYSCFG_COMP_OPAMP = struct {
        pub const base_address = 0x40010000;

        /// address: 0x40010000
        /// configuration register 1
        pub const SYSCFG_CFGR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory mapping selection
            /// bits
            MEM_MODE: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// USB interrupt remap
            USB_IT_RMP: u1,
            /// Timer 1 ITR3 selection
            TIM1_ITR_RMP: u1,
            /// DAC trigger remap (when TSEL =
            /// 001)
            DAC_TRIG_RMP: u1,
            /// ADC24 DMA remapping bit
            ADC24_DMA_RMP: u1,
            reserved3: u1,
            reserved4: u1,
            /// TIM16 DMA request remapping
            /// bit
            TIM16_DMA_RMP: u1,
            /// TIM17 DMA request remapping
            /// bit
            TIM17_DMA_RMP: u1,
            /// TIM6 and DAC1 DMA request remapping
            /// bit
            TIM6_DAC1_DMA_RMP: u1,
            /// TIM7 and DAC2 DMA request remapping
            /// bit
            TIM7_DAC2_DMA_RMP: u1,
            reserved5: u1,
            /// Fast Mode Plus (FM+) driving capability
            /// activation bits.
            I2C_PB6_FM: u1,
            /// Fast Mode Plus (FM+) driving capability
            /// activation bits.
            I2C_PB7_FM: u1,
            /// Fast Mode Plus (FM+) driving capability
            /// activation bits.
            I2C_PB8_FM: u1,
            /// Fast Mode Plus (FM+) driving capability
            /// activation bits.
            I2C_PB9_FM: u1,
            /// I2C1 Fast Mode Plus
            I2C1_FM: u1,
            /// I2C2 Fast Mode Plus
            I2C2_FM: u1,
            /// Encoder mode
            ENCODER_MODE: u2,
            reserved6: u1,
            reserved7: u1,
            /// Interrupt enable bits from
            /// FPU
            FPU_IT: u6,
        }), base_address + 0x0);

        /// address: 0x40010008
        /// external interrupt configuration register
        /// 1
        pub const SYSCFG_EXTICR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI 0 configuration bits
            EXTI0: u4,
            /// EXTI 1 configuration bits
            EXTI1: u4,
            /// EXTI 2 configuration bits
            EXTI2: u4,
            /// EXTI 3 configuration bits
            EXTI3: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001000c
        /// external interrupt configuration register
        /// 2
        pub const SYSCFG_EXTICR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI 4 configuration bits
            EXTI4: u4,
            /// EXTI 5 configuration bits
            EXTI5: u4,
            /// EXTI 6 configuration bits
            EXTI6: u4,
            /// EXTI 7 configuration bits
            EXTI7: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40010010
        /// external interrupt configuration register
        /// 3
        pub const SYSCFG_EXTICR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI 8 configuration bits
            EXTI8: u4,
            /// EXTI 9 configuration bits
            EXTI9: u4,
            /// EXTI 10 configuration bits
            EXTI10: u4,
            /// EXTI 11 configuration bits
            EXTI11: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40010014
        /// external interrupt configuration register
        /// 4
        pub const SYSCFG_EXTICR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI 12 configuration bits
            EXTI12: u4,
            /// EXTI 13 configuration bits
            EXTI13: u4,
            /// EXTI 14 configuration bits
            EXTI14: u4,
            /// EXTI 15 configuration bits
            EXTI15: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40010018
        /// configuration register 2
        pub const SYSCFG_CFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Cortex-M0 LOCKUP bit enable
            /// bit
            LOCUP_LOCK: u1,
            /// SRAM parity lock bit
            SRAM_PARITY_LOCK: u1,
            /// PVD lock enable bit
            PVD_LOCK: u1,
            reserved0: u1,
            /// Bypass address bit 29 in parity
            /// calculation
            BYP_ADD_PAR: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// SRAM parity flag
            SRAM_PEF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x18);

        /// address: 0x40010004
        /// CCM SRAM protection register
        pub const SYSCFG_RCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CCM SRAM page write protection
            /// bit
            PAGE0_WP: u1,
            /// CCM SRAM page write protection
            /// bit
            PAGE1_WP: u1,
            /// CCM SRAM page write protection
            /// bit
            PAGE2_WP: u1,
            /// CCM SRAM page write protection
            /// bit
            PAGE3_WP: u1,
            /// CCM SRAM page write protection
            /// bit
            PAGE4_WP: u1,
            /// CCM SRAM page write protection
            /// bit
            PAGE5_WP: u1,
            /// CCM SRAM page write protection
            /// bit
            PAGE6_WP: u1,
            /// CCM SRAM page write protection
            /// bit
            PAGE7_WP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x4001001c
        /// control and status register
        pub const COMP1_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparator 1 enable
            COMP1EN: u1,
            /// COMP1_INP_DAC
            COMP1_INP_DAC: u1,
            /// Comparator 1 mode
            COMP1MODE: u2,
            /// Comparator 1 inverting input
            /// selection
            COMP1INSEL: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Comparator 1 output
            /// selection
            COMP1_OUT_SEL: u4,
            reserved3: u1,
            /// Comparator 1 output
            /// polarity
            COMP1POL: u1,
            /// Comparator 1 hysteresis
            COMP1HYST: u2,
            /// Comparator 1 blanking
            /// source
            COMP1_BLANKING: u3,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Comparator 1 output
            COMP1OUT: u1,
            /// Comparator 1 lock
            COMP1LOCK: u1,
        }), base_address + 0x1c);

        /// address: 0x40010020
        /// control and status register
        pub const COMP2_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparator 2 enable
            COMP2EN: u1,
            reserved0: u1,
            /// Comparator 2 mode
            COMP2MODE: u2,
            /// Comparator 2 inverting input
            /// selection
            COMP2INSEL: u3,
            /// Comparator 2 non inverted input
            /// selection
            COMP2INPSEL: u1,
            reserved1: u1,
            /// Comparator 1inverting input
            /// selection
            COMP2INMSEL: u1,
            /// Comparator 2 output
            /// selection
            COMP2_OUT_SEL: u4,
            reserved2: u1,
            /// Comparator 2 output
            /// polarity
            COMP2POL: u1,
            /// Comparator 2 hysteresis
            COMP2HYST: u2,
            /// Comparator 2 blanking
            /// source
            COMP2_BLANKING: u3,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Comparator 2 lock
            COMP2LOCK: u1,
        }), base_address + 0x20);

        /// address: 0x40010024
        /// control and status register
        pub const COMP3_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparator 3 enable
            COMP3EN: u1,
            reserved0: u1,
            /// Comparator 3 mode
            COMP3MODE: u2,
            /// Comparator 3 inverting input
            /// selection
            COMP3INSEL: u3,
            /// Comparator 3 non inverted input
            /// selection
            COMP3INPSEL: u1,
            reserved1: u1,
            reserved2: u1,
            /// Comparator 3 output
            /// selection
            COMP3_OUT_SEL: u4,
            reserved3: u1,
            /// Comparator 3 output
            /// polarity
            COMP3POL: u1,
            /// Comparator 3 hysteresis
            COMP3HYST: u2,
            /// Comparator 3 blanking
            /// source
            COMP3_BLANKING: u3,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Comparator 3 output
            COMP3OUT: u1,
            /// Comparator 3 lock
            COMP3LOCK: u1,
        }), base_address + 0x24);

        /// address: 0x40010028
        /// control and status register
        pub const COMP4_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparator 4 enable
            COMP4EN: u1,
            reserved0: u1,
            /// Comparator 4 mode
            COMP4MODE: u2,
            /// Comparator 4 inverting input
            /// selection
            COMP4INSEL: u3,
            /// Comparator 4 non inverted input
            /// selection
            COMP4INPSEL: u1,
            reserved1: u1,
            /// Comparator 4 window mode
            COM4WINMODE: u1,
            /// Comparator 4 output
            /// selection
            COMP4_OUT_SEL: u4,
            reserved2: u1,
            /// Comparator 4 output
            /// polarity
            COMP4POL: u1,
            /// Comparator 4 hysteresis
            COMP4HYST: u2,
            /// Comparator 4 blanking
            /// source
            COMP4_BLANKING: u3,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Comparator 4 output
            COMP4OUT: u1,
            /// Comparator 4 lock
            COMP4LOCK: u1,
        }), base_address + 0x28);

        /// address: 0x4001002c
        /// control and status register
        pub const COMP5_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparator 5 enable
            COMP5EN: u1,
            reserved0: u1,
            /// Comparator 5 mode
            COMP5MODE: u2,
            /// Comparator 5 inverting input
            /// selection
            COMP5INSEL: u3,
            /// Comparator 5 non inverted input
            /// selection
            COMP5INPSEL: u1,
            reserved1: u1,
            reserved2: u1,
            /// Comparator 5 output
            /// selection
            COMP5_OUT_SEL: u4,
            reserved3: u1,
            /// Comparator 5 output
            /// polarity
            COMP5POL: u1,
            /// Comparator 5 hysteresis
            COMP5HYST: u2,
            /// Comparator 5 blanking
            /// source
            COMP5_BLANKING: u3,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Comparator51 output
            COMP5OUT: u1,
            /// Comparator 5 lock
            COMP5LOCK: u1,
        }), base_address + 0x2c);

        /// address: 0x40010030
        /// control and status register
        pub const COMP6_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparator 6 enable
            COMP6EN: u1,
            reserved0: u1,
            /// Comparator 6 mode
            COMP6MODE: u2,
            /// Comparator 6 inverting input
            /// selection
            COMP6INSEL: u3,
            /// Comparator 6 non inverted input
            /// selection
            COMP6INPSEL: u1,
            reserved1: u1,
            /// Comparator 6 window mode
            COM6WINMODE: u1,
            /// Comparator 6 output
            /// selection
            COMP6_OUT_SEL: u4,
            reserved2: u1,
            /// Comparator 6 output
            /// polarity
            COMP6POL: u1,
            /// Comparator 6 hysteresis
            COMP6HYST: u2,
            /// Comparator 6 blanking
            /// source
            COMP6_BLANKING: u3,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Comparator 6 output
            COMP6OUT: u1,
            /// Comparator 6 lock
            COMP6LOCK: u1,
        }), base_address + 0x30);

        /// address: 0x40010034
        /// control and status register
        pub const COMP7_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparator 7 enable
            COMP7EN: u1,
            reserved0: u1,
            /// Comparator 7 mode
            COMP7MODE: u2,
            /// Comparator 7 inverting input
            /// selection
            COMP7INSEL: u3,
            /// Comparator 7 non inverted input
            /// selection
            COMP7INPSEL: u1,
            reserved1: u1,
            reserved2: u1,
            /// Comparator 7 output
            /// selection
            COMP7_OUT_SEL: u4,
            reserved3: u1,
            /// Comparator 7 output
            /// polarity
            COMP7POL: u1,
            /// Comparator 7 hysteresis
            COMP7HYST: u2,
            /// Comparator 7 blanking
            /// source
            COMP7_BLANKING: u3,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Comparator 7 output
            COMP7OUT: u1,
            /// Comparator 7 lock
            COMP7LOCK: u1,
        }), base_address + 0x34);

        /// address: 0x40010038
        /// control register
        pub const OPAMP1_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// OPAMP1 enable
            OPAMP1_EN: u1,
            /// FORCE_VP
            FORCE_VP: u1,
            /// OPAMP1 Non inverting input
            /// selection
            VP_SEL: u2,
            reserved0: u1,
            /// OPAMP1 inverting input
            /// selection
            VM_SEL: u2,
            /// Timer controlled Mux mode
            /// enable
            TCM_EN: u1,
            /// OPAMP1 inverting input secondary
            /// selection
            VMS_SEL: u1,
            /// OPAMP1 Non inverting input secondary
            /// selection
            VPS_SEL: u2,
            /// Calibration mode enable
            CALON: u1,
            /// Calibration selection
            CALSEL: u2,
            /// Gain in PGA mode
            PGA_GAIN: u4,
            /// User trimming enable
            USER_TRIM: u1,
            /// Offset trimming value
            /// (PMOS)
            TRIMOFFSETP: u5,
            /// Offset trimming value
            /// (NMOS)
            TRIMOFFSETN: u5,
            /// TSTREF
            TSTREF: u1,
            /// OPAMP 1 ouput status flag
            OUTCAL: u1,
            /// OPAMP 1 lock
            LOCK: u1,
        }), base_address + 0x38);

        /// address: 0x4001003c
        /// control register
        pub const OPAMP2_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// OPAMP2 enable
            OPAMP2EN: u1,
            /// FORCE_VP
            FORCE_VP: u1,
            /// OPAMP2 Non inverting input
            /// selection
            VP_SEL: u2,
            reserved0: u1,
            /// OPAMP2 inverting input
            /// selection
            VM_SEL: u2,
            /// Timer controlled Mux mode
            /// enable
            TCM_EN: u1,
            /// OPAMP2 inverting input secondary
            /// selection
            VMS_SEL: u1,
            /// OPAMP2 Non inverting input secondary
            /// selection
            VPS_SEL: u2,
            /// Calibration mode enable
            CALON: u1,
            /// Calibration selection
            CAL_SEL: u2,
            /// Gain in PGA mode
            PGA_GAIN: u4,
            /// User trimming enable
            USER_TRIM: u1,
            /// Offset trimming value
            /// (PMOS)
            TRIMOFFSETP: u5,
            /// Offset trimming value
            /// (NMOS)
            TRIMOFFSETN: u5,
            /// TSTREF
            TSTREF: u1,
            /// OPAMP 2 ouput status flag
            OUTCAL: u1,
            /// OPAMP 2 lock
            LOCK: u1,
        }), base_address + 0x3c);

        /// address: 0x40010040
        /// control register
        pub const OPAMP3_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// OPAMP3 enable
            OPAMP3EN: u1,
            /// FORCE_VP
            FORCE_VP: u1,
            /// OPAMP3 Non inverting input
            /// selection
            VP_SEL: u2,
            reserved0: u1,
            /// OPAMP3 inverting input
            /// selection
            VM_SEL: u2,
            /// Timer controlled Mux mode
            /// enable
            TCM_EN: u1,
            /// OPAMP3 inverting input secondary
            /// selection
            VMS_SEL: u1,
            /// OPAMP3 Non inverting input secondary
            /// selection
            VPS_SEL: u2,
            /// Calibration mode enable
            CALON: u1,
            /// Calibration selection
            CALSEL: u2,
            /// Gain in PGA mode
            PGA_GAIN: u4,
            /// User trimming enable
            USER_TRIM: u1,
            /// Offset trimming value
            /// (PMOS)
            TRIMOFFSETP: u5,
            /// Offset trimming value
            /// (NMOS)
            TRIMOFFSETN: u5,
            /// TSTREF
            TSTREF: u1,
            /// OPAMP 3 ouput status flag
            OUTCAL: u1,
            /// OPAMP 3 lock
            LOCK: u1,
        }), base_address + 0x40);

        /// address: 0x40010044
        /// control register
        pub const OPAMP4_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// OPAMP4 enable
            OPAMP4EN: u1,
            /// FORCE_VP
            FORCE_VP: u1,
            /// OPAMP4 Non inverting input
            /// selection
            VP_SEL: u2,
            reserved0: u1,
            /// OPAMP4 inverting input
            /// selection
            VM_SEL: u2,
            /// Timer controlled Mux mode
            /// enable
            TCM_EN: u1,
            /// OPAMP4 inverting input secondary
            /// selection
            VMS_SEL: u1,
            /// OPAMP4 Non inverting input secondary
            /// selection
            VPS_SEL: u2,
            /// Calibration mode enable
            CALON: u1,
            /// Calibration selection
            CALSEL: u2,
            /// Gain in PGA mode
            PGA_GAIN: u4,
            /// User trimming enable
            USER_TRIM: u1,
            /// Offset trimming value
            /// (PMOS)
            TRIMOFFSETP: u5,
            /// Offset trimming value
            /// (NMOS)
            TRIMOFFSETN: u5,
            /// TSTREF
            TSTREF: u1,
            /// OPAMP 4 ouput status flag
            OUTCAL: u1,
            /// OPAMP 4 lock
            LOCK: u1,
        }), base_address + 0x44);
    };
    /// Flexible memory controller
    pub const FMC = struct {
        pub const base_address = 0xa0000400;

        /// address: 0xa0000400
        /// SRAM/NOR-Flash chip-select control register
        /// 1
        pub const BCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MBKEN
            MBKEN: u1,
            /// MUXEN
            MUXEN: u1,
            /// MTYP
            MTYP: u2,
            /// MWID
            MWID: u2,
            /// FACCEN
            FACCEN: u1,
            reserved0: u1,
            /// BURSTEN
            BURSTEN: u1,
            /// WAITPOL
            WAITPOL: u1,
            reserved1: u1,
            /// WAITCFG
            WAITCFG: u1,
            /// WREN
            WREN: u1,
            /// WAITEN
            WAITEN: u1,
            /// EXTMOD
            EXTMOD: u1,
            /// ASYNCWAIT
            ASYNCWAIT: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// CBURSTRW
            CBURSTRW: u1,
            /// CCLKEN
            CCLKEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x0);

        /// address: 0xa0000404
        /// SRAM/NOR-Flash chip-select timing register
        /// 1
        pub const BTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            /// BUSTURN
            BUSTURN: u4,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x4);

        /// address: 0xa0000408
        /// SRAM/NOR-Flash chip-select control register
        /// 2
        pub const BCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MBKEN
            MBKEN: u1,
            /// MUXEN
            MUXEN: u1,
            /// MTYP
            MTYP: u2,
            /// MWID
            MWID: u2,
            /// FACCEN
            FACCEN: u1,
            reserved0: u1,
            /// BURSTEN
            BURSTEN: u1,
            /// WAITPOL
            WAITPOL: u1,
            /// WRAPMOD
            WRAPMOD: u1,
            /// WAITCFG
            WAITCFG: u1,
            /// WREN
            WREN: u1,
            /// WAITEN
            WAITEN: u1,
            /// EXTMOD
            EXTMOD: u1,
            /// ASYNCWAIT
            ASYNCWAIT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// CBURSTRW
            CBURSTRW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x8);

        /// address: 0xa000040c
        /// SRAM/NOR-Flash chip-select timing register
        /// 2
        pub const BTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            /// BUSTURN
            BUSTURN: u4,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xc);

        /// address: 0xa0000410
        /// SRAM/NOR-Flash chip-select control register
        /// 3
        pub const BCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MBKEN
            MBKEN: u1,
            /// MUXEN
            MUXEN: u1,
            /// MTYP
            MTYP: u2,
            /// MWID
            MWID: u2,
            /// FACCEN
            FACCEN: u1,
            reserved0: u1,
            /// BURSTEN
            BURSTEN: u1,
            /// WAITPOL
            WAITPOL: u1,
            /// WRAPMOD
            WRAPMOD: u1,
            /// WAITCFG
            WAITCFG: u1,
            /// WREN
            WREN: u1,
            /// WAITEN
            WAITEN: u1,
            /// EXTMOD
            EXTMOD: u1,
            /// ASYNCWAIT
            ASYNCWAIT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// CBURSTRW
            CBURSTRW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x10);

        /// address: 0xa0000414
        /// SRAM/NOR-Flash chip-select timing register
        /// 3
        pub const BTR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            /// BUSTURN
            BUSTURN: u4,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x14);

        /// address: 0xa0000418
        /// SRAM/NOR-Flash chip-select control register
        /// 4
        pub const BCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MBKEN
            MBKEN: u1,
            /// MUXEN
            MUXEN: u1,
            /// MTYP
            MTYP: u2,
            /// MWID
            MWID: u2,
            /// FACCEN
            FACCEN: u1,
            reserved0: u1,
            /// BURSTEN
            BURSTEN: u1,
            /// WAITPOL
            WAITPOL: u1,
            /// WRAPMOD
            WRAPMOD: u1,
            /// WAITCFG
            WAITCFG: u1,
            /// WREN
            WREN: u1,
            /// WAITEN
            WAITEN: u1,
            /// EXTMOD
            EXTMOD: u1,
            /// ASYNCWAIT
            ASYNCWAIT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// CBURSTRW
            CBURSTRW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x18);

        /// address: 0xa000041c
        /// SRAM/NOR-Flash chip-select timing register
        /// 4
        pub const BTR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            /// BUSTURN
            BUSTURN: u4,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x1c);

        /// address: 0xa0000460
        /// PC Card/NAND Flash control register
        /// 2
        pub const PCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// PWAITEN
            PWAITEN: u1,
            /// PBKEN
            PBKEN: u1,
            /// PTYP
            PTYP: u1,
            /// PWID
            PWID: u2,
            /// ECCEN
            ECCEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// TCLR
            TCLR: u4,
            /// TAR
            TAR: u4,
            /// ECCPS
            ECCPS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x60);

        /// address: 0xa0000464
        /// FIFO status and interrupt register
        /// 2
        pub const SR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IRS
            IRS: u1,
            /// ILS
            ILS: u1,
            /// IFS
            IFS: u1,
            /// IREN
            IREN: u1,
            /// ILEN
            ILEN: u1,
            /// IFEN
            IFEN: u1,
            /// FEMPT
            FEMPT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x64);

        /// address: 0xa0000468
        /// Common memory space timing register
        /// 2
        pub const PMEM2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MEMSETx
            MEMSETx: u8,
            /// MEMWAITx
            MEMWAITx: u8,
            /// MEMHOLDx
            MEMHOLDx: u8,
            /// MEMHIZx
            MEMHIZx: u8,
        }), base_address + 0x68);

        /// address: 0xa000046c
        /// Attribute memory space timing register
        /// 2
        pub const PATT2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ATTSETx
            ATTSETx: u8,
            /// ATTWAITx
            ATTWAITx: u8,
            /// ATTHOLDx
            ATTHOLDx: u8,
            /// ATTHIZx
            ATTHIZx: u8,
        }), base_address + 0x6c);

        /// address: 0xa0000474
        /// ECC result register 2
        pub const ECCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ECCx
            ECCx: u32,
        }), base_address + 0x74);

        /// address: 0xa0000480
        /// PC Card/NAND Flash control register
        /// 3
        pub const PCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// PWAITEN
            PWAITEN: u1,
            /// PBKEN
            PBKEN: u1,
            /// PTYP
            PTYP: u1,
            /// PWID
            PWID: u2,
            /// ECCEN
            ECCEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// TCLR
            TCLR: u4,
            /// TAR
            TAR: u4,
            /// ECCPS
            ECCPS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x80);

        /// address: 0xa0000484
        /// FIFO status and interrupt register
        /// 3
        pub const SR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IRS
            IRS: u1,
            /// ILS
            ILS: u1,
            /// IFS
            IFS: u1,
            /// IREN
            IREN: u1,
            /// ILEN
            ILEN: u1,
            /// IFEN
            IFEN: u1,
            /// FEMPT
            FEMPT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x84);

        /// address: 0xa0000488
        /// Common memory space timing register
        /// 3
        pub const PMEM3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MEMSETx
            MEMSETx: u8,
            /// MEMWAITx
            MEMWAITx: u8,
            /// MEMHOLDx
            MEMHOLDx: u8,
            /// MEMHIZx
            MEMHIZx: u8,
        }), base_address + 0x88);

        /// address: 0xa000048c
        /// Attribute memory space timing register
        /// 3
        pub const PATT3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ATTSETx
            ATTSETx: u8,
            /// ATTWAITx
            ATTWAITx: u8,
            /// ATTHOLDx
            ATTHOLDx: u8,
            /// ATTHIZx
            ATTHIZx: u8,
        }), base_address + 0x8c);

        /// address: 0xa0000494
        /// ECC result register 3
        pub const ECCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ECCx
            ECCx: u32,
        }), base_address + 0x94);

        /// address: 0xa00004a0
        /// PC Card/NAND Flash control register
        /// 4
        pub const PCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// PWAITEN
            PWAITEN: u1,
            /// PBKEN
            PBKEN: u1,
            /// PTYP
            PTYP: u1,
            /// PWID
            PWID: u2,
            /// ECCEN
            ECCEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// TCLR
            TCLR: u4,
            /// TAR
            TAR: u4,
            /// ECCPS
            ECCPS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0xa0);

        /// address: 0xa00004a4
        /// FIFO status and interrupt register
        /// 4
        pub const SR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IRS
            IRS: u1,
            /// ILS
            ILS: u1,
            /// IFS
            IFS: u1,
            /// IREN
            IREN: u1,
            /// ILEN
            ILEN: u1,
            /// IFEN
            IFEN: u1,
            /// FEMPT
            FEMPT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0xa4);

        /// address: 0xa00004a8
        /// Common memory space timing register
        /// 4
        pub const PMEM4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MEMSETx
            MEMSETx: u8,
            /// MEMWAITx
            MEMWAITx: u8,
            /// MEMHOLDx
            MEMHOLDx: u8,
            /// MEMHIZx
            MEMHIZx: u8,
        }), base_address + 0xa8);

        /// address: 0xa00004ac
        /// Attribute memory space timing register
        /// 4
        pub const PATT4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ATTSETx
            ATTSETx: u8,
            /// ATTWAITx
            ATTWAITx: u8,
            /// ATTHOLDx
            ATTHOLDx: u8,
            /// ATTHIZx
            ATTHIZx: u8,
        }), base_address + 0xac);

        /// address: 0xa00004b0
        /// I/O space timing register 4
        pub const PIO4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IOSETx
            IOSETx: u8,
            /// IOWAITx
            IOWAITx: u8,
            /// IOHOLDx
            IOHOLDx: u8,
            /// IOHIZx
            IOHIZx: u8,
        }), base_address + 0xb0);

        /// address: 0xa0000504
        /// SRAM/NOR-Flash write timing registers
        /// 1
        pub const BWTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            /// Bus turnaround phase
            /// duration
            BUSTURN: u4,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x104);

        /// address: 0xa000050c
        /// SRAM/NOR-Flash write timing registers
        /// 2
        pub const BWTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            /// Bus turnaround phase
            /// duration
            BUSTURN: u4,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x10c);

        /// address: 0xa0000514
        /// SRAM/NOR-Flash write timing registers
        /// 3
        pub const BWTR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            /// Bus turnaround phase
            /// duration
            BUSTURN: u4,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x114);

        /// address: 0xa000051c
        /// SRAM/NOR-Flash write timing registers
        /// 4
        pub const BWTR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            /// Bus turnaround phase
            /// duration
            BUSTURN: u4,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x11c);
    };
    /// Nested Vectored Interrupt
    /// Controller
    pub const NVIC = struct {
        pub const base_address = 0xe000e100;

        /// address: 0xe000e100
        /// Interrupt Set-Enable Register
        pub const ISER0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SETENA
            SETENA: u32,
        }), base_address + 0x0);

        /// address: 0xe000e104
        /// Interrupt Set-Enable Register
        pub const ISER1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SETENA
            SETENA: u32,
        }), base_address + 0x4);

        /// address: 0xe000e108
        /// Interrupt Set-Enable Register
        pub const ISER2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SETENA
            SETENA: u32,
        }), base_address + 0x8);

        /// address: 0xe000e180
        /// Interrupt Clear-Enable
        /// Register
        pub const ICER0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CLRENA
            CLRENA: u32,
        }), base_address + 0x80);

        /// address: 0xe000e184
        /// Interrupt Clear-Enable
        /// Register
        pub const ICER1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CLRENA
            CLRENA: u32,
        }), base_address + 0x84);

        /// address: 0xe000e188
        /// Interrupt Clear-Enable
        /// Register
        pub const ICER2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CLRENA
            CLRENA: u32,
        }), base_address + 0x88);

        /// address: 0xe000e200
        /// Interrupt Set-Pending Register
        pub const ISPR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SETPEND
            SETPEND: u32,
        }), base_address + 0x100);

        /// address: 0xe000e204
        /// Interrupt Set-Pending Register
        pub const ISPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SETPEND
            SETPEND: u32,
        }), base_address + 0x104);

        /// address: 0xe000e208
        /// Interrupt Set-Pending Register
        pub const ISPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SETPEND
            SETPEND: u32,
        }), base_address + 0x108);

        /// address: 0xe000e280
        /// Interrupt Clear-Pending
        /// Register
        pub const ICPR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CLRPEND
            CLRPEND: u32,
        }), base_address + 0x180);

        /// address: 0xe000e284
        /// Interrupt Clear-Pending
        /// Register
        pub const ICPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CLRPEND
            CLRPEND: u32,
        }), base_address + 0x184);

        /// address: 0xe000e288
        /// Interrupt Clear-Pending
        /// Register
        pub const ICPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CLRPEND
            CLRPEND: u32,
        }), base_address + 0x188);

        /// address: 0xe000e300
        /// Interrupt Active Bit Register
        pub const IABR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ACTIVE
            ACTIVE: u32,
        }), base_address + 0x200);

        /// address: 0xe000e304
        /// Interrupt Active Bit Register
        pub const IABR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ACTIVE
            ACTIVE: u32,
        }), base_address + 0x204);

        /// address: 0xe000e308
        /// Interrupt Active Bit Register
        pub const IABR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ACTIVE
            ACTIVE: u32,
        }), base_address + 0x208);

        /// address: 0xe000e400
        /// Interrupt Priority Register
        pub const IPR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x300);

        /// address: 0xe000e404
        /// Interrupt Priority Register
        pub const IPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x304);

        /// address: 0xe000e408
        /// Interrupt Priority Register
        pub const IPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x308);

        /// address: 0xe000e40c
        /// Interrupt Priority Register
        pub const IPR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x30c);

        /// address: 0xe000e410
        /// Interrupt Priority Register
        pub const IPR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x310);

        /// address: 0xe000e414
        /// Interrupt Priority Register
        pub const IPR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x314);

        /// address: 0xe000e418
        /// Interrupt Priority Register
        pub const IPR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x318);

        /// address: 0xe000e41c
        /// Interrupt Priority Register
        pub const IPR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x31c);

        /// address: 0xe000e420
        /// Interrupt Priority Register
        pub const IPR8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x320);

        /// address: 0xe000e424
        /// Interrupt Priority Register
        pub const IPR9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x324);

        /// address: 0xe000e428
        /// Interrupt Priority Register
        pub const IPR10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x328);

        /// address: 0xe000e42c
        /// Interrupt Priority Register
        pub const IPR11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x32c);

        /// address: 0xe000e430
        /// Interrupt Priority Register
        pub const IPR12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x330);

        /// address: 0xe000e434
        /// Interrupt Priority Register
        pub const IPR13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x334);

        /// address: 0xe000e438
        /// Interrupt Priority Register
        pub const IPR14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x338);

        /// address: 0xe000e43c
        /// Interrupt Priority Register
        pub const IPR15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x33c);

        /// address: 0xe000e440
        /// Interrupt Priority Register
        pub const IPR16 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x340);

        /// address: 0xe000e444
        /// Interrupt Priority Register
        pub const IPR17 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x344);

        /// address: 0xe000e448
        /// Interrupt Priority Register
        pub const IPR18 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x348);

        /// address: 0xe000e44c
        /// Interrupt Priority Register
        pub const IPR19 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x34c);

        /// address: 0xe000e450
        /// Interrupt Priority Register
        pub const IPR20 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x350);
    };
    /// Floting point unit
    pub const FPU = struct {
        pub const base_address = 0xe000ef34;

        /// address: 0xe000ef34
        /// Floating-point context control
        /// register
        pub const FPCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSPACT
            LSPACT: u1,
            /// USER
            USER: u1,
            reserved0: u1,
            /// THREAD
            THREAD: u1,
            /// HFRDY
            HFRDY: u1,
            /// MMRDY
            MMRDY: u1,
            /// BFRDY
            BFRDY: u1,
            reserved1: u1,
            /// MONRDY
            MONRDY: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// LSPEN
            LSPEN: u1,
            /// ASPEN
            ASPEN: u1,
        }), base_address + 0x0);

        /// address: 0xe000ef38
        /// Floating-point context address
        /// register
        pub const FPCAR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Location of unpopulated
            /// floating-point
            ADDRESS: u29,
        }), base_address + 0x4);

        /// address: 0xe000ef3c
        /// Floating-point status control
        /// register
        pub const FPSCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Invalid operation cumulative exception
            /// bit
            IOC: u1,
            /// Division by zero cumulative exception
            /// bit.
            DZC: u1,
            /// Overflow cumulative exception
            /// bit
            OFC: u1,
            /// Underflow cumulative exception
            /// bit
            UFC: u1,
            /// Inexact cumulative exception
            /// bit
            IXC: u1,
            reserved0: u1,
            reserved1: u1,
            /// Input denormal cumulative exception
            /// bit.
            IDC: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Rounding Mode control
            /// field
            RMode: u2,
            /// Flush-to-zero mode control
            /// bit:
            FZ: u1,
            /// Default NaN mode control
            /// bit
            DN: u1,
            /// Alternative half-precision control
            /// bit
            AHP: u1,
            reserved16: u1,
            /// Overflow condition code
            /// flag
            V: u1,
            /// Carry condition code flag
            C: u1,
            /// Zero condition code flag
            Z: u1,
            /// Negative condition code
            /// flag
            N: u1,
        }), base_address + 0x8);
    };
    /// Memory protection unit
    pub const MPU = struct {
        pub const base_address = 0xe000ed90;

        /// address: 0xe000ed90
        /// MPU type register
        pub const MPU_TYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Separate flag
            SEPARATE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Number of MPU data regions
            DREGION: u8,
            /// Number of MPU instruction
            /// regions
            IREGION: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0xe000ed94
        /// MPU control register
        pub const MPU_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enables the MPU
            ENABLE: u1,
            /// Enables the operation of MPU during hard
            /// fault
            HFNMIENA: u1,
            /// Enable priviliged software access to
            /// default memory map
            PRIVDEFENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4);

        /// address: 0xe000ed98
        /// MPU region number register
        pub const MPU_RNR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPU region
            REGION: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0xe000ed9c
        /// MPU region base address
        /// register
        pub const MPU_RBAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPU region field
            REGION: u4,
            /// MPU region number valid
            VALID: u1,
            /// Region base address field
            ADDR: u27,
        }), base_address + 0xc);

        /// address: 0xe000eda0
        /// MPU region attribute and size
        /// register
        pub const MPU_RASR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Region enable bit.
            ENABLE: u1,
            /// Size of the MPU protection
            /// region
            SIZE: u5,
            reserved0: u1,
            reserved1: u1,
            /// Subregion disable bits
            SRD: u8,
            /// memory attribute
            B: u1,
            /// memory attribute
            C: u1,
            /// Shareable memory attribute
            S: u1,
            /// memory attribute
            TEX: u3,
            reserved2: u1,
            reserved3: u1,
            /// Access permission
            AP: u3,
            reserved4: u1,
            /// Instruction access disable
            /// bit
            XN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x10);
    };
    /// SysTick timer
    pub const STK = struct {
        pub const base_address = 0xe000e010;

        /// address: 0xe000e010
        /// SysTick control and status
        /// register
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            ENABLE: u1,
            /// SysTick exception request
            /// enable
            TICKINT: u1,
            /// Clock source selection
            CLKSOURCE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// COUNTFLAG
            COUNTFLAG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x0);

        /// address: 0xe000e014
        /// SysTick reload value register
        pub const LOAD = @intToPtr(*volatile Mmio(32, packed struct {
            /// RELOAD value
            RELOAD: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0xe000e018
        /// SysTick current value register
        pub const VAL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current counter value
            CURRENT: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x8);

        /// address: 0xe000e01c
        /// SysTick calibration value
        /// register
        pub const CALIB = @intToPtr(*volatile Mmio(32, packed struct {
            /// Calibration value
            TENMS: u24,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// SKEW flag: Indicates whether the TENMS
            /// value is exact
            SKEW: u1,
            /// NOREF flag. Reads as zero
            NOREF: u1,
        }), base_address + 0xc);
    };
    /// System control block
    pub const SCB = struct {
        pub const base_address = 0xe000ed00;

        /// address: 0xe000ed00
        /// CPUID base register
        pub const CPUID = @intToPtr(*volatile Mmio(32, packed struct {
            /// Revision number
            Revision: u4,
            /// Part number of the
            /// processor
            PartNo: u12,
            /// Reads as 0xF
            Constant: u4,
            /// Variant number
            Variant: u4,
            /// Implementer code
            Implementer: u8,
        }), base_address + 0x0);

        /// address: 0xe000ed04
        /// Interrupt control and state
        /// register
        pub const ICSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Active vector
            VECTACTIVE: u9,
            reserved0: u1,
            reserved1: u1,
            /// Return to base level
            RETTOBASE: u1,
            /// Pending vector
            VECTPENDING: u7,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Interrupt pending flag
            ISRPENDING: u1,
            reserved5: u1,
            reserved6: u1,
            /// SysTick exception clear-pending
            /// bit
            PENDSTCLR: u1,
            /// SysTick exception set-pending
            /// bit
            PENDSTSET: u1,
            /// PendSV clear-pending bit
            PENDSVCLR: u1,
            /// PendSV set-pending bit
            PENDSVSET: u1,
            reserved7: u1,
            reserved8: u1,
            /// NMI set-pending bit.
            NMIPENDSET: u1,
        }), base_address + 0x4);

        /// address: 0xe000ed08
        /// Vector table offset register
        pub const VTOR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Vector table base offset
            /// field
            TBLOFF: u21,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x8);

        /// address: 0xe000ed0c
        /// Application interrupt and reset control
        /// register
        pub const AIRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// VECTRESET
            VECTRESET: u1,
            /// VECTCLRACTIVE
            VECTCLRACTIVE: u1,
            /// SYSRESETREQ
            SYSRESETREQ: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// PRIGROUP
            PRIGROUP: u3,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// ENDIANESS
            ENDIANESS: u1,
            /// Register key
            VECTKEYSTAT: u16,
        }), base_address + 0xc);

        /// address: 0xe000ed10
        /// System control register
        pub const SCR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// SLEEPONEXIT
            SLEEPONEXIT: u1,
            /// SLEEPDEEP
            SLEEPDEEP: u1,
            reserved1: u1,
            /// Send Event on Pending bit
            SEVEONPEND: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x10);

        /// address: 0xe000ed14
        /// Configuration and control
        /// register
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Configures how the processor enters
            /// Thread mode
            NONBASETHRDENA: u1,
            /// USERSETMPEND
            USERSETMPEND: u1,
            reserved0: u1,
            /// UNALIGN_ TRP
            UNALIGN__TRP: u1,
            /// DIV_0_TRP
            DIV_0_TRP: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// BFHFNMIGN
            BFHFNMIGN: u1,
            /// STKALIGN
            STKALIGN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x14);

        /// address: 0xe000ed18
        /// System handler priority
        /// registers
        pub const SHPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Priority of system handler
            /// 4
            PRI_4: u8,
            /// Priority of system handler
            /// 5
            PRI_5: u8,
            /// Priority of system handler
            /// 6
            PRI_6: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0xe000ed1c
        /// System handler priority
        /// registers
        pub const SHPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// Priority of system handler
            /// 11
            PRI_11: u8,
        }), base_address + 0x1c);

        /// address: 0xe000ed20
        /// System handler priority
        /// registers
        pub const SHPR3 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Priority of system handler
            /// 14
            PRI_14: u8,
            /// Priority of system handler
            /// 15
            PRI_15: u8,
        }), base_address + 0x20);

        /// address: 0xe000ed24
        /// System handler control and state
        /// register
        pub const SHCRS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory management fault exception active
            /// bit
            MEMFAULTACT: u1,
            /// Bus fault exception active
            /// bit
            BUSFAULTACT: u1,
            reserved0: u1,
            /// Usage fault exception active
            /// bit
            USGFAULTACT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// SVC call active bit
            SVCALLACT: u1,
            /// Debug monitor active bit
            MONITORACT: u1,
            reserved4: u1,
            /// PendSV exception active
            /// bit
            PENDSVACT: u1,
            /// SysTick exception active
            /// bit
            SYSTICKACT: u1,
            /// Usage fault exception pending
            /// bit
            USGFAULTPENDED: u1,
            /// Memory management fault exception
            /// pending bit
            MEMFAULTPENDED: u1,
            /// Bus fault exception pending
            /// bit
            BUSFAULTPENDED: u1,
            /// SVC call pending bit
            SVCALLPENDED: u1,
            /// Memory management fault enable
            /// bit
            MEMFAULTENA: u1,
            /// Bus fault enable bit
            BUSFAULTENA: u1,
            /// Usage fault enable bit
            USGFAULTENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x24);

        /// address: 0xe000ed28
        /// Configurable fault status
        /// register
        pub const CFSR_UFSR_BFSR_MMFSR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Instruction access violation
            /// flag
            IACCVIOL: u1,
            reserved1: u1,
            /// Memory manager fault on unstacking for a
            /// return from exception
            MUNSTKERR: u1,
            /// Memory manager fault on stacking for
            /// exception entry.
            MSTKERR: u1,
            /// MLSPERR
            MLSPERR: u1,
            reserved2: u1,
            /// Memory Management Fault Address Register
            /// (MMAR) valid flag
            MMARVALID: u1,
            /// Instruction bus error
            IBUSERR: u1,
            /// Precise data bus error
            PRECISERR: u1,
            /// Imprecise data bus error
            IMPRECISERR: u1,
            /// Bus fault on unstacking for a return
            /// from exception
            UNSTKERR: u1,
            /// Bus fault on stacking for exception
            /// entry
            STKERR: u1,
            /// Bus fault on floating-point lazy state
            /// preservation
            LSPERR: u1,
            reserved3: u1,
            /// Bus Fault Address Register (BFAR) valid
            /// flag
            BFARVALID: u1,
            /// Undefined instruction usage
            /// fault
            UNDEFINSTR: u1,
            /// Invalid state usage fault
            INVSTATE: u1,
            /// Invalid PC load usage
            /// fault
            INVPC: u1,
            /// No coprocessor usage
            /// fault.
            NOCP: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Unaligned access usage
            /// fault
            UNALIGNED: u1,
            /// Divide by zero usage fault
            DIVBYZERO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x28);

        /// address: 0xe000ed2c
        /// Hard fault status register
        pub const HFSR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Vector table hard fault
            VECTTBL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            /// Forced hard fault
            FORCED: u1,
            /// Reserved for Debug use
            DEBUG_VT: u1,
        }), base_address + 0x2c);

        /// address: 0xe000ed34
        /// Memory management fault address
        /// register
        pub const MMFAR = @intToPtr(*volatile u32, base_address + 0x34);

        /// address: 0xe000ed38
        /// Bus fault address register
        pub const BFAR = @intToPtr(*volatile u32, base_address + 0x38);

        /// address: 0xe000ed3c
        /// Auxiliary fault status
        /// register
        pub const AFSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Implementation defined
            IMPDEF: u32,
        }), base_address + 0x3c);
    };
    /// Nested vectored interrupt
    /// controller
    pub const NVIC_STIR = struct {
        pub const base_address = 0xe000ef00;

        /// address: 0xe000ef00
        /// Software trigger interrupt
        /// register
        pub const STIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software generated interrupt
            /// ID
            INTID: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x0);
    };
    /// Floating point unit CPACR
    pub const FPU_CPACR = struct {
        pub const base_address = 0xe000ed88;

        /// address: 0xe000ed88
        /// Coprocessor access control
        /// register
        pub const CPACR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// CP
            CP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);
    };
    /// System control block ACTLR
    pub const SCB_ACTRL = struct {
        pub const base_address = 0xe000e008;

        /// address: 0xe000e008
        /// Auxiliary control register
        pub const ACTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// DISMCYCINT
            DISMCYCINT: u1,
            /// DISDEFWBUF
            DISDEFWBUF: u1,
            /// DISFOLD
            DISFOLD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// DISFPCA
            DISFPCA: u1,
            /// DISOOFP
            DISOOFP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);
    };
};

const std = @import("std");

pub fn mmio(addr: usize, comptime size: u8, comptime PackedT: type) *volatile Mmio(size, PackedT) {
    return @intToPtr(*volatile Mmio(size, PackedT), addr);
}

pub fn Mmio(comptime size: u8, comptime PackedT: type) type {
    if ((size % 8) != 0)
        @compileError("size must be divisible by 8!");

    if (!std.math.isPowerOfTwo(size / 8))
        @compileError("size must encode a power of two number of bytes!");

    const IntT = std.meta.Int(.unsigned, size);

    if (@sizeOf(PackedT) != (size / 8))
        @compileError(std.fmt.comptimePrint("IntT and PackedT must have the same size!, they are {} and {} bytes respectively", .{ size / 8, @sizeOf(PackedT) }));

    return extern struct {
        const Self = @This();

        raw: IntT,

        pub const underlying_type = PackedT;

        pub fn read(addr: *volatile Self) PackedT {
            return @bitCast(PackedT, addr.raw);
        }

        pub fn write(addr: *volatile Self, val: PackedT) void {
            // This is a workaround for a compiler bug related to miscompilation
            // If the tmp var is not used, result location will fuck things up
            var tmp = @bitCast(IntT, val);
            addr.raw = tmp;
        }

        pub fn modify(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, field.name) = @field(fields, field.name);
            }
            write(addr, val);
        }

        pub fn toggle(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, @tagName(field.default_value.?)) = !@field(val, @tagName(field.default_value.?));
            }
            write(addr, val);
        }
    };
}

pub fn MmioInt(comptime size: u8, comptime T: type) type {
    return extern struct {
        const Self = @This();

        raw: std.meta.Int(.unsigned, size),

        pub fn read(addr: *volatile Self) T {
            return @truncate(T, addr.raw);
        }

        pub fn modify(addr: *volatile Self, val: T) void {
            const Int = std.meta.Int(.unsigned, size);
            const mask = ~@as(Int, (1 << @bitSizeOf(T)) - 1);

            var tmp = addr.raw;
            addr.raw = (tmp & mask) | val;
        }
    };
}

pub fn mmioInt(addr: usize, comptime size: usize, comptime T: type) *volatile MmioInt(size, T) {
    return @intToPtr(*volatile MmioInt(size, T), addr);
}

pub const InterruptVector = extern union {
    C: fn () callconv(.C) void,
    Naked: fn () callconv(.Naked) void,
    // Interrupt is not supported on arm
};

const unhandled = InterruptVector{
    .C = struct {
        fn tmp() callconv(.C) noreturn {
            @panic("unhandled interrupt");
        }
    }.tmp,
};
