// this file was generated by regz: https://github.com/ZigEmbeddedGroup/regz
// commit: 341b0177d90a56f4307cc3226d552b39b048e7fa
//
// device: STM32F103xx
// cpu: CM3

pub const VectorTable = extern struct {
    initial_stack_pointer: u32,
    Reset: InterruptVector = unhandled,
    NMI: InterruptVector = unhandled,
    HardFault: InterruptVector = unhandled,
    MemManage: InterruptVector = unhandled,
    BusFault: InterruptVector = unhandled,
    UsageFault: InterruptVector = unhandled,
    reserved0: [4]u32 = undefined,
    SVCall: InterruptVector = unhandled,
    reserved1: [2]u32 = undefined,
    PendSV: InterruptVector = unhandled,
    SysTick: InterruptVector = unhandled,
    /// Window Watchdog interrupt
    WWDG: InterruptVector = unhandled,
    /// PVD through EXTI line detection
    /// interrupt
    PVD: InterruptVector = unhandled,
    /// Tamper interrupt
    TAMPER: InterruptVector = unhandled,
    /// RTC global interrupt
    RTC: InterruptVector = unhandled,
    /// Flash global interrupt
    FLASH: InterruptVector = unhandled,
    /// RCC global interrupt
    RCC: InterruptVector = unhandled,
    /// EXTI Line0 interrupt
    EXTI0: InterruptVector = unhandled,
    /// EXTI Line1 interrupt
    EXTI1: InterruptVector = unhandled,
    /// EXTI Line2 interrupt
    EXTI2: InterruptVector = unhandled,
    /// EXTI Line3 interrupt
    EXTI3: InterruptVector = unhandled,
    /// EXTI Line4 interrupt
    EXTI4: InterruptVector = unhandled,
    /// DMA1 Channel1 global interrupt
    DMA1_Channel1: InterruptVector = unhandled,
    /// DMA1 Channel2 global interrupt
    DMA1_Channel2: InterruptVector = unhandled,
    /// DMA1 Channel3 global interrupt
    DMA1_Channel3: InterruptVector = unhandled,
    /// DMA1 Channel4 global interrupt
    DMA1_Channel4: InterruptVector = unhandled,
    /// DMA1 Channel5 global interrupt
    DMA1_Channel5: InterruptVector = unhandled,
    /// DMA1 Channel6 global interrupt
    DMA1_Channel6: InterruptVector = unhandled,
    /// DMA1 Channel7 global interrupt
    DMA1_Channel7: InterruptVector = unhandled,
    /// ADC1 global interrupt
    ADC: InterruptVector = unhandled,
    /// CAN1 TX interrupts
    CAN1_TX: InterruptVector = unhandled,
    /// CAN1 RX0 interrupts
    CAN1_RX0: InterruptVector = unhandled,
    /// CAN1 RX1 interrupt
    CAN1_RX1: InterruptVector = unhandled,
    /// CAN1 SCE interrupt
    CAN1_SCE: InterruptVector = unhandled,
    /// EXTI Line[9:5] interrupts
    EXTI9_5: InterruptVector = unhandled,
    /// TIM1 Break interrupt and TIM9 global
    /// interrupt
    TIM1_BRK_TIM9: InterruptVector = unhandled,
    /// TIM1 Update interrupt and TIM10 global
    /// interrupt
    TIM1_UP_TIM10: InterruptVector = unhandled,
    /// TIM1 Trigger and Commutation interrupts and
    /// TIM11 global interrupt
    TIM1_TRG_COM_TIM11: InterruptVector = unhandled,
    /// TIM1 Capture Compare interrupt
    TIM1_CC: InterruptVector = unhandled,
    /// TIM2 global interrupt
    TIM2: InterruptVector = unhandled,
    /// TIM3 global interrupt
    TIM3: InterruptVector = unhandled,
    /// TIM4 global interrupt
    TIM4: InterruptVector = unhandled,
    /// I2C1 event interrupt
    I2C1_EV: InterruptVector = unhandled,
    /// I2C1 error interrupt
    I2C1_ER: InterruptVector = unhandled,
    /// I2C2 event interrupt
    I2C2_EV: InterruptVector = unhandled,
    /// I2C2 error interrupt
    I2C2_ER: InterruptVector = unhandled,
    /// SPI1 global interrupt
    SPI1: InterruptVector = unhandled,
    /// SPI2 global interrupt
    SPI2: InterruptVector = unhandled,
    /// USART1 global interrupt
    USART1: InterruptVector = unhandled,
    /// USART2 global interrupt
    USART2: InterruptVector = unhandled,
    /// USART3 global interrupt
    USART3: InterruptVector = unhandled,
    /// EXTI Line[15:10] interrupts
    EXTI15_10: InterruptVector = unhandled,
    /// RTC Alarms through EXTI line
    /// interrupt
    RTCAlarm: InterruptVector = unhandled,
    /// USB Device FS Wakeup through EXTI line
    /// interrupt
    USB_FS_WKUP: InterruptVector = unhandled,
    /// TIM8 Break interrupt and TIM12 global
    /// interrupt
    TIM8_BRK_TIM12: InterruptVector = unhandled,
    /// TIM8 Update interrupt and TIM13 global
    /// interrupt
    TIM8_UP_TIM13: InterruptVector = unhandled,
    /// TIM8 Trigger and Commutation interrupts and
    /// TIM14 global interrupt
    TIM8_TRG_COM_TIM14: InterruptVector = unhandled,
    /// TIM8 Capture Compare interrupt
    TIM8_CC: InterruptVector = unhandled,
    /// ADC3 global interrupt
    ADC3: InterruptVector = unhandled,
    /// FSMC global interrupt
    FSMC: InterruptVector = unhandled,
    /// SDIO global interrupt
    SDIO: InterruptVector = unhandled,
    /// TIM5 global interrupt
    TIM5: InterruptVector = unhandled,
    /// SPI3 global interrupt
    SPI3: InterruptVector = unhandled,
    /// UART4 global interrupt
    UART4: InterruptVector = unhandled,
    /// UART5 global interrupt
    UART5: InterruptVector = unhandled,
    /// TIM6 global interrupt
    TIM6: InterruptVector = unhandled,
    /// TIM7 global interrupt
    TIM7: InterruptVector = unhandled,
    /// DMA2 Channel1 global interrupt
    DMA2_Channel1: InterruptVector = unhandled,
    /// DMA2 Channel2 global interrupt
    DMA2_Channel2: InterruptVector = unhandled,
    /// DMA2 Channel3 global interrupt
    DMA2_Channel3: InterruptVector = unhandled,
    /// DMA2 Channel4 and DMA2 Channel5 global
    /// interrupt
    DMA2_Channel4_5: InterruptVector = unhandled,
};

pub const registers = struct {
    /// System Control Space
    pub const SCS = struct {
        pub const base_address = 0xe000e000;

        /// System Tick Timer
        pub const SysTick = struct {
            /// address: 0xe000e010
            /// SysTick Control and Status Register
            pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
                ENABLE: u1,
                TICKINT: u1,
                CLKSOURCE: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                COUNTFLAG: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
            }), base_address + 0x10);

            /// address: 0xe000e014
            /// SysTick Reload Value Register
            pub const LOAD = @intToPtr(*volatile Mmio(32, packed struct {
                RELOAD: u24,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x14);

            /// address: 0xe000e018
            /// SysTick Current Value Register
            pub const VAL = @intToPtr(*volatile Mmio(32, packed struct {
                CURRENT: u24,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x18);

            /// address: 0xe000e01c
            /// SysTick Calibration Register
            pub const CALIB = @intToPtr(*volatile Mmio(32, packed struct {
                TENMS: u24,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                SKEW: u1,
                NOREF: u1,
            }), base_address + 0x1c);
        };
    };

    /// Flexible static memory controller
    pub const FSMC = struct {
        pub const base_address = 0xa0000000;

        /// address: 0xa0000000
        /// SRAM/NOR-Flash chip-select control register
        /// 1
        pub const BCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MBKEN
            MBKEN: u1,
            /// MUXEN
            MUXEN: u1,
            /// MTYP
            MTYP: u2,
            /// MWID
            MWID: u2,
            /// FACCEN
            FACCEN: u1,
            reserved0: u1,
            /// BURSTEN
            BURSTEN: u1,
            /// WAITPOL
            WAITPOL: u1,
            reserved1: u1,
            /// WAITCFG
            WAITCFG: u1,
            /// WREN
            WREN: u1,
            /// WAITEN
            WAITEN: u1,
            /// EXTMOD
            EXTMOD: u1,
            /// ASYNCWAIT
            ASYNCWAIT: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// CBURSTRW
            CBURSTRW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x0);

        /// address: 0xa0000004
        /// SRAM/NOR-Flash chip-select timing register
        /// 1
        pub const BTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            /// BUSTURN
            BUSTURN: u4,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x4);

        /// address: 0xa0000008
        /// SRAM/NOR-Flash chip-select control register
        /// 2
        pub const BCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MBKEN
            MBKEN: u1,
            /// MUXEN
            MUXEN: u1,
            /// MTYP
            MTYP: u2,
            /// MWID
            MWID: u2,
            /// FACCEN
            FACCEN: u1,
            reserved0: u1,
            /// BURSTEN
            BURSTEN: u1,
            /// WAITPOL
            WAITPOL: u1,
            /// WRAPMOD
            WRAPMOD: u1,
            /// WAITCFG
            WAITCFG: u1,
            /// WREN
            WREN: u1,
            /// WAITEN
            WAITEN: u1,
            /// EXTMOD
            EXTMOD: u1,
            /// ASYNCWAIT
            ASYNCWAIT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// CBURSTRW
            CBURSTRW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x8);

        /// address: 0xa000000c
        /// SRAM/NOR-Flash chip-select timing register
        /// 2
        pub const BTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            /// BUSTURN
            BUSTURN: u4,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xc);

        /// address: 0xa0000010
        /// SRAM/NOR-Flash chip-select control register
        /// 3
        pub const BCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MBKEN
            MBKEN: u1,
            /// MUXEN
            MUXEN: u1,
            /// MTYP
            MTYP: u2,
            /// MWID
            MWID: u2,
            /// FACCEN
            FACCEN: u1,
            reserved0: u1,
            /// BURSTEN
            BURSTEN: u1,
            /// WAITPOL
            WAITPOL: u1,
            /// WRAPMOD
            WRAPMOD: u1,
            /// WAITCFG
            WAITCFG: u1,
            /// WREN
            WREN: u1,
            /// WAITEN
            WAITEN: u1,
            /// EXTMOD
            EXTMOD: u1,
            /// ASYNCWAIT
            ASYNCWAIT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// CBURSTRW
            CBURSTRW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x10);

        /// address: 0xa0000014
        /// SRAM/NOR-Flash chip-select timing register
        /// 3
        pub const BTR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            /// BUSTURN
            BUSTURN: u4,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x14);

        /// address: 0xa0000018
        /// SRAM/NOR-Flash chip-select control register
        /// 4
        pub const BCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MBKEN
            MBKEN: u1,
            /// MUXEN
            MUXEN: u1,
            /// MTYP
            MTYP: u2,
            /// MWID
            MWID: u2,
            /// FACCEN
            FACCEN: u1,
            reserved0: u1,
            /// BURSTEN
            BURSTEN: u1,
            /// WAITPOL
            WAITPOL: u1,
            /// WRAPMOD
            WRAPMOD: u1,
            /// WAITCFG
            WAITCFG: u1,
            /// WREN
            WREN: u1,
            /// WAITEN
            WAITEN: u1,
            /// EXTMOD
            EXTMOD: u1,
            /// ASYNCWAIT
            ASYNCWAIT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// CBURSTRW
            CBURSTRW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x18);

        /// address: 0xa000001c
        /// SRAM/NOR-Flash chip-select timing register
        /// 4
        pub const BTR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            /// BUSTURN
            BUSTURN: u4,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x1c);

        /// address: 0xa0000060
        /// PC Card/NAND Flash control register
        /// 2
        pub const PCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// PWAITEN
            PWAITEN: u1,
            /// PBKEN
            PBKEN: u1,
            /// PTYP
            PTYP: u1,
            /// PWID
            PWID: u2,
            /// ECCEN
            ECCEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// TCLR
            TCLR: u4,
            /// TAR
            TAR: u4,
            /// ECCPS
            ECCPS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x60);

        /// address: 0xa0000064
        /// FIFO status and interrupt register
        /// 2
        pub const SR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IRS
            IRS: u1,
            /// ILS
            ILS: u1,
            /// IFS
            IFS: u1,
            /// IREN
            IREN: u1,
            /// ILEN
            ILEN: u1,
            /// IFEN
            IFEN: u1,
            /// FEMPT
            FEMPT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x64);

        /// address: 0xa0000068
        /// Common memory space timing register
        /// 2
        pub const PMEM2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MEMSETx
            MEMSETx: u8,
            /// MEMWAITx
            MEMWAITx: u8,
            /// MEMHOLDx
            MEMHOLDx: u8,
            /// MEMHIZx
            MEMHIZx: u8,
        }), base_address + 0x68);

        /// address: 0xa000006c
        /// Attribute memory space timing register
        /// 2
        pub const PATT2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Attribute memory x setup
            /// time
            ATTSETx: u8,
            /// Attribute memory x wait
            /// time
            ATTWAITx: u8,
            /// Attribute memory x hold
            /// time
            ATTHOLDx: u8,
            /// Attribute memory x databus HiZ
            /// time
            ATTHIZx: u8,
        }), base_address + 0x6c);

        /// address: 0xa0000074
        /// ECC result register 2
        pub const ECCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ECC result
            ECCx: u32,
        }), base_address + 0x74);

        /// address: 0xa0000080
        /// PC Card/NAND Flash control register
        /// 3
        pub const PCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// PWAITEN
            PWAITEN: u1,
            /// PBKEN
            PBKEN: u1,
            /// PTYP
            PTYP: u1,
            /// PWID
            PWID: u2,
            /// ECCEN
            ECCEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// TCLR
            TCLR: u4,
            /// TAR
            TAR: u4,
            /// ECCPS
            ECCPS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x80);

        /// address: 0xa0000084
        /// FIFO status and interrupt register
        /// 3
        pub const SR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IRS
            IRS: u1,
            /// ILS
            ILS: u1,
            /// IFS
            IFS: u1,
            /// IREN
            IREN: u1,
            /// ILEN
            ILEN: u1,
            /// IFEN
            IFEN: u1,
            /// FEMPT
            FEMPT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x84);

        /// address: 0xa0000088
        /// Common memory space timing register
        /// 3
        pub const PMEM3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MEMSETx
            MEMSETx: u8,
            /// MEMWAITx
            MEMWAITx: u8,
            /// MEMHOLDx
            MEMHOLDx: u8,
            /// MEMHIZx
            MEMHIZx: u8,
        }), base_address + 0x88);

        /// address: 0xa000008c
        /// Attribute memory space timing register
        /// 3
        pub const PATT3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ATTSETx
            ATTSETx: u8,
            /// ATTWAITx
            ATTWAITx: u8,
            /// ATTHOLDx
            ATTHOLDx: u8,
            /// ATTHIZx
            ATTHIZx: u8,
        }), base_address + 0x8c);

        /// address: 0xa0000094
        /// ECC result register 3
        pub const ECCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ECCx
            ECCx: u32,
        }), base_address + 0x94);

        /// address: 0xa00000a0
        /// PC Card/NAND Flash control register
        /// 4
        pub const PCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// PWAITEN
            PWAITEN: u1,
            /// PBKEN
            PBKEN: u1,
            /// PTYP
            PTYP: u1,
            /// PWID
            PWID: u2,
            /// ECCEN
            ECCEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// TCLR
            TCLR: u4,
            /// TAR
            TAR: u4,
            /// ECCPS
            ECCPS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0xa0);

        /// address: 0xa00000a4
        /// FIFO status and interrupt register
        /// 4
        pub const SR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IRS
            IRS: u1,
            /// ILS
            ILS: u1,
            /// IFS
            IFS: u1,
            /// IREN
            IREN: u1,
            /// ILEN
            ILEN: u1,
            /// IFEN
            IFEN: u1,
            /// FEMPT
            FEMPT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0xa4);

        /// address: 0xa00000a8
        /// Common memory space timing register
        /// 4
        pub const PMEM4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// MEMSETx
            MEMSETx: u8,
            /// MEMWAITx
            MEMWAITx: u8,
            /// MEMHOLDx
            MEMHOLDx: u8,
            /// MEMHIZx
            MEMHIZx: u8,
        }), base_address + 0xa8);

        /// address: 0xa00000ac
        /// Attribute memory space timing register
        /// 4
        pub const PATT4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ATTSETx
            ATTSETx: u8,
            /// ATTWAITx
            ATTWAITx: u8,
            /// ATTHOLDx
            ATTHOLDx: u8,
            /// ATTHIZx
            ATTHIZx: u8,
        }), base_address + 0xac);

        /// address: 0xa00000b0
        /// I/O space timing register 4
        pub const PIO4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IOSETx
            IOSETx: u8,
            /// IOWAITx
            IOWAITx: u8,
            /// IOHOLDx
            IOHOLDx: u8,
            /// IOHIZx
            IOHIZx: u8,
        }), base_address + 0xb0);

        /// address: 0xa0000104
        /// SRAM/NOR-Flash write timing registers
        /// 1
        pub const BWTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x104);

        /// address: 0xa000010c
        /// SRAM/NOR-Flash write timing registers
        /// 2
        pub const BWTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x10c);

        /// address: 0xa0000114
        /// SRAM/NOR-Flash write timing registers
        /// 3
        pub const BWTR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x114);

        /// address: 0xa000011c
        /// SRAM/NOR-Flash write timing registers
        /// 4
        pub const BWTR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDSET
            ADDSET: u4,
            /// ADDHLD
            ADDHLD: u4,
            /// DATAST
            DATAST: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// CLKDIV
            CLKDIV: u4,
            /// DATLAT
            DATLAT: u4,
            /// ACCMOD
            ACCMOD: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x11c);
    };

    /// Power control
    pub const PWR = struct {
        pub const base_address = 0x40007000;

        /// address: 0x40007000
        /// Power control register
        /// (PWR_CR)
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Power Deep Sleep
            LPDS: u1,
            /// Power Down Deep Sleep
            PDDS: u1,
            /// Clear Wake-up Flag
            CWUF: u1,
            /// Clear STANDBY Flag
            CSBF: u1,
            /// Power Voltage Detector
            /// Enable
            PVDE: u1,
            /// PVD Level Selection
            PLS: u3,
            /// Disable Backup Domain write
            /// protection
            DBP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x0);

        /// address: 0x40007004
        /// Power control register
        /// (PWR_CR)
        pub const CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wake-Up Flag
            WUF: u1,
            /// STANDBY Flag
            SBF: u1,
            /// PVD Output
            PVDO: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Enable WKUP pin
            EWUP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x4);
    };

    /// Reset and clock control
    pub const RCC = struct {
        pub const base_address = 0x40021000;

        /// address: 0x40021000
        /// Clock control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Internal High Speed clock
            /// enable
            HSION: u1,
            /// Internal High Speed clock ready
            /// flag
            HSIRDY: u1,
            reserved0: u1,
            /// Internal High Speed clock
            /// trimming
            HSITRIM: u5,
            /// Internal High Speed clock
            /// Calibration
            HSICAL: u8,
            /// External High Speed clock
            /// enable
            HSEON: u1,
            /// External High Speed clock ready
            /// flag
            HSERDY: u1,
            /// External High Speed clock
            /// Bypass
            HSEBYP: u1,
            /// Clock Security System
            /// enable
            CSSON: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// PLL enable
            PLLON: u1,
            /// PLL clock ready flag
            PLLRDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x0);

        /// address: 0x40021004
        /// Clock configuration register
        /// (RCC_CFGR)
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// System clock Switch
            SW: u2,
            /// System Clock Switch Status
            SWS: u2,
            /// AHB prescaler
            HPRE: u4,
            /// APB Low speed prescaler
            /// (APB1)
            PPRE1: u3,
            /// APB High speed prescaler
            /// (APB2)
            PPRE2: u3,
            /// ADC prescaler
            ADCPRE: u2,
            /// PLL entry clock source
            PLLSRC: u1,
            /// HSE divider for PLL entry
            PLLXTPRE: u1,
            /// PLL Multiplication Factor
            PLLMUL: u4,
            /// USB OTG FS prescaler
            OTGFSPRE: u1,
            reserved0: u1,
            /// Microcontroller clock
            /// output
            MCO: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40021008
        /// Clock interrupt register
        /// (RCC_CIR)
        pub const CIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSI Ready Interrupt flag
            LSIRDYF: u1,
            /// LSE Ready Interrupt flag
            LSERDYF: u1,
            /// HSI Ready Interrupt flag
            HSIRDYF: u1,
            /// HSE Ready Interrupt flag
            HSERDYF: u1,
            /// PLL Ready Interrupt flag
            PLLRDYF: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock Security System Interrupt
            /// flag
            CSSF: u1,
            /// LSI Ready Interrupt Enable
            LSIRDYIE: u1,
            /// LSE Ready Interrupt Enable
            LSERDYIE: u1,
            /// HSI Ready Interrupt Enable
            HSIRDYIE: u1,
            /// HSE Ready Interrupt Enable
            HSERDYIE: u1,
            /// PLL Ready Interrupt Enable
            PLLRDYIE: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// LSI Ready Interrupt Clear
            LSIRDYC: u1,
            /// LSE Ready Interrupt Clear
            LSERDYC: u1,
            /// HSI Ready Interrupt Clear
            HSIRDYC: u1,
            /// HSE Ready Interrupt Clear
            HSERDYC: u1,
            /// PLL Ready Interrupt Clear
            PLLRDYC: u1,
            reserved5: u1,
            reserved6: u1,
            /// Clock security system interrupt
            /// clear
            CSSC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x8);

        /// address: 0x4002100c
        /// APB2 peripheral reset register
        /// (RCC_APB2RSTR)
        pub const APB2RSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function I/O
            /// reset
            AFIORST: u1,
            reserved0: u1,
            /// IO port A reset
            IOPARST: u1,
            /// IO port B reset
            IOPBRST: u1,
            /// IO port C reset
            IOPCRST: u1,
            /// IO port D reset
            IOPDRST: u1,
            /// IO port E reset
            IOPERST: u1,
            /// IO port F reset
            IOPFRST: u1,
            /// IO port G reset
            IOPGRST: u1,
            /// ADC 1 interface reset
            ADC1RST: u1,
            /// ADC 2 interface reset
            ADC2RST: u1,
            /// TIM1 timer reset
            TIM1RST: u1,
            /// SPI 1 reset
            SPI1RST: u1,
            /// TIM8 timer reset
            TIM8RST: u1,
            /// USART1 reset
            USART1RST: u1,
            /// ADC 3 interface reset
            ADC3RST: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TIM9 timer reset
            TIM9RST: u1,
            /// TIM10 timer reset
            TIM10RST: u1,
            /// TIM11 timer reset
            TIM11RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0xc);

        /// address: 0x40021010
        /// APB1 peripheral reset register
        /// (RCC_APB1RSTR)
        pub const APB1RSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer 2 reset
            TIM2RST: u1,
            /// Timer 3 reset
            TIM3RST: u1,
            /// Timer 4 reset
            TIM4RST: u1,
            /// Timer 5 reset
            TIM5RST: u1,
            /// Timer 6 reset
            TIM6RST: u1,
            /// Timer 7 reset
            TIM7RST: u1,
            /// Timer 12 reset
            TIM12RST: u1,
            /// Timer 13 reset
            TIM13RST: u1,
            /// Timer 14 reset
            TIM14RST: u1,
            reserved0: u1,
            reserved1: u1,
            /// Window watchdog reset
            WWDGRST: u1,
            reserved2: u1,
            reserved3: u1,
            /// SPI2 reset
            SPI2RST: u1,
            /// SPI3 reset
            SPI3RST: u1,
            reserved4: u1,
            /// USART 2 reset
            USART2RST: u1,
            /// USART 3 reset
            USART3RST: u1,
            /// UART 4 reset
            UART4RST: u1,
            /// UART 5 reset
            UART5RST: u1,
            /// I2C1 reset
            I2C1RST: u1,
            /// I2C2 reset
            I2C2RST: u1,
            /// USB reset
            USBRST: u1,
            reserved5: u1,
            /// CAN reset
            CANRST: u1,
            reserved6: u1,
            /// Backup interface reset
            BKPRST: u1,
            /// Power interface reset
            PWRRST: u1,
            /// DAC interface reset
            DACRST: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x10);

        /// address: 0x40021014
        /// AHB Peripheral Clock enable register
        /// (RCC_AHBENR)
        pub const AHBENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA1 clock enable
            DMA1EN: u1,
            /// DMA2 clock enable
            DMA2EN: u1,
            /// SRAM interface clock
            /// enable
            SRAMEN: u1,
            reserved0: u1,
            /// FLITF clock enable
            FLITFEN: u1,
            reserved1: u1,
            /// CRC clock enable
            CRCEN: u1,
            reserved2: u1,
            /// FSMC clock enable
            FSMCEN: u1,
            reserved3: u1,
            /// SDIO clock enable
            SDIOEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x14);

        /// address: 0x40021018
        /// APB2 peripheral clock enable register
        /// (RCC_APB2ENR)
        pub const APB2ENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function I/O clock
            /// enable
            AFIOEN: u1,
            reserved0: u1,
            /// I/O port A clock enable
            IOPAEN: u1,
            /// I/O port B clock enable
            IOPBEN: u1,
            /// I/O port C clock enable
            IOPCEN: u1,
            /// I/O port D clock enable
            IOPDEN: u1,
            /// I/O port E clock enable
            IOPEEN: u1,
            /// I/O port F clock enable
            IOPFEN: u1,
            /// I/O port G clock enable
            IOPGEN: u1,
            /// ADC 1 interface clock
            /// enable
            ADC1EN: u1,
            /// ADC 2 interface clock
            /// enable
            ADC2EN: u1,
            /// TIM1 Timer clock enable
            TIM1EN: u1,
            /// SPI 1 clock enable
            SPI1EN: u1,
            /// TIM8 Timer clock enable
            TIM8EN: u1,
            /// USART1 clock enable
            USART1EN: u1,
            /// ADC3 interface clock
            /// enable
            ADC3EN: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TIM9 Timer clock enable
            TIM9EN: u1,
            /// TIM10 Timer clock enable
            TIM10EN: u1,
            /// TIM11 Timer clock enable
            TIM11EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x18);

        /// address: 0x4002101c
        /// APB1 peripheral clock enable register
        /// (RCC_APB1ENR)
        pub const APB1ENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer 2 clock enable
            TIM2EN: u1,
            /// Timer 3 clock enable
            TIM3EN: u1,
            /// Timer 4 clock enable
            TIM4EN: u1,
            /// Timer 5 clock enable
            TIM5EN: u1,
            /// Timer 6 clock enable
            TIM6EN: u1,
            /// Timer 7 clock enable
            TIM7EN: u1,
            /// Timer 12 clock enable
            TIM12EN: u1,
            /// Timer 13 clock enable
            TIM13EN: u1,
            /// Timer 14 clock enable
            TIM14EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Window watchdog clock
            /// enable
            WWDGEN: u1,
            reserved2: u1,
            reserved3: u1,
            /// SPI 2 clock enable
            SPI2EN: u1,
            /// SPI 3 clock enable
            SPI3EN: u1,
            reserved4: u1,
            /// USART 2 clock enable
            USART2EN: u1,
            /// USART 3 clock enable
            USART3EN: u1,
            /// UART 4 clock enable
            UART4EN: u1,
            /// UART 5 clock enable
            UART5EN: u1,
            /// I2C 1 clock enable
            I2C1EN: u1,
            /// I2C 2 clock enable
            I2C2EN: u1,
            /// USB clock enable
            USBEN: u1,
            reserved5: u1,
            /// CAN clock enable
            CANEN: u1,
            reserved6: u1,
            /// Backup interface clock
            /// enable
            BKPEN: u1,
            /// Power interface clock
            /// enable
            PWREN: u1,
            /// DAC interface clock enable
            DACEN: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x1c);

        /// address: 0x40021020
        /// Backup domain control register
        /// (RCC_BDCR)
        pub const BDCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// External Low Speed oscillator
            /// enable
            LSEON: u1,
            /// External Low Speed oscillator
            /// ready
            LSERDY: u1,
            /// External Low Speed oscillator
            /// bypass
            LSEBYP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// RTC clock source selection
            RTCSEL: u2,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// RTC clock enable
            RTCEN: u1,
            /// Backup domain software
            /// reset
            BDRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x20);

        /// address: 0x40021024
        /// Control/status register
        /// (RCC_CSR)
        pub const CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Internal low speed oscillator
            /// enable
            LSION: u1,
            /// Internal low speed oscillator
            /// ready
            LSIRDY: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// Remove reset flag
            RMVF: u1,
            reserved22: u1,
            /// PIN reset flag
            PINRSTF: u1,
            /// POR/PDR reset flag
            PORRSTF: u1,
            /// Software reset flag
            SFTRSTF: u1,
            /// Independent watchdog reset
            /// flag
            IWDGRSTF: u1,
            /// Window watchdog reset flag
            WWDGRSTF: u1,
            /// Low-power reset flag
            LPWRRSTF: u1,
        }), base_address + 0x24);
    };

    /// General purpose I/O
    pub const GPIOA = struct {
        pub const base_address = 0x40010800;

        /// address: 0x40010800
        /// Port configuration register low
        /// (GPIOn_CRL)
        pub const CRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port n.0 mode bits
            MODE0: u2,
            /// Port n.0 configuration
            /// bits
            CNF0: u2,
            /// Port n.1 mode bits
            MODE1: u2,
            /// Port n.1 configuration
            /// bits
            CNF1: u2,
            /// Port n.2 mode bits
            MODE2: u2,
            /// Port n.2 configuration
            /// bits
            CNF2: u2,
            /// Port n.3 mode bits
            MODE3: u2,
            /// Port n.3 configuration
            /// bits
            CNF3: u2,
            /// Port n.4 mode bits
            MODE4: u2,
            /// Port n.4 configuration
            /// bits
            CNF4: u2,
            /// Port n.5 mode bits
            MODE5: u2,
            /// Port n.5 configuration
            /// bits
            CNF5: u2,
            /// Port n.6 mode bits
            MODE6: u2,
            /// Port n.6 configuration
            /// bits
            CNF6: u2,
            /// Port n.7 mode bits
            MODE7: u2,
            /// Port n.7 configuration
            /// bits
            CNF7: u2,
        }), base_address + 0x0);

        /// address: 0x40010804
        /// Port configuration register high
        /// (GPIOn_CRL)
        pub const CRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port n.8 mode bits
            MODE8: u2,
            /// Port n.8 configuration
            /// bits
            CNF8: u2,
            /// Port n.9 mode bits
            MODE9: u2,
            /// Port n.9 configuration
            /// bits
            CNF9: u2,
            /// Port n.10 mode bits
            MODE10: u2,
            /// Port n.10 configuration
            /// bits
            CNF10: u2,
            /// Port n.11 mode bits
            MODE11: u2,
            /// Port n.11 configuration
            /// bits
            CNF11: u2,
            /// Port n.12 mode bits
            MODE12: u2,
            /// Port n.12 configuration
            /// bits
            CNF12: u2,
            /// Port n.13 mode bits
            MODE13: u2,
            /// Port n.13 configuration
            /// bits
            CNF13: u2,
            /// Port n.14 mode bits
            MODE14: u2,
            /// Port n.14 configuration
            /// bits
            CNF14: u2,
            /// Port n.15 mode bits
            MODE15: u2,
            /// Port n.15 configuration
            /// bits
            CNF15: u2,
        }), base_address + 0x4);

        /// address: 0x40010808
        /// Port input data register
        /// (GPIOn_IDR)
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data
            IDR0: u1,
            /// Port input data
            IDR1: u1,
            /// Port input data
            IDR2: u1,
            /// Port input data
            IDR3: u1,
            /// Port input data
            IDR4: u1,
            /// Port input data
            IDR5: u1,
            /// Port input data
            IDR6: u1,
            /// Port input data
            IDR7: u1,
            /// Port input data
            IDR8: u1,
            /// Port input data
            IDR9: u1,
            /// Port input data
            IDR10: u1,
            /// Port input data
            IDR11: u1,
            /// Port input data
            IDR12: u1,
            /// Port input data
            IDR13: u1,
            /// Port input data
            IDR14: u1,
            /// Port input data
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001080c
        /// Port output data register
        /// (GPIOn_ODR)
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data
            ODR0: u1,
            /// Port output data
            ODR1: u1,
            /// Port output data
            ODR2: u1,
            /// Port output data
            ODR3: u1,
            /// Port output data
            ODR4: u1,
            /// Port output data
            ODR5: u1,
            /// Port output data
            ODR6: u1,
            /// Port output data
            ODR7: u1,
            /// Port output data
            ODR8: u1,
            /// Port output data
            ODR9: u1,
            /// Port output data
            ODR10: u1,
            /// Port output data
            ODR11: u1,
            /// Port output data
            ODR12: u1,
            /// Port output data
            ODR13: u1,
            /// Port output data
            ODR14: u1,
            /// Port output data
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40010810
        /// Port bit set/reset register
        /// (GPIOn_BSRR)
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set bit 0
            BS0: u1,
            /// Set bit 1
            BS1: u1,
            /// Set bit 1
            BS2: u1,
            /// Set bit 3
            BS3: u1,
            /// Set bit 4
            BS4: u1,
            /// Set bit 5
            BS5: u1,
            /// Set bit 6
            BS6: u1,
            /// Set bit 7
            BS7: u1,
            /// Set bit 8
            BS8: u1,
            /// Set bit 9
            BS9: u1,
            /// Set bit 10
            BS10: u1,
            /// Set bit 11
            BS11: u1,
            /// Set bit 12
            BS12: u1,
            /// Set bit 13
            BS13: u1,
            /// Set bit 14
            BS14: u1,
            /// Set bit 15
            BS15: u1,
            /// Reset bit 0
            BR0: u1,
            /// Reset bit 1
            BR1: u1,
            /// Reset bit 2
            BR2: u1,
            /// Reset bit 3
            BR3: u1,
            /// Reset bit 4
            BR4: u1,
            /// Reset bit 5
            BR5: u1,
            /// Reset bit 6
            BR6: u1,
            /// Reset bit 7
            BR7: u1,
            /// Reset bit 8
            BR8: u1,
            /// Reset bit 9
            BR9: u1,
            /// Reset bit 10
            BR10: u1,
            /// Reset bit 11
            BR11: u1,
            /// Reset bit 12
            BR12: u1,
            /// Reset bit 13
            BR13: u1,
            /// Reset bit 14
            BR14: u1,
            /// Reset bit 15
            BR15: u1,
        }), base_address + 0x10);

        /// address: 0x40010814
        /// Port bit reset register
        /// (GPIOn_BRR)
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reset bit 0
            BR0: u1,
            /// Reset bit 1
            BR1: u1,
            /// Reset bit 1
            BR2: u1,
            /// Reset bit 3
            BR3: u1,
            /// Reset bit 4
            BR4: u1,
            /// Reset bit 5
            BR5: u1,
            /// Reset bit 6
            BR6: u1,
            /// Reset bit 7
            BR7: u1,
            /// Reset bit 8
            BR8: u1,
            /// Reset bit 9
            BR9: u1,
            /// Reset bit 10
            BR10: u1,
            /// Reset bit 11
            BR11: u1,
            /// Reset bit 12
            BR12: u1,
            /// Reset bit 13
            BR13: u1,
            /// Reset bit 14
            BR14: u1,
            /// Reset bit 15
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40010818
        /// Port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port A Lock bit 0
            LCK0: u1,
            /// Port A Lock bit 1
            LCK1: u1,
            /// Port A Lock bit 2
            LCK2: u1,
            /// Port A Lock bit 3
            LCK3: u1,
            /// Port A Lock bit 4
            LCK4: u1,
            /// Port A Lock bit 5
            LCK5: u1,
            /// Port A Lock bit 6
            LCK6: u1,
            /// Port A Lock bit 7
            LCK7: u1,
            /// Port A Lock bit 8
            LCK8: u1,
            /// Port A Lock bit 9
            LCK9: u1,
            /// Port A Lock bit 10
            LCK10: u1,
            /// Port A Lock bit 11
            LCK11: u1,
            /// Port A Lock bit 12
            LCK12: u1,
            /// Port A Lock bit 13
            LCK13: u1,
            /// Port A Lock bit 14
            LCK14: u1,
            /// Port A Lock bit 15
            LCK15: u1,
            /// Lock key
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);
    };
    pub const GPIOB = struct {
        pub const base_address = 0x40010c00;

        /// address: 0x40010c00
        /// Port configuration register low
        /// (GPIOn_CRL)
        pub const CRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port n.0 mode bits
            MODE0: u2,
            /// Port n.0 configuration
            /// bits
            CNF0: u2,
            /// Port n.1 mode bits
            MODE1: u2,
            /// Port n.1 configuration
            /// bits
            CNF1: u2,
            /// Port n.2 mode bits
            MODE2: u2,
            /// Port n.2 configuration
            /// bits
            CNF2: u2,
            /// Port n.3 mode bits
            MODE3: u2,
            /// Port n.3 configuration
            /// bits
            CNF3: u2,
            /// Port n.4 mode bits
            MODE4: u2,
            /// Port n.4 configuration
            /// bits
            CNF4: u2,
            /// Port n.5 mode bits
            MODE5: u2,
            /// Port n.5 configuration
            /// bits
            CNF5: u2,
            /// Port n.6 mode bits
            MODE6: u2,
            /// Port n.6 configuration
            /// bits
            CNF6: u2,
            /// Port n.7 mode bits
            MODE7: u2,
            /// Port n.7 configuration
            /// bits
            CNF7: u2,
        }), base_address + 0x0);

        /// address: 0x40010c04
        /// Port configuration register high
        /// (GPIOn_CRL)
        pub const CRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port n.8 mode bits
            MODE8: u2,
            /// Port n.8 configuration
            /// bits
            CNF8: u2,
            /// Port n.9 mode bits
            MODE9: u2,
            /// Port n.9 configuration
            /// bits
            CNF9: u2,
            /// Port n.10 mode bits
            MODE10: u2,
            /// Port n.10 configuration
            /// bits
            CNF10: u2,
            /// Port n.11 mode bits
            MODE11: u2,
            /// Port n.11 configuration
            /// bits
            CNF11: u2,
            /// Port n.12 mode bits
            MODE12: u2,
            /// Port n.12 configuration
            /// bits
            CNF12: u2,
            /// Port n.13 mode bits
            MODE13: u2,
            /// Port n.13 configuration
            /// bits
            CNF13: u2,
            /// Port n.14 mode bits
            MODE14: u2,
            /// Port n.14 configuration
            /// bits
            CNF14: u2,
            /// Port n.15 mode bits
            MODE15: u2,
            /// Port n.15 configuration
            /// bits
            CNF15: u2,
        }), base_address + 0x4);

        /// address: 0x40010c08
        /// Port input data register
        /// (GPIOn_IDR)
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data
            IDR0: u1,
            /// Port input data
            IDR1: u1,
            /// Port input data
            IDR2: u1,
            /// Port input data
            IDR3: u1,
            /// Port input data
            IDR4: u1,
            /// Port input data
            IDR5: u1,
            /// Port input data
            IDR6: u1,
            /// Port input data
            IDR7: u1,
            /// Port input data
            IDR8: u1,
            /// Port input data
            IDR9: u1,
            /// Port input data
            IDR10: u1,
            /// Port input data
            IDR11: u1,
            /// Port input data
            IDR12: u1,
            /// Port input data
            IDR13: u1,
            /// Port input data
            IDR14: u1,
            /// Port input data
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x40010c0c
        /// Port output data register
        /// (GPIOn_ODR)
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data
            ODR0: u1,
            /// Port output data
            ODR1: u1,
            /// Port output data
            ODR2: u1,
            /// Port output data
            ODR3: u1,
            /// Port output data
            ODR4: u1,
            /// Port output data
            ODR5: u1,
            /// Port output data
            ODR6: u1,
            /// Port output data
            ODR7: u1,
            /// Port output data
            ODR8: u1,
            /// Port output data
            ODR9: u1,
            /// Port output data
            ODR10: u1,
            /// Port output data
            ODR11: u1,
            /// Port output data
            ODR12: u1,
            /// Port output data
            ODR13: u1,
            /// Port output data
            ODR14: u1,
            /// Port output data
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40010c10
        /// Port bit set/reset register
        /// (GPIOn_BSRR)
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set bit 0
            BS0: u1,
            /// Set bit 1
            BS1: u1,
            /// Set bit 1
            BS2: u1,
            /// Set bit 3
            BS3: u1,
            /// Set bit 4
            BS4: u1,
            /// Set bit 5
            BS5: u1,
            /// Set bit 6
            BS6: u1,
            /// Set bit 7
            BS7: u1,
            /// Set bit 8
            BS8: u1,
            /// Set bit 9
            BS9: u1,
            /// Set bit 10
            BS10: u1,
            /// Set bit 11
            BS11: u1,
            /// Set bit 12
            BS12: u1,
            /// Set bit 13
            BS13: u1,
            /// Set bit 14
            BS14: u1,
            /// Set bit 15
            BS15: u1,
            /// Reset bit 0
            BR0: u1,
            /// Reset bit 1
            BR1: u1,
            /// Reset bit 2
            BR2: u1,
            /// Reset bit 3
            BR3: u1,
            /// Reset bit 4
            BR4: u1,
            /// Reset bit 5
            BR5: u1,
            /// Reset bit 6
            BR6: u1,
            /// Reset bit 7
            BR7: u1,
            /// Reset bit 8
            BR8: u1,
            /// Reset bit 9
            BR9: u1,
            /// Reset bit 10
            BR10: u1,
            /// Reset bit 11
            BR11: u1,
            /// Reset bit 12
            BR12: u1,
            /// Reset bit 13
            BR13: u1,
            /// Reset bit 14
            BR14: u1,
            /// Reset bit 15
            BR15: u1,
        }), base_address + 0x10);

        /// address: 0x40010c14
        /// Port bit reset register
        /// (GPIOn_BRR)
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reset bit 0
            BR0: u1,
            /// Reset bit 1
            BR1: u1,
            /// Reset bit 1
            BR2: u1,
            /// Reset bit 3
            BR3: u1,
            /// Reset bit 4
            BR4: u1,
            /// Reset bit 5
            BR5: u1,
            /// Reset bit 6
            BR6: u1,
            /// Reset bit 7
            BR7: u1,
            /// Reset bit 8
            BR8: u1,
            /// Reset bit 9
            BR9: u1,
            /// Reset bit 10
            BR10: u1,
            /// Reset bit 11
            BR11: u1,
            /// Reset bit 12
            BR12: u1,
            /// Reset bit 13
            BR13: u1,
            /// Reset bit 14
            BR14: u1,
            /// Reset bit 15
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40010c18
        /// Port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port A Lock bit 0
            LCK0: u1,
            /// Port A Lock bit 1
            LCK1: u1,
            /// Port A Lock bit 2
            LCK2: u1,
            /// Port A Lock bit 3
            LCK3: u1,
            /// Port A Lock bit 4
            LCK4: u1,
            /// Port A Lock bit 5
            LCK5: u1,
            /// Port A Lock bit 6
            LCK6: u1,
            /// Port A Lock bit 7
            LCK7: u1,
            /// Port A Lock bit 8
            LCK8: u1,
            /// Port A Lock bit 9
            LCK9: u1,
            /// Port A Lock bit 10
            LCK10: u1,
            /// Port A Lock bit 11
            LCK11: u1,
            /// Port A Lock bit 12
            LCK12: u1,
            /// Port A Lock bit 13
            LCK13: u1,
            /// Port A Lock bit 14
            LCK14: u1,
            /// Port A Lock bit 15
            LCK15: u1,
            /// Lock key
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);
    };
    pub const GPIOC = struct {
        pub const base_address = 0x40011000;

        /// address: 0x40011000
        /// Port configuration register low
        /// (GPIOn_CRL)
        pub const CRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port n.0 mode bits
            MODE0: u2,
            /// Port n.0 configuration
            /// bits
            CNF0: u2,
            /// Port n.1 mode bits
            MODE1: u2,
            /// Port n.1 configuration
            /// bits
            CNF1: u2,
            /// Port n.2 mode bits
            MODE2: u2,
            /// Port n.2 configuration
            /// bits
            CNF2: u2,
            /// Port n.3 mode bits
            MODE3: u2,
            /// Port n.3 configuration
            /// bits
            CNF3: u2,
            /// Port n.4 mode bits
            MODE4: u2,
            /// Port n.4 configuration
            /// bits
            CNF4: u2,
            /// Port n.5 mode bits
            MODE5: u2,
            /// Port n.5 configuration
            /// bits
            CNF5: u2,
            /// Port n.6 mode bits
            MODE6: u2,
            /// Port n.6 configuration
            /// bits
            CNF6: u2,
            /// Port n.7 mode bits
            MODE7: u2,
            /// Port n.7 configuration
            /// bits
            CNF7: u2,
        }), base_address + 0x0);

        /// address: 0x40011004
        /// Port configuration register high
        /// (GPIOn_CRL)
        pub const CRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port n.8 mode bits
            MODE8: u2,
            /// Port n.8 configuration
            /// bits
            CNF8: u2,
            /// Port n.9 mode bits
            MODE9: u2,
            /// Port n.9 configuration
            /// bits
            CNF9: u2,
            /// Port n.10 mode bits
            MODE10: u2,
            /// Port n.10 configuration
            /// bits
            CNF10: u2,
            /// Port n.11 mode bits
            MODE11: u2,
            /// Port n.11 configuration
            /// bits
            CNF11: u2,
            /// Port n.12 mode bits
            MODE12: u2,
            /// Port n.12 configuration
            /// bits
            CNF12: u2,
            /// Port n.13 mode bits
            MODE13: u2,
            /// Port n.13 configuration
            /// bits
            CNF13: u2,
            /// Port n.14 mode bits
            MODE14: u2,
            /// Port n.14 configuration
            /// bits
            CNF14: u2,
            /// Port n.15 mode bits
            MODE15: u2,
            /// Port n.15 configuration
            /// bits
            CNF15: u2,
        }), base_address + 0x4);

        /// address: 0x40011008
        /// Port input data register
        /// (GPIOn_IDR)
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data
            IDR0: u1,
            /// Port input data
            IDR1: u1,
            /// Port input data
            IDR2: u1,
            /// Port input data
            IDR3: u1,
            /// Port input data
            IDR4: u1,
            /// Port input data
            IDR5: u1,
            /// Port input data
            IDR6: u1,
            /// Port input data
            IDR7: u1,
            /// Port input data
            IDR8: u1,
            /// Port input data
            IDR9: u1,
            /// Port input data
            IDR10: u1,
            /// Port input data
            IDR11: u1,
            /// Port input data
            IDR12: u1,
            /// Port input data
            IDR13: u1,
            /// Port input data
            IDR14: u1,
            /// Port input data
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001100c
        /// Port output data register
        /// (GPIOn_ODR)
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data
            ODR0: u1,
            /// Port output data
            ODR1: u1,
            /// Port output data
            ODR2: u1,
            /// Port output data
            ODR3: u1,
            /// Port output data
            ODR4: u1,
            /// Port output data
            ODR5: u1,
            /// Port output data
            ODR6: u1,
            /// Port output data
            ODR7: u1,
            /// Port output data
            ODR8: u1,
            /// Port output data
            ODR9: u1,
            /// Port output data
            ODR10: u1,
            /// Port output data
            ODR11: u1,
            /// Port output data
            ODR12: u1,
            /// Port output data
            ODR13: u1,
            /// Port output data
            ODR14: u1,
            /// Port output data
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40011010
        /// Port bit set/reset register
        /// (GPIOn_BSRR)
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set bit 0
            BS0: u1,
            /// Set bit 1
            BS1: u1,
            /// Set bit 1
            BS2: u1,
            /// Set bit 3
            BS3: u1,
            /// Set bit 4
            BS4: u1,
            /// Set bit 5
            BS5: u1,
            /// Set bit 6
            BS6: u1,
            /// Set bit 7
            BS7: u1,
            /// Set bit 8
            BS8: u1,
            /// Set bit 9
            BS9: u1,
            /// Set bit 10
            BS10: u1,
            /// Set bit 11
            BS11: u1,
            /// Set bit 12
            BS12: u1,
            /// Set bit 13
            BS13: u1,
            /// Set bit 14
            BS14: u1,
            /// Set bit 15
            BS15: u1,
            /// Reset bit 0
            BR0: u1,
            /// Reset bit 1
            BR1: u1,
            /// Reset bit 2
            BR2: u1,
            /// Reset bit 3
            BR3: u1,
            /// Reset bit 4
            BR4: u1,
            /// Reset bit 5
            BR5: u1,
            /// Reset bit 6
            BR6: u1,
            /// Reset bit 7
            BR7: u1,
            /// Reset bit 8
            BR8: u1,
            /// Reset bit 9
            BR9: u1,
            /// Reset bit 10
            BR10: u1,
            /// Reset bit 11
            BR11: u1,
            /// Reset bit 12
            BR12: u1,
            /// Reset bit 13
            BR13: u1,
            /// Reset bit 14
            BR14: u1,
            /// Reset bit 15
            BR15: u1,
        }), base_address + 0x10);

        /// address: 0x40011014
        /// Port bit reset register
        /// (GPIOn_BRR)
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reset bit 0
            BR0: u1,
            /// Reset bit 1
            BR1: u1,
            /// Reset bit 1
            BR2: u1,
            /// Reset bit 3
            BR3: u1,
            /// Reset bit 4
            BR4: u1,
            /// Reset bit 5
            BR5: u1,
            /// Reset bit 6
            BR6: u1,
            /// Reset bit 7
            BR7: u1,
            /// Reset bit 8
            BR8: u1,
            /// Reset bit 9
            BR9: u1,
            /// Reset bit 10
            BR10: u1,
            /// Reset bit 11
            BR11: u1,
            /// Reset bit 12
            BR12: u1,
            /// Reset bit 13
            BR13: u1,
            /// Reset bit 14
            BR14: u1,
            /// Reset bit 15
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40011018
        /// Port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port A Lock bit 0
            LCK0: u1,
            /// Port A Lock bit 1
            LCK1: u1,
            /// Port A Lock bit 2
            LCK2: u1,
            /// Port A Lock bit 3
            LCK3: u1,
            /// Port A Lock bit 4
            LCK4: u1,
            /// Port A Lock bit 5
            LCK5: u1,
            /// Port A Lock bit 6
            LCK6: u1,
            /// Port A Lock bit 7
            LCK7: u1,
            /// Port A Lock bit 8
            LCK8: u1,
            /// Port A Lock bit 9
            LCK9: u1,
            /// Port A Lock bit 10
            LCK10: u1,
            /// Port A Lock bit 11
            LCK11: u1,
            /// Port A Lock bit 12
            LCK12: u1,
            /// Port A Lock bit 13
            LCK13: u1,
            /// Port A Lock bit 14
            LCK14: u1,
            /// Port A Lock bit 15
            LCK15: u1,
            /// Lock key
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);
    };
    pub const GPIOD = struct {
        pub const base_address = 0x40011400;

        /// address: 0x40011400
        /// Port configuration register low
        /// (GPIOn_CRL)
        pub const CRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port n.0 mode bits
            MODE0: u2,
            /// Port n.0 configuration
            /// bits
            CNF0: u2,
            /// Port n.1 mode bits
            MODE1: u2,
            /// Port n.1 configuration
            /// bits
            CNF1: u2,
            /// Port n.2 mode bits
            MODE2: u2,
            /// Port n.2 configuration
            /// bits
            CNF2: u2,
            /// Port n.3 mode bits
            MODE3: u2,
            /// Port n.3 configuration
            /// bits
            CNF3: u2,
            /// Port n.4 mode bits
            MODE4: u2,
            /// Port n.4 configuration
            /// bits
            CNF4: u2,
            /// Port n.5 mode bits
            MODE5: u2,
            /// Port n.5 configuration
            /// bits
            CNF5: u2,
            /// Port n.6 mode bits
            MODE6: u2,
            /// Port n.6 configuration
            /// bits
            CNF6: u2,
            /// Port n.7 mode bits
            MODE7: u2,
            /// Port n.7 configuration
            /// bits
            CNF7: u2,
        }), base_address + 0x0);

        /// address: 0x40011404
        /// Port configuration register high
        /// (GPIOn_CRL)
        pub const CRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port n.8 mode bits
            MODE8: u2,
            /// Port n.8 configuration
            /// bits
            CNF8: u2,
            /// Port n.9 mode bits
            MODE9: u2,
            /// Port n.9 configuration
            /// bits
            CNF9: u2,
            /// Port n.10 mode bits
            MODE10: u2,
            /// Port n.10 configuration
            /// bits
            CNF10: u2,
            /// Port n.11 mode bits
            MODE11: u2,
            /// Port n.11 configuration
            /// bits
            CNF11: u2,
            /// Port n.12 mode bits
            MODE12: u2,
            /// Port n.12 configuration
            /// bits
            CNF12: u2,
            /// Port n.13 mode bits
            MODE13: u2,
            /// Port n.13 configuration
            /// bits
            CNF13: u2,
            /// Port n.14 mode bits
            MODE14: u2,
            /// Port n.14 configuration
            /// bits
            CNF14: u2,
            /// Port n.15 mode bits
            MODE15: u2,
            /// Port n.15 configuration
            /// bits
            CNF15: u2,
        }), base_address + 0x4);

        /// address: 0x40011408
        /// Port input data register
        /// (GPIOn_IDR)
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data
            IDR0: u1,
            /// Port input data
            IDR1: u1,
            /// Port input data
            IDR2: u1,
            /// Port input data
            IDR3: u1,
            /// Port input data
            IDR4: u1,
            /// Port input data
            IDR5: u1,
            /// Port input data
            IDR6: u1,
            /// Port input data
            IDR7: u1,
            /// Port input data
            IDR8: u1,
            /// Port input data
            IDR9: u1,
            /// Port input data
            IDR10: u1,
            /// Port input data
            IDR11: u1,
            /// Port input data
            IDR12: u1,
            /// Port input data
            IDR13: u1,
            /// Port input data
            IDR14: u1,
            /// Port input data
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001140c
        /// Port output data register
        /// (GPIOn_ODR)
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data
            ODR0: u1,
            /// Port output data
            ODR1: u1,
            /// Port output data
            ODR2: u1,
            /// Port output data
            ODR3: u1,
            /// Port output data
            ODR4: u1,
            /// Port output data
            ODR5: u1,
            /// Port output data
            ODR6: u1,
            /// Port output data
            ODR7: u1,
            /// Port output data
            ODR8: u1,
            /// Port output data
            ODR9: u1,
            /// Port output data
            ODR10: u1,
            /// Port output data
            ODR11: u1,
            /// Port output data
            ODR12: u1,
            /// Port output data
            ODR13: u1,
            /// Port output data
            ODR14: u1,
            /// Port output data
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40011410
        /// Port bit set/reset register
        /// (GPIOn_BSRR)
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set bit 0
            BS0: u1,
            /// Set bit 1
            BS1: u1,
            /// Set bit 1
            BS2: u1,
            /// Set bit 3
            BS3: u1,
            /// Set bit 4
            BS4: u1,
            /// Set bit 5
            BS5: u1,
            /// Set bit 6
            BS6: u1,
            /// Set bit 7
            BS7: u1,
            /// Set bit 8
            BS8: u1,
            /// Set bit 9
            BS9: u1,
            /// Set bit 10
            BS10: u1,
            /// Set bit 11
            BS11: u1,
            /// Set bit 12
            BS12: u1,
            /// Set bit 13
            BS13: u1,
            /// Set bit 14
            BS14: u1,
            /// Set bit 15
            BS15: u1,
            /// Reset bit 0
            BR0: u1,
            /// Reset bit 1
            BR1: u1,
            /// Reset bit 2
            BR2: u1,
            /// Reset bit 3
            BR3: u1,
            /// Reset bit 4
            BR4: u1,
            /// Reset bit 5
            BR5: u1,
            /// Reset bit 6
            BR6: u1,
            /// Reset bit 7
            BR7: u1,
            /// Reset bit 8
            BR8: u1,
            /// Reset bit 9
            BR9: u1,
            /// Reset bit 10
            BR10: u1,
            /// Reset bit 11
            BR11: u1,
            /// Reset bit 12
            BR12: u1,
            /// Reset bit 13
            BR13: u1,
            /// Reset bit 14
            BR14: u1,
            /// Reset bit 15
            BR15: u1,
        }), base_address + 0x10);

        /// address: 0x40011414
        /// Port bit reset register
        /// (GPIOn_BRR)
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reset bit 0
            BR0: u1,
            /// Reset bit 1
            BR1: u1,
            /// Reset bit 1
            BR2: u1,
            /// Reset bit 3
            BR3: u1,
            /// Reset bit 4
            BR4: u1,
            /// Reset bit 5
            BR5: u1,
            /// Reset bit 6
            BR6: u1,
            /// Reset bit 7
            BR7: u1,
            /// Reset bit 8
            BR8: u1,
            /// Reset bit 9
            BR9: u1,
            /// Reset bit 10
            BR10: u1,
            /// Reset bit 11
            BR11: u1,
            /// Reset bit 12
            BR12: u1,
            /// Reset bit 13
            BR13: u1,
            /// Reset bit 14
            BR14: u1,
            /// Reset bit 15
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40011418
        /// Port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port A Lock bit 0
            LCK0: u1,
            /// Port A Lock bit 1
            LCK1: u1,
            /// Port A Lock bit 2
            LCK2: u1,
            /// Port A Lock bit 3
            LCK3: u1,
            /// Port A Lock bit 4
            LCK4: u1,
            /// Port A Lock bit 5
            LCK5: u1,
            /// Port A Lock bit 6
            LCK6: u1,
            /// Port A Lock bit 7
            LCK7: u1,
            /// Port A Lock bit 8
            LCK8: u1,
            /// Port A Lock bit 9
            LCK9: u1,
            /// Port A Lock bit 10
            LCK10: u1,
            /// Port A Lock bit 11
            LCK11: u1,
            /// Port A Lock bit 12
            LCK12: u1,
            /// Port A Lock bit 13
            LCK13: u1,
            /// Port A Lock bit 14
            LCK14: u1,
            /// Port A Lock bit 15
            LCK15: u1,
            /// Lock key
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);
    };
    pub const GPIOE = struct {
        pub const base_address = 0x40011800;

        /// address: 0x40011800
        /// Port configuration register low
        /// (GPIOn_CRL)
        pub const CRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port n.0 mode bits
            MODE0: u2,
            /// Port n.0 configuration
            /// bits
            CNF0: u2,
            /// Port n.1 mode bits
            MODE1: u2,
            /// Port n.1 configuration
            /// bits
            CNF1: u2,
            /// Port n.2 mode bits
            MODE2: u2,
            /// Port n.2 configuration
            /// bits
            CNF2: u2,
            /// Port n.3 mode bits
            MODE3: u2,
            /// Port n.3 configuration
            /// bits
            CNF3: u2,
            /// Port n.4 mode bits
            MODE4: u2,
            /// Port n.4 configuration
            /// bits
            CNF4: u2,
            /// Port n.5 mode bits
            MODE5: u2,
            /// Port n.5 configuration
            /// bits
            CNF5: u2,
            /// Port n.6 mode bits
            MODE6: u2,
            /// Port n.6 configuration
            /// bits
            CNF6: u2,
            /// Port n.7 mode bits
            MODE7: u2,
            /// Port n.7 configuration
            /// bits
            CNF7: u2,
        }), base_address + 0x0);

        /// address: 0x40011804
        /// Port configuration register high
        /// (GPIOn_CRL)
        pub const CRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port n.8 mode bits
            MODE8: u2,
            /// Port n.8 configuration
            /// bits
            CNF8: u2,
            /// Port n.9 mode bits
            MODE9: u2,
            /// Port n.9 configuration
            /// bits
            CNF9: u2,
            /// Port n.10 mode bits
            MODE10: u2,
            /// Port n.10 configuration
            /// bits
            CNF10: u2,
            /// Port n.11 mode bits
            MODE11: u2,
            /// Port n.11 configuration
            /// bits
            CNF11: u2,
            /// Port n.12 mode bits
            MODE12: u2,
            /// Port n.12 configuration
            /// bits
            CNF12: u2,
            /// Port n.13 mode bits
            MODE13: u2,
            /// Port n.13 configuration
            /// bits
            CNF13: u2,
            /// Port n.14 mode bits
            MODE14: u2,
            /// Port n.14 configuration
            /// bits
            CNF14: u2,
            /// Port n.15 mode bits
            MODE15: u2,
            /// Port n.15 configuration
            /// bits
            CNF15: u2,
        }), base_address + 0x4);

        /// address: 0x40011808
        /// Port input data register
        /// (GPIOn_IDR)
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data
            IDR0: u1,
            /// Port input data
            IDR1: u1,
            /// Port input data
            IDR2: u1,
            /// Port input data
            IDR3: u1,
            /// Port input data
            IDR4: u1,
            /// Port input data
            IDR5: u1,
            /// Port input data
            IDR6: u1,
            /// Port input data
            IDR7: u1,
            /// Port input data
            IDR8: u1,
            /// Port input data
            IDR9: u1,
            /// Port input data
            IDR10: u1,
            /// Port input data
            IDR11: u1,
            /// Port input data
            IDR12: u1,
            /// Port input data
            IDR13: u1,
            /// Port input data
            IDR14: u1,
            /// Port input data
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001180c
        /// Port output data register
        /// (GPIOn_ODR)
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data
            ODR0: u1,
            /// Port output data
            ODR1: u1,
            /// Port output data
            ODR2: u1,
            /// Port output data
            ODR3: u1,
            /// Port output data
            ODR4: u1,
            /// Port output data
            ODR5: u1,
            /// Port output data
            ODR6: u1,
            /// Port output data
            ODR7: u1,
            /// Port output data
            ODR8: u1,
            /// Port output data
            ODR9: u1,
            /// Port output data
            ODR10: u1,
            /// Port output data
            ODR11: u1,
            /// Port output data
            ODR12: u1,
            /// Port output data
            ODR13: u1,
            /// Port output data
            ODR14: u1,
            /// Port output data
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40011810
        /// Port bit set/reset register
        /// (GPIOn_BSRR)
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set bit 0
            BS0: u1,
            /// Set bit 1
            BS1: u1,
            /// Set bit 1
            BS2: u1,
            /// Set bit 3
            BS3: u1,
            /// Set bit 4
            BS4: u1,
            /// Set bit 5
            BS5: u1,
            /// Set bit 6
            BS6: u1,
            /// Set bit 7
            BS7: u1,
            /// Set bit 8
            BS8: u1,
            /// Set bit 9
            BS9: u1,
            /// Set bit 10
            BS10: u1,
            /// Set bit 11
            BS11: u1,
            /// Set bit 12
            BS12: u1,
            /// Set bit 13
            BS13: u1,
            /// Set bit 14
            BS14: u1,
            /// Set bit 15
            BS15: u1,
            /// Reset bit 0
            BR0: u1,
            /// Reset bit 1
            BR1: u1,
            /// Reset bit 2
            BR2: u1,
            /// Reset bit 3
            BR3: u1,
            /// Reset bit 4
            BR4: u1,
            /// Reset bit 5
            BR5: u1,
            /// Reset bit 6
            BR6: u1,
            /// Reset bit 7
            BR7: u1,
            /// Reset bit 8
            BR8: u1,
            /// Reset bit 9
            BR9: u1,
            /// Reset bit 10
            BR10: u1,
            /// Reset bit 11
            BR11: u1,
            /// Reset bit 12
            BR12: u1,
            /// Reset bit 13
            BR13: u1,
            /// Reset bit 14
            BR14: u1,
            /// Reset bit 15
            BR15: u1,
        }), base_address + 0x10);

        /// address: 0x40011814
        /// Port bit reset register
        /// (GPIOn_BRR)
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reset bit 0
            BR0: u1,
            /// Reset bit 1
            BR1: u1,
            /// Reset bit 1
            BR2: u1,
            /// Reset bit 3
            BR3: u1,
            /// Reset bit 4
            BR4: u1,
            /// Reset bit 5
            BR5: u1,
            /// Reset bit 6
            BR6: u1,
            /// Reset bit 7
            BR7: u1,
            /// Reset bit 8
            BR8: u1,
            /// Reset bit 9
            BR9: u1,
            /// Reset bit 10
            BR10: u1,
            /// Reset bit 11
            BR11: u1,
            /// Reset bit 12
            BR12: u1,
            /// Reset bit 13
            BR13: u1,
            /// Reset bit 14
            BR14: u1,
            /// Reset bit 15
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40011818
        /// Port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port A Lock bit 0
            LCK0: u1,
            /// Port A Lock bit 1
            LCK1: u1,
            /// Port A Lock bit 2
            LCK2: u1,
            /// Port A Lock bit 3
            LCK3: u1,
            /// Port A Lock bit 4
            LCK4: u1,
            /// Port A Lock bit 5
            LCK5: u1,
            /// Port A Lock bit 6
            LCK6: u1,
            /// Port A Lock bit 7
            LCK7: u1,
            /// Port A Lock bit 8
            LCK8: u1,
            /// Port A Lock bit 9
            LCK9: u1,
            /// Port A Lock bit 10
            LCK10: u1,
            /// Port A Lock bit 11
            LCK11: u1,
            /// Port A Lock bit 12
            LCK12: u1,
            /// Port A Lock bit 13
            LCK13: u1,
            /// Port A Lock bit 14
            LCK14: u1,
            /// Port A Lock bit 15
            LCK15: u1,
            /// Lock key
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);
    };
    pub const GPIOF = struct {
        pub const base_address = 0x40011c00;

        /// address: 0x40011c00
        /// Port configuration register low
        /// (GPIOn_CRL)
        pub const CRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port n.0 mode bits
            MODE0: u2,
            /// Port n.0 configuration
            /// bits
            CNF0: u2,
            /// Port n.1 mode bits
            MODE1: u2,
            /// Port n.1 configuration
            /// bits
            CNF1: u2,
            /// Port n.2 mode bits
            MODE2: u2,
            /// Port n.2 configuration
            /// bits
            CNF2: u2,
            /// Port n.3 mode bits
            MODE3: u2,
            /// Port n.3 configuration
            /// bits
            CNF3: u2,
            /// Port n.4 mode bits
            MODE4: u2,
            /// Port n.4 configuration
            /// bits
            CNF4: u2,
            /// Port n.5 mode bits
            MODE5: u2,
            /// Port n.5 configuration
            /// bits
            CNF5: u2,
            /// Port n.6 mode bits
            MODE6: u2,
            /// Port n.6 configuration
            /// bits
            CNF6: u2,
            /// Port n.7 mode bits
            MODE7: u2,
            /// Port n.7 configuration
            /// bits
            CNF7: u2,
        }), base_address + 0x0);

        /// address: 0x40011c04
        /// Port configuration register high
        /// (GPIOn_CRL)
        pub const CRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port n.8 mode bits
            MODE8: u2,
            /// Port n.8 configuration
            /// bits
            CNF8: u2,
            /// Port n.9 mode bits
            MODE9: u2,
            /// Port n.9 configuration
            /// bits
            CNF9: u2,
            /// Port n.10 mode bits
            MODE10: u2,
            /// Port n.10 configuration
            /// bits
            CNF10: u2,
            /// Port n.11 mode bits
            MODE11: u2,
            /// Port n.11 configuration
            /// bits
            CNF11: u2,
            /// Port n.12 mode bits
            MODE12: u2,
            /// Port n.12 configuration
            /// bits
            CNF12: u2,
            /// Port n.13 mode bits
            MODE13: u2,
            /// Port n.13 configuration
            /// bits
            CNF13: u2,
            /// Port n.14 mode bits
            MODE14: u2,
            /// Port n.14 configuration
            /// bits
            CNF14: u2,
            /// Port n.15 mode bits
            MODE15: u2,
            /// Port n.15 configuration
            /// bits
            CNF15: u2,
        }), base_address + 0x4);

        /// address: 0x40011c08
        /// Port input data register
        /// (GPIOn_IDR)
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data
            IDR0: u1,
            /// Port input data
            IDR1: u1,
            /// Port input data
            IDR2: u1,
            /// Port input data
            IDR3: u1,
            /// Port input data
            IDR4: u1,
            /// Port input data
            IDR5: u1,
            /// Port input data
            IDR6: u1,
            /// Port input data
            IDR7: u1,
            /// Port input data
            IDR8: u1,
            /// Port input data
            IDR9: u1,
            /// Port input data
            IDR10: u1,
            /// Port input data
            IDR11: u1,
            /// Port input data
            IDR12: u1,
            /// Port input data
            IDR13: u1,
            /// Port input data
            IDR14: u1,
            /// Port input data
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x40011c0c
        /// Port output data register
        /// (GPIOn_ODR)
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data
            ODR0: u1,
            /// Port output data
            ODR1: u1,
            /// Port output data
            ODR2: u1,
            /// Port output data
            ODR3: u1,
            /// Port output data
            ODR4: u1,
            /// Port output data
            ODR5: u1,
            /// Port output data
            ODR6: u1,
            /// Port output data
            ODR7: u1,
            /// Port output data
            ODR8: u1,
            /// Port output data
            ODR9: u1,
            /// Port output data
            ODR10: u1,
            /// Port output data
            ODR11: u1,
            /// Port output data
            ODR12: u1,
            /// Port output data
            ODR13: u1,
            /// Port output data
            ODR14: u1,
            /// Port output data
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40011c10
        /// Port bit set/reset register
        /// (GPIOn_BSRR)
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set bit 0
            BS0: u1,
            /// Set bit 1
            BS1: u1,
            /// Set bit 1
            BS2: u1,
            /// Set bit 3
            BS3: u1,
            /// Set bit 4
            BS4: u1,
            /// Set bit 5
            BS5: u1,
            /// Set bit 6
            BS6: u1,
            /// Set bit 7
            BS7: u1,
            /// Set bit 8
            BS8: u1,
            /// Set bit 9
            BS9: u1,
            /// Set bit 10
            BS10: u1,
            /// Set bit 11
            BS11: u1,
            /// Set bit 12
            BS12: u1,
            /// Set bit 13
            BS13: u1,
            /// Set bit 14
            BS14: u1,
            /// Set bit 15
            BS15: u1,
            /// Reset bit 0
            BR0: u1,
            /// Reset bit 1
            BR1: u1,
            /// Reset bit 2
            BR2: u1,
            /// Reset bit 3
            BR3: u1,
            /// Reset bit 4
            BR4: u1,
            /// Reset bit 5
            BR5: u1,
            /// Reset bit 6
            BR6: u1,
            /// Reset bit 7
            BR7: u1,
            /// Reset bit 8
            BR8: u1,
            /// Reset bit 9
            BR9: u1,
            /// Reset bit 10
            BR10: u1,
            /// Reset bit 11
            BR11: u1,
            /// Reset bit 12
            BR12: u1,
            /// Reset bit 13
            BR13: u1,
            /// Reset bit 14
            BR14: u1,
            /// Reset bit 15
            BR15: u1,
        }), base_address + 0x10);

        /// address: 0x40011c14
        /// Port bit reset register
        /// (GPIOn_BRR)
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reset bit 0
            BR0: u1,
            /// Reset bit 1
            BR1: u1,
            /// Reset bit 1
            BR2: u1,
            /// Reset bit 3
            BR3: u1,
            /// Reset bit 4
            BR4: u1,
            /// Reset bit 5
            BR5: u1,
            /// Reset bit 6
            BR6: u1,
            /// Reset bit 7
            BR7: u1,
            /// Reset bit 8
            BR8: u1,
            /// Reset bit 9
            BR9: u1,
            /// Reset bit 10
            BR10: u1,
            /// Reset bit 11
            BR11: u1,
            /// Reset bit 12
            BR12: u1,
            /// Reset bit 13
            BR13: u1,
            /// Reset bit 14
            BR14: u1,
            /// Reset bit 15
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40011c18
        /// Port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port A Lock bit 0
            LCK0: u1,
            /// Port A Lock bit 1
            LCK1: u1,
            /// Port A Lock bit 2
            LCK2: u1,
            /// Port A Lock bit 3
            LCK3: u1,
            /// Port A Lock bit 4
            LCK4: u1,
            /// Port A Lock bit 5
            LCK5: u1,
            /// Port A Lock bit 6
            LCK6: u1,
            /// Port A Lock bit 7
            LCK7: u1,
            /// Port A Lock bit 8
            LCK8: u1,
            /// Port A Lock bit 9
            LCK9: u1,
            /// Port A Lock bit 10
            LCK10: u1,
            /// Port A Lock bit 11
            LCK11: u1,
            /// Port A Lock bit 12
            LCK12: u1,
            /// Port A Lock bit 13
            LCK13: u1,
            /// Port A Lock bit 14
            LCK14: u1,
            /// Port A Lock bit 15
            LCK15: u1,
            /// Lock key
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);
    };
    pub const GPIOG = struct {
        pub const base_address = 0x40012000;

        /// address: 0x40012000
        /// Port configuration register low
        /// (GPIOn_CRL)
        pub const CRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port n.0 mode bits
            MODE0: u2,
            /// Port n.0 configuration
            /// bits
            CNF0: u2,
            /// Port n.1 mode bits
            MODE1: u2,
            /// Port n.1 configuration
            /// bits
            CNF1: u2,
            /// Port n.2 mode bits
            MODE2: u2,
            /// Port n.2 configuration
            /// bits
            CNF2: u2,
            /// Port n.3 mode bits
            MODE3: u2,
            /// Port n.3 configuration
            /// bits
            CNF3: u2,
            /// Port n.4 mode bits
            MODE4: u2,
            /// Port n.4 configuration
            /// bits
            CNF4: u2,
            /// Port n.5 mode bits
            MODE5: u2,
            /// Port n.5 configuration
            /// bits
            CNF5: u2,
            /// Port n.6 mode bits
            MODE6: u2,
            /// Port n.6 configuration
            /// bits
            CNF6: u2,
            /// Port n.7 mode bits
            MODE7: u2,
            /// Port n.7 configuration
            /// bits
            CNF7: u2,
        }), base_address + 0x0);

        /// address: 0x40012004
        /// Port configuration register high
        /// (GPIOn_CRL)
        pub const CRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port n.8 mode bits
            MODE8: u2,
            /// Port n.8 configuration
            /// bits
            CNF8: u2,
            /// Port n.9 mode bits
            MODE9: u2,
            /// Port n.9 configuration
            /// bits
            CNF9: u2,
            /// Port n.10 mode bits
            MODE10: u2,
            /// Port n.10 configuration
            /// bits
            CNF10: u2,
            /// Port n.11 mode bits
            MODE11: u2,
            /// Port n.11 configuration
            /// bits
            CNF11: u2,
            /// Port n.12 mode bits
            MODE12: u2,
            /// Port n.12 configuration
            /// bits
            CNF12: u2,
            /// Port n.13 mode bits
            MODE13: u2,
            /// Port n.13 configuration
            /// bits
            CNF13: u2,
            /// Port n.14 mode bits
            MODE14: u2,
            /// Port n.14 configuration
            /// bits
            CNF14: u2,
            /// Port n.15 mode bits
            MODE15: u2,
            /// Port n.15 configuration
            /// bits
            CNF15: u2,
        }), base_address + 0x4);

        /// address: 0x40012008
        /// Port input data register
        /// (GPIOn_IDR)
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data
            IDR0: u1,
            /// Port input data
            IDR1: u1,
            /// Port input data
            IDR2: u1,
            /// Port input data
            IDR3: u1,
            /// Port input data
            IDR4: u1,
            /// Port input data
            IDR5: u1,
            /// Port input data
            IDR6: u1,
            /// Port input data
            IDR7: u1,
            /// Port input data
            IDR8: u1,
            /// Port input data
            IDR9: u1,
            /// Port input data
            IDR10: u1,
            /// Port input data
            IDR11: u1,
            /// Port input data
            IDR12: u1,
            /// Port input data
            IDR13: u1,
            /// Port input data
            IDR14: u1,
            /// Port input data
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001200c
        /// Port output data register
        /// (GPIOn_ODR)
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data
            ODR0: u1,
            /// Port output data
            ODR1: u1,
            /// Port output data
            ODR2: u1,
            /// Port output data
            ODR3: u1,
            /// Port output data
            ODR4: u1,
            /// Port output data
            ODR5: u1,
            /// Port output data
            ODR6: u1,
            /// Port output data
            ODR7: u1,
            /// Port output data
            ODR8: u1,
            /// Port output data
            ODR9: u1,
            /// Port output data
            ODR10: u1,
            /// Port output data
            ODR11: u1,
            /// Port output data
            ODR12: u1,
            /// Port output data
            ODR13: u1,
            /// Port output data
            ODR14: u1,
            /// Port output data
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40012010
        /// Port bit set/reset register
        /// (GPIOn_BSRR)
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set bit 0
            BS0: u1,
            /// Set bit 1
            BS1: u1,
            /// Set bit 1
            BS2: u1,
            /// Set bit 3
            BS3: u1,
            /// Set bit 4
            BS4: u1,
            /// Set bit 5
            BS5: u1,
            /// Set bit 6
            BS6: u1,
            /// Set bit 7
            BS7: u1,
            /// Set bit 8
            BS8: u1,
            /// Set bit 9
            BS9: u1,
            /// Set bit 10
            BS10: u1,
            /// Set bit 11
            BS11: u1,
            /// Set bit 12
            BS12: u1,
            /// Set bit 13
            BS13: u1,
            /// Set bit 14
            BS14: u1,
            /// Set bit 15
            BS15: u1,
            /// Reset bit 0
            BR0: u1,
            /// Reset bit 1
            BR1: u1,
            /// Reset bit 2
            BR2: u1,
            /// Reset bit 3
            BR3: u1,
            /// Reset bit 4
            BR4: u1,
            /// Reset bit 5
            BR5: u1,
            /// Reset bit 6
            BR6: u1,
            /// Reset bit 7
            BR7: u1,
            /// Reset bit 8
            BR8: u1,
            /// Reset bit 9
            BR9: u1,
            /// Reset bit 10
            BR10: u1,
            /// Reset bit 11
            BR11: u1,
            /// Reset bit 12
            BR12: u1,
            /// Reset bit 13
            BR13: u1,
            /// Reset bit 14
            BR14: u1,
            /// Reset bit 15
            BR15: u1,
        }), base_address + 0x10);

        /// address: 0x40012014
        /// Port bit reset register
        /// (GPIOn_BRR)
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reset bit 0
            BR0: u1,
            /// Reset bit 1
            BR1: u1,
            /// Reset bit 1
            BR2: u1,
            /// Reset bit 3
            BR3: u1,
            /// Reset bit 4
            BR4: u1,
            /// Reset bit 5
            BR5: u1,
            /// Reset bit 6
            BR6: u1,
            /// Reset bit 7
            BR7: u1,
            /// Reset bit 8
            BR8: u1,
            /// Reset bit 9
            BR9: u1,
            /// Reset bit 10
            BR10: u1,
            /// Reset bit 11
            BR11: u1,
            /// Reset bit 12
            BR12: u1,
            /// Reset bit 13
            BR13: u1,
            /// Reset bit 14
            BR14: u1,
            /// Reset bit 15
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40012018
        /// Port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port A Lock bit 0
            LCK0: u1,
            /// Port A Lock bit 1
            LCK1: u1,
            /// Port A Lock bit 2
            LCK2: u1,
            /// Port A Lock bit 3
            LCK3: u1,
            /// Port A Lock bit 4
            LCK4: u1,
            /// Port A Lock bit 5
            LCK5: u1,
            /// Port A Lock bit 6
            LCK6: u1,
            /// Port A Lock bit 7
            LCK7: u1,
            /// Port A Lock bit 8
            LCK8: u1,
            /// Port A Lock bit 9
            LCK9: u1,
            /// Port A Lock bit 10
            LCK10: u1,
            /// Port A Lock bit 11
            LCK11: u1,
            /// Port A Lock bit 12
            LCK12: u1,
            /// Port A Lock bit 13
            LCK13: u1,
            /// Port A Lock bit 14
            LCK14: u1,
            /// Port A Lock bit 15
            LCK15: u1,
            /// Lock key
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);
    };

    /// Alternate function I/O
    pub const AFIO = struct {
        pub const base_address = 0x40010000;

        /// address: 0x40010000
        /// Event Control Register
        /// (AFIO_EVCR)
        pub const EVCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pin selection
            PIN: u4,
            /// Port selection
            PORT: u3,
            /// Event Output Enable
            EVOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40010004
        /// AF remap and debug I/O configuration
        /// register (AFIO_MAPR)
        pub const MAPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SPI1 remapping
            SPI1_REMAP: u1,
            /// I2C1 remapping
            I2C1_REMAP: u1,
            /// USART1 remapping
            USART1_REMAP: u1,
            /// USART2 remapping
            USART2_REMAP: u1,
            /// USART3 remapping
            USART3_REMAP: u2,
            /// TIM1 remapping
            TIM1_REMAP: u2,
            /// TIM2 remapping
            TIM2_REMAP: u2,
            /// TIM3 remapping
            TIM3_REMAP: u2,
            /// TIM4 remapping
            TIM4_REMAP: u1,
            /// CAN1 remapping
            CAN_REMAP: u2,
            /// Port D0/Port D1 mapping on
            /// OSCIN/OSCOUT
            PD01_REMAP: u1,
            /// Set and cleared by
            /// software
            TIM5CH4_IREMAP: u1,
            /// ADC 1 External trigger injected
            /// conversion remapping
            ADC1_ETRGINJ_REMAP: u1,
            /// ADC 1 external trigger regular
            /// conversion remapping
            ADC1_ETRGREG_REMAP: u1,
            /// ADC 2 external trigger injected
            /// conversion remapping
            ADC2_ETRGINJ_REMAP: u1,
            /// ADC 2 external trigger regular
            /// conversion remapping
            ADC2_ETRGREG_REMAP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Serial wire JTAG
            /// configuration
            SWJ_CFG: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40010008
        /// External interrupt configuration register 1
        /// (AFIO_EXTICR1)
        pub const EXTICR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI0 configuration
            EXTI0: u4,
            /// EXTI1 configuration
            EXTI1: u4,
            /// EXTI2 configuration
            EXTI2: u4,
            /// EXTI3 configuration
            EXTI3: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001000c
        /// External interrupt configuration register 2
        /// (AFIO_EXTICR2)
        pub const EXTICR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI4 configuration
            EXTI4: u4,
            /// EXTI5 configuration
            EXTI5: u4,
            /// EXTI6 configuration
            EXTI6: u4,
            /// EXTI7 configuration
            EXTI7: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40010010
        /// External interrupt configuration register 3
        /// (AFIO_EXTICR3)
        pub const EXTICR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI8 configuration
            EXTI8: u4,
            /// EXTI9 configuration
            EXTI9: u4,
            /// EXTI10 configuration
            EXTI10: u4,
            /// EXTI11 configuration
            EXTI11: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40010014
        /// External interrupt configuration register 4
        /// (AFIO_EXTICR4)
        pub const EXTICR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI12 configuration
            EXTI12: u4,
            /// EXTI13 configuration
            EXTI13: u4,
            /// EXTI14 configuration
            EXTI14: u4,
            /// EXTI15 configuration
            EXTI15: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x4001001c
        /// AF remap and debug I/O configuration
        /// register
        pub const MAPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// TIM9 remapping
            TIM9_REMAP: u1,
            /// TIM10 remapping
            TIM10_REMAP: u1,
            /// TIM11 remapping
            TIM11_REMAP: u1,
            /// TIM13 remapping
            TIM13_REMAP: u1,
            /// TIM14 remapping
            TIM14_REMAP: u1,
            /// NADV connect/disconnect
            FSMC_NADV: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1c);
    };

    /// EXTI
    pub const EXTI = struct {
        pub const base_address = 0x40010400;

        /// address: 0x40010400
        /// Interrupt mask register
        /// (EXTI_IMR)
        pub const IMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt Mask on line 0
            MR0: u1,
            /// Interrupt Mask on line 1
            MR1: u1,
            /// Interrupt Mask on line 2
            MR2: u1,
            /// Interrupt Mask on line 3
            MR3: u1,
            /// Interrupt Mask on line 4
            MR4: u1,
            /// Interrupt Mask on line 5
            MR5: u1,
            /// Interrupt Mask on line 6
            MR6: u1,
            /// Interrupt Mask on line 7
            MR7: u1,
            /// Interrupt Mask on line 8
            MR8: u1,
            /// Interrupt Mask on line 9
            MR9: u1,
            /// Interrupt Mask on line 10
            MR10: u1,
            /// Interrupt Mask on line 11
            MR11: u1,
            /// Interrupt Mask on line 12
            MR12: u1,
            /// Interrupt Mask on line 13
            MR13: u1,
            /// Interrupt Mask on line 14
            MR14: u1,
            /// Interrupt Mask on line 15
            MR15: u1,
            /// Interrupt Mask on line 16
            MR16: u1,
            /// Interrupt Mask on line 17
            MR17: u1,
            /// Interrupt Mask on line 18
            MR18: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x0);

        /// address: 0x40010404
        /// Event mask register (EXTI_EMR)
        pub const EMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Event Mask on line 0
            MR0: u1,
            /// Event Mask on line 1
            MR1: u1,
            /// Event Mask on line 2
            MR2: u1,
            /// Event Mask on line 3
            MR3: u1,
            /// Event Mask on line 4
            MR4: u1,
            /// Event Mask on line 5
            MR5: u1,
            /// Event Mask on line 6
            MR6: u1,
            /// Event Mask on line 7
            MR7: u1,
            /// Event Mask on line 8
            MR8: u1,
            /// Event Mask on line 9
            MR9: u1,
            /// Event Mask on line 10
            MR10: u1,
            /// Event Mask on line 11
            MR11: u1,
            /// Event Mask on line 12
            MR12: u1,
            /// Event Mask on line 13
            MR13: u1,
            /// Event Mask on line 14
            MR14: u1,
            /// Event Mask on line 15
            MR15: u1,
            /// Event Mask on line 16
            MR16: u1,
            /// Event Mask on line 17
            MR17: u1,
            /// Event Mask on line 18
            MR18: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x4);

        /// address: 0x40010408
        /// Rising Trigger selection register
        /// (EXTI_RTSR)
        pub const RTSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rising trigger event configuration of
            /// line 0
            TR0: u1,
            /// Rising trigger event configuration of
            /// line 1
            TR1: u1,
            /// Rising trigger event configuration of
            /// line 2
            TR2: u1,
            /// Rising trigger event configuration of
            /// line 3
            TR3: u1,
            /// Rising trigger event configuration of
            /// line 4
            TR4: u1,
            /// Rising trigger event configuration of
            /// line 5
            TR5: u1,
            /// Rising trigger event configuration of
            /// line 6
            TR6: u1,
            /// Rising trigger event configuration of
            /// line 7
            TR7: u1,
            /// Rising trigger event configuration of
            /// line 8
            TR8: u1,
            /// Rising trigger event configuration of
            /// line 9
            TR9: u1,
            /// Rising trigger event configuration of
            /// line 10
            TR10: u1,
            /// Rising trigger event configuration of
            /// line 11
            TR11: u1,
            /// Rising trigger event configuration of
            /// line 12
            TR12: u1,
            /// Rising trigger event configuration of
            /// line 13
            TR13: u1,
            /// Rising trigger event configuration of
            /// line 14
            TR14: u1,
            /// Rising trigger event configuration of
            /// line 15
            TR15: u1,
            /// Rising trigger event configuration of
            /// line 16
            TR16: u1,
            /// Rising trigger event configuration of
            /// line 17
            TR17: u1,
            /// Rising trigger event configuration of
            /// line 18
            TR18: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x8);

        /// address: 0x4001040c
        /// Falling Trigger selection register
        /// (EXTI_FTSR)
        pub const FTSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Falling trigger event configuration of
            /// line 0
            TR0: u1,
            /// Falling trigger event configuration of
            /// line 1
            TR1: u1,
            /// Falling trigger event configuration of
            /// line 2
            TR2: u1,
            /// Falling trigger event configuration of
            /// line 3
            TR3: u1,
            /// Falling trigger event configuration of
            /// line 4
            TR4: u1,
            /// Falling trigger event configuration of
            /// line 5
            TR5: u1,
            /// Falling trigger event configuration of
            /// line 6
            TR6: u1,
            /// Falling trigger event configuration of
            /// line 7
            TR7: u1,
            /// Falling trigger event configuration of
            /// line 8
            TR8: u1,
            /// Falling trigger event configuration of
            /// line 9
            TR9: u1,
            /// Falling trigger event configuration of
            /// line 10
            TR10: u1,
            /// Falling trigger event configuration of
            /// line 11
            TR11: u1,
            /// Falling trigger event configuration of
            /// line 12
            TR12: u1,
            /// Falling trigger event configuration of
            /// line 13
            TR13: u1,
            /// Falling trigger event configuration of
            /// line 14
            TR14: u1,
            /// Falling trigger event configuration of
            /// line 15
            TR15: u1,
            /// Falling trigger event configuration of
            /// line 16
            TR16: u1,
            /// Falling trigger event configuration of
            /// line 17
            TR17: u1,
            /// Falling trigger event configuration of
            /// line 18
            TR18: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xc);

        /// address: 0x40010410
        /// Software interrupt event register
        /// (EXTI_SWIER)
        pub const SWIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Interrupt on line
            /// 0
            SWIER0: u1,
            /// Software Interrupt on line
            /// 1
            SWIER1: u1,
            /// Software Interrupt on line
            /// 2
            SWIER2: u1,
            /// Software Interrupt on line
            /// 3
            SWIER3: u1,
            /// Software Interrupt on line
            /// 4
            SWIER4: u1,
            /// Software Interrupt on line
            /// 5
            SWIER5: u1,
            /// Software Interrupt on line
            /// 6
            SWIER6: u1,
            /// Software Interrupt on line
            /// 7
            SWIER7: u1,
            /// Software Interrupt on line
            /// 8
            SWIER8: u1,
            /// Software Interrupt on line
            /// 9
            SWIER9: u1,
            /// Software Interrupt on line
            /// 10
            SWIER10: u1,
            /// Software Interrupt on line
            /// 11
            SWIER11: u1,
            /// Software Interrupt on line
            /// 12
            SWIER12: u1,
            /// Software Interrupt on line
            /// 13
            SWIER13: u1,
            /// Software Interrupt on line
            /// 14
            SWIER14: u1,
            /// Software Interrupt on line
            /// 15
            SWIER15: u1,
            /// Software Interrupt on line
            /// 16
            SWIER16: u1,
            /// Software Interrupt on line
            /// 17
            SWIER17: u1,
            /// Software Interrupt on line
            /// 18
            SWIER18: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x10);

        /// address: 0x40010414
        /// Pending register (EXTI_PR)
        pub const PR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pending bit 0
            PR0: u1,
            /// Pending bit 1
            PR1: u1,
            /// Pending bit 2
            PR2: u1,
            /// Pending bit 3
            PR3: u1,
            /// Pending bit 4
            PR4: u1,
            /// Pending bit 5
            PR5: u1,
            /// Pending bit 6
            PR6: u1,
            /// Pending bit 7
            PR7: u1,
            /// Pending bit 8
            PR8: u1,
            /// Pending bit 9
            PR9: u1,
            /// Pending bit 10
            PR10: u1,
            /// Pending bit 11
            PR11: u1,
            /// Pending bit 12
            PR12: u1,
            /// Pending bit 13
            PR13: u1,
            /// Pending bit 14
            PR14: u1,
            /// Pending bit 15
            PR15: u1,
            /// Pending bit 16
            PR16: u1,
            /// Pending bit 17
            PR17: u1,
            /// Pending bit 18
            PR18: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x14);
    };

    /// DMA controller
    pub const DMA1 = struct {
        pub const base_address = 0x40020000;

        /// address: 0x40020000
        /// DMA interrupt status register
        /// (DMA_ISR)
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 1 Global interrupt
            /// flag
            GIF1: u1,
            /// Channel 1 Transfer Complete
            /// flag
            TCIF1: u1,
            /// Channel 1 Half Transfer Complete
            /// flag
            HTIF1: u1,
            /// Channel 1 Transfer Error
            /// flag
            TEIF1: u1,
            /// Channel 2 Global interrupt
            /// flag
            GIF2: u1,
            /// Channel 2 Transfer Complete
            /// flag
            TCIF2: u1,
            /// Channel 2 Half Transfer Complete
            /// flag
            HTIF2: u1,
            /// Channel 2 Transfer Error
            /// flag
            TEIF2: u1,
            /// Channel 3 Global interrupt
            /// flag
            GIF3: u1,
            /// Channel 3 Transfer Complete
            /// flag
            TCIF3: u1,
            /// Channel 3 Half Transfer Complete
            /// flag
            HTIF3: u1,
            /// Channel 3 Transfer Error
            /// flag
            TEIF3: u1,
            /// Channel 4 Global interrupt
            /// flag
            GIF4: u1,
            /// Channel 4 Transfer Complete
            /// flag
            TCIF4: u1,
            /// Channel 4 Half Transfer Complete
            /// flag
            HTIF4: u1,
            /// Channel 4 Transfer Error
            /// flag
            TEIF4: u1,
            /// Channel 5 Global interrupt
            /// flag
            GIF5: u1,
            /// Channel 5 Transfer Complete
            /// flag
            TCIF5: u1,
            /// Channel 5 Half Transfer Complete
            /// flag
            HTIF5: u1,
            /// Channel 5 Transfer Error
            /// flag
            TEIF5: u1,
            /// Channel 6 Global interrupt
            /// flag
            GIF6: u1,
            /// Channel 6 Transfer Complete
            /// flag
            TCIF6: u1,
            /// Channel 6 Half Transfer Complete
            /// flag
            HTIF6: u1,
            /// Channel 6 Transfer Error
            /// flag
            TEIF6: u1,
            /// Channel 7 Global interrupt
            /// flag
            GIF7: u1,
            /// Channel 7 Transfer Complete
            /// flag
            TCIF7: u1,
            /// Channel 7 Half Transfer Complete
            /// flag
            HTIF7: u1,
            /// Channel 7 Transfer Error
            /// flag
            TEIF7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x40020004
        /// DMA interrupt flag clear register
        /// (DMA_IFCR)
        pub const IFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 1 Global interrupt
            /// clear
            CGIF1: u1,
            /// Channel 1 Transfer Complete
            /// clear
            CTCIF1: u1,
            /// Channel 1 Half Transfer
            /// clear
            CHTIF1: u1,
            /// Channel 1 Transfer Error
            /// clear
            CTEIF1: u1,
            /// Channel 2 Global interrupt
            /// clear
            CGIF2: u1,
            /// Channel 2 Transfer Complete
            /// clear
            CTCIF2: u1,
            /// Channel 2 Half Transfer
            /// clear
            CHTIF2: u1,
            /// Channel 2 Transfer Error
            /// clear
            CTEIF2: u1,
            /// Channel 3 Global interrupt
            /// clear
            CGIF3: u1,
            /// Channel 3 Transfer Complete
            /// clear
            CTCIF3: u1,
            /// Channel 3 Half Transfer
            /// clear
            CHTIF3: u1,
            /// Channel 3 Transfer Error
            /// clear
            CTEIF3: u1,
            /// Channel 4 Global interrupt
            /// clear
            CGIF4: u1,
            /// Channel 4 Transfer Complete
            /// clear
            CTCIF4: u1,
            /// Channel 4 Half Transfer
            /// clear
            CHTIF4: u1,
            /// Channel 4 Transfer Error
            /// clear
            CTEIF4: u1,
            /// Channel 5 Global interrupt
            /// clear
            CGIF5: u1,
            /// Channel 5 Transfer Complete
            /// clear
            CTCIF5: u1,
            /// Channel 5 Half Transfer
            /// clear
            CHTIF5: u1,
            /// Channel 5 Transfer Error
            /// clear
            CTEIF5: u1,
            /// Channel 6 Global interrupt
            /// clear
            CGIF6: u1,
            /// Channel 6 Transfer Complete
            /// clear
            CTCIF6: u1,
            /// Channel 6 Half Transfer
            /// clear
            CHTIF6: u1,
            /// Channel 6 Transfer Error
            /// clear
            CTEIF6: u1,
            /// Channel 7 Global interrupt
            /// clear
            CGIF7: u1,
            /// Channel 7 Transfer Complete
            /// clear
            CTCIF7: u1,
            /// Channel 7 Half Transfer
            /// clear
            CHTIF7: u1,
            /// Channel 7 Transfer Error
            /// clear
            CTEIF7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x4);

        /// address: 0x40020008
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x8);

        /// address: 0x4002000c
        /// DMA channel 1 number of data
        /// register
        pub const CNDTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40020010
        /// DMA channel 1 peripheral address
        /// register
        pub const CPAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x10);

        /// address: 0x40020014
        /// DMA channel 1 memory address
        /// register
        pub const CMAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x14);

        /// address: 0x4002001c
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x1c);

        /// address: 0x40020020
        /// DMA channel 2 number of data
        /// register
        pub const CNDTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40020024
        /// DMA channel 2 peripheral address
        /// register
        pub const CPAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x24);

        /// address: 0x40020028
        /// DMA channel 2 memory address
        /// register
        pub const CMAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x28);

        /// address: 0x40020030
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x30);

        /// address: 0x40020034
        /// DMA channel 3 number of data
        /// register
        pub const CNDTR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40020038
        /// DMA channel 3 peripheral address
        /// register
        pub const CPAR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x38);

        /// address: 0x4002003c
        /// DMA channel 3 memory address
        /// register
        pub const CMAR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x3c);

        /// address: 0x40020044
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x44);

        /// address: 0x40020048
        /// DMA channel 4 number of data
        /// register
        pub const CNDTR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4002004c
        /// DMA channel 4 peripheral address
        /// register
        pub const CPAR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x4c);

        /// address: 0x40020050
        /// DMA channel 4 memory address
        /// register
        pub const CMAR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x50);

        /// address: 0x40020058
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x58);

        /// address: 0x4002005c
        /// DMA channel 5 number of data
        /// register
        pub const CNDTR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x40020060
        /// DMA channel 5 peripheral address
        /// register
        pub const CPAR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x60);

        /// address: 0x40020064
        /// DMA channel 5 memory address
        /// register
        pub const CMAR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x64);

        /// address: 0x4002006c
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x6c);

        /// address: 0x40020070
        /// DMA channel 6 number of data
        /// register
        pub const CNDTR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x70);

        /// address: 0x40020074
        /// DMA channel 6 peripheral address
        /// register
        pub const CPAR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x74);

        /// address: 0x40020078
        /// DMA channel 6 memory address
        /// register
        pub const CMAR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x78);

        /// address: 0x40020080
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x80);

        /// address: 0x40020084
        /// DMA channel 7 number of data
        /// register
        pub const CNDTR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x40020088
        /// DMA channel 7 peripheral address
        /// register
        pub const CPAR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x88);

        /// address: 0x4002008c
        /// DMA channel 7 memory address
        /// register
        pub const CMAR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x8c);
    };
    pub const DMA2 = struct {
        pub const base_address = 0x40020400;

        /// address: 0x40020400
        /// DMA interrupt status register
        /// (DMA_ISR)
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 1 Global interrupt
            /// flag
            GIF1: u1,
            /// Channel 1 Transfer Complete
            /// flag
            TCIF1: u1,
            /// Channel 1 Half Transfer Complete
            /// flag
            HTIF1: u1,
            /// Channel 1 Transfer Error
            /// flag
            TEIF1: u1,
            /// Channel 2 Global interrupt
            /// flag
            GIF2: u1,
            /// Channel 2 Transfer Complete
            /// flag
            TCIF2: u1,
            /// Channel 2 Half Transfer Complete
            /// flag
            HTIF2: u1,
            /// Channel 2 Transfer Error
            /// flag
            TEIF2: u1,
            /// Channel 3 Global interrupt
            /// flag
            GIF3: u1,
            /// Channel 3 Transfer Complete
            /// flag
            TCIF3: u1,
            /// Channel 3 Half Transfer Complete
            /// flag
            HTIF3: u1,
            /// Channel 3 Transfer Error
            /// flag
            TEIF3: u1,
            /// Channel 4 Global interrupt
            /// flag
            GIF4: u1,
            /// Channel 4 Transfer Complete
            /// flag
            TCIF4: u1,
            /// Channel 4 Half Transfer Complete
            /// flag
            HTIF4: u1,
            /// Channel 4 Transfer Error
            /// flag
            TEIF4: u1,
            /// Channel 5 Global interrupt
            /// flag
            GIF5: u1,
            /// Channel 5 Transfer Complete
            /// flag
            TCIF5: u1,
            /// Channel 5 Half Transfer Complete
            /// flag
            HTIF5: u1,
            /// Channel 5 Transfer Error
            /// flag
            TEIF5: u1,
            /// Channel 6 Global interrupt
            /// flag
            GIF6: u1,
            /// Channel 6 Transfer Complete
            /// flag
            TCIF6: u1,
            /// Channel 6 Half Transfer Complete
            /// flag
            HTIF6: u1,
            /// Channel 6 Transfer Error
            /// flag
            TEIF6: u1,
            /// Channel 7 Global interrupt
            /// flag
            GIF7: u1,
            /// Channel 7 Transfer Complete
            /// flag
            TCIF7: u1,
            /// Channel 7 Half Transfer Complete
            /// flag
            HTIF7: u1,
            /// Channel 7 Transfer Error
            /// flag
            TEIF7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x40020404
        /// DMA interrupt flag clear register
        /// (DMA_IFCR)
        pub const IFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 1 Global interrupt
            /// clear
            CGIF1: u1,
            /// Channel 1 Transfer Complete
            /// clear
            CTCIF1: u1,
            /// Channel 1 Half Transfer
            /// clear
            CHTIF1: u1,
            /// Channel 1 Transfer Error
            /// clear
            CTEIF1: u1,
            /// Channel 2 Global interrupt
            /// clear
            CGIF2: u1,
            /// Channel 2 Transfer Complete
            /// clear
            CTCIF2: u1,
            /// Channel 2 Half Transfer
            /// clear
            CHTIF2: u1,
            /// Channel 2 Transfer Error
            /// clear
            CTEIF2: u1,
            /// Channel 3 Global interrupt
            /// clear
            CGIF3: u1,
            /// Channel 3 Transfer Complete
            /// clear
            CTCIF3: u1,
            /// Channel 3 Half Transfer
            /// clear
            CHTIF3: u1,
            /// Channel 3 Transfer Error
            /// clear
            CTEIF3: u1,
            /// Channel 4 Global interrupt
            /// clear
            CGIF4: u1,
            /// Channel 4 Transfer Complete
            /// clear
            CTCIF4: u1,
            /// Channel 4 Half Transfer
            /// clear
            CHTIF4: u1,
            /// Channel 4 Transfer Error
            /// clear
            CTEIF4: u1,
            /// Channel 5 Global interrupt
            /// clear
            CGIF5: u1,
            /// Channel 5 Transfer Complete
            /// clear
            CTCIF5: u1,
            /// Channel 5 Half Transfer
            /// clear
            CHTIF5: u1,
            /// Channel 5 Transfer Error
            /// clear
            CTEIF5: u1,
            /// Channel 6 Global interrupt
            /// clear
            CGIF6: u1,
            /// Channel 6 Transfer Complete
            /// clear
            CTCIF6: u1,
            /// Channel 6 Half Transfer
            /// clear
            CHTIF6: u1,
            /// Channel 6 Transfer Error
            /// clear
            CTEIF6: u1,
            /// Channel 7 Global interrupt
            /// clear
            CGIF7: u1,
            /// Channel 7 Transfer Complete
            /// clear
            CTCIF7: u1,
            /// Channel 7 Half Transfer
            /// clear
            CHTIF7: u1,
            /// Channel 7 Transfer Error
            /// clear
            CTEIF7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x4);

        /// address: 0x40020408
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x8);

        /// address: 0x4002040c
        /// DMA channel 1 number of data
        /// register
        pub const CNDTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40020410
        /// DMA channel 1 peripheral address
        /// register
        pub const CPAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x10);

        /// address: 0x40020414
        /// DMA channel 1 memory address
        /// register
        pub const CMAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x14);

        /// address: 0x4002041c
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x1c);

        /// address: 0x40020420
        /// DMA channel 2 number of data
        /// register
        pub const CNDTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40020424
        /// DMA channel 2 peripheral address
        /// register
        pub const CPAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x24);

        /// address: 0x40020428
        /// DMA channel 2 memory address
        /// register
        pub const CMAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x28);

        /// address: 0x40020430
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x30);

        /// address: 0x40020434
        /// DMA channel 3 number of data
        /// register
        pub const CNDTR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40020438
        /// DMA channel 3 peripheral address
        /// register
        pub const CPAR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x38);

        /// address: 0x4002043c
        /// DMA channel 3 memory address
        /// register
        pub const CMAR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x3c);

        /// address: 0x40020444
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x44);

        /// address: 0x40020448
        /// DMA channel 4 number of data
        /// register
        pub const CNDTR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4002044c
        /// DMA channel 4 peripheral address
        /// register
        pub const CPAR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x4c);

        /// address: 0x40020450
        /// DMA channel 4 memory address
        /// register
        pub const CMAR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x50);

        /// address: 0x40020458
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x58);

        /// address: 0x4002045c
        /// DMA channel 5 number of data
        /// register
        pub const CNDTR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x40020460
        /// DMA channel 5 peripheral address
        /// register
        pub const CPAR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x60);

        /// address: 0x40020464
        /// DMA channel 5 memory address
        /// register
        pub const CMAR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x64);

        /// address: 0x4002046c
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x6c);

        /// address: 0x40020470
        /// DMA channel 6 number of data
        /// register
        pub const CNDTR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x70);

        /// address: 0x40020474
        /// DMA channel 6 peripheral address
        /// register
        pub const CPAR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x74);

        /// address: 0x40020478
        /// DMA channel 6 memory address
        /// register
        pub const CMAR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x78);

        /// address: 0x40020480
        /// DMA channel configuration register
        /// (DMA_CCR)
        pub const CCR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half Transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel Priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x80);

        /// address: 0x40020484
        /// DMA channel 7 number of data
        /// register
        pub const CNDTR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x40020488
        /// DMA channel 7 peripheral address
        /// register
        pub const CPAR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x88);

        /// address: 0x4002048c
        /// DMA channel 7 memory address
        /// register
        pub const CMAR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x8c);
    };

    /// Secure digital input/output
    /// interface
    pub const SDIO = struct {
        pub const base_address = 0x40018000;

        /// address: 0x40018000
        /// Bits 1:0 = PWRCTRL: Power supply control
        /// bits
        pub const POWER = @intToPtr(*volatile Mmio(32, packed struct {
            /// PWRCTRL
            PWRCTRL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x0);

        /// address: 0x40018004
        /// SDI clock control register
        /// (SDIO_CLKCR)
        pub const CLKCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock divide factor
            CLKDIV: u8,
            /// Clock enable bit
            CLKEN: u1,
            /// Power saving configuration
            /// bit
            PWRSAV: u1,
            /// Clock divider bypass enable
            /// bit
            BYPASS: u1,
            /// Wide bus mode enable bit
            WIDBUS: u2,
            /// SDIO_CK dephasing selection
            /// bit
            NEGEDGE: u1,
            /// HW Flow Control enable
            HWFC_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40018008
        /// Bits 31:0 = : Command argument
        pub const ARG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command argument
            CMDARG: u32,
        }), base_address + 0x8);

        /// address: 0x4001800c
        /// SDIO command register
        /// (SDIO_CMD)
        pub const CMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// CMDINDEX
            CMDINDEX: u6,
            /// WAITRESP
            WAITRESP: u2,
            /// WAITINT
            WAITINT: u1,
            /// WAITPEND
            WAITPEND: u1,
            /// CPSMEN
            CPSMEN: u1,
            /// SDIOSuspend
            SDIOSuspend: u1,
            /// ENCMDcompl
            ENCMDcompl: u1,
            /// nIEN
            nIEN: u1,
            /// CE_ATACMD
            CE_ATACMD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40018010
        /// SDIO command register
        pub const RESPCMD = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x10);

        /// address: 0x40018014
        /// Bits 31:0 = CARDSTATUS1
        pub const RESPI1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CARDSTATUS1
            CARDSTATUS1: u32,
        }), base_address + 0x14);

        /// address: 0x40018018
        /// Bits 31:0 = CARDSTATUS2
        pub const RESP2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CARDSTATUS2
            CARDSTATUS2: u32,
        }), base_address + 0x18);

        /// address: 0x4001801c
        /// Bits 31:0 = CARDSTATUS3
        pub const RESP3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CARDSTATUS3
            CARDSTATUS3: u32,
        }), base_address + 0x1c);

        /// address: 0x40018020
        /// Bits 31:0 = CARDSTATUS4
        pub const RESP4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CARDSTATUS4
            CARDSTATUS4: u32,
        }), base_address + 0x20);

        /// address: 0x40018024
        /// Bits 31:0 = DATATIME: Data timeout
        /// period
        pub const DTIMER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data timeout period
            DATATIME: u32,
        }), base_address + 0x24);

        /// address: 0x40018028
        /// Bits 24:0 = DATALENGTH: Data length
        /// value
        pub const DLEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data length value
            DATALENGTH: u25,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x28);

        /// address: 0x4001802c
        /// SDIO data control register
        /// (SDIO_DCTRL)
        pub const DCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// DTEN
            DTEN: u1,
            /// DTDIR
            DTDIR: u1,
            /// DTMODE
            DTMODE: u1,
            /// DMAEN
            DMAEN: u1,
            /// DBLOCKSIZE
            DBLOCKSIZE: u4,
            /// PWSTART
            PWSTART: u1,
            /// PWSTOP
            PWSTOP: u1,
            /// RWMOD
            RWMOD: u1,
            /// SDIOEN
            SDIOEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x2c);

        /// address: 0x40018030
        /// Bits 24:0 = DATACOUNT: Data count
        /// value
        pub const DCOUNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data count value
            DATACOUNT: u25,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x30);

        /// address: 0x40018034
        /// SDIO status register
        /// (SDIO_STA)
        pub const STA = @intToPtr(*volatile Mmio(32, packed struct {
            /// CCRCFAIL
            CCRCFAIL: u1,
            /// DCRCFAIL
            DCRCFAIL: u1,
            /// CTIMEOUT
            CTIMEOUT: u1,
            /// DTIMEOUT
            DTIMEOUT: u1,
            /// TXUNDERR
            TXUNDERR: u1,
            /// RXOVERR
            RXOVERR: u1,
            /// CMDREND
            CMDREND: u1,
            /// CMDSENT
            CMDSENT: u1,
            /// DATAEND
            DATAEND: u1,
            /// STBITERR
            STBITERR: u1,
            /// DBCKEND
            DBCKEND: u1,
            /// CMDACT
            CMDACT: u1,
            /// TXACT
            TXACT: u1,
            /// RXACT
            RXACT: u1,
            /// TXFIFOHE
            TXFIFOHE: u1,
            /// RXFIFOHF
            RXFIFOHF: u1,
            /// TXFIFOF
            TXFIFOF: u1,
            /// RXFIFOF
            RXFIFOF: u1,
            /// TXFIFOE
            TXFIFOE: u1,
            /// RXFIFOE
            RXFIFOE: u1,
            /// TXDAVL
            TXDAVL: u1,
            /// RXDAVL
            RXDAVL: u1,
            /// SDIOIT
            SDIOIT: u1,
            /// CEATAEND
            CEATAEND: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x40018038
        /// SDIO interrupt clear register
        /// (SDIO_ICR)
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CCRCFAILC
            CCRCFAILC: u1,
            /// DCRCFAILC
            DCRCFAILC: u1,
            /// CTIMEOUTC
            CTIMEOUTC: u1,
            /// DTIMEOUTC
            DTIMEOUTC: u1,
            /// TXUNDERRC
            TXUNDERRC: u1,
            /// RXOVERRC
            RXOVERRC: u1,
            /// CMDRENDC
            CMDRENDC: u1,
            /// CMDSENTC
            CMDSENTC: u1,
            /// DATAENDC
            DATAENDC: u1,
            /// STBITERRC
            STBITERRC: u1,
            /// DBCKENDC
            DBCKENDC: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// SDIOITC
            SDIOITC: u1,
            /// CEATAENDC
            CEATAENDC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x38);

        /// address: 0x4001803c
        /// SDIO mask register (SDIO_MASK)
        pub const MASK = @intToPtr(*volatile Mmio(32, packed struct {
            /// CCRCFAILIE
            CCRCFAILIE: u1,
            /// DCRCFAILIE
            DCRCFAILIE: u1,
            /// CTIMEOUTIE
            CTIMEOUTIE: u1,
            /// DTIMEOUTIE
            DTIMEOUTIE: u1,
            /// TXUNDERRIE
            TXUNDERRIE: u1,
            /// RXOVERRIE
            RXOVERRIE: u1,
            /// CMDRENDIE
            CMDRENDIE: u1,
            /// CMDSENTIE
            CMDSENTIE: u1,
            /// DATAENDIE
            DATAENDIE: u1,
            /// STBITERRIE
            STBITERRIE: u1,
            /// DBACKENDIE
            DBACKENDIE: u1,
            /// CMDACTIE
            CMDACTIE: u1,
            /// TXACTIE
            TXACTIE: u1,
            /// RXACTIE
            RXACTIE: u1,
            /// TXFIFOHEIE
            TXFIFOHEIE: u1,
            /// RXFIFOHFIE
            RXFIFOHFIE: u1,
            /// TXFIFOFIE
            TXFIFOFIE: u1,
            /// RXFIFOFIE
            RXFIFOFIE: u1,
            /// TXFIFOEIE
            TXFIFOEIE: u1,
            /// RXFIFOEIE
            RXFIFOEIE: u1,
            /// TXDAVLIE
            TXDAVLIE: u1,
            /// RXDAVLIE
            RXDAVLIE: u1,
            /// SDIOITIE
            SDIOITIE: u1,
            /// CEATENDIE
            CEATENDIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x3c);

        /// address: 0x40018048
        /// Bits 23:0 = FIFOCOUNT: Remaining number of
        /// words to be written to or read from the
        /// FIFO
        pub const FIFOCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIF0COUNT
            FIF0COUNT: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x48);

        /// address: 0x40018080
        /// bits 31:0 = FIFOData: Receive and transmit
        /// FIFO data
        pub const FIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFOData
            FIFOData: u32,
        }), base_address + 0x80);
    };

    /// Real time clock
    pub const RTC = struct {
        pub const base_address = 0x40002800;

        /// address: 0x40002800
        /// RTC Control Register High
        pub const CRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second interrupt Enable
            SECIE: u1,
            /// Alarm interrupt Enable
            ALRIE: u1,
            /// Overflow interrupt Enable
            OWIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x0);

        /// address: 0x40002804
        /// RTC Control Register Low
        pub const CRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second Flag
            SECF: u1,
            /// Alarm Flag
            ALRF: u1,
            /// Overflow Flag
            OWF: u1,
            /// Registers Synchronized
            /// Flag
            RSF: u1,
            /// Configuration Flag
            CNF: u1,
            /// RTC operation OFF
            RTOFF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x4);

        /// address: 0x40002808
        /// RTC Prescaler Load Register
        /// High
        pub const PRLH = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x8);

        /// address: 0x4000280c
        /// RTC Prescaler Load Register
        /// Low
        pub const PRLL = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40002810
        /// RTC Prescaler Divider Register
        /// High
        pub const DIVH = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x10);

        /// address: 0x40002814
        /// RTC Prescaler Divider Register
        /// Low
        pub const DIVL = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x14);

        /// address: 0x40002818
        /// RTC Counter Register High
        pub const CNTH = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x18);

        /// address: 0x4000281c
        /// RTC Counter Register Low
        pub const CNTL = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x1c);

        /// address: 0x40002820
        /// RTC Alarm Register High
        pub const ALRH = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x20);

        /// address: 0x40002824
        /// RTC Alarm Register Low
        pub const ALRL = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);
    };

    /// Backup registers
    pub const BKP = struct {
        pub const base_address = 0x40006c04;

        /// address: 0x40006c04
        /// Backup data register (BKP_DR)
        pub const DR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D1: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40006c08
        /// Backup data register (BKP_DR)
        pub const DR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D2: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x40006c0c
        /// Backup data register (BKP_DR)
        pub const DR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D3: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x40006c10
        /// Backup data register (BKP_DR)
        pub const DR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D4: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40006c14
        /// Backup data register (BKP_DR)
        pub const DR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D5: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40006c18
        /// Backup data register (BKP_DR)
        pub const DR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D6: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40006c1c
        /// Backup data register (BKP_DR)
        pub const DR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D7: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40006c20
        /// Backup data register (BKP_DR)
        pub const DR8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D8: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40006c24
        /// Backup data register (BKP_DR)
        pub const DR9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D9: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40006c28
        /// Backup data register (BKP_DR)
        pub const DR10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D10: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x24);

        /// address: 0x40006c40
        /// Backup data register (BKP_DR)
        pub const DR11 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x3c);

        /// address: 0x40006c44
        /// Backup data register (BKP_DR)
        pub const DR12 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x40);

        /// address: 0x40006c48
        /// Backup data register (BKP_DR)
        pub const DR13 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x44);

        /// address: 0x40006c4c
        /// Backup data register (BKP_DR)
        pub const DR14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D14: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x40006c50
        /// Backup data register (BKP_DR)
        pub const DR15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D15: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40006c54
        /// Backup data register (BKP_DR)
        pub const DR16 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D16: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x50);

        /// address: 0x40006c58
        /// Backup data register (BKP_DR)
        pub const DR17 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D17: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x54);

        /// address: 0x40006c5c
        /// Backup data register (BKP_DR)
        pub const DR18 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D18: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x58);

        /// address: 0x40006c60
        /// Backup data register (BKP_DR)
        pub const DR19 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D19: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x40006c64
        /// Backup data register (BKP_DR)
        pub const DR20 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D20: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x60);

        /// address: 0x40006c68
        /// Backup data register (BKP_DR)
        pub const DR21 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D21: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x64);

        /// address: 0x40006c6c
        /// Backup data register (BKP_DR)
        pub const DR22 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D22: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x68);

        /// address: 0x40006c70
        /// Backup data register (BKP_DR)
        pub const DR23 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D23: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x6c);

        /// address: 0x40006c74
        /// Backup data register (BKP_DR)
        pub const DR24 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D24: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x70);

        /// address: 0x40006c78
        /// Backup data register (BKP_DR)
        pub const DR25 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D25: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x74);

        /// address: 0x40006c7c
        /// Backup data register (BKP_DR)
        pub const DR26 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D26: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x78);

        /// address: 0x40006c80
        /// Backup data register (BKP_DR)
        pub const DR27 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D27: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x7c);

        /// address: 0x40006c84
        /// Backup data register (BKP_DR)
        pub const DR28 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D28: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x80);

        /// address: 0x40006c88
        /// Backup data register (BKP_DR)
        pub const DR29 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D29: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x40006c8c
        /// Backup data register (BKP_DR)
        pub const DR30 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D30: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x88);

        /// address: 0x40006c90
        /// Backup data register (BKP_DR)
        pub const DR31 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D31: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8c);

        /// address: 0x40006c94
        /// Backup data register (BKP_DR)
        pub const DR32 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D32: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x90);

        /// address: 0x40006c98
        /// Backup data register (BKP_DR)
        pub const DR33 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D33: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x94);

        /// address: 0x40006c9c
        /// Backup data register (BKP_DR)
        pub const DR34 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D34: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x98);

        /// address: 0x40006ca0
        /// Backup data register (BKP_DR)
        pub const DR35 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D35: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x9c);

        /// address: 0x40006ca4
        /// Backup data register (BKP_DR)
        pub const DR36 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D36: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xa0);

        /// address: 0x40006ca8
        /// Backup data register (BKP_DR)
        pub const DR37 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D37: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xa4);

        /// address: 0x40006cac
        /// Backup data register (BKP_DR)
        pub const DR38 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D38: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xa8);

        /// address: 0x40006cb0
        /// Backup data register (BKP_DR)
        pub const DR39 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D39: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xac);

        /// address: 0x40006cb4
        /// Backup data register (BKP_DR)
        pub const DR40 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D40: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xb0);

        /// address: 0x40006cb8
        /// Backup data register (BKP_DR)
        pub const DR41 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D41: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xb4);

        /// address: 0x40006cbc
        /// Backup data register (BKP_DR)
        pub const DR42 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Backup data
            D42: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xb8);

        /// address: 0x40006c2c
        /// RTC clock calibration register
        /// (BKP_RTCCR)
        pub const RTCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Calibration value
            CAL: u7,
            /// Calibration Clock Output
            CCO: u1,
            /// Alarm or second output
            /// enable
            ASOE: u1,
            /// Alarm or second output
            /// selection
            ASOS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x28);

        /// address: 0x40006c30
        /// Backup control register
        /// (BKP_CR)
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tamper pin enable
            TPE: u1,
            /// Tamper pin active level
            TPAL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x2c);

        /// address: 0x40006c34
        /// BKP_CSR control/status register
        /// (BKP_CSR)
        pub const CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear Tamper event
            CTE: u1,
            /// Clear Tamper Interrupt
            CTI: u1,
            /// Tamper Pin interrupt
            /// enable
            TPIE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Tamper Event Flag
            TEF: u1,
            /// Tamper Interrupt Flag
            TIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x30);
    };

    /// Independent watchdog
    pub const IWDG = struct {
        pub const base_address = 0x40003000;

        /// address: 0x40003000
        /// Key register (IWDG_KR)
        pub const KR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Key value
            KEY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40003004
        /// Prescaler register (IWDG_PR)
        pub const PR = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x4);

        /// address: 0x40003008
        /// Reload register (IWDG_RLR)
        pub const RLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog counter reload
            /// value
            RL: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x8);

        /// address: 0x4000300c
        /// Status register (IWDG_SR)
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog prescaler value
            /// update
            PVU: u1,
            /// Watchdog counter reload value
            /// update
            RVU: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);
    };

    /// Window watchdog
    pub const WWDG = struct {
        pub const base_address = 0x40002c00;

        /// address: 0x40002c00
        /// Control register (WWDG_CR)
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7-bit counter (MSB to LSB)
            T: u7,
            /// Activation bit
            WDGA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40002c04
        /// Configuration register
        /// (WWDG_CFR)
        pub const CFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7-bit window value
            W: u7,
            /// Timer Base
            WDGTB: u2,
            /// Early Wakeup Interrupt
            EWI: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x4);

        /// address: 0x40002c08
        /// Status register (WWDG_SR)
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Early Wakeup Interrupt
            EWI: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x8);
    };

    /// Advanced timer
    pub const TIM1 = struct {
        pub const base_address = 0x40012c00;

        /// address: 0x40012c00
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40012c04
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded
            /// control
            CCPC: u1,
            reserved0: u1,
            /// Capture/compare control update
            /// selection
            CCUS: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            /// Output Idle state 1
            OIS1: u1,
            /// Output Idle state 1
            OIS1N: u1,
            /// Output Idle state 2
            OIS2: u1,
            /// Output Idle state 2
            OIS2N: u1,
            /// Output Idle state 3
            OIS3: u1,
            /// Output Idle state 3
            OIS3N: u1,
            /// Output Idle state 4
            OIS4: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40012c08
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x40012c0c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            /// COM interrupt enable
            COMIE: u1,
            /// Trigger interrupt enable
            TIE: u1,
            /// Break interrupt enable
            BIE: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            /// COM DMA request enable
            COMDE: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40012c10
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            /// COM interrupt flag
            COMIF: u1,
            /// Trigger interrupt flag
            TIF: u1,
            /// Break interrupt flag
            BIF: u1,
            reserved0: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40012c14
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            /// Capture/Compare control update
            /// generation
            COMG: u1,
            /// Trigger generation
            TG: u1,
            /// Break generation
            BG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x40012c18
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            /// Output Compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output Compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output Compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output Compare 2 mode
            OC2M: u3,
            /// Output Compare 2 clear
            /// enable
            OC2CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40012c18
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            ICPCS: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PCS: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40012c1c
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            OC4CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40012c1c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40012c20
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            /// Capture/Compare 1 complementary output
            /// enable
            CC1NE: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            /// Capture/Compare 2 complementary output
            /// enable
            CC2NE: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            /// Capture/Compare 3 complementary output
            /// enable
            CC3NE: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x20);

        /// address: 0x40012c24
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40012c28
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x40012c2c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40012c34
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40012c38
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);

        /// address: 0x40012c3c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x3c);

        /// address: 0x40012c40
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x40);

        /// address: 0x40012c48
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x40012c4c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40012c30
        /// repetition counter register
        pub const RCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x30);

        /// address: 0x40012c44
        /// break and dead-time register
        pub const BDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8,
            /// Lock configuration
            LOCK: u2,
            /// Off-state selection for Idle
            /// mode
            OSSI: u1,
            /// Off-state selection for Run
            /// mode
            OSSR: u1,
            /// Break enable
            BKE: u1,
            /// Break polarity
            BKP: u1,
            /// Automatic output enable
            AOE: u1,
            /// Main output enable
            MOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);
    };
    pub const TIM8 = struct {
        pub const base_address = 0x40013400;

        /// address: 0x40013400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40013404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded
            /// control
            CCPC: u1,
            reserved0: u1,
            /// Capture/compare control update
            /// selection
            CCUS: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            /// Output Idle state 1
            OIS1: u1,
            /// Output Idle state 1
            OIS1N: u1,
            /// Output Idle state 2
            OIS2: u1,
            /// Output Idle state 2
            OIS2N: u1,
            /// Output Idle state 3
            OIS3: u1,
            /// Output Idle state 3
            OIS3N: u1,
            /// Output Idle state 4
            OIS4: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40013408
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001340c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            /// COM interrupt enable
            COMIE: u1,
            /// Trigger interrupt enable
            TIE: u1,
            /// Break interrupt enable
            BIE: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            /// COM DMA request enable
            COMDE: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40013410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            /// COM interrupt flag
            COMIF: u1,
            /// Trigger interrupt flag
            TIF: u1,
            /// Break interrupt flag
            BIF: u1,
            reserved0: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40013414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            /// Capture/Compare control update
            /// generation
            COMG: u1,
            /// Trigger generation
            TG: u1,
            /// Break generation
            BG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x40013418
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            /// Output Compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output Compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output Compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output Compare 2 mode
            OC2M: u3,
            /// Output Compare 2 clear
            /// enable
            OC2CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40013418
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            ICPCS: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PCS: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4001341c
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            OC4CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x4001341c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40013420
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            /// Capture/Compare 1 complementary output
            /// enable
            CC1NE: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            /// Capture/Compare 2 complementary output
            /// enable
            CC2NE: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            /// Capture/Compare 3 complementary output
            /// enable
            CC3NE: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x20);

        /// address: 0x40013424
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40013428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001342c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40013434
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40013438
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);

        /// address: 0x4001343c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x3c);

        /// address: 0x40013440
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x40);

        /// address: 0x40013448
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4001344c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40013430
        /// repetition counter register
        pub const RCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x30);

        /// address: 0x40013444
        /// break and dead-time register
        pub const BDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8,
            /// Lock configuration
            LOCK: u2,
            /// Off-state selection for Idle
            /// mode
            OSSI: u1,
            /// Off-state selection for Run
            /// mode
            OSSR: u1,
            /// Break enable
            BKE: u1,
            /// Break polarity
            BKP: u1,
            /// Automatic output enable
            AOE: u1,
            /// Main output enable
            MOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);
    };

    /// General purpose timer
    pub const TIM2 = struct {
        pub const base_address = 0x40000000;

        /// address: 0x40000000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40000004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40000008
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000000c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40000010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40000014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            reserved0: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40000018
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output compare 1 mode
            OC1M: u3,
            /// Output compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output compare 2 mode
            OC2M: u3,
            /// Output compare 2 clear
            /// enable
            OC2CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40000018
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PSC: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000001c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            O24CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x4000001c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000020
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved2: u1,
            reserved3: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            reserved4: u1,
            reserved5: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x20);

        /// address: 0x40000024
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40000028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000002c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40000034
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40000038
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);

        /// address: 0x4000003c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x3c);

        /// address: 0x40000040
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x40);

        /// address: 0x40000048
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4000004c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);
    };
    pub const TIM3 = struct {
        pub const base_address = 0x40000400;

        /// address: 0x40000400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40000404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40000408
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000040c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40000410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40000414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            reserved0: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40000418
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output compare 1 mode
            OC1M: u3,
            /// Output compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output compare 2 mode
            OC2M: u3,
            /// Output compare 2 clear
            /// enable
            OC2CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40000418
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PSC: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000041c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            O24CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x4000041c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000420
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved2: u1,
            reserved3: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            reserved4: u1,
            reserved5: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x20);

        /// address: 0x40000424
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40000428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000042c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40000434
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40000438
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);

        /// address: 0x4000043c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x3c);

        /// address: 0x40000440
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x40);

        /// address: 0x40000448
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4000044c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);
    };
    pub const TIM4 = struct {
        pub const base_address = 0x40000800;

        /// address: 0x40000800
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40000804
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40000808
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000080c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40000810
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40000814
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            reserved0: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40000818
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output compare 1 mode
            OC1M: u3,
            /// Output compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output compare 2 mode
            OC2M: u3,
            /// Output compare 2 clear
            /// enable
            OC2CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40000818
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PSC: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000081c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            O24CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x4000081c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000820
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved2: u1,
            reserved3: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            reserved4: u1,
            reserved5: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x20);

        /// address: 0x40000824
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40000828
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000082c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40000834
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40000838
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);

        /// address: 0x4000083c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x3c);

        /// address: 0x40000840
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x40);

        /// address: 0x40000848
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4000084c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);
    };
    pub const TIM5 = struct {
        pub const base_address = 0x40000c00;

        /// address: 0x40000c00
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40000c04
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40000c08
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x40000c0c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40000c10
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40000c14
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            reserved0: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40000c18
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output compare 1 mode
            OC1M: u3,
            /// Output compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output compare 2 mode
            OC2M: u3,
            /// Output compare 2 clear
            /// enable
            OC2CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40000c18
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PSC: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40000c1c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            O24CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000c1c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000c20
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved2: u1,
            reserved3: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            reserved4: u1,
            reserved5: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x20);

        /// address: 0x40000c24
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40000c28
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x40000c2c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40000c34
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40000c38
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);

        /// address: 0x40000c3c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x3c);

        /// address: 0x40000c40
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x40);

        /// address: 0x40000c48
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x40000c4c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);
    };

    /// General purpose timer
    pub const TIM9 = struct {
        pub const base_address = 0x40014c00;

        /// address: 0x40014c00
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40014c04
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode selection
            MMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x40014c08
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x40014c0c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger interrupt enable
            TIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0xc);

        /// address: 0x40014c10
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x10);

        /// address: 0x40014c14
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40014c18
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            reserved0: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output Compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output Compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output Compare 2 mode
            OC2M: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x18);

        /// address: 0x40014c18
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PSC: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40014c20
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40014c24
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40014c28
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x40014c2c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40014c34
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40014c38
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);
    };
    pub const TIM12 = struct {
        pub const base_address = 0x40001800;

        /// address: 0x40001800
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40001804
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode selection
            MMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x40001808
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x4000180c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger interrupt enable
            TIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0xc);

        /// address: 0x40001810
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x10);

        /// address: 0x40001814
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40001818
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            reserved0: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output Compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output Compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output Compare 2 mode
            OC2M: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x18);

        /// address: 0x40001818
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PSC: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40001820
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40001824
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40001828
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000182c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40001834
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40001838
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);
    };

    /// General purpose timer
    pub const TIM10 = struct {
        pub const base_address = 0x40015000;

        /// address: 0x40015000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40015004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode selection
            MMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x4001500c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x40015010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x10);

        /// address: 0x40015014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x14);

        /// address: 0x40015018
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            reserved0: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x18);

        /// address: 0x40015018
        /// capture/compare mode register (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x40015020
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x20);

        /// address: 0x40015024
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40015028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001502c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40015034
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);
    };
    pub const TIM11 = struct {
        pub const base_address = 0x40015400;

        /// address: 0x40015400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40015404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode selection
            MMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x4001540c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x40015410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x10);

        /// address: 0x40015414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x14);

        /// address: 0x40015418
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            reserved0: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x18);

        /// address: 0x40015418
        /// capture/compare mode register (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x40015420
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x20);

        /// address: 0x40015424
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40015428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001542c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40015434
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);
    };
    pub const TIM13 = struct {
        pub const base_address = 0x40001c00;

        /// address: 0x40001c00
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40001c04
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode selection
            MMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x40001c0c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x40001c10
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x10);

        /// address: 0x40001c14
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x14);

        /// address: 0x40001c18
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            reserved0: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x18);

        /// address: 0x40001c18
        /// capture/compare mode register (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x40001c20
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x20);

        /// address: 0x40001c24
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40001c28
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x40001c2c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40001c34
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);
    };
    pub const TIM14 = struct {
        pub const base_address = 0x40002000;

        /// address: 0x40002000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40002004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode selection
            MMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x4000200c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x40002010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x10);

        /// address: 0x40002014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x14);

        /// address: 0x40002018
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            reserved0: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x18);

        /// address: 0x40002018
        /// capture/compare mode register (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x40002020
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x20);

        /// address: 0x40002024
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40002028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000202c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40002034
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);
    };

    /// Basic timer
    pub const TIM6 = struct {
        pub const base_address = 0x40001000;

        /// address: 0x40001000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40001004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode selection
            MMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x4000100c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Update DMA request enable
            UDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0xc);

        /// address: 0x40001010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x10);

        /// address: 0x40001014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x14);

        /// address: 0x40001024
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40001028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000102c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);
    };
    pub const TIM7 = struct {
        pub const base_address = 0x40001400;

        /// address: 0x40001400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40001404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode selection
            MMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x4000140c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Update DMA request enable
            UDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0xc);

        /// address: 0x40001410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x10);

        /// address: 0x40001414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x14);

        /// address: 0x40001424
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40001428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000142c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);
    };

    /// Inter integrated circuit
    pub const I2C1 = struct {
        pub const base_address = 0x40005400;

        /// address: 0x40005400
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1,
            /// SMBus mode
            SMBUS: u1,
            reserved0: u1,
            /// SMBus type
            SMBTYPE: u1,
            /// ARP enable
            ENARP: u1,
            /// PEC enable
            ENPEC: u1,
            /// General call enable
            ENGC: u1,
            /// Clock stretching disable (Slave
            /// mode)
            NOSTRETCH: u1,
            /// Start generation
            START: u1,
            /// Stop generation
            STOP: u1,
            /// Acknowledge enable
            ACK: u1,
            /// Acknowledge/PEC Position (for data
            /// reception)
            POS: u1,
            /// Packet error checking
            PEC: u1,
            /// SMBus alert
            ALERT: u1,
            reserved1: u1,
            /// Software reset
            SWRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40005404
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral clock frequency
            FREQ: u6,
            reserved0: u1,
            reserved1: u1,
            /// Error interrupt enable
            ITERREN: u1,
            /// Event interrupt enable
            ITEVTEN: u1,
            /// Buffer interrupt enable
            ITBUFEN: u1,
            /// DMA requests enable
            DMAEN: u1,
            /// DMA last transfer
            LAST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x4);

        /// address: 0x40005408
        /// Own address register 1
        pub const OAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interface address
            ADD0: u1,
            /// Interface address
            ADD7: u7,
            /// Interface address
            ADD10: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Addressing mode (slave
            /// mode)
            ADDMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000540c
        /// Own address register 2
        pub const OAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dual addressing mode
            /// enable
            ENDUAL: u1,
            /// Interface address
            ADD2: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xc);

        /// address: 0x40005410
        /// Data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x10);

        /// address: 0x40005414
        /// Status register 1
        pub const SR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start bit (Master mode)
            SB: u1,
            /// Address sent (master mode)/matched
            /// (slave mode)
            ADDR: u1,
            /// Byte transfer finished
            BTF: u1,
            /// 10-bit header sent (Master
            /// mode)
            ADD10: u1,
            /// Stop detection (slave
            /// mode)
            STOPF: u1,
            reserved0: u1,
            /// Data register not empty
            /// (receivers)
            RxNE: u1,
            /// Data register empty
            /// (transmitters)
            TxE: u1,
            /// Bus error
            BERR: u1,
            /// Arbitration lost (master
            /// mode)
            ARLO: u1,
            /// Acknowledge failure
            AF: u1,
            /// Overrun/Underrun
            OVR: u1,
            /// PEC Error in reception
            PECERR: u1,
            reserved1: u1,
            /// Timeout or Tlow error
            TIMEOUT: u1,
            /// SMBus alert
            SMBALERT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40005418
        /// Status register 2
        pub const SR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Master/slave
            MSL: u1,
            /// Bus busy
            BUSY: u1,
            /// Transmitter/receiver
            TRA: u1,
            reserved0: u1,
            /// General call address (Slave
            /// mode)
            GENCALL: u1,
            /// SMBus device default address (Slave
            /// mode)
            SMBDEFAULT: u1,
            /// SMBus host header (Slave
            /// mode)
            SMBHOST: u1,
            /// Dual flag (Slave mode)
            DUALF: u1,
            /// acket error checking
            /// register
            PEC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000541c
        /// Clock control register
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock control register in Fast/Standard
            /// mode (Master mode)
            CCR: u12,
            reserved0: u1,
            reserved1: u1,
            /// Fast mode duty cycle
            DUTY: u1,
            /// I2C master mode selection
            F_S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40005420
        /// TRISE register
        pub const TRISE = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x20);
    };
    pub const I2C2 = struct {
        pub const base_address = 0x40005800;

        /// address: 0x40005800
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1,
            /// SMBus mode
            SMBUS: u1,
            reserved0: u1,
            /// SMBus type
            SMBTYPE: u1,
            /// ARP enable
            ENARP: u1,
            /// PEC enable
            ENPEC: u1,
            /// General call enable
            ENGC: u1,
            /// Clock stretching disable (Slave
            /// mode)
            NOSTRETCH: u1,
            /// Start generation
            START: u1,
            /// Stop generation
            STOP: u1,
            /// Acknowledge enable
            ACK: u1,
            /// Acknowledge/PEC Position (for data
            /// reception)
            POS: u1,
            /// Packet error checking
            PEC: u1,
            /// SMBus alert
            ALERT: u1,
            reserved1: u1,
            /// Software reset
            SWRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40005804
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral clock frequency
            FREQ: u6,
            reserved0: u1,
            reserved1: u1,
            /// Error interrupt enable
            ITERREN: u1,
            /// Event interrupt enable
            ITEVTEN: u1,
            /// Buffer interrupt enable
            ITBUFEN: u1,
            /// DMA requests enable
            DMAEN: u1,
            /// DMA last transfer
            LAST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x4);

        /// address: 0x40005808
        /// Own address register 1
        pub const OAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interface address
            ADD0: u1,
            /// Interface address
            ADD7: u7,
            /// Interface address
            ADD10: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Addressing mode (slave
            /// mode)
            ADDMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000580c
        /// Own address register 2
        pub const OAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dual addressing mode
            /// enable
            ENDUAL: u1,
            /// Interface address
            ADD2: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xc);

        /// address: 0x40005810
        /// Data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x10);

        /// address: 0x40005814
        /// Status register 1
        pub const SR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start bit (Master mode)
            SB: u1,
            /// Address sent (master mode)/matched
            /// (slave mode)
            ADDR: u1,
            /// Byte transfer finished
            BTF: u1,
            /// 10-bit header sent (Master
            /// mode)
            ADD10: u1,
            /// Stop detection (slave
            /// mode)
            STOPF: u1,
            reserved0: u1,
            /// Data register not empty
            /// (receivers)
            RxNE: u1,
            /// Data register empty
            /// (transmitters)
            TxE: u1,
            /// Bus error
            BERR: u1,
            /// Arbitration lost (master
            /// mode)
            ARLO: u1,
            /// Acknowledge failure
            AF: u1,
            /// Overrun/Underrun
            OVR: u1,
            /// PEC Error in reception
            PECERR: u1,
            reserved1: u1,
            /// Timeout or Tlow error
            TIMEOUT: u1,
            /// SMBus alert
            SMBALERT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40005818
        /// Status register 2
        pub const SR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Master/slave
            MSL: u1,
            /// Bus busy
            BUSY: u1,
            /// Transmitter/receiver
            TRA: u1,
            reserved0: u1,
            /// General call address (Slave
            /// mode)
            GENCALL: u1,
            /// SMBus device default address (Slave
            /// mode)
            SMBDEFAULT: u1,
            /// SMBus host header (Slave
            /// mode)
            SMBHOST: u1,
            /// Dual flag (Slave mode)
            DUALF: u1,
            /// acket error checking
            /// register
            PEC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000581c
        /// Clock control register
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock control register in Fast/Standard
            /// mode (Master mode)
            CCR: u12,
            reserved0: u1,
            reserved1: u1,
            /// Fast mode duty cycle
            DUTY: u1,
            /// I2C master mode selection
            F_S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40005820
        /// TRISE register
        pub const TRISE = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x20);
    };

    /// Serial peripheral interface
    pub const SPI1 = struct {
        pub const base_address = 0x40013000;

        /// address: 0x40013000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// Data frame format
            DFF: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40013004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40013008
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x4001300c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40013010
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40013014
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40013018
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4001301c
        /// I2S configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Steady state clock
            /// polarity
            CKPOL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S Enable
            I2SE: u1,
            /// I2S mode selection
            I2SMOD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40013020
        /// I2S prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S Linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };
    pub const SPI2 = struct {
        pub const base_address = 0x40003800;

        /// address: 0x40003800
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// Data frame format
            DFF: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40003804
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40003808
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x4000380c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40003810
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40003814
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40003818
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000381c
        /// I2S configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Steady state clock
            /// polarity
            CKPOL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S Enable
            I2SE: u1,
            /// I2S mode selection
            I2SMOD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40003820
        /// I2S prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S Linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };
    pub const SPI3 = struct {
        pub const base_address = 0x40003c00;

        /// address: 0x40003c00
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// Data frame format
            DFF: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40003c04
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40003c08
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x40003c0c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40003c10
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40003c14
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40003c18
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40003c1c
        /// I2S configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Steady state clock
            /// polarity
            CKPOL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S Enable
            I2SE: u1,
            /// I2S mode selection
            I2SMOD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40003c20
        /// I2S prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S Linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };

    /// Universal synchronous asynchronous receiver
    /// transmitter
    pub const USART1 = struct {
        pub const base_address = 0x40013800;

        /// address: 0x40013800
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error
            PE: u1,
            /// Framing error
            FE: u1,
            /// Noise error flag
            NE: u1,
            /// Overrun error
            ORE: u1,
            /// IDLE line detected
            IDLE: u1,
            /// Read data register not
            /// empty
            RXNE: u1,
            /// Transmission complete
            TC: u1,
            /// Transmit data register
            /// empty
            TXE: u1,
            /// LIN break detection flag
            LBD: u1,
            /// CTS flag
            CTS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40013804
        /// Data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x4);

        /// address: 0x40013808
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// fraction of USARTDIV
            DIV_Fraction: u4,
            /// mantissa of USARTDIV
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001380c
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Send break
            SBK: u1,
            /// Receiver wakeup
            RWU: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// TXE interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Wakeup method
            WAKE: u1,
            /// Word length
            M: u1,
            /// USART enable
            UE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xc);

        /// address: 0x40013810
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address of the USART node
            ADD: u4,
            reserved0: u1,
            /// lin break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved1: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x10);

        /// address: 0x40013814
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// IrDA mode enable
            IREN: u1,
            /// IrDA low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x14);

        /// address: 0x40013818
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);
    };
    pub const USART2 = struct {
        pub const base_address = 0x40004400;

        /// address: 0x40004400
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error
            PE: u1,
            /// Framing error
            FE: u1,
            /// Noise error flag
            NE: u1,
            /// Overrun error
            ORE: u1,
            /// IDLE line detected
            IDLE: u1,
            /// Read data register not
            /// empty
            RXNE: u1,
            /// Transmission complete
            TC: u1,
            /// Transmit data register
            /// empty
            TXE: u1,
            /// LIN break detection flag
            LBD: u1,
            /// CTS flag
            CTS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40004404
        /// Data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x4);

        /// address: 0x40004408
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// fraction of USARTDIV
            DIV_Fraction: u4,
            /// mantissa of USARTDIV
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000440c
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Send break
            SBK: u1,
            /// Receiver wakeup
            RWU: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// TXE interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Wakeup method
            WAKE: u1,
            /// Word length
            M: u1,
            /// USART enable
            UE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xc);

        /// address: 0x40004410
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address of the USART node
            ADD: u4,
            reserved0: u1,
            /// lin break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved1: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x10);

        /// address: 0x40004414
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// IrDA mode enable
            IREN: u1,
            /// IrDA low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x14);

        /// address: 0x40004418
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);
    };
    pub const USART3 = struct {
        pub const base_address = 0x40004800;

        /// address: 0x40004800
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error
            PE: u1,
            /// Framing error
            FE: u1,
            /// Noise error flag
            NE: u1,
            /// Overrun error
            ORE: u1,
            /// IDLE line detected
            IDLE: u1,
            /// Read data register not
            /// empty
            RXNE: u1,
            /// Transmission complete
            TC: u1,
            /// Transmit data register
            /// empty
            TXE: u1,
            /// LIN break detection flag
            LBD: u1,
            /// CTS flag
            CTS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40004804
        /// Data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x4);

        /// address: 0x40004808
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// fraction of USARTDIV
            DIV_Fraction: u4,
            /// mantissa of USARTDIV
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000480c
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Send break
            SBK: u1,
            /// Receiver wakeup
            RWU: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// TXE interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Wakeup method
            WAKE: u1,
            /// Word length
            M: u1,
            /// USART enable
            UE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xc);

        /// address: 0x40004810
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address of the USART node
            ADD: u4,
            reserved0: u1,
            /// lin break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved1: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x10);

        /// address: 0x40004814
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// IrDA mode enable
            IREN: u1,
            /// IrDA low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x14);

        /// address: 0x40004818
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);
    };

    /// Analog to digital converter
    pub const ADC1 = struct {
        pub const base_address = 0x40012400;

        /// address: 0x40012400
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog flag
            AWD: u1,
            /// Regular channel end of
            /// conversion
            EOC: u1,
            /// Injected channel end of
            /// conversion
            JEOC: u1,
            /// Injected channel start
            /// flag
            JSTRT: u1,
            /// Regular channel start flag
            STRT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x0);

        /// address: 0x40012404
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog channel select
            /// bits
            AWDCH: u5,
            /// Interrupt enable for EOC
            EOCIE: u1,
            /// Analog watchdog interrupt
            /// enable
            AWDIE: u1,
            /// Interrupt enable for injected
            /// channels
            JEOCIE: u1,
            /// Scan mode
            SCAN: u1,
            /// Enable the watchdog on a single channel
            /// in scan mode
            AWDSGL: u1,
            /// Automatic injected group
            /// conversion
            JAUTO: u1,
            /// Discontinuous mode on regular
            /// channels
            DISCEN: u1,
            /// Discontinuous mode on injected
            /// channels
            JDISCEN: u1,
            /// Discontinuous mode channel
            /// count
            DISCNUM: u3,
            /// Dual mode selection
            DUALMOD: u4,
            reserved0: u1,
            reserved1: u1,
            /// Analog watchdog enable on injected
            /// channels
            JAWDEN: u1,
            /// Analog watchdog enable on regular
            /// channels
            AWDEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40012408
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// A/D converter ON / OFF
            ADON: u1,
            /// Continuous conversion
            CONT: u1,
            /// A/D calibration
            CAL: u1,
            /// Reset calibration
            RSTCAL: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Direct memory access mode
            DMA: u1,
            reserved4: u1,
            reserved5: u1,
            /// Data alignment
            ALIGN: u1,
            /// External event select for injected
            /// group
            JEXTSEL: u3,
            /// External trigger conversion mode for
            /// injected channels
            JEXTTRIG: u1,
            reserved6: u1,
            /// External event select for regular
            /// group
            EXTSEL: u3,
            /// External trigger conversion mode for
            /// regular channels
            EXTTRIG: u1,
            /// Start conversion of injected
            /// channels
            JSWSTART: u1,
            /// Start conversion of regular
            /// channels
            SWSTART: u1,
            /// Temperature sensor and VREFINT
            /// enable
            TSVREFE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x8);

        /// address: 0x4001240c
        /// sample time register 1
        pub const SMPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 10 sample time
            /// selection
            SMP10: u3,
            /// Channel 11 sample time
            /// selection
            SMP11: u3,
            /// Channel 12 sample time
            /// selection
            SMP12: u3,
            /// Channel 13 sample time
            /// selection
            SMP13: u3,
            /// Channel 14 sample time
            /// selection
            SMP14: u3,
            /// Channel 15 sample time
            /// selection
            SMP15: u3,
            /// Channel 16 sample time
            /// selection
            SMP16: u3,
            /// Channel 17 sample time
            /// selection
            SMP17: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xc);

        /// address: 0x40012410
        /// sample time register 2
        pub const SMPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 0 sample time
            /// selection
            SMP0: u3,
            /// Channel 1 sample time
            /// selection
            SMP1: u3,
            /// Channel 2 sample time
            /// selection
            SMP2: u3,
            /// Channel 3 sample time
            /// selection
            SMP3: u3,
            /// Channel 4 sample time
            /// selection
            SMP4: u3,
            /// Channel 5 sample time
            /// selection
            SMP5: u3,
            /// Channel 6 sample time
            /// selection
            SMP6: u3,
            /// Channel 7 sample time
            /// selection
            SMP7: u3,
            /// Channel 8 sample time
            /// selection
            SMP8: u3,
            /// Channel 9 sample time
            /// selection
            SMP9: u3,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x10);

        /// address: 0x40012414
        /// injected channel data offset register
        /// x
        pub const JOFR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET1: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x14);

        /// address: 0x40012418
        /// injected channel data offset register
        /// x
        pub const JOFR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET2: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x18);

        /// address: 0x4001241c
        /// injected channel data offset register
        /// x
        pub const JOFR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET3: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40012420
        /// injected channel data offset register
        /// x
        pub const JOFR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET4: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x20);

        /// address: 0x40012424
        /// watchdog higher threshold
        /// register
        pub const HTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog higher
            /// threshold
            HT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x24);

        /// address: 0x40012428
        /// watchdog lower threshold
        /// register
        pub const LTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog lower
            /// threshold
            LT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x28);

        /// address: 0x4001242c
        /// regular sequence register 1
        pub const SQR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 13th conversion in regular
            /// sequence
            SQ13: u5,
            /// 14th conversion in regular
            /// sequence
            SQ14: u5,
            /// 15th conversion in regular
            /// sequence
            SQ15: u5,
            /// 16th conversion in regular
            /// sequence
            SQ16: u5,
            /// Regular channel sequence
            /// length
            L: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x2c);

        /// address: 0x40012430
        /// regular sequence register 2
        pub const SQR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7th conversion in regular
            /// sequence
            SQ7: u5,
            /// 8th conversion in regular
            /// sequence
            SQ8: u5,
            /// 9th conversion in regular
            /// sequence
            SQ9: u5,
            /// 10th conversion in regular
            /// sequence
            SQ10: u5,
            /// 11th conversion in regular
            /// sequence
            SQ11: u5,
            /// 12th conversion in regular
            /// sequence
            SQ12: u5,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x30);

        /// address: 0x40012434
        /// regular sequence register 3
        pub const SQR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1st conversion in regular
            /// sequence
            SQ1: u5,
            /// 2nd conversion in regular
            /// sequence
            SQ2: u5,
            /// 3rd conversion in regular
            /// sequence
            SQ3: u5,
            /// 4th conversion in regular
            /// sequence
            SQ4: u5,
            /// 5th conversion in regular
            /// sequence
            SQ5: u5,
            /// 6th conversion in regular
            /// sequence
            SQ6: u5,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x34);

        /// address: 0x40012438
        /// injected sequence register
        pub const JSQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1st conversion in injected
            /// sequence
            JSQ1: u5,
            /// 2nd conversion in injected
            /// sequence
            JSQ2: u5,
            /// 3rd conversion in injected
            /// sequence
            JSQ3: u5,
            /// 4th conversion in injected
            /// sequence
            JSQ4: u5,
            /// Injected sequence length
            JL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x38);

        /// address: 0x4001243c
        /// injected data register x
        pub const JDR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x3c);

        /// address: 0x40012440
        /// injected data register x
        pub const JDR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x40012444
        /// injected data register x
        pub const JDR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);

        /// address: 0x40012448
        /// injected data register x
        pub const JDR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4001244c
        /// regular data register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Regular data
            DATA: u16,
            /// ADC2 data
            ADC2DATA: u16,
        }), base_address + 0x4c);
    };

    /// Analog to digital converter
    pub const ADC2 = struct {
        pub const base_address = 0x40012800;

        /// address: 0x40012800
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog flag
            AWD: u1,
            /// Regular channel end of
            /// conversion
            EOC: u1,
            /// Injected channel end of
            /// conversion
            JEOC: u1,
            /// Injected channel start
            /// flag
            JSTRT: u1,
            /// Regular channel start flag
            STRT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x0);

        /// address: 0x40012804
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog channel select
            /// bits
            AWDCH: u5,
            /// Interrupt enable for EOC
            EOCIE: u1,
            /// Analog watchdog interrupt
            /// enable
            AWDIE: u1,
            /// Interrupt enable for injected
            /// channels
            JEOCIE: u1,
            /// Scan mode
            SCAN: u1,
            /// Enable the watchdog on a single channel
            /// in scan mode
            AWDSGL: u1,
            /// Automatic injected group
            /// conversion
            JAUTO: u1,
            /// Discontinuous mode on regular
            /// channels
            DISCEN: u1,
            /// Discontinuous mode on injected
            /// channels
            JDISCEN: u1,
            /// Discontinuous mode channel
            /// count
            DISCNUM: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Analog watchdog enable on injected
            /// channels
            JAWDEN: u1,
            /// Analog watchdog enable on regular
            /// channels
            AWDEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40012808
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// A/D converter ON / OFF
            ADON: u1,
            /// Continuous conversion
            CONT: u1,
            /// A/D calibration
            CAL: u1,
            /// Reset calibration
            RSTCAL: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Direct memory access mode
            DMA: u1,
            reserved4: u1,
            reserved5: u1,
            /// Data alignment
            ALIGN: u1,
            /// External event select for injected
            /// group
            JEXTSEL: u3,
            /// External trigger conversion mode for
            /// injected channels
            JEXTTRIG: u1,
            reserved6: u1,
            /// External event select for regular
            /// group
            EXTSEL: u3,
            /// External trigger conversion mode for
            /// regular channels
            EXTTRIG: u1,
            /// Start conversion of injected
            /// channels
            JSWSTART: u1,
            /// Start conversion of regular
            /// channels
            SWSTART: u1,
            /// Temperature sensor and VREFINT
            /// enable
            TSVREFE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x8);

        /// address: 0x4001280c
        /// sample time register 1
        pub const SMPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 10 sample time
            /// selection
            SMP10: u3,
            /// Channel 11 sample time
            /// selection
            SMP11: u3,
            /// Channel 12 sample time
            /// selection
            SMP12: u3,
            /// Channel 13 sample time
            /// selection
            SMP13: u3,
            /// Channel 14 sample time
            /// selection
            SMP14: u3,
            /// Channel 15 sample time
            /// selection
            SMP15: u3,
            /// Channel 16 sample time
            /// selection
            SMP16: u3,
            /// Channel 17 sample time
            /// selection
            SMP17: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xc);

        /// address: 0x40012810
        /// sample time register 2
        pub const SMPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 0 sample time
            /// selection
            SMP0: u3,
            /// Channel 1 sample time
            /// selection
            SMP1: u3,
            /// Channel 2 sample time
            /// selection
            SMP2: u3,
            /// Channel 3 sample time
            /// selection
            SMP3: u3,
            /// Channel 4 sample time
            /// selection
            SMP4: u3,
            /// Channel 5 sample time
            /// selection
            SMP5: u3,
            /// Channel 6 sample time
            /// selection
            SMP6: u3,
            /// Channel 7 sample time
            /// selection
            SMP7: u3,
            /// Channel 8 sample time
            /// selection
            SMP8: u3,
            /// Channel 9 sample time
            /// selection
            SMP9: u3,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x10);

        /// address: 0x40012814
        /// injected channel data offset register
        /// x
        pub const JOFR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET1: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x14);

        /// address: 0x40012818
        /// injected channel data offset register
        /// x
        pub const JOFR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET2: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x18);

        /// address: 0x4001281c
        /// injected channel data offset register
        /// x
        pub const JOFR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET3: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40012820
        /// injected channel data offset register
        /// x
        pub const JOFR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET4: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x20);

        /// address: 0x40012824
        /// watchdog higher threshold
        /// register
        pub const HTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog higher
            /// threshold
            HT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x24);

        /// address: 0x40012828
        /// watchdog lower threshold
        /// register
        pub const LTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog lower
            /// threshold
            LT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x28);

        /// address: 0x4001282c
        /// regular sequence register 1
        pub const SQR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 13th conversion in regular
            /// sequence
            SQ13: u5,
            /// 14th conversion in regular
            /// sequence
            SQ14: u5,
            /// 15th conversion in regular
            /// sequence
            SQ15: u5,
            /// 16th conversion in regular
            /// sequence
            SQ16: u5,
            /// Regular channel sequence
            /// length
            L: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x2c);

        /// address: 0x40012830
        /// regular sequence register 2
        pub const SQR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7th conversion in regular
            /// sequence
            SQ7: u5,
            /// 8th conversion in regular
            /// sequence
            SQ8: u5,
            /// 9th conversion in regular
            /// sequence
            SQ9: u5,
            /// 10th conversion in regular
            /// sequence
            SQ10: u5,
            /// 11th conversion in regular
            /// sequence
            SQ11: u5,
            /// 12th conversion in regular
            /// sequence
            SQ12: u5,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x30);

        /// address: 0x40012834
        /// regular sequence register 3
        pub const SQR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1st conversion in regular
            /// sequence
            SQ1: u5,
            /// 2nd conversion in regular
            /// sequence
            SQ2: u5,
            /// 3rd conversion in regular
            /// sequence
            SQ3: u5,
            /// 4th conversion in regular
            /// sequence
            SQ4: u5,
            /// 5th conversion in regular
            /// sequence
            SQ5: u5,
            /// 6th conversion in regular
            /// sequence
            SQ6: u5,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x34);

        /// address: 0x40012838
        /// injected sequence register
        pub const JSQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1st conversion in injected
            /// sequence
            JSQ1: u5,
            /// 2nd conversion in injected
            /// sequence
            JSQ2: u5,
            /// 3rd conversion in injected
            /// sequence
            JSQ3: u5,
            /// 4th conversion in injected
            /// sequence
            JSQ4: u5,
            /// Injected sequence length
            JL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x38);

        /// address: 0x4001283c
        /// injected data register x
        pub const JDR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x3c);

        /// address: 0x40012840
        /// injected data register x
        pub const JDR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x40012844
        /// injected data register x
        pub const JDR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);

        /// address: 0x40012848
        /// injected data register x
        pub const JDR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4001284c
        /// regular data register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Regular data
            DATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);
    };
    pub const ADC3 = struct {
        pub const base_address = 0x40013c00;

        /// address: 0x40013c00
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog flag
            AWD: u1,
            /// Regular channel end of
            /// conversion
            EOC: u1,
            /// Injected channel end of
            /// conversion
            JEOC: u1,
            /// Injected channel start
            /// flag
            JSTRT: u1,
            /// Regular channel start flag
            STRT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x0);

        /// address: 0x40013c04
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog channel select
            /// bits
            AWDCH: u5,
            /// Interrupt enable for EOC
            EOCIE: u1,
            /// Analog watchdog interrupt
            /// enable
            AWDIE: u1,
            /// Interrupt enable for injected
            /// channels
            JEOCIE: u1,
            /// Scan mode
            SCAN: u1,
            /// Enable the watchdog on a single channel
            /// in scan mode
            AWDSGL: u1,
            /// Automatic injected group
            /// conversion
            JAUTO: u1,
            /// Discontinuous mode on regular
            /// channels
            DISCEN: u1,
            /// Discontinuous mode on injected
            /// channels
            JDISCEN: u1,
            /// Discontinuous mode channel
            /// count
            DISCNUM: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Analog watchdog enable on injected
            /// channels
            JAWDEN: u1,
            /// Analog watchdog enable on regular
            /// channels
            AWDEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40013c08
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// A/D converter ON / OFF
            ADON: u1,
            /// Continuous conversion
            CONT: u1,
            /// A/D calibration
            CAL: u1,
            /// Reset calibration
            RSTCAL: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Direct memory access mode
            DMA: u1,
            reserved4: u1,
            reserved5: u1,
            /// Data alignment
            ALIGN: u1,
            /// External event select for injected
            /// group
            JEXTSEL: u3,
            /// External trigger conversion mode for
            /// injected channels
            JEXTTRIG: u1,
            reserved6: u1,
            /// External event select for regular
            /// group
            EXTSEL: u3,
            /// External trigger conversion mode for
            /// regular channels
            EXTTRIG: u1,
            /// Start conversion of injected
            /// channels
            JSWSTART: u1,
            /// Start conversion of regular
            /// channels
            SWSTART: u1,
            /// Temperature sensor and VREFINT
            /// enable
            TSVREFE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x8);

        /// address: 0x40013c0c
        /// sample time register 1
        pub const SMPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 10 sample time
            /// selection
            SMP10: u3,
            /// Channel 11 sample time
            /// selection
            SMP11: u3,
            /// Channel 12 sample time
            /// selection
            SMP12: u3,
            /// Channel 13 sample time
            /// selection
            SMP13: u3,
            /// Channel 14 sample time
            /// selection
            SMP14: u3,
            /// Channel 15 sample time
            /// selection
            SMP15: u3,
            /// Channel 16 sample time
            /// selection
            SMP16: u3,
            /// Channel 17 sample time
            /// selection
            SMP17: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xc);

        /// address: 0x40013c10
        /// sample time register 2
        pub const SMPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 0 sample time
            /// selection
            SMP0: u3,
            /// Channel 1 sample time
            /// selection
            SMP1: u3,
            /// Channel 2 sample time
            /// selection
            SMP2: u3,
            /// Channel 3 sample time
            /// selection
            SMP3: u3,
            /// Channel 4 sample time
            /// selection
            SMP4: u3,
            /// Channel 5 sample time
            /// selection
            SMP5: u3,
            /// Channel 6 sample time
            /// selection
            SMP6: u3,
            /// Channel 7 sample time
            /// selection
            SMP7: u3,
            /// Channel 8 sample time
            /// selection
            SMP8: u3,
            /// Channel 9 sample time
            /// selection
            SMP9: u3,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x10);

        /// address: 0x40013c14
        /// injected channel data offset register
        /// x
        pub const JOFR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET1: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x14);

        /// address: 0x40013c18
        /// injected channel data offset register
        /// x
        pub const JOFR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET2: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x18);

        /// address: 0x40013c1c
        /// injected channel data offset register
        /// x
        pub const JOFR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET3: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40013c20
        /// injected channel data offset register
        /// x
        pub const JOFR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data offset for injected channel
            /// x
            JOFFSET4: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x20);

        /// address: 0x40013c24
        /// watchdog higher threshold
        /// register
        pub const HTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog higher
            /// threshold
            HT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x24);

        /// address: 0x40013c28
        /// watchdog lower threshold
        /// register
        pub const LTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog lower
            /// threshold
            LT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x28);

        /// address: 0x40013c2c
        /// regular sequence register 1
        pub const SQR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 13th conversion in regular
            /// sequence
            SQ13: u5,
            /// 14th conversion in regular
            /// sequence
            SQ14: u5,
            /// 15th conversion in regular
            /// sequence
            SQ15: u5,
            /// 16th conversion in regular
            /// sequence
            SQ16: u5,
            /// Regular channel sequence
            /// length
            L: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x2c);

        /// address: 0x40013c30
        /// regular sequence register 2
        pub const SQR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7th conversion in regular
            /// sequence
            SQ7: u5,
            /// 8th conversion in regular
            /// sequence
            SQ8: u5,
            /// 9th conversion in regular
            /// sequence
            SQ9: u5,
            /// 10th conversion in regular
            /// sequence
            SQ10: u5,
            /// 11th conversion in regular
            /// sequence
            SQ11: u5,
            /// 12th conversion in regular
            /// sequence
            SQ12: u5,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x30);

        /// address: 0x40013c34
        /// regular sequence register 3
        pub const SQR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1st conversion in regular
            /// sequence
            SQ1: u5,
            /// 2nd conversion in regular
            /// sequence
            SQ2: u5,
            /// 3rd conversion in regular
            /// sequence
            SQ3: u5,
            /// 4th conversion in regular
            /// sequence
            SQ4: u5,
            /// 5th conversion in regular
            /// sequence
            SQ5: u5,
            /// 6th conversion in regular
            /// sequence
            SQ6: u5,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x34);

        /// address: 0x40013c38
        /// injected sequence register
        pub const JSQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1st conversion in injected
            /// sequence
            JSQ1: u5,
            /// 2nd conversion in injected
            /// sequence
            JSQ2: u5,
            /// 3rd conversion in injected
            /// sequence
            JSQ3: u5,
            /// 4th conversion in injected
            /// sequence
            JSQ4: u5,
            /// Injected sequence length
            JL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x38);

        /// address: 0x40013c3c
        /// injected data register x
        pub const JDR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x3c);

        /// address: 0x40013c40
        /// injected data register x
        pub const JDR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x40013c44
        /// injected data register x
        pub const JDR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);

        /// address: 0x40013c48
        /// injected data register x
        pub const JDR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected data
            JDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x40013c4c
        /// regular data register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Regular data
            DATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);
    };

    /// Controller area network
    pub const CAN = struct {
        pub const base_address = 0x40006400;

        /// address: 0x40006400
        /// CAN_MCR
        pub const CAN_MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INRQ
            INRQ: u1,
            /// SLEEP
            SLEEP: u1,
            /// TXFP
            TXFP: u1,
            /// RFLM
            RFLM: u1,
            /// NART
            NART: u1,
            /// AWUM
            AWUM: u1,
            /// ABOM
            ABOM: u1,
            /// TTCM
            TTCM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// RESET
            RESET: u1,
            /// DBF
            DBF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x0);

        /// address: 0x40006404
        /// CAN_MSR
        pub const CAN_MSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INAK
            INAK: u1,
            /// SLAK
            SLAK: u1,
            /// ERRI
            ERRI: u1,
            /// WKUI
            WKUI: u1,
            /// SLAKI
            SLAKI: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// TXM
            TXM: u1,
            /// RXM
            RXM: u1,
            /// SAMP
            SAMP: u1,
            /// RX
            RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x4);

        /// address: 0x40006408
        /// CAN_TSR
        pub const CAN_TSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RQCP0
            RQCP0: u1,
            /// TXOK0
            TXOK0: u1,
            /// ALST0
            ALST0: u1,
            /// TERR0
            TERR0: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// ABRQ0
            ABRQ0: u1,
            /// RQCP1
            RQCP1: u1,
            /// TXOK1
            TXOK1: u1,
            /// ALST1
            ALST1: u1,
            /// TERR1
            TERR1: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// ABRQ1
            ABRQ1: u1,
            /// RQCP2
            RQCP2: u1,
            /// TXOK2
            TXOK2: u1,
            /// ALST2
            ALST2: u1,
            /// TERR2
            TERR2: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// ABRQ2
            ABRQ2: u1,
            /// CODE
            CODE: u2,
            /// Lowest priority flag for mailbox
            /// 0
            TME0: u1,
            /// Lowest priority flag for mailbox
            /// 1
            TME1: u1,
            /// Lowest priority flag for mailbox
            /// 2
            TME2: u1,
            /// Lowest priority flag for mailbox
            /// 0
            LOW0: u1,
            /// Lowest priority flag for mailbox
            /// 1
            LOW1: u1,
            /// Lowest priority flag for mailbox
            /// 2
            LOW2: u1,
        }), base_address + 0x8);

        /// address: 0x4000640c
        /// CAN_RF0R
        pub const CAN_RF0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// FMP0
            FMP0: u2,
            reserved0: u1,
            /// FULL0
            FULL0: u1,
            /// FOVR0
            FOVR0: u1,
            /// RFOM0
            RFOM0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xc);

        /// address: 0x40006410
        /// CAN_RF1R
        pub const CAN_RF1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// FMP1
            FMP1: u2,
            reserved0: u1,
            /// FULL1
            FULL1: u1,
            /// FOVR1
            FOVR1: u1,
            /// RFOM1
            RFOM1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x10);

        /// address: 0x40006414
        /// CAN_IER
        pub const CAN_IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// TMEIE
            TMEIE: u1,
            /// FMPIE0
            FMPIE0: u1,
            /// FFIE0
            FFIE0: u1,
            /// FOVIE0
            FOVIE0: u1,
            /// FMPIE1
            FMPIE1: u1,
            /// FFIE1
            FFIE1: u1,
            /// FOVIE1
            FOVIE1: u1,
            reserved0: u1,
            /// EWGIE
            EWGIE: u1,
            /// EPVIE
            EPVIE: u1,
            /// BOFIE
            BOFIE: u1,
            /// LECIE
            LECIE: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// ERRIE
            ERRIE: u1,
            /// WKUIE
            WKUIE: u1,
            /// SLKIE
            SLKIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x14);

        /// address: 0x40006418
        /// CAN_ESR
        pub const CAN_ESR = @intToPtr(*volatile Mmio(32, packed struct {
            /// EWGF
            EWGF: u1,
            /// EPVF
            EPVF: u1,
            /// BOFF
            BOFF: u1,
            reserved0: u1,
            /// LEC
            LEC: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// TEC
            TEC: u8,
            /// REC
            REC: u8,
        }), base_address + 0x18);

        /// address: 0x4000641c
        /// CAN_BTR
        pub const CAN_BTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRP
            BRP: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// TS1
            TS1: u4,
            /// TS2
            TS2: u3,
            reserved6: u1,
            /// SJW
            SJW: u2,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// LBKM
            LBKM: u1,
            /// SILM
            SILM: u1,
        }), base_address + 0x1c);

        /// address: 0x40006580
        /// CAN_TI0R
        pub const CAN_TI0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXRQ
            TXRQ: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x180);

        /// address: 0x40006584
        /// CAN_TDT0R
        pub const CAN_TDT0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TGT
            TGT: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIME
            TIME: u16,
        }), base_address + 0x184);

        /// address: 0x40006588
        /// CAN_TDL0R
        pub const CAN_TDL0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x188);

        /// address: 0x4000658c
        /// CAN_TDH0R
        pub const CAN_TDH0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x18c);

        /// address: 0x40006590
        /// CAN_TI1R
        pub const CAN_TI1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXRQ
            TXRQ: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x190);

        /// address: 0x40006594
        /// CAN_TDT1R
        pub const CAN_TDT1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TGT
            TGT: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIME
            TIME: u16,
        }), base_address + 0x194);

        /// address: 0x40006598
        /// CAN_TDL1R
        pub const CAN_TDL1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x198);

        /// address: 0x4000659c
        /// CAN_TDH1R
        pub const CAN_TDH1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x19c);

        /// address: 0x400065a0
        /// CAN_TI2R
        pub const CAN_TI2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXRQ
            TXRQ: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x1a0);

        /// address: 0x400065a4
        /// CAN_TDT2R
        pub const CAN_TDT2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TGT
            TGT: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIME
            TIME: u16,
        }), base_address + 0x1a4);

        /// address: 0x400065a8
        /// CAN_TDL2R
        pub const CAN_TDL2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x1a8);

        /// address: 0x400065ac
        /// CAN_TDH2R
        pub const CAN_TDH2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x1ac);

        /// address: 0x400065b0
        /// CAN_RI0R
        pub const CAN_RI0R = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x1b0);

        /// address: 0x400065b4
        /// CAN_RDT0R
        pub const CAN_RDT0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// FMI
            FMI: u8,
            /// TIME
            TIME: u16,
        }), base_address + 0x1b4);

        /// address: 0x400065b8
        /// CAN_RDL0R
        pub const CAN_RDL0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x1b8);

        /// address: 0x400065bc
        /// CAN_RDH0R
        pub const CAN_RDH0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x1bc);

        /// address: 0x400065c0
        /// CAN_RI1R
        pub const CAN_RI1R = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x1c0);

        /// address: 0x400065c4
        /// CAN_RDT1R
        pub const CAN_RDT1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// FMI
            FMI: u8,
            /// TIME
            TIME: u16,
        }), base_address + 0x1c4);

        /// address: 0x400065c8
        /// CAN_RDL1R
        pub const CAN_RDL1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x1c8);

        /// address: 0x400065cc
        /// CAN_RDH1R
        pub const CAN_RDH1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x1cc);

        /// address: 0x40006600
        /// CAN_FMR
        pub const CAN_FMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FINIT
            FINIT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x200);

        /// address: 0x40006604
        /// CAN_FM1R
        pub const CAN_FM1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter mode
            FBM0: u1,
            /// Filter mode
            FBM1: u1,
            /// Filter mode
            FBM2: u1,
            /// Filter mode
            FBM3: u1,
            /// Filter mode
            FBM4: u1,
            /// Filter mode
            FBM5: u1,
            /// Filter mode
            FBM6: u1,
            /// Filter mode
            FBM7: u1,
            /// Filter mode
            FBM8: u1,
            /// Filter mode
            FBM9: u1,
            /// Filter mode
            FBM10: u1,
            /// Filter mode
            FBM11: u1,
            /// Filter mode
            FBM12: u1,
            /// Filter mode
            FBM13: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x204);

        /// address: 0x4000660c
        /// CAN_FS1R
        pub const CAN_FS1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter scale configuration
            FSC0: u1,
            /// Filter scale configuration
            FSC1: u1,
            /// Filter scale configuration
            FSC2: u1,
            /// Filter scale configuration
            FSC3: u1,
            /// Filter scale configuration
            FSC4: u1,
            /// Filter scale configuration
            FSC5: u1,
            /// Filter scale configuration
            FSC6: u1,
            /// Filter scale configuration
            FSC7: u1,
            /// Filter scale configuration
            FSC8: u1,
            /// Filter scale configuration
            FSC9: u1,
            /// Filter scale configuration
            FSC10: u1,
            /// Filter scale configuration
            FSC11: u1,
            /// Filter scale configuration
            FSC12: u1,
            /// Filter scale configuration
            FSC13: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x20c);

        /// address: 0x40006614
        /// CAN_FFA1R
        pub const CAN_FFA1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter FIFO assignment for filter
            /// 0
            FFA0: u1,
            /// Filter FIFO assignment for filter
            /// 1
            FFA1: u1,
            /// Filter FIFO assignment for filter
            /// 2
            FFA2: u1,
            /// Filter FIFO assignment for filter
            /// 3
            FFA3: u1,
            /// Filter FIFO assignment for filter
            /// 4
            FFA4: u1,
            /// Filter FIFO assignment for filter
            /// 5
            FFA5: u1,
            /// Filter FIFO assignment for filter
            /// 6
            FFA6: u1,
            /// Filter FIFO assignment for filter
            /// 7
            FFA7: u1,
            /// Filter FIFO assignment for filter
            /// 8
            FFA8: u1,
            /// Filter FIFO assignment for filter
            /// 9
            FFA9: u1,
            /// Filter FIFO assignment for filter
            /// 10
            FFA10: u1,
            /// Filter FIFO assignment for filter
            /// 11
            FFA11: u1,
            /// Filter FIFO assignment for filter
            /// 12
            FFA12: u1,
            /// Filter FIFO assignment for filter
            /// 13
            FFA13: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x214);

        /// address: 0x4000661c
        /// CAN_FA1R
        pub const CAN_FA1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter active
            FACT0: u1,
            /// Filter active
            FACT1: u1,
            /// Filter active
            FACT2: u1,
            /// Filter active
            FACT3: u1,
            /// Filter active
            FACT4: u1,
            /// Filter active
            FACT5: u1,
            /// Filter active
            FACT6: u1,
            /// Filter active
            FACT7: u1,
            /// Filter active
            FACT8: u1,
            /// Filter active
            FACT9: u1,
            /// Filter active
            FACT10: u1,
            /// Filter active
            FACT11: u1,
            /// Filter active
            FACT12: u1,
            /// Filter active
            FACT13: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x21c);

        /// address: 0x40006640
        /// Filter bank 0 register 1
        pub const F0R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x240);

        /// address: 0x40006644
        /// Filter bank 0 register 2
        pub const F0R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x244);

        /// address: 0x40006648
        /// Filter bank 1 register 1
        pub const F1R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x248);

        /// address: 0x4000664c
        /// Filter bank 1 register 2
        pub const F1R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x24c);

        /// address: 0x40006650
        /// Filter bank 2 register 1
        pub const F2R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x250);

        /// address: 0x40006654
        /// Filter bank 2 register 2
        pub const F2R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x254);

        /// address: 0x40006658
        /// Filter bank 3 register 1
        pub const F3R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x258);

        /// address: 0x4000665c
        /// Filter bank 3 register 2
        pub const F3R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x25c);

        /// address: 0x40006660
        /// Filter bank 4 register 1
        pub const F4R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x260);

        /// address: 0x40006664
        /// Filter bank 4 register 2
        pub const F4R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x264);

        /// address: 0x40006668
        /// Filter bank 5 register 1
        pub const F5R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x268);

        /// address: 0x4000666c
        /// Filter bank 5 register 2
        pub const F5R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x26c);

        /// address: 0x40006670
        /// Filter bank 6 register 1
        pub const F6R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x270);

        /// address: 0x40006674
        /// Filter bank 6 register 2
        pub const F6R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x274);

        /// address: 0x40006678
        /// Filter bank 7 register 1
        pub const F7R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x278);

        /// address: 0x4000667c
        /// Filter bank 7 register 2
        pub const F7R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x27c);

        /// address: 0x40006680
        /// Filter bank 8 register 1
        pub const F8R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x280);

        /// address: 0x40006684
        /// Filter bank 8 register 2
        pub const F8R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x284);

        /// address: 0x40006688
        /// Filter bank 9 register 1
        pub const F9R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x288);

        /// address: 0x4000668c
        /// Filter bank 9 register 2
        pub const F9R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x28c);

        /// address: 0x40006690
        /// Filter bank 10 register 1
        pub const F10R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x290);

        /// address: 0x40006694
        /// Filter bank 10 register 2
        pub const F10R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x294);

        /// address: 0x40006698
        /// Filter bank 11 register 1
        pub const F11R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x298);

        /// address: 0x4000669c
        /// Filter bank 11 register 2
        pub const F11R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x29c);

        /// address: 0x400066a0
        /// Filter bank 4 register 1
        pub const F12R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2a0);

        /// address: 0x400066a4
        /// Filter bank 12 register 2
        pub const F12R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2a4);

        /// address: 0x400066a8
        /// Filter bank 13 register 1
        pub const F13R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2a8);

        /// address: 0x400066ac
        /// Filter bank 13 register 2
        pub const F13R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2ac);
    };

    /// Digital to analog converter
    pub const DAC = struct {
        pub const base_address = 0x40007400;

        /// address: 0x40007400
        /// Control register (DAC_CR)
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 enable
            EN1: u1,
            /// DAC channel1 output buffer
            /// disable
            BOFF1: u1,
            /// DAC channel1 trigger
            /// enable
            TEN1: u1,
            /// DAC channel1 trigger
            /// selection
            TSEL1: u3,
            /// DAC channel1 noise/triangle wave
            /// generation enable
            WAVE1: u2,
            /// DAC channel1 mask/amplitude
            /// selector
            MAMP1: u4,
            /// DAC channel1 DMA enable
            DMAEN1: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DAC channel2 enable
            EN2: u1,
            /// DAC channel2 output buffer
            /// disable
            BOFF2: u1,
            /// DAC channel2 trigger
            /// enable
            TEN2: u1,
            /// DAC channel2 trigger
            /// selection
            TSEL2: u3,
            /// DAC channel2 noise/triangle wave
            /// generation enable
            WAVE2: u2,
            /// DAC channel2 mask/amplitude
            /// selector
            MAMP2: u4,
            /// DAC channel2 DMA enable
            DMAEN2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40007404
        /// DAC software trigger register
        /// (DAC_SWTRIGR)
        pub const SWTRIGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 software
            /// trigger
            SWTRIG1: u1,
            /// DAC channel2 software
            /// trigger
            SWTRIG2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x4);

        /// address: 0x40007408
        /// DAC channel1 12-bit right-aligned data
        /// holding register(DAC_DHR12R1)
        pub const DHR12R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 12-bit right-aligned
            /// data
            DACC1DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x8);

        /// address: 0x4000740c
        /// DAC channel1 12-bit left aligned data
        /// holding register (DAC_DHR12L1)
        pub const DHR12L1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC channel1 12-bit left-aligned
            /// data
            DACC1DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40007410
        /// DAC channel1 8-bit right aligned data
        /// holding register (DAC_DHR8R1)
        pub const DHR8R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 8-bit right-aligned
            /// data
            DACC1DHR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x40007414
        /// DAC channel2 12-bit right aligned data
        /// holding register (DAC_DHR12R2)
        pub const DHR12R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel2 12-bit right-aligned
            /// data
            DACC2DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x14);

        /// address: 0x40007418
        /// DAC channel2 12-bit left aligned data
        /// holding register (DAC_DHR12L2)
        pub const DHR12L2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC channel2 12-bit left-aligned
            /// data
            DACC2DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000741c
        /// DAC channel2 8-bit right-aligned data
        /// holding register (DAC_DHR8R2)
        pub const DHR8R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel2 8-bit right-aligned
            /// data
            DACC2DHR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x40007420
        /// Dual DAC 12-bit right-aligned data holding
        /// register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12
        /// Reserved
        pub const DHR12RD = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 12-bit right-aligned
            /// data
            DACC1DHR: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC channel2 12-bit right-aligned
            /// data
            DACC2DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20);

        /// address: 0x40007424
        /// DUAL DAC 12-bit left aligned data holding
        /// register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0
        /// Reserved
        pub const DHR12LD = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC channel1 12-bit left-aligned
            /// data
            DACC1DHR: u12,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// DAC channel2 12-bit right-aligned
            /// data
            DACC2DHR: u12,
        }), base_address + 0x24);

        /// address: 0x40007428
        /// DUAL DAC 8-bit right aligned data holding
        /// register (DAC_DHR8RD), Bits 31:16 Reserved
        pub const DHR8RD = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 8-bit right-aligned
            /// data
            DACC1DHR: u8,
            /// DAC channel2 8-bit right-aligned
            /// data
            DACC2DHR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x4000742c
        /// DAC channel1 data output register
        /// (DAC_DOR1)
        pub const DOR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 data output
            DACC1DOR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x2c);

        /// address: 0x40007430
        /// DAC channel2 data output register
        /// (DAC_DOR2)
        pub const DOR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel2 data output
            DACC2DOR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x30);
    };

    /// Debug support
    pub const DBG = struct {
        pub const base_address = 0xe0042000;

        /// address: 0xe0042000
        /// DBGMCU_IDCODE
        pub const IDCODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// DEV_ID
            DEV_ID: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// REV_ID
            REV_ID: u16,
        }), base_address + 0x0);

        /// address: 0xe0042004
        /// DBGMCU_CR
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DBG_SLEEP
            DBG_SLEEP: u1,
            /// DBG_STOP
            DBG_STOP: u1,
            /// DBG_STANDBY
            DBG_STANDBY: u1,
            reserved0: u1,
            reserved1: u1,
            /// TRACE_IOEN
            TRACE_IOEN: u1,
            /// TRACE_MODE
            TRACE_MODE: u2,
            /// DBG_IWDG_STOP
            DBG_IWDG_STOP: u1,
            /// DBG_WWDG_STOP
            DBG_WWDG_STOP: u1,
            /// DBG_TIM1_STOP
            DBG_TIM1_STOP: u1,
            /// DBG_TIM2_STOP
            DBG_TIM2_STOP: u1,
            /// DBG_TIM3_STOP
            DBG_TIM3_STOP: u1,
            /// DBG_TIM4_STOP
            DBG_TIM4_STOP: u1,
            /// DBG_CAN1_STOP
            DBG_CAN1_STOP: u1,
            /// DBG_I2C1_SMBUS_TIMEOUT
            DBG_I2C1_SMBUS_TIMEOUT: u1,
            /// DBG_I2C2_SMBUS_TIMEOUT
            DBG_I2C2_SMBUS_TIMEOUT: u1,
            /// DBG_TIM8_STOP
            DBG_TIM8_STOP: u1,
            /// DBG_TIM5_STOP
            DBG_TIM5_STOP: u1,
            /// DBG_TIM6_STOP
            DBG_TIM6_STOP: u1,
            /// DBG_TIM7_STOP
            DBG_TIM7_STOP: u1,
            /// DBG_CAN2_STOP
            DBG_CAN2_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x4);
    };

    /// Universal asynchronous receiver
    /// transmitter
    pub const UART4 = struct {
        pub const base_address = 0x40004c00;

        /// address: 0x40004c00
        /// UART4_SR
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error
            PE: u1,
            /// Framing error
            FE: u1,
            /// Noise error flag
            NE: u1,
            /// Overrun error
            ORE: u1,
            /// IDLE line detected
            IDLE: u1,
            /// Read data register not
            /// empty
            RXNE: u1,
            /// Transmission complete
            TC: u1,
            /// Transmit data register
            /// empty
            TXE: u1,
            /// LIN break detection flag
            LBD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x0);

        /// address: 0x40004c04
        /// UART4_DR
        pub const DR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x4);

        /// address: 0x40004c08
        /// UART4_BRR
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DIV_Fraction
            DIV_Fraction: u4,
            /// DIV_Mantissa
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x40004c0c
        /// UART4_CR1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Send break
            SBK: u1,
            /// Receiver wakeup
            RWU: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// TXE interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Wakeup method
            WAKE: u1,
            /// Word length
            M: u1,
            /// USART enable
            UE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xc);

        /// address: 0x40004c10
        /// UART4_CR2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address of the USART node
            ADD: u4,
            reserved0: u1,
            /// lin break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x10);

        /// address: 0x40004c14
        /// UART4_CR3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// IrDA mode enable
            IREN: u1,
            /// IrDA low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            reserved0: u1,
            reserved1: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);
    };

    /// Universal asynchronous receiver
    /// transmitter
    pub const UART5 = struct {
        pub const base_address = 0x40005000;

        /// address: 0x40005000
        /// UART4_SR
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NE
            NE: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBD
            LBD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x0);

        /// address: 0x40005004
        /// UART4_DR
        pub const DR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x4);

        /// address: 0x40005008
        /// UART4_BRR
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DIV_Fraction
            DIV_Fraction: u4,
            /// DIV_Mantissa
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000500c
        /// UART4_CR1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SBK
            SBK: u1,
            /// RWU
            RWU: u1,
            /// RE
            RE: u1,
            /// TE
            TE: u1,
            /// IDLEIE
            IDLEIE: u1,
            /// RXNEIE
            RXNEIE: u1,
            /// TCIE
            TCIE: u1,
            /// TXEIE
            TXEIE: u1,
            /// PEIE
            PEIE: u1,
            /// PS
            PS: u1,
            /// PCE
            PCE: u1,
            /// WAKE
            WAKE: u1,
            /// M
            M: u1,
            /// UE
            UE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xc);

        /// address: 0x40005010
        /// UART4_CR2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADD
            ADD: u4,
            reserved0: u1,
            /// LBDL
            LBDL: u1,
            /// LBDIE
            LBDIE: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// STOP
            STOP: u2,
            /// LINEN
            LINEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x10);

        /// address: 0x40005014
        /// UART4_CR3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// IrDA mode enable
            IREN: u1,
            /// IrDA low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA enable transmitter
            DMAT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);
    };

    /// CRC calculation unit
    pub const CRC = struct {
        pub const base_address = 0x40023000;

        /// address: 0x40023000
        /// Data register
        pub const DR = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40023004
        /// Independent Data register
        pub const IDR = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x4);

        /// address: 0x40023008
        /// Control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reset bit
            RESET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x8);
    };

    /// FLASH
    pub const FLASH = struct {
        pub const base_address = 0x40022000;

        /// address: 0x40022000
        /// Flash access control register
        pub const ACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Latency
            LATENCY: u3,
            /// Flash half cycle access
            /// enable
            HLFCYA: u1,
            /// Prefetch buffer enable
            PRFTBE: u1,
            /// Prefetch buffer status
            PRFTBS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x0);

        /// address: 0x40022004
        /// Flash key register
        pub const KEYR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FPEC key
            KEY: u32,
        }), base_address + 0x4);

        /// address: 0x40022008
        /// Flash option key register
        pub const OPTKEYR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Option byte key
            OPTKEY: u32,
        }), base_address + 0x8);

        /// address: 0x4002200c
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Busy
            BSY: u1,
            reserved0: u1,
            /// Programming error
            PGERR: u1,
            reserved1: u1,
            /// Write protection error
            WRPRTERR: u1,
            /// End of operation
            EOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xc);

        /// address: 0x40022010
        /// Control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Programming
            PG: u1,
            /// Page Erase
            PER: u1,
            /// Mass Erase
            MER: u1,
            reserved0: u1,
            /// Option byte programming
            OPTPG: u1,
            /// Option byte erase
            OPTER: u1,
            /// Start
            STRT: u1,
            /// Lock
            LOCK: u1,
            reserved1: u1,
            /// Option bytes write enable
            OPTWRE: u1,
            /// Error interrupt enable
            ERRIE: u1,
            reserved2: u1,
            /// End of operation interrupt
            /// enable
            EOPIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40022014
        /// Flash address register
        pub const AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Flash Address
            FAR: u32,
        }), base_address + 0x14);

        /// address: 0x4002201c
        /// Option byte register
        pub const OBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Option byte error
            OPTERR: u1,
            /// Read protection
            RDPRT: u1,
            /// WDG_SW
            WDG_SW: u1,
            /// nRST_STOP
            nRST_STOP: u1,
            /// nRST_STDBY
            nRST_STDBY: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Data0
            Data0: u8,
            /// Data1
            Data1: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x1c);

        /// address: 0x40022020
        /// Write protection register
        pub const WRPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write protect
            WRP: u32,
        }), base_address + 0x20);
    };

    /// Nested Vectored Interrupt
    /// Controller
    pub const NVIC = struct {
        pub const base_address = 0xe000e000;

        /// address: 0xe000e004
        /// Interrupt Controller Type
        /// Register
        pub const ICTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Total number of interrupt lines in
            /// groups
            INTLINESNUM: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x4);

        /// address: 0xe000ef00
        /// Software Triggered Interrupt
        /// Register
        pub const STIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// interrupt to be triggered
            INTID: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0xf00);

        /// address: 0xe000e100
        /// Interrupt Set-Enable Register
        pub const ISER0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SETENA
            SETENA: u32,
        }), base_address + 0x100);

        /// address: 0xe000e104
        /// Interrupt Set-Enable Register
        pub const ISER1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SETENA
            SETENA: u32,
        }), base_address + 0x104);

        /// address: 0xe000e180
        /// Interrupt Clear-Enable
        /// Register
        pub const ICER0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CLRENA
            CLRENA: u32,
        }), base_address + 0x180);

        /// address: 0xe000e184
        /// Interrupt Clear-Enable
        /// Register
        pub const ICER1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CLRENA
            CLRENA: u32,
        }), base_address + 0x184);

        /// address: 0xe000e200
        /// Interrupt Set-Pending Register
        pub const ISPR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SETPEND
            SETPEND: u32,
        }), base_address + 0x200);

        /// address: 0xe000e204
        /// Interrupt Set-Pending Register
        pub const ISPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SETPEND
            SETPEND: u32,
        }), base_address + 0x204);

        /// address: 0xe000e280
        /// Interrupt Clear-Pending
        /// Register
        pub const ICPR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CLRPEND
            CLRPEND: u32,
        }), base_address + 0x280);

        /// address: 0xe000e284
        /// Interrupt Clear-Pending
        /// Register
        pub const ICPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CLRPEND
            CLRPEND: u32,
        }), base_address + 0x284);

        /// address: 0xe000e300
        /// Interrupt Active Bit Register
        pub const IABR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ACTIVE
            ACTIVE: u32,
        }), base_address + 0x300);

        /// address: 0xe000e304
        /// Interrupt Active Bit Register
        pub const IABR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ACTIVE
            ACTIVE: u32,
        }), base_address + 0x304);

        /// address: 0xe000e400
        /// Interrupt Priority Register
        pub const IPR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x400);

        /// address: 0xe000e404
        /// Interrupt Priority Register
        pub const IPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x404);

        /// address: 0xe000e408
        /// Interrupt Priority Register
        pub const IPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x408);

        /// address: 0xe000e40c
        /// Interrupt Priority Register
        pub const IPR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x40c);

        /// address: 0xe000e410
        /// Interrupt Priority Register
        pub const IPR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x410);

        /// address: 0xe000e414
        /// Interrupt Priority Register
        pub const IPR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x414);

        /// address: 0xe000e418
        /// Interrupt Priority Register
        pub const IPR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x418);

        /// address: 0xe000e41c
        /// Interrupt Priority Register
        pub const IPR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x41c);

        /// address: 0xe000e420
        /// Interrupt Priority Register
        pub const IPR8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x420);

        /// address: 0xe000e424
        /// Interrupt Priority Register
        pub const IPR9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x424);

        /// address: 0xe000e428
        /// Interrupt Priority Register
        pub const IPR10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x428);

        /// address: 0xe000e42c
        /// Interrupt Priority Register
        pub const IPR11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x42c);

        /// address: 0xe000e430
        /// Interrupt Priority Register
        pub const IPR12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x430);

        /// address: 0xe000e434
        /// Interrupt Priority Register
        pub const IPR13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x434);

        /// address: 0xe000e438
        /// Interrupt Priority Register
        pub const IPR14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x438);
    };

    /// Universal serial bus full-speed device
    /// interface
    pub const USB = struct {
        pub const base_address = 0x40005c00;

        /// address: 0x40005c00
        /// endpoint 0 register
        pub const EP0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40005c04
        /// endpoint 1 register
        pub const EP1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x40005c08
        /// endpoint 2 register
        pub const EP2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x40005c0c
        /// endpoint 3 register
        pub const EP3R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40005c10
        /// endpoint 4 register
        pub const EP4R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40005c14
        /// endpoint 5 register
        pub const EP5R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40005c18
        /// endpoint 6 register
        pub const EP6R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40005c1c
        /// endpoint 7 register
        pub const EP7R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40005c40
        /// control register
        pub const CNTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Force USB Reset
            FRES: u1,
            /// Power down
            PDWN: u1,
            /// Low-power mode
            LPMODE: u1,
            /// Force suspend
            FSUSP: u1,
            /// Resume request
            RESUME: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Expected start of frame interrupt
            /// mask
            ESOFM: u1,
            /// Start of frame interrupt
            /// mask
            SOFM: u1,
            /// USB reset interrupt mask
            RESETM: u1,
            /// Suspend mode interrupt
            /// mask
            SUSPM: u1,
            /// Wakeup interrupt mask
            WKUPM: u1,
            /// Error interrupt mask
            ERRM: u1,
            /// Packet memory area over / underrun
            /// interrupt mask
            PMAOVRM: u1,
            /// Correct transfer interrupt
            /// mask
            CTRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x40005c44
        /// interrupt status register
        pub const ISTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint Identifier
            EP_ID: u4,
            /// Direction of transaction
            DIR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Expected start frame
            ESOF: u1,
            /// start of frame
            SOF: u1,
            /// reset request
            RESET: u1,
            /// Suspend mode request
            SUSP: u1,
            /// Wakeup
            WKUP: u1,
            /// Error
            ERR: u1,
            /// Packet memory area over /
            /// underrun
            PMAOVR: u1,
            /// Correct transfer
            CTR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);

        /// address: 0x40005c48
        /// frame number register
        pub const FNR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame number
            FN: u11,
            /// Lost SOF
            LSOF: u2,
            /// Locked
            LCK: u1,
            /// Receive data - line status
            RXDM: u1,
            /// Receive data + line status
            RXDP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x40005c4c
        /// device address
        pub const DADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADD: u7,
            /// Enable function
            EF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4c);

        /// address: 0x40005c50
        /// Buffer table address
        pub const BTABLE = @intToPtr(*volatile MmioInt(32, u13), base_address + 0x50);
    };
};

const std = @import("std");

pub fn mmio(addr: usize, comptime size: u8, comptime PackedT: type) *volatile Mmio(size, PackedT) {
    return @intToPtr(*volatile Mmio(size, PackedT), addr);
}

pub fn Mmio(comptime size: u8, comptime PackedT: type) type {
    if ((size % 8) != 0)
        @compileError("size must be divisible by 8!");

    if (!std.math.isPowerOfTwo(size / 8))
        @compileError("size must encode a power of two number of bytes!");

    const IntT = std.meta.Int(.unsigned, size);

    if (@sizeOf(PackedT) != (size / 8))
        @compileError(std.fmt.comptimePrint("IntT and PackedT must have the same size!, they are {} and {} bytes respectively", .{ size / 8, @sizeOf(PackedT) }));

    return extern struct {
        const Self = @This();

        raw: IntT,

        pub const underlying_type = PackedT;

        pub inline fn read(addr: *volatile Self) PackedT {
            return @bitCast(PackedT, addr.raw);
        }

        pub inline fn write(addr: *volatile Self, val: PackedT) void {
            // This is a workaround for a compiler bug related to miscompilation
            // If the tmp var is not used, result location will fuck things up
            var tmp = @bitCast(IntT, val);
            addr.raw = tmp;
        }

        pub inline fn modify(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, field.name) = @field(fields, field.name);
            }
            write(addr, val);
        }

        pub inline fn toggle(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, @tagName(field.default_value.?)) = !@field(val, @tagName(field.default_value.?));
            }
            write(addr, val);
        }
    };
}

pub fn MmioInt(comptime size: u8, comptime T: type) type {
    return extern struct {
        const Self = @This();

        raw: std.meta.Int(.unsigned, size),

        pub inline fn read(addr: *volatile Self) T {
            return @truncate(T, addr.raw);
        }

        pub inline fn modify(addr: *volatile Self, val: T) void {
            const Int = std.meta.Int(.unsigned, size);
            const mask = ~@as(Int, (1 << @bitSizeOf(T)) - 1);

            var tmp = addr.raw;
            addr.raw = (tmp & mask) | val;
        }
    };
}

pub fn mmioInt(addr: usize, comptime size: usize, comptime T: type) *volatile MmioInt(size, T) {
    return @intToPtr(*volatile MmioInt(size, T), addr);
}

pub const InterruptVector = extern union {
    C: fn () callconv(.C) void,
    Naked: fn () callconv(.Naked) void,
    // Interrupt is not supported on arm
};

const unhandled = InterruptVector{
    .C = struct {
        fn tmp() callconv(.C) noreturn {
            @panic("unhandled interrupt");
        }
    }.tmp,
};
