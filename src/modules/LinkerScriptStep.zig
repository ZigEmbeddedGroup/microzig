const std = @import("std");
const MemoryRegion = @import("MemoryRegion.zig");
const Chip = @import("Chip.zig");
const Step = std.build.Step;
const Build = std.Build;
const GeneratedFile = std.build.GeneratedFile;

const LinkerscriptStep = @This();

step: Step,
generated_file: std.build.GeneratedFile,
chip: Chip,

pub fn create(owner: *Build, chip: Chip) !*LinkerscriptStep {
    var linkerscript = try owner.allocator.create(LinkerscriptStep);
    linkerscript.* = LinkerscriptStep{
        .step = Step.init(.{
            .id = .custom,
            .name = "linkerscript",
            .owner = owner,
            .makeFn = make,
        }),
        .generated_file = .{
            .step = &linkerscript.step,
        },
        .chip = chip,
    };

    return linkerscript;
}

fn make(step: *Step, _: *std.Progress.Node) anyerror!void {
    const linkerscript = @fieldParentPtr(LinkerscriptStep, "step", step);

    const owner = linkerscript.step.owner;
    const target = linkerscript.chip.cpu.target;

    var contents = std.ArrayList(u8).init(owner.allocator);
    const writer = contents.writer();
    try writer.print(
        \\/*
        \\ * This file was auto-generated by microzig
        \\ *
        \\ * Target CPU:  {s}
        \\ * Target Chip: {s}
        \\ */
        \\
        // This is not the "true" entry point, but there's no such thing on embedded platforms
        // anyways. This is the logical entrypoint that should be invoked when
        // stack, .data and .bss are set up and the CPU is ready to be used.
        \\ENTRY(microzig_main);
        \\
        \\
    , .{ linkerscript.chip.cpu.name, linkerscript.chip.name });

    try writer.writeAll("MEMORY\n{\n");
    {
        var counters = [2]usize{ 0, 0 };
        for (linkerscript.chip.memory_regions) |region| {
            // flash (rx!w) : ORIGIN = 0x00000000, LENGTH = 512k

            switch (region.kind) {
                .flash => {
                    try writer.print("  flash{d} (rx!w)", .{counters[0]});
                    counters[0] += 1;
                },
                .ram => {
                    try writer.print("  ram{d}   (rw!x)", .{counters[1]});
                    counters[1] += 1;
                },
                .custom => |custom| {
                    try writer.print("  {s} (", .{custom.name});
                    if (custom.readable) try writer.writeAll("r");
                    if (custom.writeable) try writer.writeAll("w");
                    if (custom.executable) try writer.writeAll("x");

                    if (!custom.readable or !custom.writeable or !custom.executable) {
                        try writer.writeAll("!");
                        if (!custom.readable) try writer.writeAll("r");
                        if (!custom.writeable) try writer.writeAll("w");
                        if (!custom.executable) try writer.writeAll("x");
                    }
                    try writer.writeAll(")");
                },
            }
            try writer.print(" : ORIGIN = 0x{X:0>8}, LENGTH = 0x{X:0>8}\n", .{ region.offset, region.length });
        }
    }

    try writer.writeAll("}\n\nSECTIONS\n{\n");
    {
        try writer.writeAll(
            \\  .text :
            \\  {
            \\     KEEP(*(microzig_flash_start))
            \\     *(.text*)
            \\  } > flash0
            \\
            \\
        );

        switch (target.getCpuArch()) {
            .arm, .thumb => try writer.writeAll(
                \\  .ARM.exidx : {
                \\      *(.ARM.exidx* .gnu.linkonce.armexidx.*)
                \\  } >flash0
                \\
                \\
            ),
            else => {},
        }

        try writer.writeAll(
            \\  .data :
            \\  {
            \\     microzig_data_start = .;
            \\     *(.rodata*)
            \\     *(.data*)
            \\     microzig_data_end = .;
            \\  } > ram0 AT> flash0
            \\
            \\  .bss (NOLOAD) :
            \\  {
            \\      microzig_bss_start = .;
            \\      *(.bss*)
            \\      microzig_bss_end = .;
            \\  } > ram0
            \\
            \\  microzig_data_load_start = LOADADDR(.data);
            \\
        );
    }
    try writer.writeAll("}\n");

    // TODO: Assert that the flash can actually hold all data!
    // try writer.writeAll(
    //     \\
    //     \\  ASSERT( (SIZEOF(.text) + SIZEOF(.data) > LENGTH(flash0)), "Error: .text + .data is too large for flash!" );
    //     \\
    // );

    const filename = try std.fmt.allocPrint(owner.allocator, "{s}_{s}.ld", .{
        linkerscript.chip.name,
        linkerscript.chip.cpu.name,
    });

    var hash = owner.cache.hash;
    hash.addBytes(linkerscript.chip.name);
    hash.addBytes(linkerscript.chip.cpu.name);

    // TODO: hash more information to reduce chance of collision
    for (linkerscript.chip.memory_regions) |memory_region| {
        hash.add(memory_region.offset);
        hash.add(memory_region.length);
    }

    const digest = hash.final();
    const dir_path = try owner.cache_root.join(owner.allocator, &.{
        "microzig",
        &digest,
    });

    var dir = try owner.cache_root.handle.makeOpenPath(dir_path, .{});
    defer dir.close();

    const file = try dir.createFile(filename, .{});
    defer file.close();

    try file.writeAll(contents.items);
    const full_path = owner.pathJoin(&.{ dir_path, filename });
    linkerscript.generated_file.path = full_path;
}
