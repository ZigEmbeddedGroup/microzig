name: Code Linting

on:
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  lint:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Setup Zig
        uses: mlugg/setup-zig@v2
        with:
          version: 0.15.1

      - name: Build linter
        working-directory: tools/linter
        run: zig build --release=safe

      - name: Run linter
        run: |
          echo "Base SHA: ${{ github.event.pull_request.base.sha }}"
          echo "Head SHA: ${{ github.event.pull_request.head.sha }}"

          # Get changed .zig files
          FILES=$(git diff --name-only --diff-filter=d ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} | grep '\.zig$' || true)
          echo "Changed files: $FILES"

          if [ -n "$FILES" ]; then
            echo "$FILES" | xargs ./tools/linter/zig-out/bin/linter > lint_results.json
          else
            echo "[]" > lint_results.json
          fi

          # Debug output
          echo "Lint results:"
          cat lint_results.json

      - name: Post review with grouped comments
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const crypto = require('crypto');

            if (!fs.existsSync('lint_results.json')) {
              console.log('No lint results file found');
              return;
            }

            const content = fs.readFileSync('lint_results.json', 'utf8').trim();
            if (!content || content === '[]') {
              console.log('No lint issues found');

              // Check if there's an existing review to dismiss
              const existingReviews = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number
              });

              const botReview = existingReviews.data.find(review =>
                review.user.login === 'github-actions[bot]' &&
                review.body && review.body.includes('<!-- lint-review -->')
              );

              if (botReview && botReview.state !== 'DISMISSED') {
                await github.rest.pulls.dismissReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  review_id: botReview.id,
                  message: 'All lint issues have been resolved'
                });
                console.log('Dismissed previous lint review - no issues found');
              }

              return;
            }

            const issues = JSON.parse(content);

            // Check for existing bot review
            const existingReviews = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const botReview = existingReviews.data.find(review =>
              review.user.login === 'github-actions[bot]' &&
              review.body && review.body.includes('<!-- lint-review -->')
            );

            // Create hash of current issues to check if review needs updating
            const issuesHash = crypto.createHash('md5')
              .update(JSON.stringify(issues.map(i => `${i.file}:${i.line}:${i.message}`)))
              .digest('hex')
              .substring(0, 8);

            // Check if existing review has the same issues
            if (botReview && botReview.body.includes(`<!-- lint-hash:${issuesHash} -->`)) {
              console.log('Review already exists with same issues, skipping');
              return;
            }

            // Dismiss existing review if it exists and is not already dismissed
            if (botReview && botReview.state !== 'DISMISSED') {
              await github.rest.pulls.dismissReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                review_id: botReview.id,
                message: 'Updating with new lint results'
              });
            }

            // Prepare review comments
            const reviewComments = [];
            const issuesByFile = {};

            for (const issue of issues) {
              if (!issuesByFile[issue.file]) {
                issuesByFile[issue.file] = [];
              }
              issuesByFile[issue.file].push(issue);

              reviewComments.push({
                path: issue.file,
                line: issue.line,
                body: issue.message
              });
            }

            // Create review body with summary
            const totalIssues = issues.length;
            const fileCount = Object.keys(issuesByFile).length;

            let reviewBody = `## üîç Lint Results\n\n`;
            reviewBody += `Found **${totalIssues}** issue${totalIssues !== 1 ? 's' : ''} in **${fileCount}** file${fileCount !== 1 ? 's' : ''}:\n\n`;

            for (const [file, fileIssues] of Object.entries(issuesByFile)) {
              reviewBody += `- **${file}**: ${fileIssues.length} issue${fileIssues.length !== 1 ? 's' : ''}\n`;
            }

            reviewBody += `\n<!-- lint-review -->\n<!-- lint-hash:${issuesHash} -->`;

            try {
              const review = await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                commit_id: context.payload.pull_request.head.sha,
                body: reviewBody,
                event: 'REQUEST_CHANGES',
                comments: reviewComments
              });

              console.log(`Created review with ${reviewComments.length} comments`);
            } catch (error) {
              console.error(`Failed to create review:`, error.message);

              // Fallback: try to create review without comments if there's an error
              try {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  commit_id: context.payload.pull_request.head.sha,
                  body: reviewBody + '\n\n‚ö†Ô∏è Could not attach inline comments due to an error.',
                  event: 'REQUEST_CHANGES'
                });
                console.log('Created review without inline comments as fallback');
              } catch (fallbackError) {
                console.error('Fallback review creation also failed:', fallbackError.message);
              }
            }
