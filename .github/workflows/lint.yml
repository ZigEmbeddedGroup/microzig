name: Code Linting

on:
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  lint:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required for resolveReviewThread GraphQL mutation
      pull-requests: write

    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Setup Zig
        uses: mlugg/setup-zig@v2
        with:
          version: 0.15.1

      - name: Build linter
        working-directory: tools/linter
        run: zig build --release=safe

      - name: Run linter
        run: |
          echo "Base SHA: ${{ github.event.pull_request.base.sha }}"
          echo "Head SHA: ${{ github.event.pull_request.head.sha }}"

          # Get changed .zig files
          FILES=$(git diff --name-only --diff-filter=d ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} | grep '\.zig$' || true)
          echo "Changed files: $FILES"

          if [ -n "$FILES" ]; then
            echo "$FILES" | xargs ./tools/linter/zig-out/bin/linter > lint_results.json
          else
            echo "[]" > lint_results.json
          fi

          # Debug output
          echo "Lint results:"
          cat lint_results.json

      - name: Post review with grouped comments
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const crypto = require('crypto');

            // Helper function to resolve review threads using GraphQL
            async function resolveReviewThreads(reviewId) {
              try {
                // Get all review comments for this review
                const comments = await github.rest.pulls.listCommentsForReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  review_id: reviewId
                });

                if (comments.data.length === 0) {
                  console.log(`No comments found for review ${reviewId}`);
                  return;
                }

                // Get all review threads for this PR
                const query = `
                  query($owner: String!, $repo: String!, $prNumber: Int!) {
                    repository(owner: $owner, name: $repo) {
                      pullRequest(number: $prNumber) {
                        reviewThreads(first: 100) {
                          nodes {
                            id
                            isResolved
                            comments(first: 10) {
                              nodes {
                                databaseId
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;

                const result = await github.graphql(query, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  prNumber: context.issue.number
                });

                const threads = result.repository.pullRequest.reviewThreads.nodes;
                const commentIds = new Set(comments.data.map(c => c.id));

                // Find and resolve threads that contain comments from this review
                for (const thread of threads) {
                  if (thread.isResolved) continue;

                  const hasReviewComment = thread.comments.nodes.some(c => 
                    commentIds.has(c.databaseId)
                  );

                  if (hasReviewComment) {
                    try {
                      await github.graphql(`
                        mutation($threadId: ID!) {
                          resolveReviewThread(input: {threadId: $threadId}) {
                            thread {
                              id
                            }
                          }
                        }
                      `, {
                        threadId: thread.id
                      });
                      console.log(`Resolved thread ${thread.id}`);
                    } catch (error) {
                      console.log(`Could not resolve thread ${thread.id}: ${error.message}`);
                    }
                  }
                }
              } catch (error) {
                console.log(`Error resolving threads for review ${reviewId}: ${error.message}`);
              }
            }

            if (!fs.existsSync('lint_results.json')) {
              console.log('No lint results file found');
              return;
            }

            const content = fs.readFileSync('lint_results.json', 'utf8').trim();

            // Get all existing bot reviews
            const existingReviews = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const botReviews = existingReviews.data.filter(review =>
              review.user.login === 'github-actions[bot]' &&
              review.body && review.body.includes('<!-- lint-review -->')
            );

            if (!content || content === '[]') {
              console.log('No lint issues found');

              // Dismiss all existing bot reviews and resolve their conversations
              for (const review of botReviews) {
                if (review.state !== 'DISMISSED') {
                  await resolveReviewThreads(review.id);
                  await github.rest.pulls.dismissReview({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: context.issue.number,
                    review_id: review.id,
                    message: 'All lint issues have been resolved'
                  });
                  console.log(`Dismissed review ${review.id} and resolved conversations`);
                }
              }

              return;
            }

            const issues = JSON.parse(content);

            // Create hash of current issues to check if review needs updating
            const issuesHash = crypto.createHash('md5')
              .update(JSON.stringify(issues.map(i => `${i.file}:${i.line}:${i.message}`)))
              .digest('hex')
              .substring(0, 8);

            // Check if any existing review has the same issues
            const matchingReview = botReviews.find(review => 
              review.body.includes(`<!-- lint-hash:${issuesHash} -->`)
            );

            if (matchingReview) {
              console.log('Review already exists with same issues, skipping');
              return;
            }

            // Dismiss ALL existing bot reviews and resolve their conversations
            for (const review of botReviews) {
              if (review.state !== 'DISMISSED') {
                await resolveReviewThreads(review.id);
                await github.rest.pulls.dismissReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  review_id: review.id,
                  message: 'Updating with new lint results'
                });
                console.log(`Dismissed review ${review.id} and resolved conversations`);
              }
            }

            // Prepare review comments
            const reviewComments = [];
            const issuesByFile = {};

            for (const issue of issues) {
              if (!issuesByFile[issue.file]) {
                issuesByFile[issue.file] = [];
              }
              issuesByFile[issue.file].push(issue);

              reviewComments.push({
                path: issue.file,
                line: issue.line,
                body: issue.message
              });
            }

            // Create review body with summary
            const totalIssues = issues.length;
            const fileCount = Object.keys(issuesByFile).length;

            let reviewBody = `## üîç Lint Results\n\n`;
            reviewBody += `Found **${totalIssues}** issue${totalIssues !== 1 ? 's' : ''} in **${fileCount}** file${fileCount !== 1 ? 's' : ''}:\n\n`;

            for (const [file, fileIssues] of Object.entries(issuesByFile)) {
              reviewBody += `- **${file}**: ${fileIssues.length} issue${fileIssues.length !== 1 ? 's' : ''}\n`;
            }

            reviewBody += `\n<!-- lint-review -->\n<!-- lint-hash:${issuesHash} -->`;

            try {
              const review = await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                commit_id: context.payload.pull_request.head.sha,
                body: reviewBody,
                event: 'REQUEST_CHANGES',
                comments: reviewComments
              });

              console.log(`Created review with ${reviewComments.length} comments`);
            } catch (error) {
              console.error(`Failed to create review:`, error.message);

              // Fallback: try to create review without comments if there's an error
              try {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  commit_id: context.payload.pull_request.head.sha,
                  body: reviewBody + '\n\n‚ö†Ô∏è Could not attach inline comments due to an error.',
                  event: 'REQUEST_CHANGES'
                });
                console.log('Created review without inline comments as fallback');
              } catch (fallbackError) {
                console.error('Fallback review creation also failed:', fallbackError.message);
              }
            }
