name: Code Linting

on:
  pull_request_target:
    branches: [main]
  workflow_dispatch:

jobs:
  lint:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      # SECURITY: Checkout base branch for linter binary
      - name: Checkout base branch
        uses: actions/checkout@v3
        with:
          ref: ${{ github.base_ref }}
          path: base

      - name: Setup Zig
        uses: mlugg/setup-zig@v2
        with:
          version: master

      # Build linter from trusted base branch code
      - name: Build linter
        working-directory: base/tools/linter
        run: zig build --release=safe

      # Now checkout PR code to analyze (but not execute)
      - name: Checkout PR code
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          path: pr
          fetch-depth: 0

      - name: Run linter
        working-directory: pr
        run: |
          echo "Base SHA: ${{ github.event.pull_request.base.sha }}"
          echo "Head SHA: ${{ github.event.pull_request.head.sha }}"

          # Get changed .zig files
          FILES=$(git diff --name-only --diff-filter=d ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} | grep '\.zig$' || true)
          echo "Changed files: $FILES"

          if [ -n "$FILES" ]; then
            echo "$FILES" | xargs ../base/tools/linter/zig-out/bin/linter > lint_results_raw.json
          else
            echo "[]" > lint_results_raw.json
          fi

          # Debug output
          echo "Raw lint results:"
          cat lint_results_raw.json

      - name: Filter lint results to changed lines
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');

            // Change to pr directory
            process.chdir('pr');

            if (!fs.existsSync('lint_results_raw.json')) {
              fs.writeFileSync('lint_results.json', '[]');
              console.log('No raw lint results found');
              return;
            }

            const rawIssues = JSON.parse(fs.readFileSync('lint_results_raw.json', 'utf8'));

            if (rawIssues.length === 0) {
              fs.writeFileSync('lint_results.json', '[]');
              console.log('No lint issues found');
              return;
            }

            console.log(`Found ${rawIssues.length} total lint issue(s)`);

            // Get diff with line numbers
            const baseSha = '${{ github.event.pull_request.base.sha }}';
            const headSha = '${{ github.event.pull_request.head.sha }}';

            // Parse diff to get changed line numbers per file
            const changedLines = {};

            for (const issue of rawIssues) {
              const file = issue.file;

              if (!changedLines[file]) {
                try {
                  // Get the diff for this specific file
                  const diff = execSync(
                    `git diff --unified=0 ${baseSha} ${headSha} -- "${file}"`,
                    { encoding: 'utf8' }
                  );

                  // Parse the diff to extract changed line numbers
                  const lines = new Set();
                  const diffLines = diff.split('\n');

                  for (const line of diffLines) {
                    // Match the @@ -start,count +start,count @@ format
                    const match = line.match(/^@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@/);
                    if (match) {
                      const startLine = parseInt(match[1]);
                      const count = match[2] ? parseInt(match[2]) : 1;

                      // Add all changed lines in this hunk
                      for (let i = 0; i < count; i++) {
                        lines.add(startLine + i);
                      }
                    }
                  }

                  changedLines[file] = lines;
                  console.log(`File ${file}: ${lines.size} changed line(s)`);
                } catch (error) {
                  console.log(`Could not get diff for ${file}: ${error.message}`);
                  changedLines[file] = new Set();
                }
              }
            }

            // Filter issues to only those on changed lines
            const filteredIssues = rawIssues.filter(issue => {
              const fileLines = changedLines[issue.file] || new Set();
              const isOnChangedLine = fileLines.has(issue.line);
              if (!isOnChangedLine) {
                console.log(`Filtered out: ${issue.file}:${issue.line} (not on changed line)`);
              }
              return isOnChangedLine;
            });

            // Save filtered issues
            fs.writeFileSync('lint_results.json', JSON.stringify(filteredIssues, null, 2));

            // Create summary of filtered issues
            const filtered = rawIssues.length - filteredIssues.length;
            if (filtered > 0) {
              console.log(`Filtered out ${filtered} issue(s) on unchanged lines`);

              const filteredOut = rawIssues.filter(issue => !filteredIssues.includes(issue));
              const summary = filteredOut.map(i => `${i.file}:${i.line}: ${i.message}`).join('\n');
              fs.writeFileSync('filtered_issues.txt', 
                `The following ${filtered} issue(s) exist but are not on lines changed in this PR:\n\n${summary}`
              );
            }

            console.log(`Kept ${filteredIssues.length} issue(s) on changed lines for inline comments`);

      - name: Post review with grouped comments
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const crypto = require('crypto');

            // Change to pr directory
            process.chdir('pr');

            // Helper function to resolve review threads using GraphQL
            async function resolveReviewThreads(reviewId) {
              try {
                // Get all review comments for this review
                const comments = await github.rest.pulls.listCommentsForReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  review_id: reviewId
                });

                if (comments.data.length === 0) {
                  console.log(`No comments found for review ${reviewId}`);
                  return;
                }

                // Get all review threads for this PR
                const query = `
                  query($owner: String!, $repo: String!, $prNumber: Int!) {
                    repository(owner: $owner, name: $repo) {
                      pullRequest(number: $prNumber) {
                        reviewThreads(first: 100) {
                          nodes {
                            id
                            isResolved
                            comments(first: 10) {
                              nodes {
                                databaseId
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;

                const result = await github.graphql(query, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  prNumber: context.issue.number
                });

                const threads = result.repository.pullRequest.reviewThreads.nodes;
                const commentIds = new Set(comments.data.map(c => c.id));

                // Find and resolve threads that contain comments from this review
                for (const thread of threads) {
                  if (thread.isResolved) continue;

                  const hasReviewComment = thread.comments.nodes.some(c => 
                    commentIds.has(c.databaseId)
                  );

                  if (hasReviewComment) {
                    try {
                      await github.graphql(`
                        mutation($threadId: ID!) {
                          resolveReviewThread(input: {threadId: $threadId}) {
                            thread {
                              id
                            }
                          }
                        }
                      `, {
                        threadId: thread.id
                      });
                      console.log(`Resolved thread ${thread.id}`);
                    } catch (error) {
                      console.log(`Could not resolve thread ${thread.id}: ${error.message}`);
                    }
                  }
                }
              } catch (error) {
                console.log(`Error resolving threads for review ${reviewId}: ${error.message}`);
              }
            }

            if (!fs.existsSync('lint_results.json')) {
              console.log('No lint results file found');
              return;
            }

            const content = fs.readFileSync('lint_results.json', 'utf8').trim();

            // Get all existing bot reviews
            const existingReviews = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const botReviews = existingReviews.data.filter(review =>
              review.user.login === 'github-actions[bot]' &&
              review.body && review.body.includes('<!-- lint-review -->')
            );

            // Check if there are filtered issues
            const hasFilteredIssues = fs.existsSync('filtered_issues.txt');
            const filteredContent = hasFilteredIssues ? fs.readFileSync('filtered_issues.txt', 'utf8') : '';

            if ((!content || content === '[]') && !hasFilteredIssues) {
              console.log('No lint issues found');

              // Dismiss all existing bot reviews and resolve their conversations
              for (const review of botReviews) {
                if (review.state !== 'DISMISSED') {
                  // Resolve threads first
                  await resolveReviewThreads(review.id);

                  // Only dismiss reviews that can be dismissed (APPROVED or CHANGES_REQUESTED)
                  // COMMENTED reviews cannot be dismissed via the API
                  if (review.state === 'APPROVED' || review.state === 'CHANGES_REQUESTED') {
                    try {
                      await github.rest.pulls.dismissReview({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        pull_number: context.issue.number,
                        review_id: review.id,
                        message: 'All lint issues have been resolved'
                      });
                      console.log(`Dismissed ${review.state} review ${review.id} and resolved conversations`);
                    } catch (error) {
                      console.log(`Could not dismiss review ${review.id}: ${error.message}`);
                    }
                  } else {
                    console.log(`Skipped dismissing ${review.state} review ${review.id} (only threads resolved)`);
                  }
                }
              }

              return;
            }

            const issues = content && content !== '[]' ? JSON.parse(content) : [];

            // Create hash of current issues to check if review needs updating
            const issuesHash = crypto.createHash('md5')
              .update(JSON.stringify(issues.map(i => `${i.file}:${i.line}:${i.message}`)) + filteredContent)
              .digest('hex')
              .substring(0, 8);

            // Check if any existing review has the same issues
            const matchingReview = botReviews.find(review => 
              review.body.includes(`<!-- lint-hash:${issuesHash} -->`)
            );

            if (matchingReview) {
              console.log('Review already exists with same issues, skipping');
              return;
            }

            // Dismiss ALL existing bot reviews and resolve their conversations
            for (const review of botReviews) {
              if (review.state !== 'DISMISSED') {
                // Resolve threads first
                await resolveReviewThreads(review.id);

                // Only dismiss reviews that can be dismissed (APPROVED or CHANGES_REQUESTED)
                // COMMENTED reviews cannot be dismissed via the API
                if (review.state === 'APPROVED' || review.state === 'CHANGES_REQUESTED') {
                  try {
                    await github.rest.pulls.dismissReview({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: context.issue.number,
                      review_id: review.id,
                      message: 'Updating with new lint results'
                    });
                    console.log(`Dismissed ${review.state} review ${review.id} and resolved conversations`);
                  } catch (error) {
                    console.log(`Could not dismiss review ${review.id}: ${error.message}`);
                  }
                } else {
                  console.log(`Skipped dismissing ${review.state} review ${review.id} (only threads resolved)`);
                }
              }
            }

            // Prepare review comments (only for issues on changed lines)
            const reviewComments = [];
            const issuesByFile = {};

            for (const issue of issues) {
              if (!issuesByFile[issue.file]) {
                issuesByFile[issue.file] = [];
              }
              issuesByFile[issue.file].push(issue);

              reviewComments.push({
                path: issue.file,
                line: issue.line,
                side: 'RIGHT',
                body: issue.message
              });
            }

            // Create review body with summary
            const totalIssues = issues.length;
            const fileCount = Object.keys(issuesByFile).length;

            let reviewBody = `## üîç Lint Results\n\n`;

            if (totalIssues > 0) {
              reviewBody += `Found **${totalIssues}** issue${totalIssues !== 1 ? 's' : ''} on changed lines in **${fileCount}** file${fileCount !== 1 ? 's' : ''}:\n\n`;

              for (const [file, fileIssues] of Object.entries(issuesByFile)) {
                reviewBody += `- **${file}**: ${fileIssues.length} issue${fileIssues.length !== 1 ? 's' : ''}\n`;
              }
            }

            reviewBody += `\n<!-- lint-review -->\n<!-- lint-hash:${issuesHash} -->`;

            // Determine review event type
            const reviewEvent = totalIssues > 0 ? 'REQUEST_CHANGES' : 'COMMENT';

            try {
              const review = await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                commit_id: context.payload.pull_request.head.sha,
                body: reviewBody,
                event: reviewEvent,
                comments: reviewComments
              });

              console.log(`Created review with ${reviewComments.length} inline comment(s)`);
            } catch (error) {
              console.error(`Failed to create review:`, error.message);

              // Fallback: try to create review without comments if there's an error
              try {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  commit_id: context.payload.pull_request.head.sha,
                  body: reviewBody + '\n\n‚ö†Ô∏è Could not attach inline comments due to an error.',
                  event: reviewEvent
                });
                console.log('Created review without inline comments as fallback');
              } catch (fallbackError) {
                console.error('Fallback review creation also failed:', fallbackError.message);
              }
            }
