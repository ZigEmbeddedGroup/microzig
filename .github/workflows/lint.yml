name: Code Linting

on:
  pull_request_target:
    branches: [main]
  workflow_dispatch:

jobs:
  lint:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      # SECURITY: Checkout base branch for linter binary
      - name: Checkout base branch
        uses: actions/checkout@v3
        with:
          ref: ${{ github.base_ref }}
          path: base

      - name: Setup Zig
        uses: mlugg/setup-zig@v2
        with:
          version: 0.15.1

      # Build linter from trusted base branch code
      - name: Build linter
        working-directory: base/tools/linter
        run: zig build --release=safe

      # Now checkout PR code to analyze (but not execute)
      - name: Checkout PR code
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          path: pr
          fetch-depth: 0

      - name: Run linter
        working-directory: pr
        run: |
          echo "Base SHA: ${{ github.event.pull_request.base.sha }}"
          echo "Head SHA: ${{ github.event.pull_request.head.sha }}"

          # Get changed .zig files
          FILES=$(git diff --name-only --diff-filter=d ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} | grep '\.zig$' || true)
          echo "Changed files: $FILES"

          if [ -n "$FILES" ]; then
            echo "$FILES" | xargs ../base/tools/linter/zig-out/bin/linter > lint_results_raw.json
          else
            echo "[]" > lint_results_raw.json
          fi

          # Debug output
          echo "Raw lint results:"
          cat lint_results_raw.json

      - name: Filter lint results to changed lines
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');

            // Change to pr directory
            process.chdir('pr');

            if (!fs.existsSync('lint_results_raw.json')) {
              fs.writeFileSync('lint_results.json', '[]');
              console.log('No raw lint results found');
              return;
            }

            const rawIssues = JSON.parse(fs.readFileSync('lint_results_raw.json', 'utf8'));

            if (rawIssues.length === 0) {
              fs.writeFileSync('lint_results.json', '[]');
              console.log('No lint issues found');
              return;
            }

            console.log(`Found ${rawIssues.length} total lint issue(s)`);

            // Get diff with line numbers
            const baseSha = '${{ github.event.pull_request.base.sha }}';
            const headSha = '${{ github.event.pull_request.head.sha }}';

            // Parse diff to get changed line numbers per file
            const changedLines = {};

            for (const issue of rawIssues) {
              const file = issue.file;

              if (!changedLines[file]) {
                try {
                  // Get the diff for this specific file
                  const diff = execSync(
                    `git diff --unified=0 ${baseSha} ${headSha} -- "${file}"`,
                    { encoding: 'utf8' }
                  );

                  // Parse the diff to extract changed line numbers
                  const lines = new Set();
                  const diffLines = diff.split('\n');

                  for (const line of diffLines) {
                    // Match the @@ -start,count +start,count @@ format
                    const match = line.match(/^@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@/);
                    if (match) {
                      const startLine = parseInt(match[1]);
                      const count = match[2] ? parseInt(match[2]) : 1;

                      // Add all changed lines in this hunk
                      for (let i = 0; i < count; i++) {
                        lines.add(startLine + i);
                      }
                    }
                  }

                  changedLines[file] = lines;
                  console.log(`File ${file}: ${lines.size} changed line(s)`);
                } catch (error) {
                  console.log(`Could not get diff for ${file}: ${error.message}`);
                  changedLines[file] = new Set();
                }
              }
            }

            // Filter issues to only those on changed lines
            const filteredIssues = rawIssues.filter(issue => {
              const fileLines = changedLines[issue.file] || new Set();
              const isOnChangedLine = fileLines.has(issue.line);
              if (!isOnChangedLine) {
                console.log(`Filtered out: ${issue.file}:${issue.line} (not on changed line)`);
              }
              return isOnChangedLine;
            });

            // Save filtered issues
            fs.writeFileSync('lint_results.json', JSON.stringify(filteredIssues, null, 2));

            // Create summary of filtered issues
            const filtered = rawIssues.length - filteredIssues.length;
            if (filtered > 0) {
              console.log(`Filtered out ${filtered} issue(s) on unchanged lines`);

              const filteredOut = rawIssues.filter(issue => !filteredIssues.includes(issue));
              const summary = filteredOut.map(i => `${i.file}:${i.line}: ${i.message}`).join('\n');
              fs.writeFileSync('filtered_issues.txt', 
                `The following ${filtered} issue(s) exist but are not on lines changed in this PR:\n\n${summary}`
              );
            }

            console.log(`Kept ${filteredIssues.length} issue(s) on changed lines for inline comments`);

      - name: Post review with grouped comments
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const crypto = require('crypto');

            // Change to pr directory
            process.chdir('pr');

            // Helper function to delete all existing bot review comments
            async function deleteExistingBotComments() {
              try {
                // List all review comments on this PR
                const comments = await github.paginate(
                  github.rest.pulls.listReviewComments,
                  {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: context.issue.number,
                    per_page: 100
                  }
                );

                // Filter to only bot comments with our marker
                const botComments = comments.filter(c =>
                  c.user.login === 'github-actions[bot]'
                );

                console.log(`Found ${botComments.length} existing bot review comment(s) to delete`);

                // Delete each bot comment
                for (const comment of botComments) {
                  try {
                    await github.rest.pulls.deleteReviewComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      comment_id: comment.id
                    });
                    console.log(`Deleted comment ${comment.id}`);
                  } catch (error) {
                    console.log(`Could not delete comment ${comment.id}: ${error.message}`);
                  }
                }
              } catch (error) {
                console.log(`Error deleting bot comments: ${error.message}`);
              }
            }

            // Helper function to find and update or delete bot issue comment
            async function findBotIssueComment() {
              try {
                const comments = await github.paginate(
                  github.rest.issues.listComments,
                  {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    per_page: 100
                  }
                );

                return comments.find(c =>
                  c.user.login === 'github-actions[bot]' &&
                  c.body && c.body.includes('<!-- lint-review -->')
                );
              } catch (error) {
                console.log(`Error finding bot comment: ${error.message}`);
                return null;
              }
            }

            if (!fs.existsSync('lint_results.json')) {
              console.log('No lint results file found');
              return;
            }

            const content = fs.readFileSync('lint_results.json', 'utf8').trim();

            // Check if there are filtered issues
            const hasFilteredIssues = fs.existsSync('filtered_issues.txt');
            const filteredContent = hasFilteredIssues ? fs.readFileSync('filtered_issues.txt', 'utf8') : '';

            const issues = content && content !== '[]' ? JSON.parse(content) : [];

            // Create hash of current issues to detect changes
            const issuesHash = crypto.createHash('md5')
              .update(JSON.stringify(issues.map(i => `${i.file}:${i.line}:${i.message}`)) + filteredContent)
              .digest('hex')
              .substring(0, 8);

            // Find existing bot comment
            const existingComment = await findBotIssueComment();

            // Check if the existing comment already has the same hash
            if (existingComment && existingComment.body.includes(`<!-- lint-hash:${issuesHash} -->`)) {
              console.log('Comment already exists with same issues, skipping');
              return;
            }

            // Delete all existing bot review comments (inline comments)
            await deleteExistingBotComments();

            // If no issues, delete the summary comment and return
            if (issues.length === 0 && !hasFilteredIssues) {
              console.log('No lint issues found');
              if (existingComment) {
                try {
                  await github.rest.issues.deleteComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: existingComment.id
                  });
                  console.log('Deleted existing lint comment (no issues remaining)');
                } catch (error) {
                  console.log(`Could not delete comment: ${error.message}`);
                }
              }
              return;
            }

            // Prepare inline review comments
            const reviewComments = [];
            const issuesByFile = {};

            for (const issue of issues) {
              if (!issuesByFile[issue.file]) {
                issuesByFile[issue.file] = [];
              }
              issuesByFile[issue.file].push(issue);

              reviewComments.push({
                path: issue.file,
                line: issue.line,
                side: 'RIGHT',
                body: issue.message
              });
            }

            // Create summary comment body
            const totalIssues = issues.length;
            const fileCount = Object.keys(issuesByFile).length;

            let commentBody = `## Lint Results\n\n`;

            if (totalIssues > 0) {
              commentBody += `Found **${totalIssues}** issue${totalIssues !== 1 ? 's' : ''} on changed lines in **${fileCount}** file${fileCount !== 1 ? 's' : ''}:\n\n`;

              for (const [file, fileIssues] of Object.entries(issuesByFile)) {
                commentBody += `- **${file}**: ${fileIssues.length} issue${fileIssues.length !== 1 ? 's' : ''}\n`;
              }
            } else {
              commentBody += `No issues on changed lines.\n`;
            }

            commentBody += `\n<!-- lint-review -->\n<!-- lint-hash:${issuesHash} -->`;

            // Update or create the summary comment
            try {
              if (existingComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingComment.id,
                  body: commentBody
                });
                console.log('Updated existing lint summary comment');
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: commentBody
                });
                console.log('Created new lint summary comment');
              }
            } catch (error) {
              console.error(`Failed to update/create summary comment: ${error.message}`);
            }

            // Create inline review comments if there are issues
            if (reviewComments.length > 0) {
              try {
                const review = await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  commit_id: context.payload.pull_request.head.sha,
                  event: 'COMMENT',
                  comments: reviewComments
                });

                console.log(`Created review with ${reviewComments.length} inline comment(s)`);
              } catch (error) {
                console.error(`Failed to create inline comments: ${error.message}`);
              }
            }
