const std = @import("std");
const builtin = @import("builtin");
const microzig = @import("microzig");
const mmio = microzig.mmio;
const app = microzig.app;
const shared = @import("cortex_m/shared_types.zig");
const VectorTable = microzig.chip.VectorTable;

const Core = enum {
    cortex_m0,
    cortex_m0plus,
    cortex_m3,
    cortex_m33,
    cortex_m4,
    cortex_m55,
    cortex_m7,
};

const cortex_m = std.meta.stringToEnum(Core, microzig.config.cpu_name) orelse
    @compileError(std.fmt.comptimePrint("Unrecognized Cortex-M core name: {s}", .{microzig.config.cpu_name}));

/// Segger's RTT support
pub const rtt = @import("rtt");

/// Complete list of interrupt values based on the chip's `interrupts` array.
pub const Interrupt = microzig.utilities.GenerateInterruptEnum(i32);

/// Used to set interrupt handlers.
pub const Handler = microzig.interrupt.Handler;

/// Allowable `interrupt` options for microzig.options.
pub const InterruptOptions = microzig.utilities.GenerateInterruptOptions(&.{
    .{ .InterruptEnum = Interrupt, .HandlerFn = Handler },
});

/// Allowable `platform` options for microzig.options.
pub const CPU_Options = core.CPU_Options;

/// External Interrupts
/// These are the interrupts generated by the NVIC.
pub const ExternalInterrupt = blk: {
    // Note: The value of each field is the interrupt number (VTOR offset),
    //       not the offset into the whole vector table.

    const vector_info = @typeInfo(Interrupt).@"enum";
    const vector_fields = vector_info.fields;
    var result_len: usize = 0;

    for (vector_fields) |field| {
        if (field.value >= 0) result_len += 1;
    }

    if (result_len == 0) break :blk enum {};

    var fields: [result_len]std.builtin.Type.EnumField = undefined;
    var field_index: usize = 0;

    for (microzig.chip.interrupts) |intr| {
        if (intr.index >= 0) {
            fields[field_index] = .{
                .name = intr.name,
                .value = intr.index,
            };
            field_index += 1;
        }
    }

    break :blk @Type(.{ .@"enum" = .{
        .tag_type = u8,
        .fields = &fields,
        .decls = &.{},
        .is_exhaustive = true,
    } });
};

/// Machine exceptions.
pub const Exception = blk: {
    // Note: The value of each field is the index into the whole
    //       vector table, not the negative offset from VTOR.

    const vector_info = @typeInfo(Interrupt).@"enum";
    const vector_fields = vector_info.fields;
    var result_len: usize = 0;

    for (vector_fields) |field| {
        if (field.value < 0) result_len += 1;
    }

    if (result_len == 0) break :blk enum {};

    var fields: [result_len]std.builtin.Type.EnumField = undefined;
    var field_index: usize = 0;

    for (microzig.chip.interrupts) |intr| {
        if (intr.index < 0) {
            fields[field_index] = .{
                .name = intr.name,
                .value = 16 + intr.index, // Cortex-M exceptions are mapped to vector table slots 0 - 15
            };
            field_index += 1;
        }
    }

    break :blk @Type(.{ .@"enum" = .{
        .tag_type = u4,
        .fields = &fields,
        .decls = &.{},
        .is_exhaustive = true,
    } });
};

pub const interrupt = struct {
    /// The priority of an interrupt.
    /// Cortex-M uses a reversed priority scheme so the lowest priority is 15 and the highest is 0.
    ///
    /// Note: Some platforms may only use the most significant bits of the priority register.
    pub const Priority = enum(u8) {
        lowest = 15,
        highest = 0,
        _,
    };

    pub fn globally_enabled() bool {
        var mrs: u32 = undefined;
        asm volatile ("mrs %[mrs], 16"
            : [mrs] "+r" (mrs),
        );
        return mrs & 0x1 == 0;
    }

    pub fn enable_interrupts() void {
        asm volatile ("cpsie i");
    }

    pub fn disable_interrupts() void {
        asm volatile ("cpsid i");
    }

    fn assert_not_exception(comptime int: Interrupt) void {
        if (@intFromEnum(int) < 0) {
            @compileError("expected interrupt, got exception: " ++ @tagName(int));
        }
    }

    pub const exception = struct {
        const ppb = switch (cortex_m) {
            .cortex_m7 => microzig.chip.peripherals.SCB,
            else => microzig.cpu.peripherals.ppb,
        };

        pub fn is_enabled(comptime excpt: Exception) bool {
            switch (cortex_m) {
                .cortex_m3, .cortex_m4, .cortex_m7 => {
                    const raw = ppb.SHCSR.raw;
                    switch (excpt) {
                        .UsageFault => return (raw & 0x0004_0000) != 0,
                        .BusFault => return (raw & 0x0002_0000) != 0,
                        .MemManageFault => return (raw & 0x0001_0000) != 0,
                        else => @compileError("not supported on this platform"),
                    }
                },
                .cortex_m33,
                .cortex_m55,
                => {
                    const raw = ppb.SHCSR.raw;
                    switch (excpt) {
                        .SecureFault => return (raw & 0x0008_0000) != 0,
                        .UsageFault => return (raw & 0x0004_0000) != 0,
                        .BusFault => return (raw & 0x0002_0000) != 0,
                        .MemManageFault => return (raw & 0x0001_0000) != 0,
                        else => @compileError("not supported on this platform"),
                    }
                },
                else => @compileError("not supported on this platform"),
            }
        }

        pub fn enable(comptime excpt: Exception) void {
            switch (cortex_m) {
                .cortex_m3, .cortex_m4, .cortex_m7 => {
                    switch (excpt) {
                        .UsageFault => ppb.SHCSR.raw |= 0x0004_0000,
                        .BusFault => ppb.SHCSR.raw |= 0x0002_0000,
                        .MemManageFault => ppb.SHCSR.raw |= 0x0001_0000,
                        else => @compileError("not supported on this platform"),
                    }
                },
                .cortex_m33,
                .cortex_m55,
                => {
                    switch (excpt) {
                        .SecureFault => ppb.SHCSR.raw |= 0x0008_0000,
                        .UsageFault => ppb.SHCSR.raw |= 0x0004_0000,
                        .BusFault => ppb.SHCSR.raw |= 0x0002_0000,
                        .MemManageFault => ppb.SHCSR.raw |= 0x0001_0000,
                        else => @compileError("not supported on this platform"),
                    }
                },
                else => @compileError("not supported on this platform"),
            }
        }

        pub fn disable(comptime excpt: Exception) void {
            switch (cortex_m) {
                .cortex_m3, .cortex_m4, .cortex_m7 => {
                    switch (excpt) {
                        .UsageFault => ppb.SHCSR.raw &= ~@as(u32, 0x0004_0000),
                        .BusFault => ppb.SHCSR.raw &= ~@as(u32, 0x0002_0000),
                        .MemManageFault => ppb.SHCSR.raw &= ~@as(u32, 0x0001_0000),
                        else => @compileError("not supported on this platform"),
                    }
                },
                .cortex_m33,
                .cortex_m55,
                => {
                    switch (excpt) {
                        .SecureFault => ppb.SHCSR.raw &= ~@as(u32, 0x0008_0000),
                        .UsageFault => ppb.SHCSR.raw &= ~@as(u32, 0x0004_0000),
                        .BusFault => ppb.SHCSR.raw &= ~@as(u32, 0x0002_0000),
                        .MemManageFault => ppb.SHCSR.raw &= ~@as(u32, 0x0001_0000),
                        else => @compileError("not supported on this platform"),
                    }
                },
                else => @compileError("not supported on this platform"),
            }
        }

        pub fn is_pending(comptime excpt: Exception) bool {
            switch (cortex_m) {
                .cortex_m0plus,
                => {
                    if (excpt == .SVCALL) return (ppb.SHCSR.raw & 0x0000_8000) != 0;
                    @compileError("not supported on this platform");
                },
                .cortex_m3, .cortex_m4, .cortex_m7 => {
                    const raw = ppb.SHCSR.raw;
                    switch (excpt) {
                        .SVCall => return (raw & 0x0000_8000) != 0,
                        .BusFault => return (raw & 0x0000_4000) != 0,
                        .MemManageFault => return (raw & 0x0000_2000) != 0,
                        .UsageFault => return (raw & 0x0000_1000) != 0,
                        else => @compileError("not supported on this platform"),
                    }
                },
                .cortex_m33,
                .cortex_m55,
                => {
                    const raw = ppb.SHCSR.raw;
                    switch (excpt) {
                        .HardFault => return (raw & 0x0020_0000) != 0,
                        .SecureFault => return (raw & 0x0010_0000) != 0,
                        .SVCall => return (raw & 0x0000_8000) != 0,
                        .BusFault => return (raw & 0x0000_4000) != 0,
                        .MemManageFault => return (raw & 0x0000_2000) != 0,
                        .UsageFault => return (raw & 0x0000_1000) != 0,
                        else => @compileError("not supported on this platform"),
                    }
                },
                else => @compileError("not supported on this platform"),
            }
        }

        pub fn set_pending(comptime excpt: Exception) void {
            switch (cortex_m) {
                .cortex_m0plus,
                => {
                    if (excpt == .SVCALL) ppb.SHCSR.raw |= 0x0000_8000;
                    @compileError("not supported on this platform");
                },
                .cortex_m3, .cortex_m4, .cortex_m7 => {
                    switch (excpt) {
                        .SVCall => ppb.SHCSR.raw |= 0x0000_8000,
                        .BusFault => ppb.SHCSR.raw |= 0x0000_4000,
                        .MemManageFault => ppb.SHCSR.raw |= 0x0000_2000,
                        .UsageFault => ppb.SHCSR.raw |= 0x0000_1000,
                        else => @compileError("not supported on this platform"),
                    }
                },
                .cortex_m33,
                .cortex_m55,
                => {
                    switch (excpt) {
                        .HardFault => ppb.SHCSR.raw |= 0x0020_0000,
                        .SecureFault => ppb.SHCSR.raw |= 0x0010_0000,
                        .SVCall => ppb.SHCSR.raw |= 0x0000_8000,
                        .BusFault => ppb.SHCSR.raw |= 0x0000_4000,
                        .MemManageFault => ppb.SHCSR.raw |= 0x0000_2000,
                        .UsageFault => ppb.SHCSR.raw |= 0x0000_1000,
                        else => @compileError("not supported on this platform"),
                    }
                },
                else => @compileError("not supported on this platform"),
            }
        }

        pub fn clear_pending(comptime excpt: Exception) void {
            switch (cortex_m) {
                .cortex_m0plus,
                => {
                    if (excpt == .SVCALL) ppb.SHCSR.raw &= ~@as(u32, 0x0000_8000);
                    @compileError("not supported on this platform");
                },
                .cortex_m3, .cortex_m4, .cortex_m7 => {
                    switch (excpt) {
                        .SVCall => ppb.SHCSR.raw &= ~@as(u32, 0x0000_8000),
                        .BusFault => ppb.SHCSR.raw &= ~@as(u32, 0x0000_4000),
                        .MemManageFault => ppb.SHCSR.raw &= ~@as(u32, 0x0000_2000),
                        .UsageFault => ppb.SHCSR.raw &= ~@as(u32, 0x0000_1000),
                        else => @compileError("not supported on this platform"),
                    }
                },
                .cortex_m33,
                .cortex_m55,
                => {
                    switch (excpt) {
                        .HardFault => ppb.SHCSR.raw &= ~@as(u32, 0x0020_0000),
                        .SecureFault => ppb.SHCSR.raw &= ~@as(u32, 0x0010_0000),
                        .SVCall => ppb.SHCSR.raw &= ~@as(u32, 0x0000_8000),
                        .BusFault => ppb.SHCSR.raw &= ~@as(u32, 0x0000_4000),
                        .MemManageFault => ppb.SHCSR.raw &= ~@as(u32, 0x0000_2000),
                        .UsageFault => ppb.SHCSR.raw &= ~@as(u32, 0x0000_1000),
                        else => @compileError("not supported on this platform"),
                    }
                },
                else => @compileError("not supported on this platform"),
            }
        }

        /// Note: Although the Priority values are 0 - 15, some platforms may
        ///       only use the most significant bits.
        pub fn set_priority(comptime excpt: Exception, priority: Priority) void {
            const num: u2 = @intCast(@intFromEnum(excpt) / 4);
            const shift: u5 = @as(u5, @intCast(@intFromEnum(excpt))) % 4 * 8;

            // The code below is safe since the switch is compile-time resolved.
            // The any SHPRn register which is unavailable on a platform will
            // not be accessed as no matching `Exception` will be exist.

            switch (num) {
                0 => {
                    @compileError("Cannot set the priority for the exception");
                },
                1 => {
                    ppb.SHPR1.raw &= ~(@as(u32, 0xFF) << shift);
                    ppb.SHPR1.raw |= @as(u32, @intFromEnum(priority)) << shift;
                },
                2 => {
                    ppb.SHPR2.raw &= ~(@as(u32, 0xFF) << shift);
                    ppb.SHPR2.raw |= @as(u32, @intFromEnum(priority)) << shift;
                },
                3 => {
                    ppb.SHPR3.raw &= ~(@as(u32, 0xFF) << shift);
                    ppb.SHPR3.raw |= @as(u32, @intFromEnum(priority)) << shift;
                },
            }
        }

        pub fn get_priority(comptime excpt: Exception) Priority {
            const num: u2 = @intCast(@intFromEnum(excpt) / 4);
            const shift: u5 = @as(u5, @intCast(@intFromEnum(excpt))) % 4 * 8;

            const raw: u8 = (switch (num) {
                0 => @compileError("Cannot get the priority for the exception"),
                1 => ppb.SHPR1.raw,
                2 => ppb.SHPR2.raw,
                3 => ppb.SHPR3.raw,
            } >> shift) & 0xFF;

            return @enumFromInt(raw);
        }
    };

    const nvic = peripherals.nvic;

    pub fn is_enabled(comptime int: ExternalInterrupt) bool {
        const num: comptime_int = @intFromEnum(int);
        switch (cortex_m) {
            .cortex_m0,
            .cortex_m0plus,
            => {
                return nvic.ISER & (1 << num) != 0;
            },
            .cortex_m3,
            .cortex_m33,
            .cortex_m4,
            .cortex_m55,
            .cortex_m7,
            => {
                const bank = num / 32;
                const index = num % 32;
                return nvic.ISER[bank] & (1 << index) != 0;
            },
        }
    }

    pub fn enable(comptime int: ExternalInterrupt) void {
        const num: comptime_int = @intFromEnum(int);
        switch (cortex_m) {
            .cortex_m0,
            .cortex_m0plus,
            => {
                nvic.ISER |= 1 << num;
            },
            .cortex_m3,
            .cortex_m33,
            .cortex_m4,
            .cortex_m55,
            .cortex_m7,
            => {
                const bank = num / 32;
                const index = num % 32;
                nvic.ISER[bank] |= 1 << index;
            },
        }
    }

    pub fn disable(comptime int: ExternalInterrupt) void {
        const num: comptime_int = @intFromEnum(int);
        switch (cortex_m) {
            .cortex_m0,
            .cortex_m0plus,
            => {
                nvic.ICER |= 1 << num;
            },
            .cortex_m3,
            .cortex_m33,
            .cortex_m4,
            .cortex_m55,
            .cortex_m7,
            => {
                const bank = num / 32;
                const index = num % 32;
                nvic.ICER[bank] |= 1 << index;
            },
        }
    }

    pub fn is_pending(comptime int: ExternalInterrupt) bool {
        const num: comptime_int = @intFromEnum(int);
        switch (cortex_m) {
            .cortex_m0,
            .cortex_m0plus,
            => {
                return nvic.ISPR & (1 << num) != 0;
            },
            .cortex_m3,
            .cortex_m33,
            .cortex_m4,
            .cortex_m55,
            .cortex_m7,
            => {
                const bank = num / 32;
                const index = num % 32;
                return nvic.ISPR[bank] & (1 << index) != 0;
            },
        }
    }

    pub fn set_pending(comptime int: ExternalInterrupt) void {
        const num: comptime_int = @intFromEnum(int);
        switch (cortex_m) {
            .cortex_m0,
            .cortex_m0plus,
            => {
                nvic.ISPR |= 1 << num;
            },
            .cortex_m3,
            .cortex_m33,
            .cortex_m4,
            .cortex_m55,
            .cortex_m7,
            => {
                const bank = num / 32;
                const index = num % 32;
                nvic.ISPR[bank] |= 1 << index;
            },
        }
    }

    pub fn clear_pending(comptime int: ExternalInterrupt) void {
        const num: comptime_int = @intFromEnum(int);
        switch (cortex_m) {
            .cortex_m0,
            .cortex_m0plus,
            => {
                nvic.ICPR |= 1 << num;
            },
            .cortex_m3,
            .cortex_m33,
            .cortex_m4,
            .cortex_m55,
            .cortex_m7,
            => {
                const bank = num / 32;
                const index = num % 32;
                nvic.ICPR[bank] |= 1 << index;
            },
        }
    }

    pub fn set_priority(comptime int: ExternalInterrupt, priority: Priority) void {
        nvic.IPR[@intFromEnum(int)] = @intFromEnum(priority);
    }

    pub fn get_priority(comptime int: ExternalInterrupt) Priority {
        return @enumFromInt(peripherals.nvic.IPR[@intFromEnum(int)]);
    }
};

pub fn executing_isr() bool {
    return peripherals.scb.ICSR.read().VECTACTIVE != 0;
}

pub fn enable_fault_irq() void {
    asm volatile ("cpsie f");
}
pub fn disable_fault_irq() void {
    asm volatile ("cpsid f");
}

pub fn nop() void {
    asm volatile ("nop");
}
pub fn wfi() void {
    asm volatile ("wfi");
}
pub fn wfe() void {
    asm volatile ("wfe");
}
pub fn sev() void {
    asm volatile ("sev");
}
pub fn isb() void {
    asm volatile ("isb");
}
pub fn dsb() void {
    asm volatile ("dsb");
}
pub fn dmb() void {
    asm volatile ("dmb");
}
pub fn clrex() void {
    asm volatile ("clrex");
}

/// Atomic operations with fallback to critical sections for Cortex-M0/M0+
pub const atomic = struct {
    pub const has_native_atomics = switch (cortex_m) {
        .cortex_m0, .cortex_m0plus => false,
        else => true,
    };

    /// Atomic add
    pub fn add(comptime T: type, ptr: *T, delta: T) T {
        if (has_native_atomics) {
            return @atomicRmw(T, ptr, .Add, delta, .monotonic);
        } else {
            const cs = microzig.interrupt.enter_critical_section();
            defer cs.leave();

            const old_value = ptr.*;
            ptr.* = old_value +% delta;
            return old_value;
        }
    }

    /// Atomic load
    pub fn load(comptime T: type, ptr: *const T, comptime ordering: std.builtin.AtomicOrder) T {
        if (has_native_atomics) {
            return @atomicLoad(T, ptr, ordering);
        } else {
            const cs = microzig.interrupt.enter_critical_section();
            defer cs.leave();

            return ptr.*;
        }
    }

    /// Atomic store
    pub fn store(comptime T: type, ptr: *T, value: T, comptime ordering: std.builtin.AtomicOrder) void {
        if (has_native_atomics) {
            @atomicStore(T, ptr, value, ordering);
        } else {
            const cs = microzig.interrupt.enter_critical_section();
            defer cs.leave();

            ptr.* = value;
        }
    }

    /// Atomic compare and swap
    pub fn cmpxchg(
        comptime T: type,
        ptr: *T,
        expected_value: T,
        new_value: T,
        comptime success_ordering: std.builtin.AtomicOrder,
        comptime failure_ordering: std.builtin.AtomicOrder,
    ) ?T {
        if (has_native_atomics) {
            return @cmpxchgWeak(T, ptr, expected_value, new_value, success_ordering, failure_ordering);
        } else {
            const cs = microzig.interrupt.enter_critical_section();
            defer cs.leave();

            const current = ptr.*;
            if (current == expected_value) {
                ptr.* = new_value;
                return null;
            }
            return current;
        }
    }

    /// Atomic read-modify-write
    pub fn rmw(
        comptime T: type,
        ptr: *T,
        comptime op: std.builtin.AtomicRmwOp,
        operand: T,
        comptime ordering: std.builtin.AtomicOrder,
    ) T {
        if (has_native_atomics) {
            return @atomicRmw(T, ptr, op, operand, ordering);
        } else {
            const cs = microzig.interrupt.enter_critical_section();
            defer cs.leave();

            const old_value = ptr.*;
            ptr.* = switch (op) {
                .Xchg => operand,
                .Add => old_value +% operand,
                .Sub => old_value -% operand,
                .And => old_value & operand,
                .Nand => ~(old_value & operand),
                .Or => old_value | operand,
                .Xor => old_value ^ operand,
                .Max => @max(old_value, operand),
                .Min => @min(old_value, operand),
            };
            return old_value;
        }
    }
};

/// Enables the FPU.
///
/// NOTE: This function is automatically called on cpu startup if the cpu has
/// an fpu and hard float is enabled. HAL's also call this in the startup of
/// other cores.
pub inline fn enable_fpu() void {
    // Taken from the rust crate cortex-m-rt.
    asm volatile (
        \\ldr r0, =0xE000ED88
        \\ldr r1, =(0b1111 << 20)
        \\ldr r2, [r0]
        \\orr r2, r2, r1
        \\str r2, [r0]
        \\dsb
        \\isb
    );
}

/// The RAM vector table used. You can swap interrupt handlers at runtime here.
/// Available when using a RAM vector table or a RAM image.
pub var ram_vector_table: VectorTable align(256) = if (using_ram_vector_table or is_ram_image)
    startup_logic.generate_vector_table()
else
    @compileError("`ram_vector_table` is not available. Consider adding .cpu = .{ .ram_vector_table = true }" ++
        " to your microzig_options or using a RAM image");

pub const startup_logic = struct {
    extern fn microzig_main() noreturn;

    pub fn ram_image_start() linksection("microzig_ram_start") callconv(.naked) noreturn {
        const eos = comptime microzig.utilities.get_end_of_stack();
        asm volatile (
            \\
            // Set up stack and jump to _start
            \\msr msp, %[eos]
            // using bx instead of b because the _start function might be too far away
            \\bx %[start_fn]
            :
            : [eos] "r" (@as(u32, @intFromPtr(eos))),
              [start_fn] "r" (@as(u32, @intFromPtr(&_start))),
        );
    }

    pub fn _start() callconv(.c) noreturn {
        microzig.utilities.initialize_system_memories(.auto);

        if (using_ram_vector_table or is_ram_image) {
            asm volatile (
                \\
                // Set VTOR to point to ram table
                \\mov r0, %[_vector_table]
                \\mov r1, %[_VTOR_ADDRESS]
                \\str r0, [r1]
                :
                : [_vector_table] "r" (&ram_vector_table),
                  [_VTOR_ADDRESS] "r" (&peripherals.scb.VTOR),
                : .{ .memory = true, .r0 = true, .r1 = true });
        }

        if (fpu_present and builtin.abi.float() == .hard) {
            enable_fpu();
        } else if (!fpu_present and builtin.abi.float() == .hard) {
            @compileError(
                \\Hard float enabled though the chip doesn't have an FPU. If
                \\your chip has an FPU please add the `cpu.fpuPresent` = `true`
                \\property to your chip file, either manually or via patches.
                \\If you want to use patches, you can use something like this:
                \\```
                \\.{ .set_device_property = .{
                \\    .device_name = "CHIP_NAME",
                \\    .key = "cpu.fpuPresent",
                \\    .value = "true"
                \\} },
                \\```
            );
        }

        if (@hasField(types.peripherals.SystemControlBlock, "SHCSR")) {
            // Enable distinction between MemFault, BusFault and UsageFault:
            peripherals.scb.SHCSR.modify(.{
                .MEMFAULTENA = 1,
                .BUSFAULTENA = 1,
                .USGFAULTENA = 1,
            });
            enable_fault_irq();
        }

        // If the compiler gets too aggressive with inlining we might get some
        // floating point operations before the FPU is enabled.
        @call(.never_inline, microzig_main, .{});
    }

    // Validate that the VectorTable type has all the fault handlers that the CPU expects
    comptime {
        if (@hasDecl(core, "cpu_flags")) {
            const flags = core.cpu_flags;
            if ((flags.has_hard_fault and !@hasField(VectorTable, HardFault_name)) or
                (flags.has_bus_fault and !@hasField(VectorTable, BusFault_name)) or
                (flags.has_mem_manage_fault and !@hasField(VectorTable, MemManageFault_name)) or
                (flags.has_usage_fault and !@hasField(VectorTable, UsageFault_name)))
                @compileError("The CPU configures a fault vector, but it is not present in the VectorTable type!");
        }
    }

    // If we are using a RAM vector table, we can use a dummy one (only 8 bytes) that only provides
    // the reset vector and the initial stack pointer.
    const FlashVectorTable = if (using_ram_vector_table)
        extern struct {
            initial_stack_pointer: usize,
            Reset: Handler,
        }
    else
        VectorTable;

    // The vector table in flash must be aligned to 256 as VTOR ignores the lower 8 bits of the
    // address.
    const _vector_table: FlashVectorTable align(256) = if (is_ram_image) {
        @compileError("`_vector_table` is not available in a RAM image. Use `ram_vector_table` instead.");
    } else if (using_ram_vector_table)
        .{
            .initial_stack_pointer = microzig.config.end_of_stack,
            .Reset = .{ .c = microzig.cpu.startup_logic._start },
        }
    else
        generate_vector_table();

    fn generate_vector_table() VectorTable {
        var tmp: VectorTable = .{
            .initial_stack_pointer = microzig.utilities.get_end_of_stack(),
            .Reset = .{ .c = microzig.cpu.startup_logic._start },
        };

        // Apply interrupts
        for (@typeInfo(@TypeOf(microzig.options.interrupts)).@"struct".fields) |field| {
            const maybe_handler = @field(microzig.options.interrupts, field.name);
            const maybe_default = get_hal_default_handler(field.name);

            @field(tmp, field.name) = blk: {
                if (maybe_handler) |handler| {
                    if (!microzig.options.overwrite_hal_interrupts and maybe_default != null)
                        @compileError(std.fmt.comptimePrint(
                            \\Interrupt {s} is used internally by the HAL; overriding it may cause malfunction.
                            \\If you are sure of what you are doing, set "overwrite_hal_interrupts" to true in: "microzig_options".
                            \\
                        , .{field.name}));
                    break :blk handler;
                } else break :blk maybe_default orelse default_exception_handler(field.name);
            };
        }

        return tmp;
    }

    fn get_hal_default_handler(comptime handler_name: []const u8) ?microzig.interrupt.Handler {
        if (microzig.config.has_hal) {
            if (@hasDecl(microzig.hal, "default_interrupts")) {
                return @field(microzig.hal.default_interrupts, handler_name);
            }
        }
        return null;
    }

    fn default_exception_handler(comptime name: []const u8) microzig.interrupt.Handler {
        return switch (builtin.mode) {
            .Debug => .{ .c = DebugExceptionHandler(name).handle },
            else => .{ .c = ReleaseExceptionHandler.handle },
        };
    }

    fn DebugExceptionHandler(comptime name: []const u8) type {
        if (microzig.options.cpu.verbose_unhandled_irq) {
            return struct {
                pub const handle = debugExceptionHandler(name);
            };
        }
        return ReleaseExceptionHandler;
    }

    const IrqHandlerFn = *const fn () callconv(.c) void;

    fn debugExceptionHandler(comptime name: []const u8) IrqHandlerFn {
        // Only use verbose fault handlers on cores that have the required registers
        const has_hfsr = @hasField(types.peripherals.SystemControlBlock, "HFSR");
        const has_cfsr = @hasField(types.peripherals.SystemControlBlock, "CFSR");

        if (comptime std.mem.eql(u8, name, HardFault_name) and has_hfsr)
            return debug.hard_fault_handler;
        if (comptime std.mem.eql(u8, name, BusFault_name) and has_cfsr)
            return debug.bus_fault_handler;
        if (comptime std.mem.eql(u8, name, MemManageFault_name))
            return debug.mem_manage_fault_handler;
        if (comptime std.mem.eql(u8, name, UsageFault_name) and has_cfsr)
            return debug.usage_fault_handler;

        return struct {
            fn handle() callconv(.c) void {
                @panic("Unhandled exception: " ++ name);
            }
        }.handle;
    }

    const ReleaseExceptionHandler = struct {
        fn handle() callconv(.c) void {
            @panic("Unhandled exception");
        }
    };

    const HardFault_name = "HardFault";
    const BusFault_name = "BusFault";
    const MemManageFault_name = "MemManageFault";
    const UsageFault_name = "UsageFault";
};

/// Implements several mechanisms to easy debugging with Cortex-M cpus.
///
/// Read more here:
///     https://interrupt.memfault.com/blog/cortex-m-hardfault-debug
pub const debug = struct {
    const logger = std.log.scoped(.cortex_m_debug);

    /// This frame is pushed mostly by the CPU itself, and we move it into
    /// the parameter register, so we can inspect it.
    pub const ContextStateFrame = extern struct {
        r0: u32,
        r1: u32,
        r2: u32,
        r3: u32,
        r12: u32,
        lr: u32,
        return_address: u32,
        xpsr: u32,
    };

    /// Wraps `handler` in a small asm block that ensures that it is a regular interrupt handler
    /// function, but also provides us with a ContextStateFrame fetched from the system status:
    pub fn make_fault_handler(comptime handler: *const fn (context: *ContextStateFrame) callconv(.c) void) *const fn () callconv(.c) void {
        return struct {
            fn invoke() callconv(.c) void {
                // See this article on how we use that:
                // https://interrupt.memfault.com/blog/cortex-m-hardfault-debug
                asm volatile (
                    \\
                    // Check 2th bit of LR.
                    \\tst lr, #4
                    // Do "if then else" equal
                    \\ite eq
                    // if equals, we use the MSP
                    \\mrseq r0, msp
                    // otherwise, we use the PSP
                    \\mrsne r0, psp
                    // Then we branch to our handler:
                    \\b %[handler]
                    :
                    : [handler] "s" (handler),
                );
            }
        }.invoke;
    }

    pub fn hard_fault_handler() callconv(.c) void {
        const hfsr = peripherals.scb.HFSR.read();

        logger.err("Hard Fault:", .{});
        logger.err("  VECTTBL:  {}", .{hfsr.VECTTBL});
        logger.err("  FORCED:   {}", .{hfsr.FORCED});
        logger.err("  DEBUGEVT: {}", .{hfsr.DEBUGEVT});

        @panic("Hard fault");
    }

    pub fn mem_manage_fault_handler() callconv(.c) void {
        @panic("Memory fault");
    }

    pub const bus_fault_handler = make_fault_handler(handle_bus_fault_wrapped);

    fn handle_bus_fault_wrapped(context: *const ContextStateFrame) callconv(.c) void {
        const bfsr = peripherals.scb.CFSR.read().BFSR;

        logger.err("Bus Fault:", .{});
        logger.err("  context                         =  r0:0x{X:0>8}  r1:0x{X:0>8}  r2:0x{X:0>8}    r3:0x{X:0>8}", .{
            context.r0,
            context.r1,
            context.r2,
            context.r3,
        });
        logger.err("                                    r12:0x{X:0>8}  lr:0x{X:0>8}  ra:0x{X:0>8}  xpsr:0x{X:0>8}", .{
            context.r12,
            context.lr,
            context.return_address,
            context.xpsr,
        });
        logger.err("  instruction bus error           = {}", .{bfsr.instruction_bus_error});
        logger.err("  precice data bus error          = {}", .{bfsr.precice_data_bus_error});
        logger.err("  imprecice data bus error        = {}", .{bfsr.imprecice_data_bus_error});
        logger.err("  unstacking exception error      = {}", .{bfsr.unstacking_exception_error});
        logger.err("  exception stacking error        = {}", .{bfsr.exception_stacking_error});
        logger.err("  busfault address register valid = {}", .{bfsr.busfault_address_register_valid});
        if (bfsr.busfault_address_register_valid) {
            const address = peripherals.scb.BFAR;
            logger.err("    busfault address register = 0x{X:0>8}", .{address});
        }

        @panic("Bus fault");
    }

    pub const usage_fault_handler = make_fault_handler(handle_usage_fault_wrapped);

    fn handle_usage_fault_wrapped(context: *const ContextStateFrame) callconv(.c) void {
        const ufsr = peripherals.scb.CFSR.read().UFSR;

        logger.err("Usage Fault:", .{});
        logger.err(
            "  context                         =  r0:0x{X:0>8}  r1:0x{X:0>8}  r2:0x{X:0>8}    r3:0x{X:0>8}",
            .{ context.r0, context.r1, context.r2, context.r3 },
        );
        logger.err(
            "                                    r12:0x{X:0>8}  lr:0x{X:0>8}  ra:0x{X:0>8}  xpsr:0x{X:0>8}",
            .{ context.r12, context.lr, context.return_address, context.xpsr },
        );
        logger.err("  undefined instruction     = {}", .{ufsr.undefined_instruction});
        logger.err("  invalid state             = {}", .{ufsr.invalid_state});
        logger.err("  invalid pc load           = {}", .{ufsr.invalid_pc_load});
        logger.err("  missing coprocessor usage = {}", .{ufsr.missing_coprocessor_usage});
        logger.err("  unaligned memory access   = {}", .{ufsr.unaligned_memory_access});
        logger.err("  divide by zero            = {}", .{ufsr.divide_by_zero});

        @panic("Usage fault");
    }
};

const is_ram_image = microzig.config.ram_image;
const using_ram_vector_table = @hasField(CPU_Options, "ram_vector_table") and microzig.options.cpu.ram_vector_table;

pub fn export_startup_logic() void {
    if (is_ram_image) {
        @export(&startup_logic.ram_image_start, .{
            .name = "_entry_point",
            .linkage = .strong,
        });
    } else {
        @export(&startup_logic._vector_table, .{
            .name = "_vector_table",
            .section = "microzig_flash_start",
            .linkage = .strong,
        });
    }

    @export(&startup_logic._start, .{
        .name = "_start",
    });
}

const scs_base = 0xE000E000;
const itm_base = 0xE0000000;
const dwt_base = 0xE0001000;
const tpi_base = 0xE0040000;

const coredebug_base = 0xE000EDF0;
const systick_base = scs_base + 0x0010;
const nvic_base = scs_base + 0x0100;
const scb_base = scs_base + core.scb_base_offset;
const mpu_base = scs_base + 0x0D90;
const fpu_base = scs_base + 0x0F34;

// TODO: will have to standardize this with regz code generation
const mpu_present = @hasDecl(microzig.chip, "properties") and
    @hasDecl(microzig.chip.properties, "cpu.mpuPresent") and
    std.mem.eql(u8, microzig.chip.properties.@"cpu.mpuPresent", "true");
const fpu_present = @hasDecl(microzig.chip, "properties") and
    @hasDecl(microzig.chip.properties, "cpu.fpuPresent") and
    std.mem.eql(u8, microzig.chip.properties.@"cpu.fpuPresent", "true");

const core = blk: {
    break :blk switch (cortex_m) {
        .cortex_m0 => @import("cortex_m/m0.zig"),
        .cortex_m0plus => @import("cortex_m/m0plus.zig"),
        .cortex_m3 => @import("cortex_m/m3.zig"),
        .cortex_m33 => @import("cortex_m/m33.zig"),
        .cortex_m4 => @import("cortex_m/m4.zig"),
        .cortex_m55 => @import("cortex_m/m55.zig"),
        .cortex_m7 => @import("cortex_m/m7.zig"),
    };
};

pub const utils = switch (cortex_m) {
    .cortex_m7 => @import("cortex_m/m7_utils.zig"),
    else => void{},
};

pub const peripherals = struct {
    /// System Control Block (SCB).
    pub const scb: *volatile types.peripherals.SystemControlBlock = @ptrFromInt(scb_base);

    /// Floating Point Unit (FPU).
    pub const fpu: *volatile types.peripherals.FloatingPointUnit = if (fpu_present)
        @ptrFromInt(fpu_base)
    else
        @compileError("this CPU does not have an FPU");

    /// Nested Vector Interrupt Controller (NVIC).
    pub const nvic: *volatile types.peripherals.NestedVectorInterruptController = @ptrFromInt(nvic_base);

    /// System Timer (SysTick).
    pub const systick: *volatile types.peripherals.SysTick = @ptrFromInt(systick_base);

    /// Memory Protection Unit (MPU).
    pub const mpu: *volatile types.peripherals.MemoryProtectionUnit = if (mpu_present)
        @ptrFromInt(mpu_base)
    else
        @compileError("this CPU does not have an MPU");

    pub const dbg: (if (@hasDecl(core, "DebugRegisters"))
        *volatile core.DebugRegisters
    else
        *volatile anyopaque) = @ptrFromInt(coredebug_base);

    pub const itm: (if (@hasDecl(core, "ITM"))
        *volatile core.ITM
    else
        *volatile anyopaque) = @ptrFromInt(itm_base);

    pub const tpiu: (if (@hasDecl(core, "TPIU"))
        *volatile core.TPIU
    else
        *volatile anyopaque) = @ptrFromInt(tpi_base);
};

pub const types = struct {
    pub const peripherals = struct {
        /// System Control Block (SCB).
        pub const SystemControlBlock = core.SystemControlBlock;

        /// Floating Point Unit (FPU).
        pub const FloatingPointUnit = if (@hasDecl(core, "FloatingPointUnit"))
            core.FloatingPointUnit
        else
            @compileError("this CPU does not have an FPU definition");

        /// Nested Vector Interrupt Controller (NVIC).
        pub const NestedVectorInterruptController = core.NestedVectorInterruptController;

        /// System Timer (SysTick).
        pub const SysTick = extern struct {
            /// Control and Status Register.
            CTRL: mmio.Mmio(packed struct(u32) {
                /// Enables the counter:
                /// 0 = counter disabled.
                /// 1 = counter enabled.
                ENABLE: u1,
                /// Enables SysTick exception request:
                /// 0 = counting down to zero does not assert the SysTick exception request
                /// 1 = counting down to zero asserts the SysTick exception request.
                ///
                /// Software can use COUNTFLAG to determine if SysTick has ever counted to zero.
                TICKINT: u1,
                /// Indicates the clock source:
                /// 0 = external clock
                /// 1 = processor clock.
                CLKSOURCE: u1,
                reserved0: u13 = 0,
                /// Returns 1 if timer counted to 0 since last time this was read.
                COUNTFLAG: u1,
                reserved1: u15 = 0,
            }),
            /// Reload Value Register.
            LOAD: mmio.Mmio(packed struct(u32) {
                /// Value to load into the VAL register when the counter is enabled and when it reaches 0.
                RELOAD: u24,
                reserved0: u8 = 0,
            }),
            /// Current Value Register.
            VAL: mmio.Mmio(packed struct(u32) {
                /// Reads return the current value of the SysTick counter.
                /// A write of any value clears the field to 0, and also clears the CTRL.COUNTFLAG bit to 0.
                CURRENT: u24,
                reserved0: u8 = 0,
            }),
            /// Calibration Register.
            CALIB: mmio.Mmio(packed struct(u32) {
                /// Reload value for 10ms (100Hz) timing, subject to system clock skew errors. If the value
                /// reads as zero, the calibration value is not known.
                TENMS: u24,
                reserved0: u6 = 0,
                /// Indicates whether the TENMS value is exact.
                /// 0 = TENMS value is exact
                /// 1 = TENMS value is inexact, or not given.
                ///
                /// An inexact TENMS value can affect the suitability of SysTick as a software real time clock.
                SKEW: u1,
                /// Indicates whether the device provides a reference clock to the processor:
                /// 0 = reference clock provided
                /// 1 = no reference clock provided.
                /// If your device does not provide a reference clock, the CTRL.CLKSOURCE bit reads-as-one
                /// and ignores writes.
                NOREF: u1,
            }),
        };

        /// Memory Protection Unit (MPU).
        pub const MemoryProtectionUnit = if (@hasDecl(core, "MemoryProtectionUnit"))
            core.MemoryProtectionUnit
        else
            @compileError("this CPU does not have an MPU definition");
    };
};
